# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import Dict, List, Any


class AddSampleDataByCsvRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        oss_file_name: str = None,
        reg_id: str = None,
        sample_batch_uuid: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Uploaded OSS address.
        self.oss_file_name = oss_file_name
        # Region code
        self.reg_id = reg_id
        # Sample UUID.
        self.sample_batch_uuid = sample_batch_uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.oss_file_name is not None:
            result['ossFileName'] = self.oss_file_name
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.sample_batch_uuid is not None:
            result['sampleBatchUuid'] = self.sample_batch_uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ossFileName') is not None:
            self.oss_file_name = m.get('ossFileName')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('sampleBatchUuid') is not None:
            self.sample_batch_uuid = m.get('sampleBatchUuid')
        return self


class AddSampleDataByCsvResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddSampleDataByCsvResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddSampleDataByCsvResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddSampleDataByCsvResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddSampleDataByTextRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        data_value: str = None,
        reg_id: str = None,
        sample_batch_uuid: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # List data.
        self.data_value = data_value
        # Region code
        self.reg_id = reg_id
        # Sample UUID.
        self.sample_batch_uuid = sample_batch_uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.data_value is not None:
            result['dataValue'] = self.data_value
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.sample_batch_uuid is not None:
            result['sampleBatchUuid'] = self.sample_batch_uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('dataValue') is not None:
            self.data_value = m.get('dataValue')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('sampleBatchUuid') is not None:
            self.sample_batch_uuid = m.get('sampleBatchUuid')
        return self


class AddSampleDataByTextResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddSampleDataByTextResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddSampleDataByTextResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddSampleDataByTextResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchDeleteSampleDataRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        uuids: str = None,
    ):
        # Language of the error message returned by the interface. Values: zh: Chinese; en: English. Default is en.
        self.lang = lang
        # Region code
        self.reg_id = reg_id
        # UUID.
        self.uuids = uuids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.uuids is not None:
            result['uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        return self


class BatchDeleteSampleDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class BatchDeleteSampleDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchDeleteSampleDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchDeleteSampleDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindVariableRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        api_region_id: str = None,
        api_type: str = None,
        create_type: str = None,
        define_id: str = None,
        define_ids: str = None,
        description: str = None,
        event_code: str = None,
        exception_value: str = None,
        id: int = None,
        output_field: str = None,
        output_type: str = None,
        params: str = None,
        params_list: str = None,
        reg_id: str = None,
        source_type: str = None,
        title: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # API region ID
        self.api_region_id = api_region_id
        # API type
        self.api_type = api_type
        # Creation type
        self.create_type = create_type
        # Associated variable definition primary key ID
        self.define_id = define_id
        # Variable definition IDs, can be multiple. If binding multiple IDs, separate them with commas
        self.define_ids = define_ids
        # Description information.
        self.description = description
        # Event code
        # 
        # This parameter is required.
        self.event_code = event_code
        # Exception value
        self.exception_value = exception_value
        # Variable primary key ID
        self.id = id
        # Output field path
        self.output_field = output_field
        # Output type
        self.output_type = output_type
        # Binding input parameter information
        self.params = params
        # Event parameter mapping 2.0, either params or paramsList must not be empty. List, JSON structure
        self.params_list = params_list
        # Region code
        self.reg_id = reg_id
        # Variable source
        self.source_type = source_type
        # Title
        # 
        # This parameter is required.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.api_region_id is not None:
            result['apiRegionId'] = self.api_region_id
        if self.api_type is not None:
            result['apiType'] = self.api_type
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.define_id is not None:
            result['defineId'] = self.define_id
        if self.define_ids is not None:
            result['defineIds'] = self.define_ids
        if self.description is not None:
            result['description'] = self.description
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.exception_value is not None:
            result['exceptionValue'] = self.exception_value
        if self.id is not None:
            result['id'] = self.id
        if self.output_field is not None:
            result['outputField'] = self.output_field
        if self.output_type is not None:
            result['outputType'] = self.output_type
        if self.params is not None:
            result['params'] = self.params
        if self.params_list is not None:
            result['paramsList'] = self.params_list
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('apiRegionId') is not None:
            self.api_region_id = m.get('apiRegionId')
        if m.get('apiType') is not None:
            self.api_type = m.get('apiType')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('defineId') is not None:
            self.define_id = m.get('defineId')
        if m.get('defineIds') is not None:
            self.define_ids = m.get('defineIds')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('exceptionValue') is not None:
            self.exception_value = m.get('exceptionValue')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('outputField') is not None:
            self.output_field = m.get('outputField')
        if m.get('outputType') is not None:
            self.output_type = m.get('outputType')
        if m.get('params') is not None:
            self.params = m.get('params')
        if m.get('paramsList') is not None:
            self.params_list = m.get('paramsList')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class BindVariableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class BindVariableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindVariableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindVariableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CheckCopyRuleVariableRequest(TeaModel):
    def __init__(
        self,
        create_type: str = None,
        lang: str = None,
        reg_id: str = None,
        source_rule_id: str = None,
        source_rule_ids: str = None,
        target_event_code: str = None,
    ):
        # Creation type
        self.create_type = create_type
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id
        # Source policy ID
        self.source_rule_id = source_rule_id
        # Source policy IDs
        self.source_rule_ids = source_rule_ids
        # Target event
        self.target_event_code = target_event_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_type is not None:
            result['CreateType'] = self.create_type
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        if self.source_rule_id is not None:
            result['SourceRuleId'] = self.source_rule_id
        if self.source_rule_ids is not None:
            result['SourceRuleIds'] = self.source_rule_ids
        if self.target_event_code is not None:
            result['TargetEventCode'] = self.target_event_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateType') is not None:
            self.create_type = m.get('CreateType')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        if m.get('SourceRuleId') is not None:
            self.source_rule_id = m.get('SourceRuleId')
        if m.get('SourceRuleIds') is not None:
            self.source_rule_ids = m.get('SourceRuleIds')
        if m.get('TargetEventCode') is not None:
            self.target_event_code = m.get('TargetEventCode')
        return self


class CheckCopyRuleVariableResponseBodyResultObjectMessage(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        title: str = None,
        type: str = None,
    ):
        # Primary key ID of the variable
        self.id = id
        # Name of the variable
        self.name = name
        # Title of the variable
        self.title = title
        # Type of the variable
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.title is not None:
            result['Title'] = self.title
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CheckCopyRuleVariableResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        message: List[CheckCopyRuleVariableResponseBodyResultObjectMessage] = None,
    ):
        # Information.
        self.message = message

    def validate(self):
        if self.message:
            for k in self.message:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Message'] = []
        if self.message is not None:
            for k in self.message:
                result['Message'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.message = []
        if m.get('Message') is not None:
            for k in m.get('Message'):
                temp_model = CheckCopyRuleVariableResponseBodyResultObjectMessage()
                self.message.append(temp_model.from_map(k))
        return self


class CheckCopyRuleVariableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: CheckCopyRuleVariableResponseBodyResultObject = None,
    ):
        # ID of the request
        self.request_id = request_id
        # Returned result information
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            temp_model = CheckCopyRuleVariableResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['ResultObject'])
        return self


class CheckCopyRuleVariableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CheckCopyRuleVariableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CheckCopyRuleVariableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CheckCustVariableLimitRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Creation type
        self.create_type = create_type
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class CheckCustVariableLimitResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class CheckCustVariableLimitResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CheckCustVariableLimitResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CheckCustVariableLimitResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CheckExpressionVariableLimitRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class CheckExpressionVariableLimitResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class CheckExpressionVariableLimitResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CheckExpressionVariableLimitResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CheckExpressionVariableLimitResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CheckFieldLimitRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        source: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id
        # Source of the field
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class CheckFieldLimitResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID
        self.request_id = request_id
        # Whether the condition is met: -**true**: meets the condition-**false**: does not meet the condition
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class CheckFieldLimitResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CheckFieldLimitResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CheckFieldLimitResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CheckUsageVariableRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        id: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Primary Key ID
        # 
        # This parameter is required.
        self.id = id
        # Region ID
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class CheckUsageVariableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Whether it was successful
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class CheckUsageVariableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CheckUsageVariableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CheckUsageVariableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CompareCopyRuleVariableRequest(TeaModel):
    def __init__(
        self,
        create_type: str = None,
        lang: str = None,
        reg_id: str = None,
        source_rule_id: str = None,
        source_rule_ids: str = None,
        target_event_code: str = None,
    ):
        # Creation type
        self.create_type = create_type
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code.
        self.reg_id = reg_id
        # Original policy ruleId.
        self.source_rule_id = source_rule_id
        # Original policy ruleIds.
        self.source_rule_ids = source_rule_ids
        # Target event eventCode.
        self.target_event_code = target_event_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_type is not None:
            result['CreateType'] = self.create_type
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        if self.source_rule_id is not None:
            result['SourceRuleId'] = self.source_rule_id
        if self.source_rule_ids is not None:
            result['SourceRuleIds'] = self.source_rule_ids
        if self.target_event_code is not None:
            result['TargetEventCode'] = self.target_event_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateType') is not None:
            self.create_type = m.get('CreateType')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        if m.get('SourceRuleId') is not None:
            self.source_rule_id = m.get('SourceRuleId')
        if m.get('SourceRuleIds') is not None:
            self.source_rule_ids = m.get('SourceRuleIds')
        if m.get('TargetEventCode') is not None:
            self.target_event_code = m.get('TargetEventCode')
        return self


class CompareCopyRuleVariableResponseBodyResultObjectCustVariableList(TeaModel):
    def __init__(
        self,
        description: str = None,
        id: int = None,
        name: str = None,
        out_type: str = None,
        title: str = None,
    ):
        # Description
        self.description = description
        # Variable ID
        self.id = id
        # Variable name
        self.name = name
        # Variable type
        self.out_type = out_type
        # Title
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.out_type is not None:
            result['OutType'] = self.out_type
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutType') is not None:
            self.out_type = m.get('OutType')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class CompareCopyRuleVariableResponseBodyResultObjectEventVariableList(TeaModel):
    def __init__(
        self,
        description: str = None,
        id: int = None,
        name: str = None,
        out_type: str = None,
        title: str = None,
    ):
        # Description
        self.description = description
        # Variable id
        self.id = id
        # Variable name
        self.name = name
        # Variable type
        self.out_type = out_type
        # Title
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.out_type is not None:
            result['OutType'] = self.out_type
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutType') is not None:
            self.out_type = m.get('OutType')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class CompareCopyRuleVariableResponseBodyResultObjectExpressionVariableList(TeaModel):
    def __init__(
        self,
        description: str = None,
        id: int = None,
        name: str = None,
        out_type: str = None,
        title: str = None,
    ):
        # Description
        self.description = description
        # Variable ID
        self.id = id
        # Variable name
        self.name = name
        # Variable Type
        self.out_type = out_type
        # Title
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.out_type is not None:
            result['OutType'] = self.out_type
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutType') is not None:
            self.out_type = m.get('OutType')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class CompareCopyRuleVariableResponseBodyResultObjectNameListVariableList(TeaModel):
    def __init__(
        self,
        description: str = None,
        id: int = None,
        name: str = None,
        out_type: str = None,
        title: str = None,
    ):
        # Description
        self.description = description
        # Variable id
        self.id = id
        # Variable name
        self.name = name
        # Variable type
        self.out_type = out_type
        # Title
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.out_type is not None:
            result['OutType'] = self.out_type
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutType') is not None:
            self.out_type = m.get('OutType')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class CompareCopyRuleVariableResponseBodyResultObjectQueryExpressionVariableList(TeaModel):
    def __init__(
        self,
        description: str = None,
        id: int = None,
        name: str = None,
        out_type: str = None,
        title: str = None,
    ):
        # Description
        self.description = description
        # Variable ID
        self.id = id
        # Variable Name
        self.name = name
        # Variable Type
        self.out_type = out_type
        # Title
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.out_type is not None:
            result['OutType'] = self.out_type
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutType') is not None:
            self.out_type = m.get('OutType')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class CompareCopyRuleVariableResponseBodyResultObjectSystemVariableList(TeaModel):
    def __init__(
        self,
        description: str = None,
        id: int = None,
        name: str = None,
        out_type: str = None,
        title: str = None,
    ):
        # Description
        self.description = description
        # Variable ID
        self.id = id
        # Variable name
        self.name = name
        # Variable type
        self.out_type = out_type
        # Title
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.out_type is not None:
            result['OutType'] = self.out_type
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutType') is not None:
            self.out_type = m.get('OutType')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class CompareCopyRuleVariableResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        cust_variable_list: List[CompareCopyRuleVariableResponseBodyResultObjectCustVariableList] = None,
        event_variable_list: List[CompareCopyRuleVariableResponseBodyResultObjectEventVariableList] = None,
        expression_variable_list: List[CompareCopyRuleVariableResponseBodyResultObjectExpressionVariableList] = None,
        name_list_variable_list: List[CompareCopyRuleVariableResponseBodyResultObjectNameListVariableList] = None,
        query_expression_variable_list: List[CompareCopyRuleVariableResponseBodyResultObjectQueryExpressionVariableList] = None,
        system_variable_list: List[CompareCopyRuleVariableResponseBodyResultObjectSystemVariableList] = None,
    ):
        # Cumulative variable list
        self.cust_variable_list = cust_variable_list
        # Event field variables
        self.event_variable_list = event_variable_list
        # Custom variable list
        self.expression_variable_list = expression_variable_list
        # Name list variables
        self.name_list_variable_list = name_list_variable_list
        # Custom Query Variable List
        self.query_expression_variable_list = query_expression_variable_list
        # System variable list
        self.system_variable_list = system_variable_list

    def validate(self):
        if self.cust_variable_list:
            for k in self.cust_variable_list:
                if k:
                    k.validate()
        if self.event_variable_list:
            for k in self.event_variable_list:
                if k:
                    k.validate()
        if self.expression_variable_list:
            for k in self.expression_variable_list:
                if k:
                    k.validate()
        if self.name_list_variable_list:
            for k in self.name_list_variable_list:
                if k:
                    k.validate()
        if self.query_expression_variable_list:
            for k in self.query_expression_variable_list:
                if k:
                    k.validate()
        if self.system_variable_list:
            for k in self.system_variable_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CustVariableList'] = []
        if self.cust_variable_list is not None:
            for k in self.cust_variable_list:
                result['CustVariableList'].append(k.to_map() if k else None)
        result['EventVariableList'] = []
        if self.event_variable_list is not None:
            for k in self.event_variable_list:
                result['EventVariableList'].append(k.to_map() if k else None)
        result['ExpressionVariableList'] = []
        if self.expression_variable_list is not None:
            for k in self.expression_variable_list:
                result['ExpressionVariableList'].append(k.to_map() if k else None)
        result['NameListVariableList'] = []
        if self.name_list_variable_list is not None:
            for k in self.name_list_variable_list:
                result['NameListVariableList'].append(k.to_map() if k else None)
        result['QueryExpressionVariableList'] = []
        if self.query_expression_variable_list is not None:
            for k in self.query_expression_variable_list:
                result['QueryExpressionVariableList'].append(k.to_map() if k else None)
        result['SystemVariableList'] = []
        if self.system_variable_list is not None:
            for k in self.system_variable_list:
                result['SystemVariableList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cust_variable_list = []
        if m.get('CustVariableList') is not None:
            for k in m.get('CustVariableList'):
                temp_model = CompareCopyRuleVariableResponseBodyResultObjectCustVariableList()
                self.cust_variable_list.append(temp_model.from_map(k))
        self.event_variable_list = []
        if m.get('EventVariableList') is not None:
            for k in m.get('EventVariableList'):
                temp_model = CompareCopyRuleVariableResponseBodyResultObjectEventVariableList()
                self.event_variable_list.append(temp_model.from_map(k))
        self.expression_variable_list = []
        if m.get('ExpressionVariableList') is not None:
            for k in m.get('ExpressionVariableList'):
                temp_model = CompareCopyRuleVariableResponseBodyResultObjectExpressionVariableList()
                self.expression_variable_list.append(temp_model.from_map(k))
        self.name_list_variable_list = []
        if m.get('NameListVariableList') is not None:
            for k in m.get('NameListVariableList'):
                temp_model = CompareCopyRuleVariableResponseBodyResultObjectNameListVariableList()
                self.name_list_variable_list.append(temp_model.from_map(k))
        self.query_expression_variable_list = []
        if m.get('QueryExpressionVariableList') is not None:
            for k in m.get('QueryExpressionVariableList'):
                temp_model = CompareCopyRuleVariableResponseBodyResultObjectQueryExpressionVariableList()
                self.query_expression_variable_list.append(temp_model.from_map(k))
        self.system_variable_list = []
        if m.get('SystemVariableList') is not None:
            for k in m.get('SystemVariableList'):
                temp_model = CompareCopyRuleVariableResponseBodyResultObjectSystemVariableList()
                self.system_variable_list.append(temp_model.from_map(k))
        return self


class CompareCopyRuleVariableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: CompareCopyRuleVariableResponseBodyResultObject = None,
    ):
        # Id of the request
        self.request_id = request_id
        # Result object.
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            temp_model = CompareCopyRuleVariableResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['ResultObject'])
        return self


class CompareCopyRuleVariableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CompareCopyRuleVariableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CompareCopyRuleVariableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAnalysisConditionFavoriteRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        condition: str = None,
        event_begin_time: int = None,
        event_codes: str = None,
        event_end_time: int = None,
        field_name: str = None,
        field_value: str = None,
        name: str = None,
        reg_id: str = None,
        type: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Condition value.
        # 
        # This parameter is required.
        self.condition = condition
        # Start time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.event_begin_time = event_begin_time
        # Event codes, separated by commas
        # 
        # This parameter is required.
        self.event_codes = event_codes
        # End time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.event_end_time = event_end_time
        # Field name
        self.field_name = field_name
        # Field value
        self.field_value = field_value
        # Condition favorite name
        # 
        # This parameter is required.
        self.name = name
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Query type
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.condition is not None:
            result['condition'] = self.condition
        if self.event_begin_time is not None:
            result['eventBeginTime'] = self.event_begin_time
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.event_end_time is not None:
            result['eventEndTime'] = self.event_end_time
        if self.field_name is not None:
            result['fieldName'] = self.field_name
        if self.field_value is not None:
            result['fieldValue'] = self.field_value
        if self.name is not None:
            result['name'] = self.name
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        if m.get('eventBeginTime') is not None:
            self.event_begin_time = m.get('eventBeginTime')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('eventEndTime') is not None:
            self.event_end_time = m.get('eventEndTime')
        if m.get('fieldName') is not None:
            self.field_name = m.get('fieldName')
        if m.get('fieldValue') is not None:
            self.field_value = m.get('fieldValue')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateAnalysisConditionFavoriteResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class CreateAnalysisConditionFavoriteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAnalysisConditionFavoriteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAnalysisConditionFavoriteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAnalysisExportTaskRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        columns: str = None,
        conditions: str = None,
        event_begin_time: int = None,
        event_codes: str = None,
        event_end_time: int = None,
        field_name: str = None,
        field_value: str = None,
        file_format: str = None,
        reg_id: str = None,
        scope: str = None,
        type: str = None,
    ):
        # Sets the language type for the request and response messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Custom columns
        self.columns = columns
        # Query expression
        self.conditions = conditions
        # Start time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.event_begin_time = event_begin_time
        # Event code.
        # 
        # This parameter is required.
        self.event_codes = event_codes
        # End time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.event_end_time = event_end_time
        # Field name
        self.field_name = field_name
        # Field value
        self.field_value = field_value
        # File format, Excel, CSV
        # 
        # This parameter is required.
        self.file_format = file_format
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Export scope: ALL: All, SELECT: Selected rows
        # 
        # This parameter is required.
        self.scope = scope
        # Type, BASIC: Basic query, ADVANCE: Advanced query, BATCH: Batch query
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.columns is not None:
            result['columns'] = self.columns
        if self.conditions is not None:
            result['conditions'] = self.conditions
        if self.event_begin_time is not None:
            result['eventBeginTime'] = self.event_begin_time
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.event_end_time is not None:
            result['eventEndTime'] = self.event_end_time
        if self.field_name is not None:
            result['fieldName'] = self.field_name
        if self.field_value is not None:
            result['fieldValue'] = self.field_value
        if self.file_format is not None:
            result['fileFormat'] = self.file_format
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.scope is not None:
            result['scope'] = self.scope
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('columns') is not None:
            self.columns = m.get('columns')
        if m.get('conditions') is not None:
            self.conditions = m.get('conditions')
        if m.get('eventBeginTime') is not None:
            self.event_begin_time = m.get('eventBeginTime')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('eventEndTime') is not None:
            self.event_end_time = m.get('eventEndTime')
        if m.get('fieldName') is not None:
            self.field_name = m.get('fieldName')
        if m.get('fieldValue') is not None:
            self.field_value = m.get('fieldValue')
        if m.get('fileFormat') is not None:
            self.file_format = m.get('fileFormat')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateAnalysisExportTaskResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        columns: str = None,
        conditions: str = None,
        event_begin_time: int = None,
        event_codes: str = None,
        event_end_time: int = None,
        file_format: str = None,
        oss_key: str = None,
        scope: str = None,
        status: str = None,
        type: str = None,
        user_id: int = None,
    ):
        # Export list.
        self.columns = columns
        # Export task conditions.
        self.conditions = conditions
        # Event start time.
        self.event_begin_time = event_begin_time
        # Event code.
        self.event_codes = event_codes
        # End time.
        self.event_end_time = event_end_time
        # File format.
        self.file_format = file_format
        # OSS-generated key.
        self.oss_key = oss_key
        # Export task scope.
        self.scope = scope
        # Task status.
        self.status = status
        # Export task type.
        self.type = type
        # User UID
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.columns is not None:
            result['columns'] = self.columns
        if self.conditions is not None:
            result['conditions'] = self.conditions
        if self.event_begin_time is not None:
            result['eventBeginTime'] = self.event_begin_time
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.event_end_time is not None:
            result['eventEndTime'] = self.event_end_time
        if self.file_format is not None:
            result['fileFormat'] = self.file_format
        if self.oss_key is not None:
            result['ossKey'] = self.oss_key
        if self.scope is not None:
            result['scope'] = self.scope
        if self.status is not None:
            result['status'] = self.status
        if self.type is not None:
            result['type'] = self.type
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('columns') is not None:
            self.columns = m.get('columns')
        if m.get('conditions') is not None:
            self.conditions = m.get('conditions')
        if m.get('eventBeginTime') is not None:
            self.event_begin_time = m.get('eventBeginTime')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('eventEndTime') is not None:
            self.event_end_time = m.get('eventEndTime')
        if m.get('fileFormat') is not None:
            self.file_format = m.get('fileFormat')
        if m.get('ossKey') is not None:
            self.oss_key = m.get('ossKey')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class CreateAnalysisExportTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: CreateAnalysisExportTaskResponseBodyResultObject = None,
    ):
        # Request ID
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = CreateAnalysisExportTaskResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class CreateAnalysisExportTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAnalysisExportTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAnalysisExportTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAppKeyRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Set the language type for requests and responses, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class CreateAppKeyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        data: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Data object
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class CreateAppKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAppKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAppKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCustVariableRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        condition: str = None,
        create_type: str = None,
        description: str = None,
        event_codes: str = None,
        history_value_type: str = None,
        object: str = None,
        outputs: str = None,
        reg_id: str = None,
        subject: str = None,
        time_type: str = None,
        title: str = None,
        tw_count: int = None,
        velocity_fc: str = None,
        velocity_tw: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Condition value.
        self.condition = condition
        # Creation type
        self.create_type = create_type
        # Description information.
        self.description = description
        # Event code
        # 
        # This parameter is required.
        self.event_codes = event_codes
        # Value type
        self.history_value_type = history_value_type
        # Accumulative object
        self.object = object
        # Variable return type
        self.outputs = outputs
        # Region code
        self.reg_id = reg_id
        # Primary object
        # 
        # This parameter is required.
        self.subject = subject
        # Time slice type
        # 
        # This parameter is required.
        self.time_type = time_type
        # Title.
        # 
        # This parameter is required.
        self.title = title
        # Number of time units
        self.tw_count = tw_count
        # Variable type
        # 
        # This parameter is required.
        self.velocity_fc = velocity_fc
        # Time slice unit
        # 
        # This parameter is required.
        self.velocity_tw = velocity_tw

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.condition is not None:
            result['condition'] = self.condition
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.description is not None:
            result['description'] = self.description
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.history_value_type is not None:
            result['historyValueType'] = self.history_value_type
        if self.object is not None:
            result['object'] = self.object
        if self.outputs is not None:
            result['outputs'] = self.outputs
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.subject is not None:
            result['subject'] = self.subject
        if self.time_type is not None:
            result['timeType'] = self.time_type
        if self.title is not None:
            result['title'] = self.title
        if self.tw_count is not None:
            result['twCount'] = self.tw_count
        if self.velocity_fc is not None:
            result['velocityFC'] = self.velocity_fc
        if self.velocity_tw is not None:
            result['velocityTW'] = self.velocity_tw
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('historyValueType') is not None:
            self.history_value_type = m.get('historyValueType')
        if m.get('object') is not None:
            self.object = m.get('object')
        if m.get('outputs') is not None:
            self.outputs = m.get('outputs')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('timeType') is not None:
            self.time_type = m.get('timeType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('twCount') is not None:
            self.tw_count = m.get('twCount')
        if m.get('velocityFC') is not None:
            self.velocity_fc = m.get('velocityFC')
        if m.get('velocityTW') is not None:
            self.velocity_tw = m.get('velocityTW')
        return self


class CreateCustVariableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class CreateCustVariableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCustVariableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCustVariableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataSourceRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        description: str = None,
        name: str = None,
        oss_key: str = None,
        reg_id: str = None,
        type: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Data source description.
        self.description = description
        # Data source name.
        # 
        # This parameter is required.
        self.name = name
        # OSS file key.
        # 
        # This parameter is required.
        self.oss_key = oss_key
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Data source type
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.description is not None:
            result['description'] = self.description
        if self.name is not None:
            result['name'] = self.name
        if self.oss_key is not None:
            result['ossKey'] = self.oss_key
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('ossKey') is not None:
            self.oss_key = m.get('ossKey')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class CreateDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEventRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        event_name: str = None,
        input_fields_str: str = None,
        memo: str = None,
        reg_id: str = None,
        template_code: str = None,
        template_name: str = None,
        template_type: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Creation type
        self.create_type = create_type
        # Event name.
        self.event_name = event_name
        # Input parameters, JSON string.
        self.input_fields_str = input_fields_str
        # Memo information
        self.memo = memo
        # Region code
        self.reg_id = reg_id
        # Input field template type
        self.template_code = template_code
        # Published template name.
        self.template_name = template_name
        # Template type.
        self.template_type = template_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.input_fields_str is not None:
            result['inputFieldsStr'] = self.input_fields_str
        if self.memo is not None:
            result['memo'] = self.memo
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.template_code is not None:
            result['templateCode'] = self.template_code
        if self.template_name is not None:
            result['templateName'] = self.template_name
        if self.template_type is not None:
            result['templateType'] = self.template_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('inputFieldsStr') is not None:
            self.input_fields_str = m.get('inputFieldsStr')
        if m.get('memo') is not None:
            self.memo = m.get('memo')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('templateCode') is not None:
            self.template_code = m.get('templateCode')
        if m.get('templateName') is not None:
            self.template_name = m.get('templateName')
        if m.get('templateType') is not None:
            self.template_type = m.get('templateType')
        return self


class CreateEventResponseBody(TeaModel):
    def __init__(
        self,
        data: bool = None,
        request_id: str = None,
    ):
        # Return result.
        self.data = data
        # Request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateEventResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEventResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateExpressionVariableRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        description: str = None,
        event_code: str = None,
        expression: str = None,
        expression_title: str = None,
        expression_variable: str = None,
        outlier: str = None,
        outputs: str = None,
        reg_id: str = None,
        title: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Description.
        self.description = description
        # Event code
        # 
        # This parameter is required.
        self.event_code = event_code
        # Calculation expression
        # 
        # This parameter is required.
        self.expression = expression
        # Display value of calculation expression
        # 
        # This parameter is required.
        self.expression_title = expression_title
        # Calculation expression variable
        self.expression_variable = expression_variable
        # Outlier
        # 
        # This parameter is required.
        self.outlier = outlier
        # Variable return type
        # 
        # This parameter is required.
        self.outputs = outputs
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Title.
        # 
        # This parameter is required.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.description is not None:
            result['description'] = self.description
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.expression is not None:
            result['expression'] = self.expression
        if self.expression_title is not None:
            result['expressionTitle'] = self.expression_title
        if self.expression_variable is not None:
            result['expressionVariable'] = self.expression_variable
        if self.outlier is not None:
            result['outlier'] = self.outlier
        if self.outputs is not None:
            result['outputs'] = self.outputs
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('expression') is not None:
            self.expression = m.get('expression')
        if m.get('expressionTitle') is not None:
            self.expression_title = m.get('expressionTitle')
        if m.get('expressionVariable') is not None:
            self.expression_variable = m.get('expressionVariable')
        if m.get('outlier') is not None:
            self.outlier = m.get('outlier')
        if m.get('outputs') is not None:
            self.outputs = m.get('outputs')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class CreateExpressionVariableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class CreateExpressionVariableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateExpressionVariableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateExpressionVariableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateFieldRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        classify: str = None,
        description: str = None,
        enum_data: str = None,
        name: str = None,
        reg_id: str = None,
        source: str = None,
        title: str = None,
        type: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Field classification.
        self.classify = classify
        # Description information.
        self.description = description
        # Enum data.
        self.enum_data = enum_data
        # Field name.
        self.name = name
        # Region code.
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Business source.
        self.source = source
        # Title.
        self.title = title
        # Field type.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.classify is not None:
            result['classify'] = self.classify
        if self.description is not None:
            result['description'] = self.description
        if self.enum_data is not None:
            result['enumData'] = self.enum_data
        if self.name is not None:
            result['name'] = self.name
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.source is not None:
            result['source'] = self.source
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('classify') is not None:
            self.classify = m.get('classify')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enumData') is not None:
            self.enum_data = m.get('enumData')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateFieldResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object.
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class CreateFieldResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateFieldResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateFieldResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateModelRequest(TeaModel):
    def __init__(
        self,
        buc_id: str = None,
        counts: str = None,
        file_md5: str = None,
        file_path: str = None,
        model_name: str = None,
        model_scene: str = None,
        parameter_num: str = None,
        reg_id: str = None,
        user_local_file_name: str = None,
    ):
        # Submitter ID.
        # 
        # This parameter is required.
        self.buc_id = buc_id
        # Number of file rows.
        # 
        # This parameter is required.
        self.counts = counts
        # File MD5 value.
        # 
        # This parameter is required.
        self.file_md5 = file_md5
        # File path.
        # 
        # This parameter is required.
        self.file_path = file_path
        # Model name.
        # 
        # This parameter is required.
        self.model_name = model_name
        # Model scenario.
        # 
        # This parameter is required.
        self.model_scene = model_scene
        # Number of file columns.
        # 
        # This parameter is required.
        self.parameter_num = parameter_num
        # Region code
        self.reg_id = reg_id
        # Uploaded file name.
        # 
        # This parameter is required.
        self.user_local_file_name = user_local_file_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.buc_id is not None:
            result['BucId'] = self.buc_id
        if self.counts is not None:
            result['Counts'] = self.counts
        if self.file_md5 is not None:
            result['FileMD5'] = self.file_md5
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.model_name is not None:
            result['ModelName'] = self.model_name
        if self.model_scene is not None:
            result['ModelScene'] = self.model_scene
        if self.parameter_num is not None:
            result['ParameterNum'] = self.parameter_num
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        if self.user_local_file_name is not None:
            result['UserLocalFileName'] = self.user_local_file_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucId') is not None:
            self.buc_id = m.get('BucId')
        if m.get('Counts') is not None:
            self.counts = m.get('Counts')
        if m.get('FileMD5') is not None:
            self.file_md5 = m.get('FileMD5')
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('ModelName') is not None:
            self.model_name = m.get('ModelName')
        if m.get('ModelScene') is not None:
            self.model_scene = m.get('ModelScene')
        if m.get('ParameterNum') is not None:
            self.parameter_num = m.get('ParameterNum')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        if m.get('UserLocalFileName') is not None:
            self.user_local_file_name = m.get('UserLocalFileName')
        return self


class CreateModelResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Result object.
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            self.result_object = m.get('ResultObject')
        return self


class CreateModelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateModelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateModelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePocEvRequest(TeaModel):
    def __init__(
        self,
        date_format: str = None,
        file_name: str = None,
        file_type: str = None,
        file_url: str = None,
        lang: str = None,
        reg_id: str = None,
        service_code: str = None,
        service_name: str = None,
        tab: str = None,
        task_name: str = None,
        type: str = None,
    ):
        # Date format type
        self.date_format = date_format
        # File name.
        # > The file name must end with txt or sql. For example, test.txt, test.sql.
        self.file_name = file_name
        # File type
        self.file_type = file_type
        # File URL.
        self.file_url = file_url
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id
        # Service code.
        self.service_code = service_code
        # Service name.
        self.service_name = service_name
        # Scenario.
        self.tab = tab
        # Task name.
        self.task_name = task_name
        # Access type.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date_format is not None:
            result['DateFormat'] = self.date_format
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        if self.service_code is not None:
            result['ServiceCode'] = self.service_code
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        if self.tab is not None:
            result['Tab'] = self.tab
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DateFormat') is not None:
            self.date_format = m.get('DateFormat')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        if m.get('ServiceCode') is not None:
            self.service_code = m.get('ServiceCode')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        if m.get('Tab') is not None:
            self.tab = m.get('Tab')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreatePocEvResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: str = None,
    ):
        # Response code.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Return message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Return result
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            self.result_object = m.get('ResultObject')
        return self


class CreatePocEvResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreatePocEvResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePocEvResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateQueryVariableRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        data_source_code: str = None,
        description: str = None,
        event_code: str = None,
        expression: str = None,
        expression_title: str = None,
        expression_variable: str = None,
        outlier: str = None,
        outputs: str = None,
        reg_id: str = None,
        title: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Data source ID.
        # 
        # This parameter is required.
        self.data_source_code = data_source_code
        # Description.
        self.description = description
        # Event code
        # 
        # This parameter is required.
        self.event_code = event_code
        # Calculation expression
        # 
        # This parameter is required.
        self.expression = expression
        # Display value of calculation expression
        # 
        # This parameter is required.
        self.expression_title = expression_title
        # Calculation expression variable
        # 
        # This parameter is required.
        self.expression_variable = expression_variable
        # Outlier
        # 
        # This parameter is required.
        self.outlier = outlier
        # Variable return type
        # 
        # This parameter is required.
        self.outputs = outputs
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Title.
        # 
        # This parameter is required.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.data_source_code is not None:
            result['dataSourceCode'] = self.data_source_code
        if self.description is not None:
            result['description'] = self.description
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.expression is not None:
            result['expression'] = self.expression
        if self.expression_title is not None:
            result['expressionTitle'] = self.expression_title
        if self.expression_variable is not None:
            result['expressionVariable'] = self.expression_variable
        if self.outlier is not None:
            result['outlier'] = self.outlier
        if self.outputs is not None:
            result['outputs'] = self.outputs
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('dataSourceCode') is not None:
            self.data_source_code = m.get('dataSourceCode')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('expression') is not None:
            self.expression = m.get('expression')
        if m.get('expressionTitle') is not None:
            self.expression_title = m.get('expressionTitle')
        if m.get('expressionVariable') is not None:
            self.expression_variable = m.get('expressionVariable')
        if m.get('outlier') is not None:
            self.outlier = m.get('outlier')
        if m.get('outputs') is not None:
            self.outputs = m.get('outputs')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class CreateQueryVariableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class CreateQueryVariableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateQueryVariableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateQueryVariableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRecommendEventRuleRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        event_code: str = None,
        event_name: str = None,
        recommend_rule_ids_str: str = None,
        reg_id: str = None,
        task_id: int = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Event code.
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Strategy ID.
        self.recommend_rule_ids_str = recommend_rule_ids_str
        # Region code.
        self.reg_id = reg_id
        # Task ID.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.recommend_rule_ids_str is not None:
            result['recommendRuleIdsStr'] = self.recommend_rule_ids_str
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.task_id is not None:
            result['taskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('recommendRuleIdsStr') is not None:
            self.recommend_rule_ids_str = m.get('recommendRuleIdsStr')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        return self


class CreateRecommendEventRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object.
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class CreateRecommendEventRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRecommendEventRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRecommendEventRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRecommendTaskRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        name: str = None,
        reg_id: str = None,
        sample_id: int = None,
        variables_str: str = None,
        velocities_str: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Name
        # 
        # This parameter is required.
        self.name = name
        # Region code
        self.reg_id = reg_id
        # Task ID.
        # 
        # This parameter is required.
        self.sample_id = sample_id
        # Variables to be calculated, variables
        # 
        # This parameter is required.
        self.variables_str = variables_str
        # Indicator effect
        # 
        # This parameter is required.
        self.velocities_str = velocities_str

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['name'] = self.name
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.sample_id is not None:
            result['sampleId'] = self.sample_id
        if self.variables_str is not None:
            result['variablesStr'] = self.variables_str
        if self.velocities_str is not None:
            result['velocitiesStr'] = self.velocities_str
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('sampleId') is not None:
            self.sample_id = m.get('sampleId')
        if m.get('variablesStr') is not None:
            self.variables_str = m.get('variablesStr')
        if m.get('velocitiesStr') is not None:
            self.velocities_str = m.get('velocitiesStr')
        return self


class CreateRecommendTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class CreateRecommendTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRecommendTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRecommendTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRuleRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        console_rule_id: int = None,
        create_type: str = None,
        event_code: str = None,
        event_name: str = None,
        logic_expression: str = None,
        memo: str = None,
        reg_id: str = None,
        rule_actions: str = None,
        rule_body: str = None,
        rule_expressions: str = None,
        rule_name: str = None,
        rule_status: str = None,
        rule_type: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Rule ID.
        self.console_rule_id = console_rule_id
        # Creation type
        self.create_type = create_type
        # Event code
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Policy expression execution logic
        self.logic_expression = logic_expression
        # Memo
        self.memo = memo
        # Region code
        self.reg_id = reg_id
        # Policy execution output action
        self.rule_actions = rule_actions
        # DSL policy execution logic
        self.rule_body = rule_body
        # Policy expression
        self.rule_expressions = rule_expressions
        # Policy name
        self.rule_name = rule_name
        # Policy status
        self.rule_status = rule_status
        # Policy type
        self.rule_type = rule_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.console_rule_id is not None:
            result['consoleRuleId'] = self.console_rule_id
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.logic_expression is not None:
            result['logicExpression'] = self.logic_expression
        if self.memo is not None:
            result['memo'] = self.memo
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.rule_actions is not None:
            result['ruleActions'] = self.rule_actions
        if self.rule_body is not None:
            result['ruleBody'] = self.rule_body
        if self.rule_expressions is not None:
            result['ruleExpressions'] = self.rule_expressions
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        if self.rule_status is not None:
            result['ruleStatus'] = self.rule_status
        if self.rule_type is not None:
            result['ruleType'] = self.rule_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('consoleRuleId') is not None:
            self.console_rule_id = m.get('consoleRuleId')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('logicExpression') is not None:
            self.logic_expression = m.get('logicExpression')
        if m.get('memo') is not None:
            self.memo = m.get('memo')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('ruleActions') is not None:
            self.rule_actions = m.get('ruleActions')
        if m.get('ruleBody') is not None:
            self.rule_body = m.get('ruleBody')
        if m.get('ruleExpressions') is not None:
            self.rule_expressions = m.get('ruleExpressions')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        if m.get('ruleStatus') is not None:
            self.rule_status = m.get('ruleStatus')
        if m.get('ruleType') is not None:
            self.rule_type = m.get('ruleType')
        return self


class CreateRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return result.
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class CreateRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSampleRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        client_file_name: str = None,
        client_path: str = None,
        file_type: str = None,
        reg_id: str = None,
        sample_tag: str = None,
        sample_type: str = None,
        sample_values: str = None,
        upload_type: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # OSS client uploaded file name
        self.client_file_name = client_file_name
        # OSS client address
        self.client_path = client_path
        # File type
        self.file_type = file_type
        # Region code
        self.reg_id = reg_id
        # Sample tag
        self.sample_tag = sample_tag
        # Sample type
        self.sample_type = sample_type
        # Sample values
        self.sample_values = sample_values
        # Upload type
        self.upload_type = upload_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.client_file_name is not None:
            result['clientFileName'] = self.client_file_name
        if self.client_path is not None:
            result['clientPath'] = self.client_path
        if self.file_type is not None:
            result['fileType'] = self.file_type
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.sample_tag is not None:
            result['sampleTag'] = self.sample_tag
        if self.sample_type is not None:
            result['sampleType'] = self.sample_type
        if self.sample_values is not None:
            result['sampleValues'] = self.sample_values
        if self.upload_type is not None:
            result['uploadType'] = self.upload_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('clientFileName') is not None:
            self.client_file_name = m.get('clientFileName')
        if m.get('clientPath') is not None:
            self.client_path = m.get('clientPath')
        if m.get('fileType') is not None:
            self.file_type = m.get('fileType')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('sampleTag') is not None:
            self.sample_tag = m.get('sampleTag')
        if m.get('sampleType') is not None:
            self.sample_type = m.get('sampleType')
        if m.get('sampleValues') is not None:
            self.sample_values = m.get('sampleValues')
        if m.get('uploadType') is not None:
            self.upload_type = m.get('uploadType')
        return self


class CreateSampleResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        community_count: int = None,
        fail_count: int = None,
        recall_probability: str = None,
        risk_density: str = None,
        sample_count: int = None,
        success_count: int = None,
    ):
        # Number of colored groups
        self.community_count = community_count
        # Number of failed samples
        self.fail_count = fail_count
        # Recall probability
        self.recall_probability = recall_probability
        # Risk density
        self.risk_density = risk_density
        # Number of samples
        self.sample_count = sample_count
        # Number of successful samples
        self.success_count = success_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.community_count is not None:
            result['communityCount'] = self.community_count
        if self.fail_count is not None:
            result['failCount'] = self.fail_count
        if self.recall_probability is not None:
            result['recallProbability'] = self.recall_probability
        if self.risk_density is not None:
            result['riskDensity'] = self.risk_density
        if self.sample_count is not None:
            result['sampleCount'] = self.sample_count
        if self.success_count is not None:
            result['successCount'] = self.success_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('communityCount') is not None:
            self.community_count = m.get('communityCount')
        if m.get('failCount') is not None:
            self.fail_count = m.get('failCount')
        if m.get('recallProbability') is not None:
            self.recall_probability = m.get('recallProbability')
        if m.get('riskDensity') is not None:
            self.risk_density = m.get('riskDensity')
        if m.get('sampleCount') is not None:
            self.sample_count = m.get('sampleCount')
        if m.get('successCount') is not None:
            self.success_count = m.get('successCount')
        return self


class CreateSampleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: CreateSampleResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = CreateSampleResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class CreateSampleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSampleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSampleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSampleApiRequest(TeaModel):
    def __init__(
        self,
        data_type: str = None,
        data_value: str = None,
        lang: str = None,
        reg_id: str = None,
        sample_batch_type: str = None,
        service_list: str = None,
    ):
        # Same as input parameter
        self.data_type = data_type
        # Specific data value
        self.data_value = data_value
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # regionId
        self.reg_id = reg_id
        # Sample batch type
        self.sample_batch_type = sample_batch_type
        # Service list.
        self.service_list = service_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_type is not None:
            result['DataType'] = self.data_type
        if self.data_value is not None:
            result['DataValue'] = self.data_value
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        if self.sample_batch_type is not None:
            result['SampleBatchType'] = self.sample_batch_type
        if self.service_list is not None:
            result['ServiceList'] = self.service_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataType') is not None:
            self.data_type = m.get('DataType')
        if m.get('DataValue') is not None:
            self.data_value = m.get('DataValue')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        if m.get('SampleBatchType') is not None:
            self.sample_batch_type = m.get('SampleBatchType')
        if m.get('ServiceList') is not None:
            self.service_list = m.get('ServiceList')
        return self


class CreateSampleApiResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
    ):
        # Status code.
        self.code = code
        # Error message.
        self.message = message
        # ID of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateSampleApiResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSampleApiResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSampleApiResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSampleBatchRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        batch_name: str = None,
        data_type: str = None,
        data_value: str = None,
        description: str = None,
        oss_file_name: str = None,
        reg_id: str = None,
        sample_batch_type: str = None,
        service_list: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Sample batch name
        self.batch_name = batch_name
        # Data type
        self.data_type = data_type
        # Content of the list entered in the text box
        self.data_value = data_value
        # Description information.
        self.description = description
        # Uploaded OSS address.
        self.oss_file_name = oss_file_name
        # Region code
        self.reg_id = reg_id
        # Specific type of sample list
        self.sample_batch_type = sample_batch_type
        # Service list
        self.service_list = service_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.batch_name is not None:
            result['batchName'] = self.batch_name
        if self.data_type is not None:
            result['dataType'] = self.data_type
        if self.data_value is not None:
            result['dataValue'] = self.data_value
        if self.description is not None:
            result['description'] = self.description
        if self.oss_file_name is not None:
            result['ossFileName'] = self.oss_file_name
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.sample_batch_type is not None:
            result['sampleBatchType'] = self.sample_batch_type
        if self.service_list is not None:
            result['serviceList'] = self.service_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('batchName') is not None:
            self.batch_name = m.get('batchName')
        if m.get('dataType') is not None:
            self.data_type = m.get('dataType')
        if m.get('dataValue') is not None:
            self.data_value = m.get('dataValue')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('ossFileName') is not None:
            self.oss_file_name = m.get('ossFileName')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('sampleBatchType') is not None:
            self.sample_batch_type = m.get('sampleBatchType')
        if m.get('serviceList') is not None:
            self.service_list = m.get('serviceList')
        return self


class CreateSampleBatchResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # ID of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateSampleBatchResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSampleBatchResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSampleBatchResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSampleDataRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        description: str = None,
        encrypt_type: str = None,
        name: str = None,
        reg_id: str = None,
        risk_value: str = None,
        scene: str = None,
        store_path: str = None,
        store_type: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Description.
        self.description = description
        # Encryption type
        self.encrypt_type = encrypt_type
        # Name
        self.name = name
        # Region code
        self.reg_id = reg_id
        # Specified risk value
        self.risk_value = risk_value
        # Scene
        self.scene = scene
        # Storage path
        self.store_path = store_path
        # Storage type
        self.store_type = store_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.description is not None:
            result['description'] = self.description
        if self.encrypt_type is not None:
            result['encryptType'] = self.encrypt_type
        if self.name is not None:
            result['name'] = self.name
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.risk_value is not None:
            result['riskValue'] = self.risk_value
        if self.scene is not None:
            result['scene'] = self.scene
        if self.store_path is not None:
            result['storePath'] = self.store_path
        if self.store_type is not None:
            result['storeType'] = self.store_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('encryptType') is not None:
            self.encrypt_type = m.get('encryptType')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('riskValue') is not None:
            self.risk_value = m.get('riskValue')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        if m.get('storePath') is not None:
            self.store_path = m.get('storePath')
        if m.get('storeType') is not None:
            self.store_type = m.get('storeType')
        return self


class CreateSampleDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class CreateSampleDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSampleDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSampleDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSimulationTaskRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        data_source_config: str = None,
        data_source_type: str = None,
        end_time: int = None,
        event_code: str = None,
        filters_str: str = None,
        reg_id: str = None,
        rules_str: str = None,
        run_task: bool = None,
        start_time: int = None,
        task_name: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Data source configuration
        self.data_source_config = data_source_config
        # Data source type
        self.data_source_type = data_source_type
        # End time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.end_time = end_time
        # Event code
        # 
        # This parameter is required.
        self.event_code = event_code
        # Filters
        self.filters_str = filters_str
        # Region code
        self.reg_id = reg_id
        # Rules list
        # 
        # This parameter is required.
        self.rules_str = rules_str
        # Whether to run the task directly
        # 
        # This parameter is required.
        self.run_task = run_task
        # Start time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.start_time = start_time
        # Task name
        # 
        # This parameter is required.
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.data_source_config is not None:
            result['dataSourceConfig'] = self.data_source_config
        if self.data_source_type is not None:
            result['dataSourceType'] = self.data_source_type
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.filters_str is not None:
            result['filtersStr'] = self.filters_str
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.rules_str is not None:
            result['rulesStr'] = self.rules_str
        if self.run_task is not None:
            result['runTask'] = self.run_task
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.task_name is not None:
            result['taskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('dataSourceConfig') is not None:
            self.data_source_config = m.get('dataSourceConfig')
        if m.get('dataSourceType') is not None:
            self.data_source_type = m.get('dataSourceType')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('filtersStr') is not None:
            self.filters_str = m.get('filtersStr')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('rulesStr') is not None:
            self.rules_str = m.get('rulesStr')
        if m.get('runTask') is not None:
            self.run_task = m.get('runTask')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('taskName') is not None:
            self.task_name = m.get('taskName')
        return self


class CreateSimulationTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class CreateSimulationTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSimulationTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSimulationTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeepCopyRuleRequest(TeaModel):
    def __init__(
        self,
        create_type: str = None,
        cust_insert_info: str = None,
        cust_write_info: str = None,
        expression_variable_info: str = None,
        lang: str = None,
        query_expression_variable_info: str = None,
        reg_id: str = None,
        source_rule_id: str = None,
        source_rule_ids: str = None,
        target_event_code: str = None,
        target_event_name: str = None,
    ):
        # Creation type
        self.create_type = create_type
        # Newly added cumulative variable
        self.cust_insert_info = cust_insert_info
        # Read cumulative variable
        self.cust_write_info = cust_write_info
        # Custom variables to be added
        self.expression_variable_info = expression_variable_info
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Custom query variables to be added
        self.query_expression_variable_info = query_expression_variable_info
        # Region code
        self.reg_id = reg_id
        # Source policy ID
        self.source_rule_id = source_rule_id
        # Target policy ID
        self.source_rule_ids = source_rule_ids
        # Target event
        self.target_event_code = target_event_code
        # Target event name
        self.target_event_name = target_event_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_type is not None:
            result['CreateType'] = self.create_type
        if self.cust_insert_info is not None:
            result['CustInsertInfo'] = self.cust_insert_info
        if self.cust_write_info is not None:
            result['CustWriteInfo'] = self.cust_write_info
        if self.expression_variable_info is not None:
            result['ExpressionVariableInfo'] = self.expression_variable_info
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.query_expression_variable_info is not None:
            result['QueryExpressionVariableInfo'] = self.query_expression_variable_info
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        if self.source_rule_id is not None:
            result['SourceRuleId'] = self.source_rule_id
        if self.source_rule_ids is not None:
            result['SourceRuleIds'] = self.source_rule_ids
        if self.target_event_code is not None:
            result['TargetEventCode'] = self.target_event_code
        if self.target_event_name is not None:
            result['TargetEventName'] = self.target_event_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateType') is not None:
            self.create_type = m.get('CreateType')
        if m.get('CustInsertInfo') is not None:
            self.cust_insert_info = m.get('CustInsertInfo')
        if m.get('CustWriteInfo') is not None:
            self.cust_write_info = m.get('CustWriteInfo')
        if m.get('ExpressionVariableInfo') is not None:
            self.expression_variable_info = m.get('ExpressionVariableInfo')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('QueryExpressionVariableInfo') is not None:
            self.query_expression_variable_info = m.get('QueryExpressionVariableInfo')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        if m.get('SourceRuleId') is not None:
            self.source_rule_id = m.get('SourceRuleId')
        if m.get('SourceRuleIds') is not None:
            self.source_rule_ids = m.get('SourceRuleIds')
        if m.get('TargetEventCode') is not None:
            self.target_event_code = m.get('TargetEventCode')
        if m.get('TargetEventName') is not None:
            self.target_event_name = m.get('TargetEventName')
        return self


class DeepCopyRuleResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        batch_copy_flag: bool = None,
        console_rule_id: int = None,
        rule_id: str = None,
        rule_version_id: int = None,
    ):
        # Whether to redirect to details
        self.batch_copy_flag = batch_copy_flag
        # Primary key of the policy
        self.console_rule_id = console_rule_id
        # Policy ID
        self.rule_id = rule_id
        # Primary key of the policy version
        self.rule_version_id = rule_version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_copy_flag is not None:
            result['BatchCopyFlag'] = self.batch_copy_flag
        if self.console_rule_id is not None:
            result['ConsoleRuleId'] = self.console_rule_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_version_id is not None:
            result['RuleVersionId'] = self.rule_version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BatchCopyFlag') is not None:
            self.batch_copy_flag = m.get('BatchCopyFlag')
        if m.get('ConsoleRuleId') is not None:
            self.console_rule_id = m.get('ConsoleRuleId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleVersionId') is not None:
            self.rule_version_id = m.get('RuleVersionId')
        return self


class DeepCopyRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DeepCopyRuleResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned result information
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            temp_model = DeepCopyRuleResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['ResultObject'])
        return self


class DeepCopyRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeepCopyRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeepCopyRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAnalysisConditionFavoriteRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        id: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Primary key ID
        # 
        # This parameter is required.
        self.id = id
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DeleteAnalysisConditionFavoriteResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DeleteAnalysisConditionFavoriteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAnalysisConditionFavoriteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAnalysisConditionFavoriteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteByPassShuntEventRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        event_id: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Event ID.
        self.event_id = event_id
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.event_id is not None:
            result['eventId'] = self.event_id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('eventId') is not None:
            self.event_id = m.get('eventId')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DeleteByPassShuntEventResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: bool = None,
        success: bool = None,
    ):
        # Status code
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object
        # Whether it was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteByPassShuntEventResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteByPassShuntEventResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteByPassShuntEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCustVariableRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        data_version: int = None,
        reg_id: str = None,
        variable_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Creation type
        self.create_type = create_type
        # Data version.
        self.data_version = data_version
        # Region code
        self.reg_id = reg_id
        # Variable ID
        self.variable_id = variable_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.data_version is not None:
            result['dataVersion'] = self.data_version
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.variable_id is not None:
            result['variableId'] = self.variable_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('dataVersion') is not None:
            self.data_version = m.get('dataVersion')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('variableId') is not None:
            self.variable_id = m.get('variableId')
        return self


class DeleteCustVariableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DeleteCustVariableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCustVariableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCustVariableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDataSourceRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        id: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Primary key ID
        # 
        # This parameter is required.
        self.id = id
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DeleteDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DeleteDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEventFieldRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        event_code: str = None,
        field_name: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Event code
        self.event_code = event_code
        # Field name
        self.field_name = field_name
        # Region ID
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.field_name is not None:
            result['fieldName'] = self.field_name
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('fieldName') is not None:
            self.field_name = m.get('fieldName')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DeleteEventFieldResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        resule_object: bool = None,
    ):
        # ID of the request
        self.request_id = request_id
        # Result object
        self.resule_object = resule_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resule_object is not None:
            result['resuleObject'] = self.resule_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resuleObject') is not None:
            self.resule_object = m.get('resuleObject')
        return self


class DeleteEventFieldResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEventFieldResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEventFieldResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteExpressionVariableRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        data_version: int = None,
        id: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Data version.
        # 
        # This parameter is required.
        self.data_version = data_version
        # Variable ID
        # 
        # This parameter is required.
        self.id = id
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.data_version is not None:
            result['dataVersion'] = self.data_version
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('dataVersion') is not None:
            self.data_version = m.get('dataVersion')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DeleteExpressionVariableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DeleteExpressionVariableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteExpressionVariableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteExpressionVariableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteFieldRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        id: int = None,
        name: str = None,
        reg_id: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Primary key ID of the field
        self.id = id
        # Name of the field.
        self.name = name
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DeleteFieldResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DeleteFieldResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteFieldResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteFieldResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteNameListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        ids: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Name list ID, multiple IDs should be separated by commas
        self.ids = ids
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.ids is not None:
            result['ids'] = self.ids
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ids') is not None:
            self.ids = m.get('ids')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DeleteNameListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DeleteNameListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteNameListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteNameListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteNameListDataRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        variable_id: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id
        # Variable ID
        self.variable_id = variable_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.variable_id is not None:
            result['variableId'] = self.variable_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('variableId') is not None:
            self.variable_id = m.get('variableId')
        return self


class DeleteNameListDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DeleteNameListDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteNameListDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteNameListDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteQueryVariableRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        id: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Variable ID.
        # 
        # This parameter is required.
        self.id = id
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DeleteQueryVariableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DeleteQueryVariableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteQueryVariableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteQueryVariableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRuleRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        console_rule_id: int = None,
        reg_id: str = None,
        rule_id: str = None,
        rule_version_id: int = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Policy primary key ID
        self.console_rule_id = console_rule_id
        # Region code
        self.reg_id = reg_id
        # Policy ID
        self.rule_id = rule_id
        # Policy version primary key ID
        self.rule_version_id = rule_version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.console_rule_id is not None:
            result['consoleRuleId'] = self.console_rule_id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.rule_version_id is not None:
            result['ruleVersionId'] = self.rule_version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('consoleRuleId') is not None:
            self.console_rule_id = m.get('consoleRuleId')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('ruleVersionId') is not None:
            self.rule_version_id = m.get('ruleVersionId')
        return self


class DeleteRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DeleteRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSampleBatchRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        ids: str = None,
        reg_id: str = None,
        versions: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # IDs for batch deletion operations.
        self.ids = ids
        # Region code.
        self.reg_id = reg_id
        # List of versions.
        # 
        # This parameter is required.
        self.versions = versions

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.ids is not None:
            result['ids'] = self.ids
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.versions is not None:
            result['versions'] = self.versions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ids') is not None:
            self.ids = m.get('ids')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('versions') is not None:
            self.versions = m.get('versions')
        return self


class DeleteSampleBatchResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        data: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned data object.
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class DeleteSampleBatchResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSampleBatchResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSampleBatchResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSampleBatchMetaRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        batch_uuid: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # UUID.
        self.batch_uuid = batch_uuid
        # Region code.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.batch_uuid is not None:
            result['batchUuid'] = self.batch_uuid
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('batchUuid') is not None:
            self.batch_uuid = m.get('batchUuid')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DeleteSampleBatchMetaResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # ID of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSampleBatchMetaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSampleBatchMetaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSampleBatchMetaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSampleDataRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        id: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Primary key ID
        self.id = id
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DeleteSampleDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DeleteSampleDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSampleDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSampleDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSelfBindVariableRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        id: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Variable ID
        self.id = id
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DeleteSelfBindVariableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # ID of the request
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DeleteSelfBindVariableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSelfBindVariableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSelfBindVariableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAdvanceSearchLeftVariableListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        event_codes: str = None,
        reg_id: str = None,
        scene: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Event code.
        # 
        # This parameter is required.
        self.event_codes = event_codes
        # Region code
        self.reg_id = reg_id
        # Scene
        # 
        # This parameter is required.
        self.scene = scene

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.scene is not None:
            result['scene'] = self.scene
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        return self


class DescribeAdvanceSearchLeftVariableListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        code: str = None,
        description: str = None,
        display_type: str = None,
        field_rank: int = None,
        field_type: str = None,
        id: int = None,
        name: str = None,
        parent_name: str = None,
        source_type: str = None,
        title: str = None,
        type: str = None,
    ):
        # Variable code
        self.code = code
        # Description.
        self.description = description
        # Display type and grouping label
        self.display_type = display_type
        # Variable return value type
        self.field_rank = field_rank
        # Field table sorting
        self.field_type = field_type
        # Primary key ID
        self.id = id
        # Variable name
        self.name = name
        # Parent node
        self.parent_name = parent_name
        # Data source
        self.source_type = source_type
        # Title.
        self.title = title
        # Variable type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.description is not None:
            result['description'] = self.description
        if self.display_type is not None:
            result['displayType'] = self.display_type
        if self.field_rank is not None:
            result['fieldRank'] = self.field_rank
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.parent_name is not None:
            result['parentName'] = self.parent_name
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayType') is not None:
            self.display_type = m.get('displayType')
        if m.get('fieldRank') is not None:
            self.field_rank = m.get('fieldRank')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parentName') is not None:
            self.parent_name = m.get('parentName')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeAdvanceSearchLeftVariableListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeAdvanceSearchLeftVariableListResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeAdvanceSearchLeftVariableListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeAdvanceSearchLeftVariableListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAdvanceSearchLeftVariableListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAdvanceSearchLeftVariableListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAdvanceSearchPageListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        condition: str = None,
        current_page: int = None,
        event_begin_time: int = None,
        event_codes: str = None,
        event_end_time: int = None,
        field_name: str = None,
        field_value: str = None,
        page_size: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Condition value.
        self.condition = condition
        # Current page number.
        # 
        # This parameter is required.
        self.current_page = current_page
        # Query start time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.event_begin_time = event_begin_time
        # Event code.
        # 
        # This parameter is required.
        self.event_codes = event_codes
        # End time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.event_end_time = event_end_time
        # Field name
        self.field_name = field_name
        # Field value
        self.field_value = field_value
        # Page size, default value is 10
        # 
        # This parameter is required.
        self.page_size = page_size
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.condition is not None:
            result['condition'] = self.condition
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.event_begin_time is not None:
            result['eventBeginTime'] = self.event_begin_time
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.event_end_time is not None:
            result['eventEndTime'] = self.event_end_time
        if self.field_name is not None:
            result['fieldName'] = self.field_name
        if self.field_value is not None:
            result['fieldValue'] = self.field_value
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('eventBeginTime') is not None:
            self.event_begin_time = m.get('eventBeginTime')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('eventEndTime') is not None:
            self.event_end_time = m.get('eventEndTime')
        if m.get('fieldName') is not None:
            self.field_name = m.get('fieldName')
        if m.get('fieldValue') is not None:
            self.field_value = m.get('fieldValue')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeAdvanceSearchPageListResponseBodyResultObjectHeader(TeaModel):
    def __init__(
        self,
        field_name: str = None,
        field_title: str = None,
        is_default: bool = None,
    ):
        # Field name
        self.field_name = field_name
        # Field title.
        self.field_title = field_title
        # Whether it is a default display field (displayed in the response, not used as a parameter)
        # - true: Yes
        # - false: No
        self.is_default = is_default

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_name is not None:
            result['fieldName'] = self.field_name
        if self.field_title is not None:
            result['fieldTitle'] = self.field_title
        if self.is_default is not None:
            result['isDefault'] = self.is_default
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldName') is not None:
            self.field_name = m.get('fieldName')
        if m.get('fieldTitle') is not None:
            self.field_title = m.get('fieldTitle')
        if m.get('isDefault') is not None:
            self.is_default = m.get('isDefault')
        return self


class DescribeAdvanceSearchPageListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        data: List[Dict[str, Any]] = None,
        header: List[DescribeAdvanceSearchPageListResponseBodyResultObjectHeader] = None,
        page_size: int = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Current page number.
        self.current_page = current_page
        # Returned data object
        self.data = data
        # Table header
        self.header = header
        # Number of items per page. Default value: 20, minimum value: 1, maximum value: 50.
        self.page_size = page_size
        # Total number of items
        self.total_item = total_item
        # Total number of pages
        self.total_page = total_page

    def validate(self):
        if self.header:
            for k in self.header:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.data is not None:
            result['data'] = self.data
        result['header'] = []
        if self.header is not None:
            for k in self.header:
                result['header'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('data') is not None:
            self.data = m.get('data')
        self.header = []
        if m.get('header') is not None:
            for k in m.get('header'):
                temp_model = DescribeAdvanceSearchPageListResponseBodyResultObjectHeader()
                self.header.append(temp_model.from_map(k))
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeAdvanceSearchPageListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeAdvanceSearchPageListResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeAdvanceSearchPageListResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeAdvanceSearchPageListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAdvanceSearchPageListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAdvanceSearchPageListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAllDataSourceRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeAllDataSourceResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        event_code: str = None,
        event_name: str = None,
        id: int = None,
    ):
        # Event code
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Policy primary key ID
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class DescribeAllDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeAllDataSourceResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeAllDataSourceResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeAllDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAllDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAllDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAllEventNameAndCodeRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for the request and response messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Creation type
        self.create_type = create_type
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeAllEventNameAndCodeResponseBodyResultObjectChildren(TeaModel):
    def __init__(
        self,
        create_type: str = None,
        event_code: str = None,
        event_name: str = None,
        event_type: str = None,
    ):
        # Creation type
        self.create_type = create_type
        # Event code
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Event type
        self.event_type = event_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.event_type is not None:
            result['eventType'] = self.event_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('eventType') is not None:
            self.event_type = m.get('eventType')
        return self


class DescribeAllEventNameAndCodeResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        children: List[DescribeAllEventNameAndCodeResponseBodyResultObjectChildren] = None,
        create_type: str = None,
        event_code: str = None,
        event_name: str = None,
        event_type: str = None,
    ):
        # List of child fields.
        self.children = children
        # Creation type
        self.create_type = create_type
        # Event code
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Event type
        self.event_type = event_type

    def validate(self):
        if self.children:
            for k in self.children:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['children'] = []
        if self.children is not None:
            for k in self.children:
                result['children'].append(k.to_map() if k else None)
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.event_type is not None:
            result['eventType'] = self.event_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.children = []
        if m.get('children') is not None:
            for k in m.get('children'):
                temp_model = DescribeAllEventNameAndCodeResponseBodyResultObjectChildren()
                self.children.append(temp_model.from_map(k))
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('eventType') is not None:
            self.event_type = m.get('eventType')
        return self


class DescribeAllEventNameAndCodeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: List[DescribeAllEventNameAndCodeResponseBodyResultObject] = None,
        success: bool = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object
        # Whether the operation was successful.
        self.success = success

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeAllEventNameAndCodeResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeAllEventNameAndCodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAllEventNameAndCodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAllEventNameAndCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAllRootVariableRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        source_ip: str = None,
        device_variable_ids: str = None,
        event_code: str = None,
        expression_variable_ids: str = None,
        id: int = None,
        native_variable_ids: str = None,
        query_variable_ids: str = None,
        reg_id: str = None,
        velocity_variable_ids: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Request source IP. No need to fill in, the system will automatically obtain it.
        self.source_ip = source_ip
        # Device variable list
        self.device_variable_ids = device_variable_ids
        # Event code
        self.event_code = event_code
        # Custom variable list
        self.expression_variable_ids = expression_variable_ids
        # Variable ID.
        self.id = id
        # Event field list
        self.native_variable_ids = native_variable_ids
        # Custom query variable
        self.query_variable_ids = query_variable_ids
        # Region code
        self.reg_id = reg_id
        # Custom cumulative variable
        self.velocity_variable_ids = velocity_variable_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.device_variable_ids is not None:
            result['deviceVariableIds'] = self.device_variable_ids
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.expression_variable_ids is not None:
            result['expressionVariableIds'] = self.expression_variable_ids
        if self.id is not None:
            result['id'] = self.id
        if self.native_variable_ids is not None:
            result['nativeVariableIds'] = self.native_variable_ids
        if self.query_variable_ids is not None:
            result['queryVariableIds'] = self.query_variable_ids
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.velocity_variable_ids is not None:
            result['velocityVariableIds'] = self.velocity_variable_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('deviceVariableIds') is not None:
            self.device_variable_ids = m.get('deviceVariableIds')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('expressionVariableIds') is not None:
            self.expression_variable_ids = m.get('expressionVariableIds')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('nativeVariableIds') is not None:
            self.native_variable_ids = m.get('nativeVariableIds')
        if m.get('queryVariableIds') is not None:
            self.query_variable_ids = m.get('queryVariableIds')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('velocityVariableIds') is not None:
            self.velocity_variable_ids = m.get('velocityVariableIds')
        return self


class DescribeAllRootVariableResponseBodyResultObjectOutputThreshold(TeaModel):
    def __init__(
        self,
        max_value: float = None,
        min_value: float = None,
    ):
        # Maximum value
        self.max_value = max_value
        # Minimum value.
        self.min_value = min_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_value is not None:
            result['maxValue'] = self.max_value
        if self.min_value is not None:
            result['minValue'] = self.min_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxValue') is not None:
            self.max_value = m.get('maxValue')
        if m.get('minValue') is not None:
            self.min_value = m.get('minValue')
        return self


class DescribeAllRootVariableResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        code: str = None,
        description: str = None,
        display_type: str = None,
        favorite_flag: bool = None,
        field_rank: int = None,
        field_type: str = None,
        id: int = None,
        input_field_type: str = None,
        inputs: str = None,
        name: str = None,
        output_threshold: DescribeAllRootVariableResponseBodyResultObjectOutputThreshold = None,
        source_type: str = None,
        title: str = None,
        type: str = None,
    ):
        # Variable code
        self.code = code
        # Variable description.
        self.description = description
        # Display type and group label
        self.display_type = display_type
        # Favorite flag
        self.favorite_flag = favorite_flag
        # Field ranking
        self.field_rank = field_rank
        # Field type.
        self.field_type = field_type
        # Variable ID.
        self.id = id
        # Input field type.
        self.input_field_type = input_field_type
        # Variable input.
        self.inputs = inputs
        # Variable name.
        self.name = name
        # Maximum cross-sectional area of the checkbox.
        self.output_threshold = output_threshold
        # Data source
        self.source_type = source_type
        # Title.
        self.title = title
        # Variable type.
        self.type = type

    def validate(self):
        if self.output_threshold:
            self.output_threshold.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.description is not None:
            result['description'] = self.description
        if self.display_type is not None:
            result['displayType'] = self.display_type
        if self.favorite_flag is not None:
            result['favoriteFlag'] = self.favorite_flag
        if self.field_rank is not None:
            result['fieldRank'] = self.field_rank
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.id is not None:
            result['id'] = self.id
        if self.input_field_type is not None:
            result['inputFieldType'] = self.input_field_type
        if self.inputs is not None:
            result['inputs'] = self.inputs
        if self.name is not None:
            result['name'] = self.name
        if self.output_threshold is not None:
            result['outputThreshold'] = self.output_threshold.to_map()
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayType') is not None:
            self.display_type = m.get('displayType')
        if m.get('favoriteFlag') is not None:
            self.favorite_flag = m.get('favoriteFlag')
        if m.get('fieldRank') is not None:
            self.field_rank = m.get('fieldRank')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('inputFieldType') is not None:
            self.input_field_type = m.get('inputFieldType')
        if m.get('inputs') is not None:
            self.inputs = m.get('inputs')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('outputThreshold') is not None:
            temp_model = DescribeAllRootVariableResponseBodyResultObjectOutputThreshold()
            self.output_threshold = temp_model.from_map(m['outputThreshold'])
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeAllRootVariableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeAllRootVariableResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeAllRootVariableResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeAllRootVariableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAllRootVariableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAllRootVariableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAnalysisColumnFieldListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeAnalysisColumnFieldListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeAnalysisColumnFieldListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAnalysisColumnFieldListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAnalysisColumnFieldListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAnalysisColumnListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeAnalysisColumnListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        event_code: str = None,
        event_name: str = None,
        is_default: bool = None,
        variable_name: str = None,
        variable_title: str = None,
        variable_type: str = None,
    ):
        # Event code
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Whether it is a default column.
        self.is_default = is_default
        # Variable name.
        self.variable_name = variable_name
        # Variable title.
        self.variable_title = variable_title
        # Variable type.
        self.variable_type = variable_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.is_default is not None:
            result['isDefault'] = self.is_default
        if self.variable_name is not None:
            result['variableName'] = self.variable_name
        if self.variable_title is not None:
            result['variableTitle'] = self.variable_title
        if self.variable_type is not None:
            result['variableType'] = self.variable_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('isDefault') is not None:
            self.is_default = m.get('isDefault')
        if m.get('variableName') is not None:
            self.variable_name = m.get('variableName')
        if m.get('variableTitle') is not None:
            self.variable_title = m.get('variableTitle')
        if m.get('variableType') is not None:
            self.variable_type = m.get('variableType')
        return self


class DescribeAnalysisColumnListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeAnalysisColumnListResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeAnalysisColumnListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeAnalysisColumnListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAnalysisColumnListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAnalysisColumnListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAnalysisConditionFavoriteListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeAnalysisConditionFavoriteListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        condition: str = None,
        event_begin_time: int = None,
        event_codes: str = None,
        event_end_time: int = None,
        field_name: str = None,
        field_value: str = None,
        id: int = None,
        name: str = None,
        type: str = None,
    ):
        # Condition value.
        self.condition = condition
        # Event start timestamp.
        self.event_begin_time = event_begin_time
        # Event codes.
        self.event_codes = event_codes
        # Event end time.
        self.event_end_time = event_end_time
        # Field name.
        self.field_name = field_name
        # Field value.
        self.field_value = field_value
        # Primary key ID
        self.id = id
        # Condition name
        self.name = name
        # Type, BASIC: Basic query, ADVANCE: Advanced query, BATCH: Batch query
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['condition'] = self.condition
        if self.event_begin_time is not None:
            result['eventBeginTime'] = self.event_begin_time
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.event_end_time is not None:
            result['eventEndTime'] = self.event_end_time
        if self.field_name is not None:
            result['fieldName'] = self.field_name
        if self.field_value is not None:
            result['fieldValue'] = self.field_value
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        if m.get('eventBeginTime') is not None:
            self.event_begin_time = m.get('eventBeginTime')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('eventEndTime') is not None:
            self.event_end_time = m.get('eventEndTime')
        if m.get('fieldName') is not None:
            self.field_name = m.get('fieldName')
        if m.get('fieldValue') is not None:
            self.field_value = m.get('fieldValue')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeAnalysisConditionFavoriteListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeAnalysisConditionFavoriteListResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeAnalysisConditionFavoriteListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeAnalysisConditionFavoriteListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAnalysisConditionFavoriteListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAnalysisConditionFavoriteListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAnalysisExportTaskDownloadUrlRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeAnalysisExportTaskDownloadUrlResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        download_file_url: str = None,
        execute_time: int = None,
        status: str = None,
    ):
        # Download URL.
        self.download_file_url = download_file_url
        # Download execution time
        self.execute_time = execute_time
        # Task status.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_file_url is not None:
            result['downloadFileUrl'] = self.download_file_url
        if self.execute_time is not None:
            result['executeTime'] = self.execute_time
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('downloadFileUrl') is not None:
            self.download_file_url = m.get('downloadFileUrl')
        if m.get('executeTime') is not None:
            self.execute_time = m.get('executeTime')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class DescribeAnalysisExportTaskDownloadUrlResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeAnalysisExportTaskDownloadUrlResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeAnalysisExportTaskDownloadUrlResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeAnalysisExportTaskDownloadUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAnalysisExportTaskDownloadUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAnalysisExportTaskDownloadUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApiRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        api_id: str = None,
        api_region_id: str = None,
        api_type: str = None,
        reg_id: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # API unique ID.
        # 
        # This parameter is required.
        self.api_id = api_id
        # Region ID.
        # 
        # This parameter is required.
        self.api_region_id = api_region_id
        # API type
        # 
        # This parameter is required.
        self.api_type = api_type
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.api_id is not None:
            result['apiId'] = self.api_id
        if self.api_region_id is not None:
            result['apiRegionId'] = self.api_region_id
        if self.api_type is not None:
            result['apiType'] = self.api_type
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('apiId') is not None:
            self.api_id = m.get('apiId')
        if m.get('apiRegionId') is not None:
            self.api_region_id = m.get('apiRegionId')
        if m.get('apiType') is not None:
            self.api_type = m.get('apiType')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeApiResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeApiResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApiResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApiResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApiGroupsRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        api_region_id: str = None,
        reg_id: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region ID.
        # 
        # This parameter is required.
        self.api_region_id = api_region_id
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.api_region_id is not None:
            result['apiRegionId'] = self.api_region_id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('apiRegionId') is not None:
            self.api_region_id = m.get('apiRegionId')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeApiGroupsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeApiGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApiGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApiGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApiLimitRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeApiLimitResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        limit: bool = None,
        max_total_item: int = None,
        total_item: int = None,
    ):
        # Whether the maximum number has been exceeded
        self.limit = limit
        # Maximum number of items that can be created
        self.max_total_item = max_total_item
        # Total number of items
        self.total_item = total_item

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.limit is not None:
            result['limit'] = self.limit
        if self.max_total_item is not None:
            result['maxTotalItem'] = self.max_total_item
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('maxTotalItem') is not None:
            self.max_total_item = m.get('maxTotalItem')
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        return self


class DescribeApiLimitResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeApiLimitResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeApiLimitResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeApiLimitResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApiLimitResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApiLimitResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApiNameListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and responses, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeApiNameListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        api_id: str = None,
        api_name: str = None,
    ):
        # API ID.
        self.api_id = api_id
        # API name.
        self.api_name = api_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_id is not None:
            result['apiId'] = self.api_id
        if self.api_name is not None:
            result['apiName'] = self.api_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('apiId') is not None:
            self.api_id = m.get('apiId')
        if m.get('apiName') is not None:
            self.api_name = m.get('apiName')
        return self


class DescribeApiNameListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeApiNameListResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeApiNameListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeApiNameListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApiNameListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApiNameListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApiVariableRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        id: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Variable ID
        # 
        # This parameter is required.
        self.id = id
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeApiVariableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeApiVariableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApiVariableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApiVariableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApisRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        api_group_id: str = None,
        api_region_id: str = None,
        api_type: str = None,
        reg_id: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # API group ID.
        # 
        # This parameter is required.
        self.api_group_id = api_group_id
        # Region ID.
        # 
        # This parameter is required.
        self.api_region_id = api_region_id
        # API type.
        # 
        # This parameter is required.
        self.api_type = api_type
        # Region code.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.api_group_id is not None:
            result['apiGroupId'] = self.api_group_id
        if self.api_region_id is not None:
            result['apiRegionId'] = self.api_region_id
        if self.api_type is not None:
            result['apiType'] = self.api_type
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('apiGroupId') is not None:
            self.api_group_id = m.get('apiGroupId')
        if m.get('apiRegionId') is not None:
            self.api_region_id = m.get('apiRegionId')
        if m.get('apiType') is not None:
            self.api_type = m.get('apiType')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeApisResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object.
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeApisResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApisResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApisResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAppKeyPageRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        current_page: str = None,
        page_size: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Current page number.
        self.current_page = current_page
        # Number of items per page, default value is 10.
        self.page_size = page_size
        # Region code.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeAppKeyPageResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        android_sdk_url: str = None,
        android_sdk_version: str = None,
        app_key: str = None,
        gmt_create: int = None,
        ios_sdk_url: str = None,
        ios_sdk_version: str = None,
        memo: str = None,
        sdk_items: str = None,
        used: str = None,
    ):
        # Android SDK download URL.
        self.android_sdk_url = android_sdk_url
        # Android SDK version number.
        self.android_sdk_version = android_sdk_version
        # Application appkey.
        self.app_key = app_key
        # Creation time.
        self.gmt_create = gmt_create
        # iOS SDK download URL.
        self.ios_sdk_url = ios_sdk_url
        # iOS SDK version number.
        self.ios_sdk_version = ios_sdk_version
        # Memo.
        self.memo = memo
        # Deprecated.
        self.sdk_items = sdk_items
        # Whether this appKey is integrated.
        self.used = used

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.android_sdk_url is not None:
            result['androidSdkUrl'] = self.android_sdk_url
        if self.android_sdk_version is not None:
            result['androidSdkVersion'] = self.android_sdk_version
        if self.app_key is not None:
            result['appKey'] = self.app_key
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.ios_sdk_url is not None:
            result['iosSdkUrl'] = self.ios_sdk_url
        if self.ios_sdk_version is not None:
            result['iosSdkVersion'] = self.ios_sdk_version
        if self.memo is not None:
            result['memo'] = self.memo
        if self.sdk_items is not None:
            result['sdkItems'] = self.sdk_items
        if self.used is not None:
            result['used'] = self.used
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('androidSdkUrl') is not None:
            self.android_sdk_url = m.get('androidSdkUrl')
        if m.get('androidSdkVersion') is not None:
            self.android_sdk_version = m.get('androidSdkVersion')
        if m.get('appKey') is not None:
            self.app_key = m.get('appKey')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('iosSdkUrl') is not None:
            self.ios_sdk_url = m.get('iosSdkUrl')
        if m.get('iosSdkVersion') is not None:
            self.ios_sdk_version = m.get('iosSdkVersion')
        if m.get('memo') is not None:
            self.memo = m.get('memo')
        if m.get('sdkItems') is not None:
            self.sdk_items = m.get('sdkItems')
        if m.get('used') is not None:
            self.used = m.get('used')
        return self


class DescribeAppKeyPageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeAppKeyPageResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Number of items per page, default value is 10.
        self.page_size = page_size
        # Returned object.
        self.result_object = result_object
        # Total number of items.
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeAppKeyPageResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeAppKeyPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAppKeyPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAppKeyPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAuditConfigRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        audit_relation_type: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Audit type
        self.audit_relation_type = audit_relation_type
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.audit_relation_type is not None:
            result['auditRelationType'] = self.audit_relation_type
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('auditRelationType') is not None:
            self.audit_relation_type = m.get('auditRelationType')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeAuditConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        result_object: bool = None,
        success: bool = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message
        self.message = message
        # Returned object
        self.result_object = result_object
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeAuditConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAuditConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAuditConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAuditDetailsRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        id: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Primary key ID
        # 
        # This parameter is required.
        self.id = id
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeAuditDetailsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        result_object: bool = None,
        success: bool = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Returned object
        self.result_object = result_object
        # Whether the call was successful
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeAuditDetailsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAuditDetailsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAuditDetailsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAuditPageListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        audit_status: str = None,
        current_page: str = None,
        event_code: str = None,
        page_size: str = None,
        reg_id: str = None,
        rule_name: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Audit status
        self.audit_status = audit_status
        # Current page number.
        self.current_page = current_page
        # Event code
        self.event_code = event_code
        # Page size, default value is 10
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id
        # Policy name
        self.rule_name = rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.audit_status is not None:
            result['auditStatus'] = self.audit_status
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('auditStatus') is not None:
            self.audit_status = m.get('auditStatus')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        return self


class DescribeAuditPageListResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        request_id: str = None,
        result_object: bool = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Current page number.
        self.current_page = current_page
        # Number of records per page, default value: 10.
        self.page_size = page_size
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object
        # Total items
        self.total_item = total_item
        # Total pages
        self.total_page = total_page

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeAuditPageListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAuditPageListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAuditPageListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAuthEventNameListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeAuthEventNameListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeAuthEventNameListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAuthEventNameListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAuthEventNameListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAuthRulePageListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        event_code: str = None,
        reg_id: str = None,
        rule_name: str = None,
        status: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Event code
        self.event_code = event_code
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Policy name
        self.rule_name = rule_name
        # Status.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class DescribeAuthRulePageListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        console_rule_id: int = None,
        create_type: str = None,
        gmt_modified: int = None,
        id: int = None,
        memo: str = None,
        rule_id: str = None,
        rule_name: str = None,
        rule_version_id: int = None,
        status: str = None,
        version: int = None,
    ):
        # Console rule ID.
        self.console_rule_id = console_rule_id
        # Creation type
        self.create_type = create_type
        # Modification time
        self.gmt_modified = gmt_modified
        # Policy primary key ID
        self.id = id
        # Memo
        self.memo = memo
        # Policy ID
        self.rule_id = rule_id
        # Policy name
        self.rule_name = rule_name
        # Policy version primary key ID
        self.rule_version_id = rule_version_id
        # Status.
        self.status = status
        # Version number
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.console_rule_id is not None:
            result['consoleRuleId'] = self.console_rule_id
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.memo is not None:
            result['memo'] = self.memo
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        if self.rule_version_id is not None:
            result['ruleVersionId'] = self.rule_version_id
        if self.status is not None:
            result['status'] = self.status
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('consoleRuleId') is not None:
            self.console_rule_id = m.get('consoleRuleId')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('memo') is not None:
            self.memo = m.get('memo')
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        if m.get('ruleVersionId') is not None:
            self.rule_version_id = m.get('ruleVersionId')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class DescribeAuthRulePageListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeAuthRulePageListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10
        self.page_size = page_size
        # Returned object
        self.result_object = result_object
        # Total items
        self.total_item = total_item
        # Total pages
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeAuthRulePageListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeAuthRulePageListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAuthRulePageListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAuthRulePageListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAuthSceneListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeAuthSceneListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        service_code: str = None,
    ):
        # Service code
        self.service_code = service_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.service_code is not None:
            result['serviceCode'] = self.service_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('serviceCode') is not None:
            self.service_code = m.get('serviceCode')
        return self


class DescribeAuthSceneListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeAuthSceneListResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeAuthSceneListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeAuthSceneListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAuthSceneListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAuthSceneListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAuthScenePageListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        scene_name: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Scene name.
        self.scene_name = scene_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.scene_name is not None:
            result['sceneName'] = self.scene_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('sceneName') is not None:
            self.scene_name = m.get('sceneName')
        return self


class DescribeAuthScenePageListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        common_rule_count: int = None,
        custom_rule_count: int = None,
        event_code: str = None,
        scene_name: str = None,
        server_name: str = None,
    ):
        # Number of common rules
        self.common_rule_count = common_rule_count
        # Number of custom rules
        self.custom_rule_count = custom_rule_count
        # Event code
        self.event_code = event_code
        # Scene name.
        self.scene_name = scene_name
        # Service name.
        self.server_name = server_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_rule_count is not None:
            result['commonRuleCount'] = self.common_rule_count
        if self.custom_rule_count is not None:
            result['customRuleCount'] = self.custom_rule_count
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.scene_name is not None:
            result['sceneName'] = self.scene_name
        if self.server_name is not None:
            result['serverName'] = self.server_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonRuleCount') is not None:
            self.common_rule_count = m.get('commonRuleCount')
        if m.get('customRuleCount') is not None:
            self.custom_rule_count = m.get('customRuleCount')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('sceneName') is not None:
            self.scene_name = m.get('sceneName')
        if m.get('serverName') is not None:
            self.server_name = m.get('serverName')
        return self


class DescribeAuthScenePageListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeAuthScenePageListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10
        self.page_size = page_size
        # Returned object
        self.result_object = result_object
        # Total number of items
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeAuthScenePageListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeAuthScenePageListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAuthScenePageListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAuthScenePageListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAuthStatusRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and responses, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeAuthStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeAuthStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAuthStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAuthStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAvgExecuteCostReportRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeAvgExecuteCostReportResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        ratio: str = None,
        value: str = None,
    ):
        # Comparison with yesterday\\"s average execution time
        self.ratio = ratio
        # Today\\"s average execution time
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ratio is not None:
            result['ratio'] = self.ratio
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ratio') is not None:
            self.ratio = m.get('ratio')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeAvgExecuteCostReportResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: List[DescribeAvgExecuteCostReportResponseBodyResultObject] = None,
        success: bool = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object
        # Whether the call was successful
        self.success = success

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeAvgExecuteCostReportResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeAvgExecuteCostReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAvgExecuteCostReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAvgExecuteCostReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBasicSearchPageListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        current_page: int = None,
        event_begin_time: int = None,
        event_codes: str = None,
        event_end_time: int = None,
        field_name: str = None,
        field_value: str = None,
        page_size: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Current page number.
        # 
        # This parameter is required.
        self.current_page = current_page
        # Query start time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.event_begin_time = event_begin_time
        # Event code.
        # 
        # This parameter is required.
        self.event_codes = event_codes
        # End time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.event_end_time = event_end_time
        # Field name
        self.field_name = field_name
        # Field value
        self.field_value = field_value
        # Page size, with a default value of 10
        # 
        # This parameter is required.
        self.page_size = page_size
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.event_begin_time is not None:
            result['eventBeginTime'] = self.event_begin_time
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.event_end_time is not None:
            result['eventEndTime'] = self.event_end_time
        if self.field_name is not None:
            result['fieldName'] = self.field_name
        if self.field_value is not None:
            result['fieldValue'] = self.field_value
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('eventBeginTime') is not None:
            self.event_begin_time = m.get('eventBeginTime')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('eventEndTime') is not None:
            self.event_end_time = m.get('eventEndTime')
        if m.get('fieldName') is not None:
            self.field_name = m.get('fieldName')
        if m.get('fieldValue') is not None:
            self.field_value = m.get('fieldValue')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeBasicSearchPageListResponseBodyResultObjectHeader(TeaModel):
    def __init__(
        self,
        field_name: str = None,
        field_title: str = None,
        is_default: bool = None,
    ):
        # Field name
        self.field_name = field_name
        # Field title.
        self.field_title = field_title
        # Whether it is a default display field (displayed in the response, not used as a parameter)
        # - true: Yes
        # - false: No
        self.is_default = is_default

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_name is not None:
            result['fieldName'] = self.field_name
        if self.field_title is not None:
            result['fieldTitle'] = self.field_title
        if self.is_default is not None:
            result['isDefault'] = self.is_default
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldName') is not None:
            self.field_name = m.get('fieldName')
        if m.get('fieldTitle') is not None:
            self.field_title = m.get('fieldTitle')
        if m.get('isDefault') is not None:
            self.is_default = m.get('isDefault')
        return self


class DescribeBasicSearchPageListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        data: List[Dict[str, Any]] = None,
        header: List[DescribeBasicSearchPageListResponseBodyResultObjectHeader] = None,
        page_size: int = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Current page number in pagination queries.
        self.current_page = current_page
        # Returned data object
        self.data = data
        # Table header
        self.header = header
        # Page size, with a default value of 10
        self.page_size = page_size
        # Total number of items
        self.total_item = total_item
        # Total number of pages
        self.total_page = total_page

    def validate(self):
        if self.header:
            for k in self.header:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.data is not None:
            result['data'] = self.data
        result['header'] = []
        if self.header is not None:
            for k in self.header:
                result['header'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('data') is not None:
            self.data = m.get('data')
        self.header = []
        if m.get('header') is not None:
            for k in m.get('header'):
                temp_model = DescribeBasicSearchPageListResponseBodyResultObjectHeader()
                self.header.append(temp_model.from_map(k))
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeBasicSearchPageListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeBasicSearchPageListResponseBodyResultObject = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeBasicSearchPageListResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeBasicSearchPageListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeBasicSearchPageListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBasicSearchPageListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBasicStartRequest(TeaModel):
    def __init__(
        self,
        app_key: str = None,
        end_ds: str = None,
        reg_id: str = None,
        service: str = None,
        start_ds: str = None,
    ):
        # Application appkey.
        self.app_key = app_key
        # End time, accurate to milliseconds (ms).
        self.end_ds = end_ds
        # Region code
        self.reg_id = reg_id
        # Service to call
        self.service = service
        # Start time, accurate to milliseconds (ms).
        self.start_ds = start_ds

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_key is not None:
            result['appKey'] = self.app_key
        if self.end_ds is not None:
            result['endDs'] = self.end_ds
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.service is not None:
            result['service'] = self.service
        if self.start_ds is not None:
            result['startDs'] = self.start_ds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('appKey') is not None:
            self.app_key = m.get('appKey')
        if m.get('endDs') is not None:
            self.end_ds = m.get('endDs')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('service') is not None:
            self.service = m.get('service')
        if m.get('startDs') is not None:
            self.start_ds = m.get('startDs')
        return self


class DescribeBasicStartResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: bool = None,
        success: bool = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Return message
        self.message = message
        # Request ID
        self.request_id = request_id
        # Returned object
        self.result_object = result_object
        # Whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeBasicStartResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeBasicStartResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBasicStartResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeByPassShuntEventRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        event_id: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Event ID.
        self.event_id = event_id
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.event_id is not None:
            result['eventId'] = self.event_id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('eventId') is not None:
            self.event_id = m.get('eventId')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeByPassShuntEventResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        event_name: str = None,
    ):
        # Event name.
        self.event_name = event_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_name is not None:
            result['eventName'] = self.event_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        return self


class DescribeByPassShuntEventResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: DescribeByPassShuntEventResponseBodyResultObject = None,
        success: bool = None,
    ):
        # Error code.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error details
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object
        # Whether it was successful.
        self.success = success

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeByPassShuntEventResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeByPassShuntEventResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeByPassShuntEventResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeByPassShuntEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCustVariableConfigListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        biz_type: str = None,
        reg_id: str = None,
        time_type: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Configuration type
        # 
        # This parameter is required.
        self.biz_type = biz_type
        # Region code
        self.reg_id = reg_id
        # Time type
        self.time_type = time_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.biz_type is not None:
            result['bizType'] = self.biz_type
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.time_type is not None:
            result['timeType'] = self.time_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('bizType') is not None:
            self.biz_type = m.get('bizType')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('timeType') is not None:
            self.time_type = m.get('timeType')
        return self


class DescribeCustVariableConfigListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        config_key: str = None,
        config_value: str = None,
    ):
        # Configuration key
        self.config_key = config_key
        # Configuration value
        self.config_value = config_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_key is not None:
            result['configKey'] = self.config_key
        if self.config_value is not None:
            result['configValue'] = self.config_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('configKey') is not None:
            self.config_key = m.get('configKey')
        if m.get('configValue') is not None:
            self.config_value = m.get('configValue')
        return self


class DescribeCustVariableConfigListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeCustVariableConfigListResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeCustVariableConfigListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeCustVariableConfigListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCustVariableConfigListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCustVariableConfigListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCustVariableDetailRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        id: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Primary key ID of the cumulative variable
        # 
        # This parameter is required.
        self.id = id
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeCustVariableDetailResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        condition: str = None,
        data_version: int = None,
        description: str = None,
        event_codes: str = None,
        history_value_type: str = None,
        id: int = None,
        object: str = None,
        outputs: str = None,
        subject: str = None,
        time_type: str = None,
        title: str = None,
        tw_count: str = None,
        velocity_fc: str = None,
        velocity_tw: str = None,
    ):
        # Condition value.
        self.condition = condition
        # Data version.
        self.data_version = data_version
        # Description information.
        self.description = description
        # Event code.
        self.event_codes = event_codes
        # Value type
        self.history_value_type = history_value_type
        # Primary key ID of the cumulative variable
        self.id = id
        # Cumulative object
        self.object = object
        # Variable return type
        self.outputs = outputs
        # Main object
        self.subject = subject
        # Time slice type
        self.time_type = time_type
        # Title.
        self.title = title
        # Time count
        self.tw_count = tw_count
        # Variable type
        self.velocity_fc = velocity_fc
        # Time slice unit
        self.velocity_tw = velocity_tw

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['condition'] = self.condition
        if self.data_version is not None:
            result['dataVersion'] = self.data_version
        if self.description is not None:
            result['description'] = self.description
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.history_value_type is not None:
            result['historyValueType'] = self.history_value_type
        if self.id is not None:
            result['id'] = self.id
        if self.object is not None:
            result['object'] = self.object
        if self.outputs is not None:
            result['outputs'] = self.outputs
        if self.subject is not None:
            result['subject'] = self.subject
        if self.time_type is not None:
            result['timeType'] = self.time_type
        if self.title is not None:
            result['title'] = self.title
        if self.tw_count is not None:
            result['twCount'] = self.tw_count
        if self.velocity_fc is not None:
            result['velocityFC'] = self.velocity_fc
        if self.velocity_tw is not None:
            result['velocityTW'] = self.velocity_tw
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        if m.get('dataVersion') is not None:
            self.data_version = m.get('dataVersion')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('historyValueType') is not None:
            self.history_value_type = m.get('historyValueType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('object') is not None:
            self.object = m.get('object')
        if m.get('outputs') is not None:
            self.outputs = m.get('outputs')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('timeType') is not None:
            self.time_type = m.get('timeType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('twCount') is not None:
            self.tw_count = m.get('twCount')
        if m.get('velocityFC') is not None:
            self.velocity_fc = m.get('velocityFC')
        if m.get('velocityTW') is not None:
            self.velocity_tw = m.get('velocityTW')
        return self


class DescribeCustVariableDetailResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeCustVariableDetailResponseBodyResultObject] = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeCustVariableDetailResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeCustVariableDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCustVariableDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCustVariableDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCustVariablePageRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        current_page: int = None,
        description: str = None,
        event_code: str = None,
        page_size: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Creation type
        self.create_type = create_type
        # Pagination parameter, current page number.
        self.current_page = current_page
        # Description
        self.description = description
        # Event code
        self.event_code = event_code
        # Number of records per page, default value: 10
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.description is not None:
            result['description'] = self.description
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeCustVariablePageResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        data_version: int = None,
        description: str = None,
        gmt_modified: int = None,
        id: int = None,
        name: str = None,
        status: str = None,
        title: str = None,
    ):
        # Data version.
        self.data_version = data_version
        # Description information.
        self.description = description
        # Modification time
        self.gmt_modified = gmt_modified
        # Primary key ID of accumulated variable
        self.id = id
        # Accumulated variable name: generated by backend
        self.name = name
        # Status.
        self.status = status
        # Title.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_version is not None:
            result['dataVersion'] = self.data_version
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.status is not None:
            result['status'] = self.status
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dataVersion') is not None:
            self.data_version = m.get('dataVersion')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class DescribeCustVariablePageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeCustVariablePageResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10
        self.page_size = page_size
        # Returned object
        self.result_object = result_object
        # Total number of items
        self.total_item = total_item
        # Total number of pages
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeCustVariablePageResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeCustVariablePageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCustVariablePageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCustVariablePageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDataSourceDataDownloadUrlRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        data_source_id: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Data source ID.
        # 
        # This parameter is required.
        self.data_source_id = data_source_id
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.data_source_id is not None:
            result['dataSourceId'] = self.data_source_id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('dataSourceId') is not None:
            self.data_source_id = m.get('dataSourceId')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeDataSourceDataDownloadUrlResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        download_file_url: str = None,
    ):
        # Download URL.
        self.download_file_url = download_file_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_file_url is not None:
            result['downloadFileUrl'] = self.download_file_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('downloadFileUrl') is not None:
            self.download_file_url = m.get('downloadFileUrl')
        return self


class DescribeDataSourceDataDownloadUrlResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeDataSourceDataDownloadUrlResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeDataSourceDataDownloadUrlResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeDataSourceDataDownloadUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDataSourceDataDownloadUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDataSourceDataDownloadUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDataSourceFieldsRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        data_source_code: str = None,
        reg_id: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Data source code
        # 
        # This parameter is required.
        self.data_source_code = data_source_code
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.data_source_code is not None:
            result['dataSourceCode'] = self.data_source_code
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('dataSourceCode') is not None:
            self.data_source_code = m.get('dataSourceCode')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeDataSourceFieldsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeDataSourceFieldsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDataSourceFieldsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDataSourceFieldsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDataSourcePageListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        source_ip: str = None,
        current_page: int = None,
        name: str = None,
        page_size: int = None,
        reg_id: str = None,
        type: str = None,
    ):
        # Set the language type for request and response, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Request source IP.
        self.source_ip = source_ip
        # Current page number.
        self.current_page = current_page
        # Variable name
        self.name = name
        # Page size, default value is 10
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id
        # Type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.name is not None:
            result['name'] = self.name
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeDataSourcePageListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        creator: str = None,
        description: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        id: int = None,
        modifier: str = None,
        name: str = None,
        total: int = None,
        type: str = None,
    ):
        # Creator of the data source.
        self.creator = creator
        # Data source description.
        self.description = description
        # Time when the data source was created.
        self.gmt_create = gmt_create
        # Time when the data source was last modified.
        self.gmt_modified = gmt_modified
        # Data source ID.
        self.id = id
        # Last modifier.
        self.modifier = modifier
        # Data source name.
        self.name = name
        # Total pages.
        self.total = total
        # Data source type.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.name is not None:
            result['name'] = self.name
        if self.total is not None:
            result['total'] = self.total
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('total') is not None:
            self.total = m.get('total')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeDataSourcePageListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeDataSourcePageListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10
        self.page_size = page_size
        # Return object
        self.result_object = result_object
        # Total items
        self.total_item = total_item
        # Total pages
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeDataSourcePageListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeDataSourcePageListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDataSourcePageListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDataSourcePageListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDecisionResultFluctuationRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        event_codes: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Event code.
        self.event_codes = event_codes
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeDecisionResultFluctuationResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        status: str = None,
        today_num: int = None,
        within_seven_day_num: str = None,
        within_thirty_day_num: str = None,
        within_three_day_num: str = None,
        yesterday_num: int = None,
    ):
        # Execution status.
        self.status = status
        # Today\\"s count
        self.today_num = today_num
        # Count within the last seven days
        self.within_seven_day_num = within_seven_day_num
        # Count within the last thirty days
        self.within_thirty_day_num = within_thirty_day_num
        # Count within the last three days
        self.within_three_day_num = within_three_day_num
        # Yesterday\\"s count
        self.yesterday_num = yesterday_num

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['status'] = self.status
        if self.today_num is not None:
            result['todayNum'] = self.today_num
        if self.within_seven_day_num is not None:
            result['withinSevenDayNum'] = self.within_seven_day_num
        if self.within_thirty_day_num is not None:
            result['withinThirtyDayNum'] = self.within_thirty_day_num
        if self.within_three_day_num is not None:
            result['withinThreeDayNum'] = self.within_three_day_num
        if self.yesterday_num is not None:
            result['yesterdayNum'] = self.yesterday_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('todayNum') is not None:
            self.today_num = m.get('todayNum')
        if m.get('withinSevenDayNum') is not None:
            self.within_seven_day_num = m.get('withinSevenDayNum')
        if m.get('withinThirtyDayNum') is not None:
            self.within_thirty_day_num = m.get('withinThirtyDayNum')
        if m.get('withinThreeDayNum') is not None:
            self.within_three_day_num = m.get('withinThreeDayNum')
        if m.get('yesterdayNum') is not None:
            self.yesterday_num = m.get('yesterdayNum')
        return self


class DescribeDecisionResultFluctuationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: List[DescribeDecisionResultFluctuationResponseBodyResultObject] = None,
        success: bool = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error details
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object
        # Indicates whether the operation was successful.
        self.success = success

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeDecisionResultFluctuationResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeDecisionResultFluctuationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDecisionResultFluctuationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDecisionResultFluctuationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDecisionResultTrendRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        begin_time: int = None,
        end_time: int = None,
        event_codes: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Start timestamp, in milliseconds.
        self.begin_time = begin_time
        # End time, accurate to milliseconds (ms).
        self.end_time = end_time
        # Event code.
        self.event_codes = event_codes
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.begin_time is not None:
            result['beginTime'] = self.begin_time
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('beginTime') is not None:
            self.begin_time = m.get('beginTime')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeDecisionResultTrendResponseBodyResultObjectSeriesData(TeaModel):
    def __init__(
        self,
        num: int = None,
        scale: str = None,
    ):
        # Number
        self.num = num
        # ratio
        self.scale = scale

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.num is not None:
            result['num'] = self.num
        if self.scale is not None:
            result['scale'] = self.scale
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('num') is not None:
            self.num = m.get('num')
        if m.get('scale') is not None:
            self.scale = m.get('scale')
        return self


class DescribeDecisionResultTrendResponseBodyResultObjectSeries(TeaModel):
    def __init__(
        self,
        data: List[DescribeDecisionResultTrendResponseBodyResultObjectSeriesData] = None,
        name: str = None,
    ):
        # Returned data object
        self.data = data
        # Name.
        self.name = name

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = DescribeDecisionResultTrendResponseBodyResultObjectSeriesData()
                self.data.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DescribeDecisionResultTrendResponseBodyResultObjectXaxis(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
    ):
        # X-axis data structure.
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class DescribeDecisionResultTrendResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        series: List[DescribeDecisionResultTrendResponseBodyResultObjectSeries] = None,
        xaxis: DescribeDecisionResultTrendResponseBodyResultObjectXaxis = None,
    ):
        # Chart data
        self.series = series
        # X-axis data
        self.xaxis = xaxis

    def validate(self):
        if self.series:
            for k in self.series:
                if k:
                    k.validate()
        if self.xaxis:
            self.xaxis.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['series'] = []
        if self.series is not None:
            for k in self.series:
                result['series'].append(k.to_map() if k else None)
        if self.xaxis is not None:
            result['xaxis'] = self.xaxis.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.series = []
        if m.get('series') is not None:
            for k in m.get('series'):
                temp_model = DescribeDecisionResultTrendResponseBodyResultObjectSeries()
                self.series.append(temp_model.from_map(k))
        if m.get('xaxis') is not None:
            temp_model = DescribeDecisionResultTrendResponseBodyResultObjectXaxis()
            self.xaxis = temp_model.from_map(m['xaxis'])
        return self


class DescribeDecisionResultTrendResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: DescribeDecisionResultTrendResponseBodyResultObject = None,
        success: bool = None,
    ):
        # Status code
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error details
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object
        # Whether the request was successful.
        self.success = success

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeDecisionResultTrendResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeDecisionResultTrendResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDecisionResultTrendResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDecisionResultTrendResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDetailStartRequest(TeaModel):
    def __init__(
        self,
        app_key: str = None,
        end_ds: str = None,
        reg_id: str = None,
        service: str = None,
        start_ds: str = None,
    ):
        # Application appkey.
        self.app_key = app_key
        # End time
        #      
        # Format yyyymmdd
        self.end_ds = end_ds
        # Region code
        self.reg_id = reg_id
        # Called service
        self.service = service
        # Start time
        #      
        #  Format yyyymmdd
        self.start_ds = start_ds

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_key is not None:
            result['appKey'] = self.app_key
        if self.end_ds is not None:
            result['endDs'] = self.end_ds
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.service is not None:
            result['service'] = self.service
        if self.start_ds is not None:
            result['startDs'] = self.start_ds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('appKey') is not None:
            self.app_key = m.get('appKey')
        if m.get('endDs') is not None:
            self.end_ds = m.get('endDs')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('service') is not None:
            self.service = m.get('service')
        if m.get('startDs') is not None:
            self.start_ds = m.get('startDs')
        return self


class DescribeDetailStartResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: bool = None,
        success: bool = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error details
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object
        # Indicates whether the operation was successful, with true representing success.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeDetailStartResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDetailStartResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDetailStartResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDownloadUrlRequest(TeaModel):
    def __init__(
        self,
        file_type: str = None,
        lang: str = None,
        reg_id: str = None,
        task_id: int = None,
        type: str = None,
    ):
        # File type
        self.file_type = file_type
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id
        # Task ID.
        self.task_id = task_id
        # Download type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeDownloadUrlResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: str = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeDownloadUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDownloadUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDownloadUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventBaseInfoByEventCodeRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        event_code: str = None,
        reg_id: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Creation type
        self.create_type = create_type
        # Event code
        self.event_code = event_code
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeEventBaseInfoByEventCodeResponseBodyResultObjectInputFields(TeaModel):
    def __init__(
        self,
        description: str = None,
        field_code: str = None,
        field_rank: str = None,
        field_source: str = None,
        field_type: str = None,
        title: str = None,
    ):
        # Field description.
        self.description = description
        # Field code
        self.field_code = field_code
        # Field ranking
        self.field_rank = field_rank
        # Field source.
        self.field_source = field_source
        # Field type.
        self.field_type = field_type
        # Field name.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.field_code is not None:
            result['fieldCode'] = self.field_code
        if self.field_rank is not None:
            result['fieldRank'] = self.field_rank
        if self.field_source is not None:
            result['fieldSource'] = self.field_source
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('fieldCode') is not None:
            self.field_code = m.get('fieldCode')
        if m.get('fieldRank') is not None:
            self.field_rank = m.get('fieldRank')
        if m.get('fieldSource') is not None:
            self.field_source = m.get('fieldSource')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class DescribeEventBaseInfoByEventCodeResponseBodyResultObjectRuleDetails(TeaModel):
    def __init__(
        self,
        logic_expression: str = None,
        memo: str = None,
        rule_actions: str = None,
        rule_auth_type: str = None,
        rule_expressions: str = None,
        rule_id: str = None,
        rule_name: str = None,
        rule_status: str = None,
    ):
        # Policy Execution Logic
        self.logic_expression = logic_expression
        # Memo
        self.memo = memo
        # Rule Actions
        self.rule_actions = rule_actions
        # Policy Type
        self.rule_auth_type = rule_auth_type
        # Event Expressions.
        self.rule_expressions = rule_expressions
        # Policy ID
        self.rule_id = rule_id
        # Policy Name
        self.rule_name = rule_name
        # Policy Status
        self.rule_status = rule_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logic_expression is not None:
            result['logicExpression'] = self.logic_expression
        if self.memo is not None:
            result['memo'] = self.memo
        if self.rule_actions is not None:
            result['ruleActions'] = self.rule_actions
        if self.rule_auth_type is not None:
            result['ruleAuthType'] = self.rule_auth_type
        if self.rule_expressions is not None:
            result['ruleExpressions'] = self.rule_expressions
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        if self.rule_status is not None:
            result['ruleStatus'] = self.rule_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('logicExpression') is not None:
            self.logic_expression = m.get('logicExpression')
        if m.get('memo') is not None:
            self.memo = m.get('memo')
        if m.get('ruleActions') is not None:
            self.rule_actions = m.get('ruleActions')
        if m.get('ruleAuthType') is not None:
            self.rule_auth_type = m.get('ruleAuthType')
        if m.get('ruleExpressions') is not None:
            self.rule_expressions = m.get('ruleExpressions')
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        if m.get('ruleStatus') is not None:
            self.rule_status = m.get('ruleStatus')
        return self


class DescribeEventBaseInfoByEventCodeResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        biz_version: int = None,
        event_code: str = None,
        event_name: str = None,
        event_stauts: str = None,
        input_fields: List[DescribeEventBaseInfoByEventCodeResponseBodyResultObjectInputFields] = None,
        memo: str = None,
        rule_details: List[DescribeEventBaseInfoByEventCodeResponseBodyResultObjectRuleDetails] = None,
        template_code: str = None,
        template_name: str = None,
        template_type: str = None,
    ):
        # Business version number
        self.biz_version = biz_version
        # Event code
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Event status.
        self.event_stauts = event_stauts
        # Field list.
        self.input_fields = input_fields
        # Memo.
        self.memo = memo
        # Policy Information
        self.rule_details = rule_details
        # Operation template code
        self.template_code = template_code
        # Template name
        self.template_name = template_name
        # Template type.
        self.template_type = template_type

    def validate(self):
        if self.input_fields:
            for k in self.input_fields:
                if k:
                    k.validate()
        if self.rule_details:
            for k in self.rule_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_version is not None:
            result['bizVersion'] = self.biz_version
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.event_stauts is not None:
            result['eventStauts'] = self.event_stauts
        result['inputFields'] = []
        if self.input_fields is not None:
            for k in self.input_fields:
                result['inputFields'].append(k.to_map() if k else None)
        if self.memo is not None:
            result['memo'] = self.memo
        result['ruleDetails'] = []
        if self.rule_details is not None:
            for k in self.rule_details:
                result['ruleDetails'].append(k.to_map() if k else None)
        if self.template_code is not None:
            result['templateCode'] = self.template_code
        if self.template_name is not None:
            result['templateName'] = self.template_name
        if self.template_type is not None:
            result['templateType'] = self.template_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bizVersion') is not None:
            self.biz_version = m.get('bizVersion')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('eventStauts') is not None:
            self.event_stauts = m.get('eventStauts')
        self.input_fields = []
        if m.get('inputFields') is not None:
            for k in m.get('inputFields'):
                temp_model = DescribeEventBaseInfoByEventCodeResponseBodyResultObjectInputFields()
                self.input_fields.append(temp_model.from_map(k))
        if m.get('memo') is not None:
            self.memo = m.get('memo')
        self.rule_details = []
        if m.get('ruleDetails') is not None:
            for k in m.get('ruleDetails'):
                temp_model = DescribeEventBaseInfoByEventCodeResponseBodyResultObjectRuleDetails()
                self.rule_details.append(temp_model.from_map(k))
        if m.get('templateCode') is not None:
            self.template_code = m.get('templateCode')
        if m.get('templateName') is not None:
            self.template_name = m.get('templateName')
        if m.get('templateType') is not None:
            self.template_type = m.get('templateType')
        return self


class DescribeEventBaseInfoByEventCodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeEventBaseInfoByEventCodeResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeEventBaseInfoByEventCodeResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeEventBaseInfoByEventCodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEventBaseInfoByEventCodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventBaseInfoByEventCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventCountRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Creation type
        self.create_type = create_type
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeEventCountResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        limit: bool = None,
        max_total_item: int = None,
        total_item: int = None,
    ):
        # Whether it exceeds the maximum number
        self.limit = limit
        # Maximum creation count
        self.max_total_item = max_total_item
        # Total count
        self.total_item = total_item

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.limit is not None:
            result['limit'] = self.limit
        if self.max_total_item is not None:
            result['maxTotalItem'] = self.max_total_item
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('maxTotalItem') is not None:
            self.max_total_item = m.get('maxTotalItem')
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        return self


class DescribeEventCountResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: DescribeEventCountResponseBodyResultObject = None,
        success: bool = None,
    ):
        # Status code
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error details
        self.message = message
        # Request ID
        self.request_id = request_id
        # Returned object
        self.result_object = result_object
        # Whether the request was successful.
        self.success = success

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeEventCountResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeEventCountResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEventCountResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventDetailByRequestIdRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        event_code: str = None,
        event_time: int = None,
        reg_id: str = None,
        s_request_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Event code
        self.event_code = event_code
        # Event execution time
        self.event_time = event_time
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Request ID.
        # 
        # This parameter is required.
        self.s_request_id = s_request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_time is not None:
            result['eventTime'] = self.event_time
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.s_request_id is not None:
            result['sRequestId'] = self.s_request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventTime') is not None:
            self.event_time = m.get('eventTime')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('sRequestId') is not None:
            self.s_request_id = m.get('sRequestId')
        return self


class DescribeEventDetailByRequestIdResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeEventDetailByRequestIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEventDetailByRequestIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventDetailByRequestIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventLogDetailRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        req_id_by_log: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id
        # Log details.
        # 
        # This parameter is required.
        self.req_id_by_log = req_id_by_log

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.req_id_by_log is not None:
            result['reqIdByLog'] = self.req_id_by_log
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('reqIdByLog') is not None:
            self.req_id_by_log = m.get('reqIdByLog')
        return self


class DescribeEventLogDetailResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeEventLogDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEventLogDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventLogDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventLogPageRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        account_id_prp: str = None,
        begin_time: int = None,
        condition_1al: str = None,
        condition_2al: str = None,
        condition_3al: str = None,
        current_page: int = None,
        device_type_lrp: str = None,
        email_prp: str = None,
        end_time: int = None,
        fail_reason_lrp: str = None,
        ip_prp: str = None,
        login_result_arp: str = None,
        login_type_lrp: str = None,
        mac_prp: str = None,
        mobile_prp: str = None,
        nick_name_prp: str = None,
        operate_source_lrp: str = None,
        page_size: int = None,
        refer_prp: str = None,
        reg_id: str = None,
        register_ip_prp: str = None,
        req_id_pbs: str = None,
        score_ebs: int = None,
        score_sbs: int = None,
        service_abs: str = None,
        tags_lbs: str = None,
        umid_pdi: str = None,
        user_agent_prp: str = None,
        user_name_type_lrp: str = None,
    ):
        self.lang = lang
        self.account_id_prp = account_id_prp
        self.begin_time = begin_time
        self.condition_1al = condition_1al
        self.condition_2al = condition_2al
        self.condition_3al = condition_3al
        self.current_page = current_page
        self.device_type_lrp = device_type_lrp
        self.email_prp = email_prp
        self.end_time = end_time
        self.fail_reason_lrp = fail_reason_lrp
        self.ip_prp = ip_prp
        self.login_result_arp = login_result_arp
        self.login_type_lrp = login_type_lrp
        self.mac_prp = mac_prp
        self.mobile_prp = mobile_prp
        self.nick_name_prp = nick_name_prp
        self.operate_source_lrp = operate_source_lrp
        self.page_size = page_size
        self.refer_prp = refer_prp
        self.reg_id = reg_id
        self.register_ip_prp = register_ip_prp
        # requestId
        self.req_id_pbs = req_id_pbs
        self.score_ebs = score_ebs
        self.score_sbs = score_sbs
        self.service_abs = service_abs
        self.tags_lbs = tags_lbs
        self.umid_pdi = umid_pdi
        self.user_agent_prp = user_agent_prp
        self.user_name_type_lrp = user_name_type_lrp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.account_id_prp is not None:
            result['accountIdPRP'] = self.account_id_prp
        if self.begin_time is not None:
            result['beginTime'] = self.begin_time
        if self.condition_1al is not None:
            result['condition1AL'] = self.condition_1al
        if self.condition_2al is not None:
            result['condition2AL'] = self.condition_2al
        if self.condition_3al is not None:
            result['condition3AL'] = self.condition_3al
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.device_type_lrp is not None:
            result['deviceTypeLRP'] = self.device_type_lrp
        if self.email_prp is not None:
            result['emailPRP'] = self.email_prp
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.fail_reason_lrp is not None:
            result['failReasonLRP'] = self.fail_reason_lrp
        if self.ip_prp is not None:
            result['ipPRP'] = self.ip_prp
        if self.login_result_arp is not None:
            result['loginResultARP'] = self.login_result_arp
        if self.login_type_lrp is not None:
            result['loginTypeLRP'] = self.login_type_lrp
        if self.mac_prp is not None:
            result['macPRP'] = self.mac_prp
        if self.mobile_prp is not None:
            result['mobilePRP'] = self.mobile_prp
        if self.nick_name_prp is not None:
            result['nickNamePRP'] = self.nick_name_prp
        if self.operate_source_lrp is not None:
            result['operateSourceLRP'] = self.operate_source_lrp
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.refer_prp is not None:
            result['referPRP'] = self.refer_prp
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.register_ip_prp is not None:
            result['registerIpPRP'] = self.register_ip_prp
        if self.req_id_pbs is not None:
            result['reqIdPBS'] = self.req_id_pbs
        if self.score_ebs is not None:
            result['scoreEBS'] = self.score_ebs
        if self.score_sbs is not None:
            result['scoreSBS'] = self.score_sbs
        if self.service_abs is not None:
            result['serviceABS'] = self.service_abs
        if self.tags_lbs is not None:
            result['tagsLBS'] = self.tags_lbs
        if self.umid_pdi is not None:
            result['umidPDI'] = self.umid_pdi
        if self.user_agent_prp is not None:
            result['userAgentPRP'] = self.user_agent_prp
        if self.user_name_type_lrp is not None:
            result['userNameTypeLRP'] = self.user_name_type_lrp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('accountIdPRP') is not None:
            self.account_id_prp = m.get('accountIdPRP')
        if m.get('beginTime') is not None:
            self.begin_time = m.get('beginTime')
        if m.get('condition1AL') is not None:
            self.condition_1al = m.get('condition1AL')
        if m.get('condition2AL') is not None:
            self.condition_2al = m.get('condition2AL')
        if m.get('condition3AL') is not None:
            self.condition_3al = m.get('condition3AL')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('deviceTypeLRP') is not None:
            self.device_type_lrp = m.get('deviceTypeLRP')
        if m.get('emailPRP') is not None:
            self.email_prp = m.get('emailPRP')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('failReasonLRP') is not None:
            self.fail_reason_lrp = m.get('failReasonLRP')
        if m.get('ipPRP') is not None:
            self.ip_prp = m.get('ipPRP')
        if m.get('loginResultARP') is not None:
            self.login_result_arp = m.get('loginResultARP')
        if m.get('loginTypeLRP') is not None:
            self.login_type_lrp = m.get('loginTypeLRP')
        if m.get('macPRP') is not None:
            self.mac_prp = m.get('macPRP')
        if m.get('mobilePRP') is not None:
            self.mobile_prp = m.get('mobilePRP')
        if m.get('nickNamePRP') is not None:
            self.nick_name_prp = m.get('nickNamePRP')
        if m.get('operateSourceLRP') is not None:
            self.operate_source_lrp = m.get('operateSourceLRP')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('referPRP') is not None:
            self.refer_prp = m.get('referPRP')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('registerIpPRP') is not None:
            self.register_ip_prp = m.get('registerIpPRP')
        if m.get('reqIdPBS') is not None:
            self.req_id_pbs = m.get('reqIdPBS')
        if m.get('scoreEBS') is not None:
            self.score_ebs = m.get('scoreEBS')
        if m.get('scoreSBS') is not None:
            self.score_sbs = m.get('scoreSBS')
        if m.get('serviceABS') is not None:
            self.service_abs = m.get('serviceABS')
        if m.get('tagsLBS') is not None:
            self.tags_lbs = m.get('tagsLBS')
        if m.get('umidPDI') is not None:
            self.umid_pdi = m.get('umidPDI')
        if m.get('userAgentPRP') is not None:
            self.user_agent_prp = m.get('userAgentPRP')
        if m.get('userNameTypeLRP') is not None:
            self.user_name_type_lrp = m.get('userNameTypeLRP')
        return self


class DescribeEventLogPageResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        account_id: str = None,
        email: str = None,
        ip: str = None,
        mobile: str = None,
        nick_name: str = None,
        request_id: str = None,
        score: str = None,
        service: str = None,
        tags: str = None,
        timestamp: str = None,
        umid: str = None,
    ):
        self.account_id = account_id
        self.email = email
        # ip
        self.ip = ip
        self.mobile = mobile
        self.nick_name = nick_name
        self.request_id = request_id
        self.score = score
        self.service = service
        self.tags = tags
        self.timestamp = timestamp
        self.umid = umid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        if self.email is not None:
            result['email'] = self.email
        if self.ip is not None:
            result['ip'] = self.ip
        if self.mobile is not None:
            result['mobile'] = self.mobile
        if self.nick_name is not None:
            result['nickName'] = self.nick_name
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.score is not None:
            result['score'] = self.score
        if self.service is not None:
            result['service'] = self.service
        if self.tags is not None:
            result['tags'] = self.tags
        if self.timestamp is not None:
            result['timestamp'] = self.timestamp
        if self.umid is not None:
            result['umid'] = self.umid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('mobile') is not None:
            self.mobile = m.get('mobile')
        if m.get('nickName') is not None:
            self.nick_name = m.get('nickName')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('score') is not None:
            self.score = m.get('score')
        if m.get('service') is not None:
            self.service = m.get('service')
        if m.get('tags') is not None:
            self.tags = m.get('tags')
        if m.get('timestamp') is not None:
            self.timestamp = m.get('timestamp')
        if m.get('umid') is not None:
            self.umid = m.get('umid')
        return self


class DescribeEventLogPageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeEventLogPageResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        self.request_id = request_id
        self.current_page = current_page
        self.page_size = page_size
        self.result_object = result_object
        self.total_item = total_item
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeEventLogPageResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeEventLogPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEventLogPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventLogPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventPageListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        current_page: int = None,
        event_code: str = None,
        event_name: str = None,
        event_status: str = None,
        page_size: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Creation type
        self.create_type = create_type
        # Current page number.
        self.current_page = current_page
        # Event code
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Event status.
        self.event_status = event_status
        # Page size, with a default value of 10
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.event_status is not None:
            result['eventStatus'] = self.event_status
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('eventStatus') is not None:
            self.event_status = m.get('eventStatus')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeEventPageListResponseBodyResultObjectChildren(TeaModel):
    def __init__(
        self,
        event_code: str = None,
        event_name: str = None,
        event_status: str = None,
        event_type: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        rule_count: int = None,
    ):
        # Event code.
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Event status.
        self.event_status = event_status
        # Event type.
        self.event_type = event_type
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time
        self.gmt_modified = gmt_modified
        # Primary key ID
        self.id = id
        # Total number of rules.
        self.rule_count = rule_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.event_status is not None:
            result['eventStatus'] = self.event_status
        if self.event_type is not None:
            result['eventType'] = self.event_type
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.rule_count is not None:
            result['ruleCount'] = self.rule_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('eventStatus') is not None:
            self.event_status = m.get('eventStatus')
        if m.get('eventType') is not None:
            self.event_type = m.get('eventType')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('ruleCount') is not None:
            self.rule_count = m.get('ruleCount')
        return self


class DescribeEventPageListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        children: List[DescribeEventPageListResponseBodyResultObjectChildren] = None,
        event_code: str = None,
        event_name: str = None,
        event_status: str = None,
        event_type: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        rule_count: int = None,
        template_code: str = None,
        template_name: str = None,
        template_type: str = None,
        user_count: int = None,
    ):
        # Object
        self.children = children
        # Event code
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Event status.
        self.event_status = event_status
        # Event type.
        self.event_type = event_type
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time
        self.gmt_modified = gmt_modified
        # Database ID.
        self.id = id
        # Total number of rules.
        self.rule_count = rule_count
        # Template code
        self.template_code = template_code
        # Template name.
        self.template_name = template_name
        # Template type
        self.template_type = template_type
        # Number of customer authorizations
        self.user_count = user_count

    def validate(self):
        if self.children:
            for k in self.children:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['children'] = []
        if self.children is not None:
            for k in self.children:
                result['children'].append(k.to_map() if k else None)
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.event_status is not None:
            result['eventStatus'] = self.event_status
        if self.event_type is not None:
            result['eventType'] = self.event_type
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.rule_count is not None:
            result['ruleCount'] = self.rule_count
        if self.template_code is not None:
            result['templateCode'] = self.template_code
        if self.template_name is not None:
            result['templateName'] = self.template_name
        if self.template_type is not None:
            result['templateType'] = self.template_type
        if self.user_count is not None:
            result['userCount'] = self.user_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.children = []
        if m.get('children') is not None:
            for k in m.get('children'):
                temp_model = DescribeEventPageListResponseBodyResultObjectChildren()
                self.children.append(temp_model.from_map(k))
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('eventStatus') is not None:
            self.event_status = m.get('eventStatus')
        if m.get('eventType') is not None:
            self.event_type = m.get('eventType')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('ruleCount') is not None:
            self.rule_count = m.get('ruleCount')
        if m.get('templateCode') is not None:
            self.template_code = m.get('templateCode')
        if m.get('templateName') is not None:
            self.template_name = m.get('templateName')
        if m.get('templateType') is not None:
            self.template_type = m.get('templateType')
        if m.get('userCount') is not None:
            self.user_count = m.get('userCount')
        return self


class DescribeEventPageListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeEventPageListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, with a default value of 10
        self.page_size = page_size
        # Returned object
        self.result_object = result_object
        # Total number of items
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeEventPageListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeEventPageListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEventPageListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventPageListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventResultBarChartRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        begin_time: int = None,
        end_time: int = None,
        event_codes: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Start time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.begin_time = begin_time
        # End time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.end_time = end_time
        # Event code.
        self.event_codes = event_codes
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.begin_time is not None:
            result['beginTime'] = self.begin_time
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('beginTime') is not None:
            self.begin_time = m.get('beginTime')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeEventResultBarChartResponseBodyResultObjectSeriesData(TeaModel):
    def __init__(
        self,
        num: int = None,
        scale: str = None,
    ):
        # Number.
        self.num = num
        # Scale
        self.scale = scale

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.num is not None:
            result['num'] = self.num
        if self.scale is not None:
            result['scale'] = self.scale
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('num') is not None:
            self.num = m.get('num')
        if m.get('scale') is not None:
            self.scale = m.get('scale')
        return self


class DescribeEventResultBarChartResponseBodyResultObjectSeries(TeaModel):
    def __init__(
        self,
        data: List[DescribeEventResultBarChartResponseBodyResultObjectSeriesData] = None,
        name: str = None,
        stack: str = None,
    ):
        # Returned data object
        self.data = data
        # Series name.
        self.name = name
        # Label key
        self.stack = stack

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.stack is not None:
            result['stack'] = self.stack
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = DescribeEventResultBarChartResponseBodyResultObjectSeriesData()
                self.data.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('stack') is not None:
            self.stack = m.get('stack')
        return self


class DescribeEventResultBarChartResponseBodyResultObjectXaxis(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
    ):
        # Returned data object
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class DescribeEventResultBarChartResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        series: List[DescribeEventResultBarChartResponseBodyResultObjectSeries] = None,
        xaxis: DescribeEventResultBarChartResponseBodyResultObjectXaxis = None,
    ):
        # Chart data
        self.series = series
        # xaxis interface configuration.
        self.xaxis = xaxis

    def validate(self):
        if self.series:
            for k in self.series:
                if k:
                    k.validate()
        if self.xaxis:
            self.xaxis.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['series'] = []
        if self.series is not None:
            for k in self.series:
                result['series'].append(k.to_map() if k else None)
        if self.xaxis is not None:
            result['xaxis'] = self.xaxis.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.series = []
        if m.get('series') is not None:
            for k in m.get('series'):
                temp_model = DescribeEventResultBarChartResponseBodyResultObjectSeries()
                self.series.append(temp_model.from_map(k))
        if m.get('xaxis') is not None:
            temp_model = DescribeEventResultBarChartResponseBodyResultObjectXaxis()
            self.xaxis = temp_model.from_map(m['xaxis'])
        return self


class DescribeEventResultBarChartResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: DescribeEventResultBarChartResponseBodyResultObject = None,
        success: bool = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID
        self.request_id = request_id
        # Returned object
        self.result_object = result_object
        # Whether the request was successful.
        self.success = success

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeEventResultBarChartResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeEventResultBarChartResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEventResultBarChartResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventResultBarChartResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventResultListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        begin_time: int = None,
        current_page: int = None,
        end_time: int = None,
        page_size: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Start time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.begin_time = begin_time
        # Current page number.
        self.current_page = current_page
        # End time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.end_time = end_time
        # Page size, default value is 10
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.begin_time is not None:
            result['beginTime'] = self.begin_time
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('beginTime') is not None:
            self.begin_time = m.get('beginTime')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeEventResultListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        event_code: str = None,
        event_name: str = None,
        pass_num: int = None,
        pending_num: int = None,
        reject_num: int = None,
        total_num: int = None,
    ):
        # Event code
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Number of passed checks.
        self.pass_num = pass_num
        # Number of pending items.
        self.pending_num = pending_num
        # Number of rejected approvals.
        self.reject_num = reject_num
        # Total number of items.
        self.total_num = total_num

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.pass_num is not None:
            result['passNum'] = self.pass_num
        if self.pending_num is not None:
            result['pendingNum'] = self.pending_num
        if self.reject_num is not None:
            result['rejectNum'] = self.reject_num
        if self.total_num is not None:
            result['totalNum'] = self.total_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('passNum') is not None:
            self.pass_num = m.get('passNum')
        if m.get('pendingNum') is not None:
            self.pending_num = m.get('pendingNum')
        if m.get('rejectNum') is not None:
            self.reject_num = m.get('rejectNum')
        if m.get('totalNum') is not None:
            self.total_num = m.get('totalNum')
        return self


class DescribeEventResultListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        current_page: int = None,
        http_status_code: str = None,
        message: str = None,
        page_size: int = None,
        request_id: str = None,
        result_object: List[DescribeEventResultListResponseBodyResultObject] = None,
        success: bool = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Status code.
        self.code = code
        # Current page number.
        self.current_page = current_page
        # HTTP status code
        self.http_status_code = http_status_code
        # Error details
        self.message = message
        # Page size, default value is 10
        self.page_size = page_size
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object
        # Whether the query was successful.
        self.success = success
        # Total number of items.
        self.total_item = total_item
        # Total number of pages
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeEventResultListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeEventResultListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEventResultListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventResultListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventTaskHistoryRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Set the language type for request and response messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeEventTaskHistoryResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        task_code: str = None,
        task_name: str = None,
        task_status: str = None,
        url: str = None,
    ):
        # Task code.
        self.task_code = task_code
        # Task name
        self.task_name = task_name
        # Task status.
        self.task_status = task_status
        # OSS download URL
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_code is not None:
            result['taskCode'] = self.task_code
        if self.task_name is not None:
            result['taskName'] = self.task_name
        if self.task_status is not None:
            result['taskStatus'] = self.task_status
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('taskCode') is not None:
            self.task_code = m.get('taskCode')
        if m.get('taskName') is not None:
            self.task_name = m.get('taskName')
        if m.get('taskStatus') is not None:
            self.task_status = m.get('taskStatus')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class DescribeEventTaskHistoryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeEventTaskHistoryResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeEventTaskHistoryResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeEventTaskHistoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEventTaskHistoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventTaskHistoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventTotalCountReportRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeEventTotalCountReportResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        ratio: str = None,
        value: str = None,
    ):
        # Comparison with yesterday\\"s event invocation count
        self.ratio = ratio
        # Today\\"s event invocation count
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ratio is not None:
            result['ratio'] = self.ratio
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ratio') is not None:
            self.ratio = m.get('ratio')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeEventTotalCountReportResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: DescribeEventTotalCountReportResponseBodyResultObject = None,
        success: bool = None,
    ):
        # Status code
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object
        # Indicates whether this operation was successful, `true` means success.
        self.success = success

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeEventTotalCountReportResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeEventTotalCountReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEventTotalCountReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventTotalCountReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventUploadPolicyRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeEventUploadPolicyResponseBody(TeaModel):
    def __init__(
        self,
        access_id: str = None,
        host: str = None,
        key: str = None,
        policy: str = None,
        request_id: str = None,
        signature: str = None,
        sts_token: str = None,
    ):
        # ID for accessing OSS
        self.access_id = access_id
        # OSS host.
        self.host = host
        # The Key required for file upload.
        self.key = key
        # OSS security policy
        self.policy = policy
        # Request ID
        self.request_id = request_id
        # Signature data.
        self.signature = signature
        # Temporary identity credential.
        self.sts_token = sts_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_id is not None:
            result['AccessId'] = self.access_id
        if self.host is not None:
            result['Host'] = self.host
        if self.key is not None:
            result['Key'] = self.key
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.signature is not None:
            result['Signature'] = self.signature
        if self.sts_token is not None:
            result['StsToken'] = self.sts_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessId') is not None:
            self.access_id = m.get('AccessId')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Signature') is not None:
            self.signature = m.get('Signature')
        if m.get('StsToken') is not None:
            self.sts_token = m.get('StsToken')
        return self


class DescribeEventUploadPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEventUploadPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventUploadPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventVariableListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        filter_dto: str = None,
        ref_obj_id: str = None,
        ref_obj_type: str = None,
        reg_id: str = None,
        type: str = None,
    ):
        self.lang = lang
        self.create_type = create_type
        self.filter_dto = filter_dto
        # This parameter is required.
        self.ref_obj_id = ref_obj_id
        # This parameter is required.
        self.ref_obj_type = ref_obj_type
        self.reg_id = reg_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.filter_dto is not None:
            result['filterDTO'] = self.filter_dto
        if self.ref_obj_id is not None:
            result['refObjId'] = self.ref_obj_id
        if self.ref_obj_type is not None:
            result['refObjType'] = self.ref_obj_type
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('filterDTO') is not None:
            self.filter_dto = m.get('filterDTO')
        if m.get('refObjId') is not None:
            self.ref_obj_id = m.get('refObjId')
        if m.get('refObjType') is not None:
            self.ref_obj_type = m.get('refObjType')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeEventVariableListResponseBodyResultObjectActionsOutputThreshold(TeaModel):
    def __init__(
        self,
        max_value: float = None,
        min_value: float = None,
    ):
        self.max_value = max_value
        self.min_value = min_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_value is not None:
            result['maxValue'] = self.max_value
        if self.min_value is not None:
            result['minValue'] = self.min_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxValue') is not None:
            self.max_value = m.get('maxValue')
        if m.get('minValue') is not None:
            self.min_value = m.get('minValue')
        return self


class DescribeEventVariableListResponseBodyResultObjectActionsVariableVelocity(TeaModel):
    def __init__(
        self,
        iv: str = None,
    ):
        self.iv = iv

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iv is not None:
            result['iv'] = self.iv
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('iv') is not None:
            self.iv = m.get('iv')
        return self


class DescribeEventVariableListResponseBodyResultObjectActions(TeaModel):
    def __init__(
        self,
        code: str = None,
        data_display: str = None,
        define_id: str = None,
        description: str = None,
        display_type: str = None,
        expression_title: str = None,
        favorite_flag: bool = None,
        field_detail: str = None,
        field_rank: int = None,
        field_source: str = None,
        field_type: str = None,
        id: int = None,
        input_field_type: str = None,
        input_required: str = None,
        inputs: str = None,
        name: str = None,
        outlier: str = None,
        output_threshold: DescribeEventVariableListResponseBodyResultObjectActionsOutputThreshold = None,
        parent_name: str = None,
        source_type: str = None,
        title: str = None,
        type: str = None,
        variable_velocity: DescribeEventVariableListResponseBodyResultObjectActionsVariableVelocity = None,
        x_label: str = None,
        y_label: str = None,
    ):
        self.code = code
        self.data_display = data_display
        self.define_id = define_id
        self.description = description
        self.display_type = display_type
        self.expression_title = expression_title
        self.favorite_flag = favorite_flag
        self.field_detail = field_detail
        self.field_rank = field_rank
        self.field_source = field_source
        self.field_type = field_type
        self.id = id
        self.input_field_type = input_field_type
        self.input_required = input_required
        self.inputs = inputs
        self.name = name
        self.outlier = outlier
        self.output_threshold = output_threshold
        self.parent_name = parent_name
        self.source_type = source_type
        self.title = title
        self.type = type
        self.variable_velocity = variable_velocity
        self.x_label = x_label
        self.y_label = y_label

    def validate(self):
        if self.output_threshold:
            self.output_threshold.validate()
        if self.variable_velocity:
            self.variable_velocity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data_display is not None:
            result['dataDisplay'] = self.data_display
        if self.define_id is not None:
            result['defineId'] = self.define_id
        if self.description is not None:
            result['description'] = self.description
        if self.display_type is not None:
            result['displayType'] = self.display_type
        if self.expression_title is not None:
            result['expressionTitle'] = self.expression_title
        if self.favorite_flag is not None:
            result['favoriteFlag'] = self.favorite_flag
        if self.field_detail is not None:
            result['fieldDetail'] = self.field_detail
        if self.field_rank is not None:
            result['fieldRank'] = self.field_rank
        if self.field_source is not None:
            result['fieldSource'] = self.field_source
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.id is not None:
            result['id'] = self.id
        if self.input_field_type is not None:
            result['inputFieldType'] = self.input_field_type
        if self.input_required is not None:
            result['inputRequired'] = self.input_required
        if self.inputs is not None:
            result['inputs'] = self.inputs
        if self.name is not None:
            result['name'] = self.name
        if self.outlier is not None:
            result['outlier'] = self.outlier
        if self.output_threshold is not None:
            result['outputThreshold'] = self.output_threshold.to_map()
        if self.parent_name is not None:
            result['parentName'] = self.parent_name
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        if self.variable_velocity is not None:
            result['variableVelocity'] = self.variable_velocity.to_map()
        if self.x_label is not None:
            result['xLabel'] = self.x_label
        if self.y_label is not None:
            result['yLabel'] = self.y_label
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('dataDisplay') is not None:
            self.data_display = m.get('dataDisplay')
        if m.get('defineId') is not None:
            self.define_id = m.get('defineId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayType') is not None:
            self.display_type = m.get('displayType')
        if m.get('expressionTitle') is not None:
            self.expression_title = m.get('expressionTitle')
        if m.get('favoriteFlag') is not None:
            self.favorite_flag = m.get('favoriteFlag')
        if m.get('fieldDetail') is not None:
            self.field_detail = m.get('fieldDetail')
        if m.get('fieldRank') is not None:
            self.field_rank = m.get('fieldRank')
        if m.get('fieldSource') is not None:
            self.field_source = m.get('fieldSource')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('inputFieldType') is not None:
            self.input_field_type = m.get('inputFieldType')
        if m.get('inputRequired') is not None:
            self.input_required = m.get('inputRequired')
        if m.get('inputs') is not None:
            self.inputs = m.get('inputs')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('outlier') is not None:
            self.outlier = m.get('outlier')
        if m.get('outputThreshold') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectActionsOutputThreshold()
            self.output_threshold = temp_model.from_map(m['outputThreshold'])
        if m.get('parentName') is not None:
            self.parent_name = m.get('parentName')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('variableVelocity') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectActionsVariableVelocity()
            self.variable_velocity = temp_model.from_map(m['variableVelocity'])
        if m.get('xLabel') is not None:
            self.x_label = m.get('xLabel')
        if m.get('yLabel') is not None:
            self.y_label = m.get('yLabel')
        return self


class DescribeEventVariableListResponseBodyResultObjectDeviceVariablesOutputThreshold(TeaModel):
    def __init__(
        self,
        max_value: float = None,
        min_value: float = None,
    ):
        self.max_value = max_value
        self.min_value = min_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_value is not None:
            result['maxValue'] = self.max_value
        if self.min_value is not None:
            result['minValue'] = self.min_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxValue') is not None:
            self.max_value = m.get('maxValue')
        if m.get('minValue') is not None:
            self.min_value = m.get('minValue')
        return self


class DescribeEventVariableListResponseBodyResultObjectDeviceVariablesVariableVelocity(TeaModel):
    def __init__(
        self,
        iv: str = None,
    ):
        self.iv = iv

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iv is not None:
            result['iv'] = self.iv
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('iv') is not None:
            self.iv = m.get('iv')
        return self


class DescribeEventVariableListResponseBodyResultObjectDeviceVariables(TeaModel):
    def __init__(
        self,
        code: str = None,
        data_display: str = None,
        define_id: str = None,
        description: str = None,
        display_type: str = None,
        expression_title: str = None,
        favorite_flag: bool = None,
        field_detail: str = None,
        field_rank: int = None,
        field_source: str = None,
        field_type: str = None,
        id: int = None,
        input_field_type: str = None,
        input_required: str = None,
        inputs: str = None,
        name: str = None,
        outlier: str = None,
        output_threshold: DescribeEventVariableListResponseBodyResultObjectDeviceVariablesOutputThreshold = None,
        parent_name: str = None,
        source_type: str = None,
        title: str = None,
        type: str = None,
        variable_velocity: DescribeEventVariableListResponseBodyResultObjectDeviceVariablesVariableVelocity = None,
        x_label: str = None,
        y_label: str = None,
    ):
        self.code = code
        self.data_display = data_display
        self.define_id = define_id
        self.description = description
        self.display_type = display_type
        self.expression_title = expression_title
        self.favorite_flag = favorite_flag
        self.field_detail = field_detail
        self.field_rank = field_rank
        self.field_source = field_source
        self.field_type = field_type
        self.id = id
        self.input_field_type = input_field_type
        self.input_required = input_required
        self.inputs = inputs
        self.name = name
        self.outlier = outlier
        self.output_threshold = output_threshold
        self.parent_name = parent_name
        self.source_type = source_type
        self.title = title
        self.type = type
        self.variable_velocity = variable_velocity
        self.x_label = x_label
        self.y_label = y_label

    def validate(self):
        if self.output_threshold:
            self.output_threshold.validate()
        if self.variable_velocity:
            self.variable_velocity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data_display is not None:
            result['dataDisplay'] = self.data_display
        if self.define_id is not None:
            result['defineId'] = self.define_id
        if self.description is not None:
            result['description'] = self.description
        if self.display_type is not None:
            result['displayType'] = self.display_type
        if self.expression_title is not None:
            result['expressionTitle'] = self.expression_title
        if self.favorite_flag is not None:
            result['favoriteFlag'] = self.favorite_flag
        if self.field_detail is not None:
            result['fieldDetail'] = self.field_detail
        if self.field_rank is not None:
            result['fieldRank'] = self.field_rank
        if self.field_source is not None:
            result['fieldSource'] = self.field_source
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.id is not None:
            result['id'] = self.id
        if self.input_field_type is not None:
            result['inputFieldType'] = self.input_field_type
        if self.input_required is not None:
            result['inputRequired'] = self.input_required
        if self.inputs is not None:
            result['inputs'] = self.inputs
        if self.name is not None:
            result['name'] = self.name
        if self.outlier is not None:
            result['outlier'] = self.outlier
        if self.output_threshold is not None:
            result['outputThreshold'] = self.output_threshold.to_map()
        if self.parent_name is not None:
            result['parentName'] = self.parent_name
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        if self.variable_velocity is not None:
            result['variableVelocity'] = self.variable_velocity.to_map()
        if self.x_label is not None:
            result['xLabel'] = self.x_label
        if self.y_label is not None:
            result['yLabel'] = self.y_label
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('dataDisplay') is not None:
            self.data_display = m.get('dataDisplay')
        if m.get('defineId') is not None:
            self.define_id = m.get('defineId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayType') is not None:
            self.display_type = m.get('displayType')
        if m.get('expressionTitle') is not None:
            self.expression_title = m.get('expressionTitle')
        if m.get('favoriteFlag') is not None:
            self.favorite_flag = m.get('favoriteFlag')
        if m.get('fieldDetail') is not None:
            self.field_detail = m.get('fieldDetail')
        if m.get('fieldRank') is not None:
            self.field_rank = m.get('fieldRank')
        if m.get('fieldSource') is not None:
            self.field_source = m.get('fieldSource')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('inputFieldType') is not None:
            self.input_field_type = m.get('inputFieldType')
        if m.get('inputRequired') is not None:
            self.input_required = m.get('inputRequired')
        if m.get('inputs') is not None:
            self.inputs = m.get('inputs')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('outlier') is not None:
            self.outlier = m.get('outlier')
        if m.get('outputThreshold') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectDeviceVariablesOutputThreshold()
            self.output_threshold = temp_model.from_map(m['outputThreshold'])
        if m.get('parentName') is not None:
            self.parent_name = m.get('parentName')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('variableVelocity') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectDeviceVariablesVariableVelocity()
            self.variable_velocity = temp_model.from_map(m['variableVelocity'])
        if m.get('xLabel') is not None:
            self.x_label = m.get('xLabel')
        if m.get('yLabel') is not None:
            self.y_label = m.get('yLabel')
        return self


class DescribeEventVariableListResponseBodyResultObjectExpressionVariablesOutputThreshold(TeaModel):
    def __init__(
        self,
        max_value: float = None,
        min_value: float = None,
    ):
        self.max_value = max_value
        self.min_value = min_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_value is not None:
            result['maxValue'] = self.max_value
        if self.min_value is not None:
            result['minValue'] = self.min_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxValue') is not None:
            self.max_value = m.get('maxValue')
        if m.get('minValue') is not None:
            self.min_value = m.get('minValue')
        return self


class DescribeEventVariableListResponseBodyResultObjectExpressionVariablesVariableVelocity(TeaModel):
    def __init__(
        self,
        iv: str = None,
    ):
        self.iv = iv

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iv is not None:
            result['iv'] = self.iv
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('iv') is not None:
            self.iv = m.get('iv')
        return self


class DescribeEventVariableListResponseBodyResultObjectExpressionVariables(TeaModel):
    def __init__(
        self,
        code: str = None,
        data_display: str = None,
        define_id: str = None,
        description: str = None,
        display_type: str = None,
        expression_title: str = None,
        favorite_flag: bool = None,
        field_detail: str = None,
        field_rank: int = None,
        field_source: str = None,
        field_type: str = None,
        id: int = None,
        input_field_type: str = None,
        input_required: str = None,
        inputs: str = None,
        name: str = None,
        outlier: str = None,
        output_threshold: DescribeEventVariableListResponseBodyResultObjectExpressionVariablesOutputThreshold = None,
        parent_name: str = None,
        source_type: str = None,
        title: str = None,
        type: str = None,
        variable_velocity: DescribeEventVariableListResponseBodyResultObjectExpressionVariablesVariableVelocity = None,
        x_label: str = None,
        y_label: str = None,
    ):
        self.code = code
        self.data_display = data_display
        self.define_id = define_id
        self.description = description
        self.display_type = display_type
        self.expression_title = expression_title
        self.favorite_flag = favorite_flag
        self.field_detail = field_detail
        self.field_rank = field_rank
        self.field_source = field_source
        self.field_type = field_type
        self.id = id
        self.input_field_type = input_field_type
        self.input_required = input_required
        self.inputs = inputs
        self.name = name
        self.outlier = outlier
        self.output_threshold = output_threshold
        self.parent_name = parent_name
        self.source_type = source_type
        self.title = title
        self.type = type
        self.variable_velocity = variable_velocity
        self.x_label = x_label
        self.y_label = y_label

    def validate(self):
        if self.output_threshold:
            self.output_threshold.validate()
        if self.variable_velocity:
            self.variable_velocity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data_display is not None:
            result['dataDisplay'] = self.data_display
        if self.define_id is not None:
            result['defineId'] = self.define_id
        if self.description is not None:
            result['description'] = self.description
        if self.display_type is not None:
            result['displayType'] = self.display_type
        if self.expression_title is not None:
            result['expressionTitle'] = self.expression_title
        if self.favorite_flag is not None:
            result['favoriteFlag'] = self.favorite_flag
        if self.field_detail is not None:
            result['fieldDetail'] = self.field_detail
        if self.field_rank is not None:
            result['fieldRank'] = self.field_rank
        if self.field_source is not None:
            result['fieldSource'] = self.field_source
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.id is not None:
            result['id'] = self.id
        if self.input_field_type is not None:
            result['inputFieldType'] = self.input_field_type
        if self.input_required is not None:
            result['inputRequired'] = self.input_required
        if self.inputs is not None:
            result['inputs'] = self.inputs
        if self.name is not None:
            result['name'] = self.name
        if self.outlier is not None:
            result['outlier'] = self.outlier
        if self.output_threshold is not None:
            result['outputThreshold'] = self.output_threshold.to_map()
        if self.parent_name is not None:
            result['parentName'] = self.parent_name
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        if self.variable_velocity is not None:
            result['variableVelocity'] = self.variable_velocity.to_map()
        if self.x_label is not None:
            result['xLabel'] = self.x_label
        if self.y_label is not None:
            result['yLabel'] = self.y_label
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('dataDisplay') is not None:
            self.data_display = m.get('dataDisplay')
        if m.get('defineId') is not None:
            self.define_id = m.get('defineId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayType') is not None:
            self.display_type = m.get('displayType')
        if m.get('expressionTitle') is not None:
            self.expression_title = m.get('expressionTitle')
        if m.get('favoriteFlag') is not None:
            self.favorite_flag = m.get('favoriteFlag')
        if m.get('fieldDetail') is not None:
            self.field_detail = m.get('fieldDetail')
        if m.get('fieldRank') is not None:
            self.field_rank = m.get('fieldRank')
        if m.get('fieldSource') is not None:
            self.field_source = m.get('fieldSource')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('inputFieldType') is not None:
            self.input_field_type = m.get('inputFieldType')
        if m.get('inputRequired') is not None:
            self.input_required = m.get('inputRequired')
        if m.get('inputs') is not None:
            self.inputs = m.get('inputs')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('outlier') is not None:
            self.outlier = m.get('outlier')
        if m.get('outputThreshold') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectExpressionVariablesOutputThreshold()
            self.output_threshold = temp_model.from_map(m['outputThreshold'])
        if m.get('parentName') is not None:
            self.parent_name = m.get('parentName')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('variableVelocity') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectExpressionVariablesVariableVelocity()
            self.variable_velocity = temp_model.from_map(m['variableVelocity'])
        if m.get('xLabel') is not None:
            self.x_label = m.get('xLabel')
        if m.get('yLabel') is not None:
            self.y_label = m.get('yLabel')
        return self


class DescribeEventVariableListResponseBodyResultObjectFavoriteVariablesOutputThreshold(TeaModel):
    def __init__(
        self,
        max_value: float = None,
        min_value: float = None,
    ):
        self.max_value = max_value
        self.min_value = min_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_value is not None:
            result['maxValue'] = self.max_value
        if self.min_value is not None:
            result['minValue'] = self.min_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxValue') is not None:
            self.max_value = m.get('maxValue')
        if m.get('minValue') is not None:
            self.min_value = m.get('minValue')
        return self


class DescribeEventVariableListResponseBodyResultObjectFavoriteVariablesVariableVelocity(TeaModel):
    def __init__(
        self,
        iv: str = None,
    ):
        self.iv = iv

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iv is not None:
            result['iv'] = self.iv
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('iv') is not None:
            self.iv = m.get('iv')
        return self


class DescribeEventVariableListResponseBodyResultObjectFavoriteVariables(TeaModel):
    def __init__(
        self,
        code: str = None,
        data_display: str = None,
        define_id: str = None,
        description: str = None,
        display_type: str = None,
        expression_title: str = None,
        favorite_flag: bool = None,
        field_detail: str = None,
        field_rank: int = None,
        field_source: str = None,
        field_type: str = None,
        id: int = None,
        input_field_type: str = None,
        input_required: str = None,
        inputs: str = None,
        name: str = None,
        outlier: str = None,
        output_threshold: DescribeEventVariableListResponseBodyResultObjectFavoriteVariablesOutputThreshold = None,
        parent_name: str = None,
        source_type: str = None,
        title: str = None,
        type: str = None,
        variable_velocity: DescribeEventVariableListResponseBodyResultObjectFavoriteVariablesVariableVelocity = None,
        x_label: str = None,
        y_label: str = None,
    ):
        self.code = code
        self.data_display = data_display
        self.define_id = define_id
        self.description = description
        self.display_type = display_type
        self.expression_title = expression_title
        self.favorite_flag = favorite_flag
        self.field_detail = field_detail
        self.field_rank = field_rank
        self.field_source = field_source
        self.field_type = field_type
        self.id = id
        self.input_field_type = input_field_type
        self.input_required = input_required
        self.inputs = inputs
        self.name = name
        self.outlier = outlier
        self.output_threshold = output_threshold
        self.parent_name = parent_name
        self.source_type = source_type
        self.title = title
        self.type = type
        self.variable_velocity = variable_velocity
        self.x_label = x_label
        self.y_label = y_label

    def validate(self):
        if self.output_threshold:
            self.output_threshold.validate()
        if self.variable_velocity:
            self.variable_velocity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data_display is not None:
            result['dataDisplay'] = self.data_display
        if self.define_id is not None:
            result['defineId'] = self.define_id
        if self.description is not None:
            result['description'] = self.description
        if self.display_type is not None:
            result['displayType'] = self.display_type
        if self.expression_title is not None:
            result['expressionTitle'] = self.expression_title
        if self.favorite_flag is not None:
            result['favoriteFlag'] = self.favorite_flag
        if self.field_detail is not None:
            result['fieldDetail'] = self.field_detail
        if self.field_rank is not None:
            result['fieldRank'] = self.field_rank
        if self.field_source is not None:
            result['fieldSource'] = self.field_source
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.id is not None:
            result['id'] = self.id
        if self.input_field_type is not None:
            result['inputFieldType'] = self.input_field_type
        if self.input_required is not None:
            result['inputRequired'] = self.input_required
        if self.inputs is not None:
            result['inputs'] = self.inputs
        if self.name is not None:
            result['name'] = self.name
        if self.outlier is not None:
            result['outlier'] = self.outlier
        if self.output_threshold is not None:
            result['outputThreshold'] = self.output_threshold.to_map()
        if self.parent_name is not None:
            result['parentName'] = self.parent_name
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        if self.variable_velocity is not None:
            result['variableVelocity'] = self.variable_velocity.to_map()
        if self.x_label is not None:
            result['xLabel'] = self.x_label
        if self.y_label is not None:
            result['yLabel'] = self.y_label
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('dataDisplay') is not None:
            self.data_display = m.get('dataDisplay')
        if m.get('defineId') is not None:
            self.define_id = m.get('defineId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayType') is not None:
            self.display_type = m.get('displayType')
        if m.get('expressionTitle') is not None:
            self.expression_title = m.get('expressionTitle')
        if m.get('favoriteFlag') is not None:
            self.favorite_flag = m.get('favoriteFlag')
        if m.get('fieldDetail') is not None:
            self.field_detail = m.get('fieldDetail')
        if m.get('fieldRank') is not None:
            self.field_rank = m.get('fieldRank')
        if m.get('fieldSource') is not None:
            self.field_source = m.get('fieldSource')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('inputFieldType') is not None:
            self.input_field_type = m.get('inputFieldType')
        if m.get('inputRequired') is not None:
            self.input_required = m.get('inputRequired')
        if m.get('inputs') is not None:
            self.inputs = m.get('inputs')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('outlier') is not None:
            self.outlier = m.get('outlier')
        if m.get('outputThreshold') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectFavoriteVariablesOutputThreshold()
            self.output_threshold = temp_model.from_map(m['outputThreshold'])
        if m.get('parentName') is not None:
            self.parent_name = m.get('parentName')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('variableVelocity') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectFavoriteVariablesVariableVelocity()
            self.variable_velocity = temp_model.from_map(m['variableVelocity'])
        if m.get('xLabel') is not None:
            self.x_label = m.get('xLabel')
        if m.get('yLabel') is not None:
            self.y_label = m.get('yLabel')
        return self


class DescribeEventVariableListResponseBodyResultObjectMiddleVariablesOutputThreshold(TeaModel):
    def __init__(
        self,
        max_value: float = None,
        min_value: float = None,
    ):
        self.max_value = max_value
        self.min_value = min_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_value is not None:
            result['maxValue'] = self.max_value
        if self.min_value is not None:
            result['minValue'] = self.min_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxValue') is not None:
            self.max_value = m.get('maxValue')
        if m.get('minValue') is not None:
            self.min_value = m.get('minValue')
        return self


class DescribeEventVariableListResponseBodyResultObjectMiddleVariablesVariableVelocity(TeaModel):
    def __init__(
        self,
        iv: str = None,
    ):
        self.iv = iv

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iv is not None:
            result['iv'] = self.iv
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('iv') is not None:
            self.iv = m.get('iv')
        return self


class DescribeEventVariableListResponseBodyResultObjectMiddleVariables(TeaModel):
    def __init__(
        self,
        code: str = None,
        data_display: str = None,
        define_id: str = None,
        description: str = None,
        display_type: str = None,
        expression_title: str = None,
        favorite_flag: bool = None,
        field_detail: str = None,
        field_rank: int = None,
        field_source: str = None,
        field_type: str = None,
        id: int = None,
        input_field_type: str = None,
        input_required: str = None,
        inputs: str = None,
        name: str = None,
        outlier: str = None,
        output_threshold: DescribeEventVariableListResponseBodyResultObjectMiddleVariablesOutputThreshold = None,
        parent_name: str = None,
        source_type: str = None,
        title: str = None,
        type: str = None,
        variable_velocity: DescribeEventVariableListResponseBodyResultObjectMiddleVariablesVariableVelocity = None,
        x_label: str = None,
        y_label: str = None,
    ):
        self.code = code
        self.data_display = data_display
        self.define_id = define_id
        self.description = description
        self.display_type = display_type
        self.expression_title = expression_title
        self.favorite_flag = favorite_flag
        self.field_detail = field_detail
        self.field_rank = field_rank
        self.field_source = field_source
        self.field_type = field_type
        self.id = id
        self.input_field_type = input_field_type
        self.input_required = input_required
        self.inputs = inputs
        self.name = name
        self.outlier = outlier
        self.output_threshold = output_threshold
        self.parent_name = parent_name
        self.source_type = source_type
        self.title = title
        self.type = type
        self.variable_velocity = variable_velocity
        self.x_label = x_label
        self.y_label = y_label

    def validate(self):
        if self.output_threshold:
            self.output_threshold.validate()
        if self.variable_velocity:
            self.variable_velocity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data_display is not None:
            result['dataDisplay'] = self.data_display
        if self.define_id is not None:
            result['defineId'] = self.define_id
        if self.description is not None:
            result['description'] = self.description
        if self.display_type is not None:
            result['displayType'] = self.display_type
        if self.expression_title is not None:
            result['expressionTitle'] = self.expression_title
        if self.favorite_flag is not None:
            result['favoriteFlag'] = self.favorite_flag
        if self.field_detail is not None:
            result['fieldDetail'] = self.field_detail
        if self.field_rank is not None:
            result['fieldRank'] = self.field_rank
        if self.field_source is not None:
            result['fieldSource'] = self.field_source
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.id is not None:
            result['id'] = self.id
        if self.input_field_type is not None:
            result['inputFieldType'] = self.input_field_type
        if self.input_required is not None:
            result['inputRequired'] = self.input_required
        if self.inputs is not None:
            result['inputs'] = self.inputs
        if self.name is not None:
            result['name'] = self.name
        if self.outlier is not None:
            result['outlier'] = self.outlier
        if self.output_threshold is not None:
            result['outputThreshold'] = self.output_threshold.to_map()
        if self.parent_name is not None:
            result['parentName'] = self.parent_name
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        if self.variable_velocity is not None:
            result['variableVelocity'] = self.variable_velocity.to_map()
        if self.x_label is not None:
            result['xLabel'] = self.x_label
        if self.y_label is not None:
            result['yLabel'] = self.y_label
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('dataDisplay') is not None:
            self.data_display = m.get('dataDisplay')
        if m.get('defineId') is not None:
            self.define_id = m.get('defineId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayType') is not None:
            self.display_type = m.get('displayType')
        if m.get('expressionTitle') is not None:
            self.expression_title = m.get('expressionTitle')
        if m.get('favoriteFlag') is not None:
            self.favorite_flag = m.get('favoriteFlag')
        if m.get('fieldDetail') is not None:
            self.field_detail = m.get('fieldDetail')
        if m.get('fieldRank') is not None:
            self.field_rank = m.get('fieldRank')
        if m.get('fieldSource') is not None:
            self.field_source = m.get('fieldSource')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('inputFieldType') is not None:
            self.input_field_type = m.get('inputFieldType')
        if m.get('inputRequired') is not None:
            self.input_required = m.get('inputRequired')
        if m.get('inputs') is not None:
            self.inputs = m.get('inputs')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('outlier') is not None:
            self.outlier = m.get('outlier')
        if m.get('outputThreshold') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectMiddleVariablesOutputThreshold()
            self.output_threshold = temp_model.from_map(m['outputThreshold'])
        if m.get('parentName') is not None:
            self.parent_name = m.get('parentName')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('variableVelocity') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectMiddleVariablesVariableVelocity()
            self.variable_velocity = temp_model.from_map(m['variableVelocity'])
        if m.get('xLabel') is not None:
            self.x_label = m.get('xLabel')
        if m.get('yLabel') is not None:
            self.y_label = m.get('yLabel')
        return self


class DescribeEventVariableListResponseBodyResultObjectModelVariablesOutputThreshold(TeaModel):
    def __init__(
        self,
        max_value: float = None,
        min_value: float = None,
    ):
        self.max_value = max_value
        self.min_value = min_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_value is not None:
            result['maxValue'] = self.max_value
        if self.min_value is not None:
            result['minValue'] = self.min_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxValue') is not None:
            self.max_value = m.get('maxValue')
        if m.get('minValue') is not None:
            self.min_value = m.get('minValue')
        return self


class DescribeEventVariableListResponseBodyResultObjectModelVariablesVariableVelocity(TeaModel):
    def __init__(
        self,
        iv: str = None,
    ):
        self.iv = iv

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iv is not None:
            result['iv'] = self.iv
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('iv') is not None:
            self.iv = m.get('iv')
        return self


class DescribeEventVariableListResponseBodyResultObjectModelVariables(TeaModel):
    def __init__(
        self,
        code: str = None,
        data_display: str = None,
        define_id: str = None,
        description: str = None,
        display_type: str = None,
        expression_title: str = None,
        favorite_flag: bool = None,
        field_detail: str = None,
        field_rank: int = None,
        field_source: str = None,
        field_type: str = None,
        id: int = None,
        input_field_type: str = None,
        input_required: str = None,
        inputs: str = None,
        name: str = None,
        outlier: str = None,
        output_threshold: DescribeEventVariableListResponseBodyResultObjectModelVariablesOutputThreshold = None,
        parent_name: str = None,
        source_type: str = None,
        title: str = None,
        type: str = None,
        variable_velocity: DescribeEventVariableListResponseBodyResultObjectModelVariablesVariableVelocity = None,
        x_label: str = None,
        y_label: str = None,
    ):
        self.code = code
        self.data_display = data_display
        self.define_id = define_id
        self.description = description
        self.display_type = display_type
        self.expression_title = expression_title
        self.favorite_flag = favorite_flag
        self.field_detail = field_detail
        self.field_rank = field_rank
        self.field_source = field_source
        self.field_type = field_type
        self.id = id
        self.input_field_type = input_field_type
        self.input_required = input_required
        self.inputs = inputs
        self.name = name
        self.outlier = outlier
        self.output_threshold = output_threshold
        self.parent_name = parent_name
        self.source_type = source_type
        self.title = title
        self.type = type
        self.variable_velocity = variable_velocity
        self.x_label = x_label
        self.y_label = y_label

    def validate(self):
        if self.output_threshold:
            self.output_threshold.validate()
        if self.variable_velocity:
            self.variable_velocity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data_display is not None:
            result['dataDisplay'] = self.data_display
        if self.define_id is not None:
            result['defineId'] = self.define_id
        if self.description is not None:
            result['description'] = self.description
        if self.display_type is not None:
            result['displayType'] = self.display_type
        if self.expression_title is not None:
            result['expressionTitle'] = self.expression_title
        if self.favorite_flag is not None:
            result['favoriteFlag'] = self.favorite_flag
        if self.field_detail is not None:
            result['fieldDetail'] = self.field_detail
        if self.field_rank is not None:
            result['fieldRank'] = self.field_rank
        if self.field_source is not None:
            result['fieldSource'] = self.field_source
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.id is not None:
            result['id'] = self.id
        if self.input_field_type is not None:
            result['inputFieldType'] = self.input_field_type
        if self.input_required is not None:
            result['inputRequired'] = self.input_required
        if self.inputs is not None:
            result['inputs'] = self.inputs
        if self.name is not None:
            result['name'] = self.name
        if self.outlier is not None:
            result['outlier'] = self.outlier
        if self.output_threshold is not None:
            result['outputThreshold'] = self.output_threshold.to_map()
        if self.parent_name is not None:
            result['parentName'] = self.parent_name
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        if self.variable_velocity is not None:
            result['variableVelocity'] = self.variable_velocity.to_map()
        if self.x_label is not None:
            result['xLabel'] = self.x_label
        if self.y_label is not None:
            result['yLabel'] = self.y_label
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('dataDisplay') is not None:
            self.data_display = m.get('dataDisplay')
        if m.get('defineId') is not None:
            self.define_id = m.get('defineId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayType') is not None:
            self.display_type = m.get('displayType')
        if m.get('expressionTitle') is not None:
            self.expression_title = m.get('expressionTitle')
        if m.get('favoriteFlag') is not None:
            self.favorite_flag = m.get('favoriteFlag')
        if m.get('fieldDetail') is not None:
            self.field_detail = m.get('fieldDetail')
        if m.get('fieldRank') is not None:
            self.field_rank = m.get('fieldRank')
        if m.get('fieldSource') is not None:
            self.field_source = m.get('fieldSource')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('inputFieldType') is not None:
            self.input_field_type = m.get('inputFieldType')
        if m.get('inputRequired') is not None:
            self.input_required = m.get('inputRequired')
        if m.get('inputs') is not None:
            self.inputs = m.get('inputs')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('outlier') is not None:
            self.outlier = m.get('outlier')
        if m.get('outputThreshold') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectModelVariablesOutputThreshold()
            self.output_threshold = temp_model.from_map(m['outputThreshold'])
        if m.get('parentName') is not None:
            self.parent_name = m.get('parentName')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('variableVelocity') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectModelVariablesVariableVelocity()
            self.variable_velocity = temp_model.from_map(m['variableVelocity'])
        if m.get('xLabel') is not None:
            self.x_label = m.get('xLabel')
        if m.get('yLabel') is not None:
            self.y_label = m.get('yLabel')
        return self


class DescribeEventVariableListResponseBodyResultObjectNameListOutputThreshold(TeaModel):
    def __init__(
        self,
        max_value: float = None,
        min_value: float = None,
    ):
        self.max_value = max_value
        self.min_value = min_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_value is not None:
            result['maxValue'] = self.max_value
        if self.min_value is not None:
            result['minValue'] = self.min_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxValue') is not None:
            self.max_value = m.get('maxValue')
        if m.get('minValue') is not None:
            self.min_value = m.get('minValue')
        return self


class DescribeEventVariableListResponseBodyResultObjectNameListVariableVelocity(TeaModel):
    def __init__(
        self,
        iv: str = None,
    ):
        self.iv = iv

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iv is not None:
            result['iv'] = self.iv
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('iv') is not None:
            self.iv = m.get('iv')
        return self


class DescribeEventVariableListResponseBodyResultObjectNameList(TeaModel):
    def __init__(
        self,
        code: str = None,
        data_display: str = None,
        define_id: str = None,
        description: str = None,
        display_type: str = None,
        expression_title: str = None,
        favorite_flag: bool = None,
        field_detail: str = None,
        field_rank: int = None,
        field_source: str = None,
        field_type: str = None,
        id: int = None,
        input_field_type: str = None,
        input_required: str = None,
        inputs: str = None,
        name: str = None,
        outlier: str = None,
        output_threshold: DescribeEventVariableListResponseBodyResultObjectNameListOutputThreshold = None,
        parent_name: str = None,
        source_type: str = None,
        title: str = None,
        type: str = None,
        variable_velocity: DescribeEventVariableListResponseBodyResultObjectNameListVariableVelocity = None,
        x_label: str = None,
        y_label: str = None,
    ):
        self.code = code
        self.data_display = data_display
        self.define_id = define_id
        self.description = description
        self.display_type = display_type
        self.expression_title = expression_title
        self.favorite_flag = favorite_flag
        self.field_detail = field_detail
        self.field_rank = field_rank
        self.field_source = field_source
        self.field_type = field_type
        self.id = id
        self.input_field_type = input_field_type
        self.input_required = input_required
        self.inputs = inputs
        self.name = name
        self.outlier = outlier
        self.output_threshold = output_threshold
        self.parent_name = parent_name
        self.source_type = source_type
        self.title = title
        self.type = type
        self.variable_velocity = variable_velocity
        self.x_label = x_label
        self.y_label = y_label

    def validate(self):
        if self.output_threshold:
            self.output_threshold.validate()
        if self.variable_velocity:
            self.variable_velocity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data_display is not None:
            result['dataDisplay'] = self.data_display
        if self.define_id is not None:
            result['defineId'] = self.define_id
        if self.description is not None:
            result['description'] = self.description
        if self.display_type is not None:
            result['displayType'] = self.display_type
        if self.expression_title is not None:
            result['expressionTitle'] = self.expression_title
        if self.favorite_flag is not None:
            result['favoriteFlag'] = self.favorite_flag
        if self.field_detail is not None:
            result['fieldDetail'] = self.field_detail
        if self.field_rank is not None:
            result['fieldRank'] = self.field_rank
        if self.field_source is not None:
            result['fieldSource'] = self.field_source
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.id is not None:
            result['id'] = self.id
        if self.input_field_type is not None:
            result['inputFieldType'] = self.input_field_type
        if self.input_required is not None:
            result['inputRequired'] = self.input_required
        if self.inputs is not None:
            result['inputs'] = self.inputs
        if self.name is not None:
            result['name'] = self.name
        if self.outlier is not None:
            result['outlier'] = self.outlier
        if self.output_threshold is not None:
            result['outputThreshold'] = self.output_threshold.to_map()
        if self.parent_name is not None:
            result['parentName'] = self.parent_name
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        if self.variable_velocity is not None:
            result['variableVelocity'] = self.variable_velocity.to_map()
        if self.x_label is not None:
            result['xLabel'] = self.x_label
        if self.y_label is not None:
            result['yLabel'] = self.y_label
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('dataDisplay') is not None:
            self.data_display = m.get('dataDisplay')
        if m.get('defineId') is not None:
            self.define_id = m.get('defineId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayType') is not None:
            self.display_type = m.get('displayType')
        if m.get('expressionTitle') is not None:
            self.expression_title = m.get('expressionTitle')
        if m.get('favoriteFlag') is not None:
            self.favorite_flag = m.get('favoriteFlag')
        if m.get('fieldDetail') is not None:
            self.field_detail = m.get('fieldDetail')
        if m.get('fieldRank') is not None:
            self.field_rank = m.get('fieldRank')
        if m.get('fieldSource') is not None:
            self.field_source = m.get('fieldSource')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('inputFieldType') is not None:
            self.input_field_type = m.get('inputFieldType')
        if m.get('inputRequired') is not None:
            self.input_required = m.get('inputRequired')
        if m.get('inputs') is not None:
            self.inputs = m.get('inputs')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('outlier') is not None:
            self.outlier = m.get('outlier')
        if m.get('outputThreshold') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectNameListOutputThreshold()
            self.output_threshold = temp_model.from_map(m['outputThreshold'])
        if m.get('parentName') is not None:
            self.parent_name = m.get('parentName')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('variableVelocity') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectNameListVariableVelocity()
            self.variable_velocity = temp_model.from_map(m['variableVelocity'])
        if m.get('xLabel') is not None:
            self.x_label = m.get('xLabel')
        if m.get('yLabel') is not None:
            self.y_label = m.get('yLabel')
        return self


class DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctionsOutputThreshold(TeaModel):
    def __init__(
        self,
        max_value: float = None,
        min_value: float = None,
    ):
        self.max_value = max_value
        self.min_value = min_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_value is not None:
            result['maxValue'] = self.max_value
        if self.min_value is not None:
            result['minValue'] = self.min_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxValue') is not None:
            self.max_value = m.get('maxValue')
        if m.get('minValue') is not None:
            self.min_value = m.get('minValue')
        return self


class DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctionsVariableVelocity(TeaModel):
    def __init__(
        self,
        iv: str = None,
    ):
        self.iv = iv

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iv is not None:
            result['iv'] = self.iv
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('iv') is not None:
            self.iv = m.get('iv')
        return self


class DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctions(TeaModel):
    def __init__(
        self,
        code: str = None,
        data_display: str = None,
        define_id: str = None,
        description: str = None,
        display_type: str = None,
        expression_title: str = None,
        favorite_flag: bool = None,
        field_detail: str = None,
        field_rank: int = None,
        field_source: str = None,
        field_type: str = None,
        id: int = None,
        input_field_type: str = None,
        input_required: str = None,
        inputs: str = None,
        name: str = None,
        outlier: str = None,
        output_threshold: DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctionsOutputThreshold = None,
        parent_name: str = None,
        source_type: str = None,
        title: str = None,
        type: str = None,
        variable_velocity: DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctionsVariableVelocity = None,
        x_label: str = None,
        y_label: str = None,
    ):
        self.code = code
        self.data_display = data_display
        self.define_id = define_id
        self.description = description
        self.display_type = display_type
        self.expression_title = expression_title
        self.favorite_flag = favorite_flag
        self.field_detail = field_detail
        self.field_rank = field_rank
        self.field_source = field_source
        self.field_type = field_type
        self.id = id
        self.input_field_type = input_field_type
        self.input_required = input_required
        self.inputs = inputs
        self.name = name
        self.outlier = outlier
        self.output_threshold = output_threshold
        self.parent_name = parent_name
        self.source_type = source_type
        self.title = title
        self.type = type
        self.variable_velocity = variable_velocity
        self.x_label = x_label
        self.y_label = y_label

    def validate(self):
        if self.output_threshold:
            self.output_threshold.validate()
        if self.variable_velocity:
            self.variable_velocity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data_display is not None:
            result['dataDisplay'] = self.data_display
        if self.define_id is not None:
            result['defineId'] = self.define_id
        if self.description is not None:
            result['description'] = self.description
        if self.display_type is not None:
            result['displayType'] = self.display_type
        if self.expression_title is not None:
            result['expressionTitle'] = self.expression_title
        if self.favorite_flag is not None:
            result['favoriteFlag'] = self.favorite_flag
        if self.field_detail is not None:
            result['fieldDetail'] = self.field_detail
        if self.field_rank is not None:
            result['fieldRank'] = self.field_rank
        if self.field_source is not None:
            result['fieldSource'] = self.field_source
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.id is not None:
            result['id'] = self.id
        if self.input_field_type is not None:
            result['inputFieldType'] = self.input_field_type
        if self.input_required is not None:
            result['inputRequired'] = self.input_required
        if self.inputs is not None:
            result['inputs'] = self.inputs
        if self.name is not None:
            result['name'] = self.name
        if self.outlier is not None:
            result['outlier'] = self.outlier
        if self.output_threshold is not None:
            result['outputThreshold'] = self.output_threshold.to_map()
        if self.parent_name is not None:
            result['parentName'] = self.parent_name
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        if self.variable_velocity is not None:
            result['variableVelocity'] = self.variable_velocity.to_map()
        if self.x_label is not None:
            result['xLabel'] = self.x_label
        if self.y_label is not None:
            result['yLabel'] = self.y_label
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('dataDisplay') is not None:
            self.data_display = m.get('dataDisplay')
        if m.get('defineId') is not None:
            self.define_id = m.get('defineId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayType') is not None:
            self.display_type = m.get('displayType')
        if m.get('expressionTitle') is not None:
            self.expression_title = m.get('expressionTitle')
        if m.get('favoriteFlag') is not None:
            self.favorite_flag = m.get('favoriteFlag')
        if m.get('fieldDetail') is not None:
            self.field_detail = m.get('fieldDetail')
        if m.get('fieldRank') is not None:
            self.field_rank = m.get('fieldRank')
        if m.get('fieldSource') is not None:
            self.field_source = m.get('fieldSource')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('inputFieldType') is not None:
            self.input_field_type = m.get('inputFieldType')
        if m.get('inputRequired') is not None:
            self.input_required = m.get('inputRequired')
        if m.get('inputs') is not None:
            self.inputs = m.get('inputs')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('outlier') is not None:
            self.outlier = m.get('outlier')
        if m.get('outputThreshold') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctionsOutputThreshold()
            self.output_threshold = temp_model.from_map(m['outputThreshold'])
        if m.get('parentName') is not None:
            self.parent_name = m.get('parentName')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('variableVelocity') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctionsVariableVelocity()
            self.variable_velocity = temp_model.from_map(m['variableVelocity'])
        if m.get('xLabel') is not None:
            self.x_label = m.get('xLabel')
        if m.get('yLabel') is not None:
            self.y_label = m.get('yLabel')
        return self


class DescribeEventVariableListResponseBodyResultObjectNativeVariablesOutputThreshold(TeaModel):
    def __init__(
        self,
        max_value: float = None,
        min_value: float = None,
    ):
        self.max_value = max_value
        self.min_value = min_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_value is not None:
            result['maxValue'] = self.max_value
        if self.min_value is not None:
            result['minValue'] = self.min_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxValue') is not None:
            self.max_value = m.get('maxValue')
        if m.get('minValue') is not None:
            self.min_value = m.get('minValue')
        return self


class DescribeEventVariableListResponseBodyResultObjectNativeVariablesVariableVelocity(TeaModel):
    def __init__(
        self,
        iv: str = None,
    ):
        self.iv = iv

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iv is not None:
            result['iv'] = self.iv
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('iv') is not None:
            self.iv = m.get('iv')
        return self


class DescribeEventVariableListResponseBodyResultObjectNativeVariables(TeaModel):
    def __init__(
        self,
        code: str = None,
        data_display: str = None,
        define_id: str = None,
        description: str = None,
        display_type: str = None,
        expression_title: str = None,
        favorite_flag: bool = None,
        field_detail: str = None,
        field_rank: int = None,
        field_source: str = None,
        field_type: str = None,
        id: int = None,
        input_field_type: str = None,
        input_required: str = None,
        inputs: str = None,
        name: str = None,
        outlier: str = None,
        output_threshold: DescribeEventVariableListResponseBodyResultObjectNativeVariablesOutputThreshold = None,
        parent_name: str = None,
        source_type: str = None,
        title: str = None,
        type: str = None,
        variable_velocity: DescribeEventVariableListResponseBodyResultObjectNativeVariablesVariableVelocity = None,
        x_label: str = None,
        y_label: str = None,
    ):
        self.code = code
        self.data_display = data_display
        self.define_id = define_id
        self.description = description
        self.display_type = display_type
        self.expression_title = expression_title
        self.favorite_flag = favorite_flag
        self.field_detail = field_detail
        self.field_rank = field_rank
        self.field_source = field_source
        self.field_type = field_type
        self.id = id
        self.input_field_type = input_field_type
        self.input_required = input_required
        self.inputs = inputs
        self.name = name
        self.outlier = outlier
        self.output_threshold = output_threshold
        self.parent_name = parent_name
        self.source_type = source_type
        self.title = title
        self.type = type
        self.variable_velocity = variable_velocity
        self.x_label = x_label
        self.y_label = y_label

    def validate(self):
        if self.output_threshold:
            self.output_threshold.validate()
        if self.variable_velocity:
            self.variable_velocity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data_display is not None:
            result['dataDisplay'] = self.data_display
        if self.define_id is not None:
            result['defineId'] = self.define_id
        if self.description is not None:
            result['description'] = self.description
        if self.display_type is not None:
            result['displayType'] = self.display_type
        if self.expression_title is not None:
            result['expressionTitle'] = self.expression_title
        if self.favorite_flag is not None:
            result['favoriteFlag'] = self.favorite_flag
        if self.field_detail is not None:
            result['fieldDetail'] = self.field_detail
        if self.field_rank is not None:
            result['fieldRank'] = self.field_rank
        if self.field_source is not None:
            result['fieldSource'] = self.field_source
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.id is not None:
            result['id'] = self.id
        if self.input_field_type is not None:
            result['inputFieldType'] = self.input_field_type
        if self.input_required is not None:
            result['inputRequired'] = self.input_required
        if self.inputs is not None:
            result['inputs'] = self.inputs
        if self.name is not None:
            result['name'] = self.name
        if self.outlier is not None:
            result['outlier'] = self.outlier
        if self.output_threshold is not None:
            result['outputThreshold'] = self.output_threshold.to_map()
        if self.parent_name is not None:
            result['parentName'] = self.parent_name
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        if self.variable_velocity is not None:
            result['variableVelocity'] = self.variable_velocity.to_map()
        if self.x_label is not None:
            result['xLabel'] = self.x_label
        if self.y_label is not None:
            result['yLabel'] = self.y_label
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('dataDisplay') is not None:
            self.data_display = m.get('dataDisplay')
        if m.get('defineId') is not None:
            self.define_id = m.get('defineId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayType') is not None:
            self.display_type = m.get('displayType')
        if m.get('expressionTitle') is not None:
            self.expression_title = m.get('expressionTitle')
        if m.get('favoriteFlag') is not None:
            self.favorite_flag = m.get('favoriteFlag')
        if m.get('fieldDetail') is not None:
            self.field_detail = m.get('fieldDetail')
        if m.get('fieldRank') is not None:
            self.field_rank = m.get('fieldRank')
        if m.get('fieldSource') is not None:
            self.field_source = m.get('fieldSource')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('inputFieldType') is not None:
            self.input_field_type = m.get('inputFieldType')
        if m.get('inputRequired') is not None:
            self.input_required = m.get('inputRequired')
        if m.get('inputs') is not None:
            self.inputs = m.get('inputs')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('outlier') is not None:
            self.outlier = m.get('outlier')
        if m.get('outputThreshold') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectNativeVariablesOutputThreshold()
            self.output_threshold = temp_model.from_map(m['outputThreshold'])
        if m.get('parentName') is not None:
            self.parent_name = m.get('parentName')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('variableVelocity') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectNativeVariablesVariableVelocity()
            self.variable_velocity = temp_model.from_map(m['variableVelocity'])
        if m.get('xLabel') is not None:
            self.x_label = m.get('xLabel')
        if m.get('yLabel') is not None:
            self.y_label = m.get('yLabel')
        return self


class DescribeEventVariableListResponseBodyResultObjectQueryVariablesOutputThreshold(TeaModel):
    def __init__(
        self,
        max_value: float = None,
        min_value: float = None,
    ):
        self.max_value = max_value
        self.min_value = min_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_value is not None:
            result['maxValue'] = self.max_value
        if self.min_value is not None:
            result['minValue'] = self.min_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxValue') is not None:
            self.max_value = m.get('maxValue')
        if m.get('minValue') is not None:
            self.min_value = m.get('minValue')
        return self


class DescribeEventVariableListResponseBodyResultObjectQueryVariablesVariableVelocity(TeaModel):
    def __init__(
        self,
        iv: str = None,
    ):
        self.iv = iv

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iv is not None:
            result['iv'] = self.iv
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('iv') is not None:
            self.iv = m.get('iv')
        return self


class DescribeEventVariableListResponseBodyResultObjectQueryVariables(TeaModel):
    def __init__(
        self,
        code: str = None,
        data_display: str = None,
        define_id: str = None,
        description: str = None,
        display_type: str = None,
        expression_title: str = None,
        favorite_flag: bool = None,
        field_detail: str = None,
        field_rank: int = None,
        field_source: str = None,
        field_type: str = None,
        id: int = None,
        input_field_type: str = None,
        input_required: str = None,
        inputs: str = None,
        name: str = None,
        outlier: str = None,
        output_threshold: DescribeEventVariableListResponseBodyResultObjectQueryVariablesOutputThreshold = None,
        parent_name: str = None,
        source_type: str = None,
        title: str = None,
        type: str = None,
        variable_velocity: DescribeEventVariableListResponseBodyResultObjectQueryVariablesVariableVelocity = None,
        x_label: str = None,
        y_label: str = None,
    ):
        self.code = code
        self.data_display = data_display
        self.define_id = define_id
        self.description = description
        self.display_type = display_type
        self.expression_title = expression_title
        self.favorite_flag = favorite_flag
        self.field_detail = field_detail
        self.field_rank = field_rank
        self.field_source = field_source
        self.field_type = field_type
        self.id = id
        self.input_field_type = input_field_type
        self.input_required = input_required
        self.inputs = inputs
        self.name = name
        self.outlier = outlier
        self.output_threshold = output_threshold
        self.parent_name = parent_name
        self.source_type = source_type
        self.title = title
        self.type = type
        self.variable_velocity = variable_velocity
        self.x_label = x_label
        self.y_label = y_label

    def validate(self):
        if self.output_threshold:
            self.output_threshold.validate()
        if self.variable_velocity:
            self.variable_velocity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data_display is not None:
            result['dataDisplay'] = self.data_display
        if self.define_id is not None:
            result['defineId'] = self.define_id
        if self.description is not None:
            result['description'] = self.description
        if self.display_type is not None:
            result['displayType'] = self.display_type
        if self.expression_title is not None:
            result['expressionTitle'] = self.expression_title
        if self.favorite_flag is not None:
            result['favoriteFlag'] = self.favorite_flag
        if self.field_detail is not None:
            result['fieldDetail'] = self.field_detail
        if self.field_rank is not None:
            result['fieldRank'] = self.field_rank
        if self.field_source is not None:
            result['fieldSource'] = self.field_source
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.id is not None:
            result['id'] = self.id
        if self.input_field_type is not None:
            result['inputFieldType'] = self.input_field_type
        if self.input_required is not None:
            result['inputRequired'] = self.input_required
        if self.inputs is not None:
            result['inputs'] = self.inputs
        if self.name is not None:
            result['name'] = self.name
        if self.outlier is not None:
            result['outlier'] = self.outlier
        if self.output_threshold is not None:
            result['outputThreshold'] = self.output_threshold.to_map()
        if self.parent_name is not None:
            result['parentName'] = self.parent_name
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        if self.variable_velocity is not None:
            result['variableVelocity'] = self.variable_velocity.to_map()
        if self.x_label is not None:
            result['xLabel'] = self.x_label
        if self.y_label is not None:
            result['yLabel'] = self.y_label
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('dataDisplay') is not None:
            self.data_display = m.get('dataDisplay')
        if m.get('defineId') is not None:
            self.define_id = m.get('defineId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayType') is not None:
            self.display_type = m.get('displayType')
        if m.get('expressionTitle') is not None:
            self.expression_title = m.get('expressionTitle')
        if m.get('favoriteFlag') is not None:
            self.favorite_flag = m.get('favoriteFlag')
        if m.get('fieldDetail') is not None:
            self.field_detail = m.get('fieldDetail')
        if m.get('fieldRank') is not None:
            self.field_rank = m.get('fieldRank')
        if m.get('fieldSource') is not None:
            self.field_source = m.get('fieldSource')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('inputFieldType') is not None:
            self.input_field_type = m.get('inputFieldType')
        if m.get('inputRequired') is not None:
            self.input_required = m.get('inputRequired')
        if m.get('inputs') is not None:
            self.inputs = m.get('inputs')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('outlier') is not None:
            self.outlier = m.get('outlier')
        if m.get('outputThreshold') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectQueryVariablesOutputThreshold()
            self.output_threshold = temp_model.from_map(m['outputThreshold'])
        if m.get('parentName') is not None:
            self.parent_name = m.get('parentName')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('variableVelocity') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectQueryVariablesVariableVelocity()
            self.variable_velocity = temp_model.from_map(m['variableVelocity'])
        if m.get('xLabel') is not None:
            self.x_label = m.get('xLabel')
        if m.get('yLabel') is not None:
            self.y_label = m.get('yLabel')
        return self


class DescribeEventVariableListResponseBodyResultObjectSelfVariablesOutputThreshold(TeaModel):
    def __init__(
        self,
        max_value: float = None,
        min_value: float = None,
    ):
        self.max_value = max_value
        self.min_value = min_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_value is not None:
            result['maxValue'] = self.max_value
        if self.min_value is not None:
            result['minValue'] = self.min_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxValue') is not None:
            self.max_value = m.get('maxValue')
        if m.get('minValue') is not None:
            self.min_value = m.get('minValue')
        return self


class DescribeEventVariableListResponseBodyResultObjectSelfVariablesVariableVelocity(TeaModel):
    def __init__(
        self,
        iv: str = None,
    ):
        self.iv = iv

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iv is not None:
            result['iv'] = self.iv
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('iv') is not None:
            self.iv = m.get('iv')
        return self


class DescribeEventVariableListResponseBodyResultObjectSelfVariables(TeaModel):
    def __init__(
        self,
        code: str = None,
        data_display: str = None,
        define_id: str = None,
        description: str = None,
        display_type: str = None,
        expression_title: str = None,
        favorite_flag: bool = None,
        field_detail: str = None,
        field_rank: int = None,
        field_source: str = None,
        field_type: str = None,
        id: int = None,
        input_field_type: str = None,
        input_required: str = None,
        inputs: str = None,
        name: str = None,
        outlier: str = None,
        output_threshold: DescribeEventVariableListResponseBodyResultObjectSelfVariablesOutputThreshold = None,
        parent_name: str = None,
        source_type: str = None,
        title: str = None,
        type: str = None,
        variable_velocity: DescribeEventVariableListResponseBodyResultObjectSelfVariablesVariableVelocity = None,
        x_label: str = None,
        y_label: str = None,
    ):
        self.code = code
        self.data_display = data_display
        self.define_id = define_id
        self.description = description
        self.display_type = display_type
        self.expression_title = expression_title
        self.favorite_flag = favorite_flag
        self.field_detail = field_detail
        self.field_rank = field_rank
        self.field_source = field_source
        self.field_type = field_type
        self.id = id
        self.input_field_type = input_field_type
        self.input_required = input_required
        self.inputs = inputs
        self.name = name
        self.outlier = outlier
        self.output_threshold = output_threshold
        self.parent_name = parent_name
        self.source_type = source_type
        self.title = title
        self.type = type
        self.variable_velocity = variable_velocity
        self.x_label = x_label
        self.y_label = y_label

    def validate(self):
        if self.output_threshold:
            self.output_threshold.validate()
        if self.variable_velocity:
            self.variable_velocity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data_display is not None:
            result['dataDisplay'] = self.data_display
        if self.define_id is not None:
            result['defineId'] = self.define_id
        if self.description is not None:
            result['description'] = self.description
        if self.display_type is not None:
            result['displayType'] = self.display_type
        if self.expression_title is not None:
            result['expressionTitle'] = self.expression_title
        if self.favorite_flag is not None:
            result['favoriteFlag'] = self.favorite_flag
        if self.field_detail is not None:
            result['fieldDetail'] = self.field_detail
        if self.field_rank is not None:
            result['fieldRank'] = self.field_rank
        if self.field_source is not None:
            result['fieldSource'] = self.field_source
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.id is not None:
            result['id'] = self.id
        if self.input_field_type is not None:
            result['inputFieldType'] = self.input_field_type
        if self.input_required is not None:
            result['inputRequired'] = self.input_required
        if self.inputs is not None:
            result['inputs'] = self.inputs
        if self.name is not None:
            result['name'] = self.name
        if self.outlier is not None:
            result['outlier'] = self.outlier
        if self.output_threshold is not None:
            result['outputThreshold'] = self.output_threshold.to_map()
        if self.parent_name is not None:
            result['parentName'] = self.parent_name
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        if self.variable_velocity is not None:
            result['variableVelocity'] = self.variable_velocity.to_map()
        if self.x_label is not None:
            result['xLabel'] = self.x_label
        if self.y_label is not None:
            result['yLabel'] = self.y_label
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('dataDisplay') is not None:
            self.data_display = m.get('dataDisplay')
        if m.get('defineId') is not None:
            self.define_id = m.get('defineId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayType') is not None:
            self.display_type = m.get('displayType')
        if m.get('expressionTitle') is not None:
            self.expression_title = m.get('expressionTitle')
        if m.get('favoriteFlag') is not None:
            self.favorite_flag = m.get('favoriteFlag')
        if m.get('fieldDetail') is not None:
            self.field_detail = m.get('fieldDetail')
        if m.get('fieldRank') is not None:
            self.field_rank = m.get('fieldRank')
        if m.get('fieldSource') is not None:
            self.field_source = m.get('fieldSource')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('inputFieldType') is not None:
            self.input_field_type = m.get('inputFieldType')
        if m.get('inputRequired') is not None:
            self.input_required = m.get('inputRequired')
        if m.get('inputs') is not None:
            self.inputs = m.get('inputs')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('outlier') is not None:
            self.outlier = m.get('outlier')
        if m.get('outputThreshold') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectSelfVariablesOutputThreshold()
            self.output_threshold = temp_model.from_map(m['outputThreshold'])
        if m.get('parentName') is not None:
            self.parent_name = m.get('parentName')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('variableVelocity') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectSelfVariablesVariableVelocity()
            self.variable_velocity = temp_model.from_map(m['variableVelocity'])
        if m.get('xLabel') is not None:
            self.x_label = m.get('xLabel')
        if m.get('yLabel') is not None:
            self.y_label = m.get('yLabel')
        return self


class DescribeEventVariableListResponseBodyResultObjectSysVariablesOutputThreshold(TeaModel):
    def __init__(
        self,
        max_value: float = None,
        min_value: float = None,
    ):
        self.max_value = max_value
        self.min_value = min_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_value is not None:
            result['maxValue'] = self.max_value
        if self.min_value is not None:
            result['minValue'] = self.min_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxValue') is not None:
            self.max_value = m.get('maxValue')
        if m.get('minValue') is not None:
            self.min_value = m.get('minValue')
        return self


class DescribeEventVariableListResponseBodyResultObjectSysVariablesVariableVelocity(TeaModel):
    def __init__(
        self,
        iv: str = None,
    ):
        self.iv = iv

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iv is not None:
            result['iv'] = self.iv
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('iv') is not None:
            self.iv = m.get('iv')
        return self


class DescribeEventVariableListResponseBodyResultObjectSysVariables(TeaModel):
    def __init__(
        self,
        code: str = None,
        data_display: str = None,
        define_id: str = None,
        description: str = None,
        display_type: str = None,
        expression_title: str = None,
        favorite_flag: bool = None,
        field_detail: str = None,
        field_rank: int = None,
        field_source: str = None,
        field_type: str = None,
        id: int = None,
        input_field_type: str = None,
        input_required: str = None,
        inputs: str = None,
        name: str = None,
        outlier: str = None,
        output_threshold: DescribeEventVariableListResponseBodyResultObjectSysVariablesOutputThreshold = None,
        parent_name: str = None,
        source_type: str = None,
        title: str = None,
        type: str = None,
        variable_velocity: DescribeEventVariableListResponseBodyResultObjectSysVariablesVariableVelocity = None,
        x_label: str = None,
        y_label: str = None,
    ):
        self.code = code
        self.data_display = data_display
        self.define_id = define_id
        self.description = description
        self.display_type = display_type
        self.expression_title = expression_title
        self.favorite_flag = favorite_flag
        self.field_detail = field_detail
        self.field_rank = field_rank
        self.field_source = field_source
        self.field_type = field_type
        self.id = id
        self.input_field_type = input_field_type
        self.input_required = input_required
        self.inputs = inputs
        self.name = name
        self.outlier = outlier
        self.output_threshold = output_threshold
        self.parent_name = parent_name
        self.source_type = source_type
        self.title = title
        self.type = type
        self.variable_velocity = variable_velocity
        self.x_label = x_label
        self.y_label = y_label

    def validate(self):
        if self.output_threshold:
            self.output_threshold.validate()
        if self.variable_velocity:
            self.variable_velocity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data_display is not None:
            result['dataDisplay'] = self.data_display
        if self.define_id is not None:
            result['defineId'] = self.define_id
        if self.description is not None:
            result['description'] = self.description
        if self.display_type is not None:
            result['displayType'] = self.display_type
        if self.expression_title is not None:
            result['expressionTitle'] = self.expression_title
        if self.favorite_flag is not None:
            result['favoriteFlag'] = self.favorite_flag
        if self.field_detail is not None:
            result['fieldDetail'] = self.field_detail
        if self.field_rank is not None:
            result['fieldRank'] = self.field_rank
        if self.field_source is not None:
            result['fieldSource'] = self.field_source
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.id is not None:
            result['id'] = self.id
        if self.input_field_type is not None:
            result['inputFieldType'] = self.input_field_type
        if self.input_required is not None:
            result['inputRequired'] = self.input_required
        if self.inputs is not None:
            result['inputs'] = self.inputs
        if self.name is not None:
            result['name'] = self.name
        if self.outlier is not None:
            result['outlier'] = self.outlier
        if self.output_threshold is not None:
            result['outputThreshold'] = self.output_threshold.to_map()
        if self.parent_name is not None:
            result['parentName'] = self.parent_name
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        if self.variable_velocity is not None:
            result['variableVelocity'] = self.variable_velocity.to_map()
        if self.x_label is not None:
            result['xLabel'] = self.x_label
        if self.y_label is not None:
            result['yLabel'] = self.y_label
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('dataDisplay') is not None:
            self.data_display = m.get('dataDisplay')
        if m.get('defineId') is not None:
            self.define_id = m.get('defineId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayType') is not None:
            self.display_type = m.get('displayType')
        if m.get('expressionTitle') is not None:
            self.expression_title = m.get('expressionTitle')
        if m.get('favoriteFlag') is not None:
            self.favorite_flag = m.get('favoriteFlag')
        if m.get('fieldDetail') is not None:
            self.field_detail = m.get('fieldDetail')
        if m.get('fieldRank') is not None:
            self.field_rank = m.get('fieldRank')
        if m.get('fieldSource') is not None:
            self.field_source = m.get('fieldSource')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('inputFieldType') is not None:
            self.input_field_type = m.get('inputFieldType')
        if m.get('inputRequired') is not None:
            self.input_required = m.get('inputRequired')
        if m.get('inputs') is not None:
            self.inputs = m.get('inputs')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('outlier') is not None:
            self.outlier = m.get('outlier')
        if m.get('outputThreshold') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectSysVariablesOutputThreshold()
            self.output_threshold = temp_model.from_map(m['outputThreshold'])
        if m.get('parentName') is not None:
            self.parent_name = m.get('parentName')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('variableVelocity') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectSysVariablesVariableVelocity()
            self.variable_velocity = temp_model.from_map(m['variableVelocity'])
        if m.get('xLabel') is not None:
            self.x_label = m.get('xLabel')
        if m.get('yLabel') is not None:
            self.y_label = m.get('yLabel')
        return self


class DescribeEventVariableListResponseBodyResultObjectVelocityVariablesOutputThreshold(TeaModel):
    def __init__(
        self,
        max_value: float = None,
        min_value: float = None,
    ):
        self.max_value = max_value
        self.min_value = min_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_value is not None:
            result['maxValue'] = self.max_value
        if self.min_value is not None:
            result['minValue'] = self.min_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxValue') is not None:
            self.max_value = m.get('maxValue')
        if m.get('minValue') is not None:
            self.min_value = m.get('minValue')
        return self


class DescribeEventVariableListResponseBodyResultObjectVelocityVariablesVariableVelocity(TeaModel):
    def __init__(
        self,
        iv: str = None,
    ):
        self.iv = iv

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iv is not None:
            result['iv'] = self.iv
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('iv') is not None:
            self.iv = m.get('iv')
        return self


class DescribeEventVariableListResponseBodyResultObjectVelocityVariables(TeaModel):
    def __init__(
        self,
        code: str = None,
        data_display: str = None,
        define_id: str = None,
        description: str = None,
        display_type: str = None,
        expression_title: str = None,
        favorite_flag: bool = None,
        field_detail: str = None,
        field_rank: int = None,
        field_source: str = None,
        field_type: str = None,
        id: int = None,
        input_field_type: str = None,
        input_required: str = None,
        inputs: str = None,
        name: str = None,
        outlier: str = None,
        output_threshold: DescribeEventVariableListResponseBodyResultObjectVelocityVariablesOutputThreshold = None,
        parent_name: str = None,
        source_type: str = None,
        title: str = None,
        type: str = None,
        variable_velocity: DescribeEventVariableListResponseBodyResultObjectVelocityVariablesVariableVelocity = None,
        x_label: str = None,
        y_label: str = None,
    ):
        self.code = code
        self.data_display = data_display
        self.define_id = define_id
        self.description = description
        self.display_type = display_type
        self.expression_title = expression_title
        self.favorite_flag = favorite_flag
        self.field_detail = field_detail
        self.field_rank = field_rank
        self.field_source = field_source
        self.field_type = field_type
        self.id = id
        self.input_field_type = input_field_type
        self.input_required = input_required
        self.inputs = inputs
        self.name = name
        self.outlier = outlier
        self.output_threshold = output_threshold
        self.parent_name = parent_name
        self.source_type = source_type
        self.title = title
        self.type = type
        self.variable_velocity = variable_velocity
        self.x_label = x_label
        self.y_label = y_label

    def validate(self):
        if self.output_threshold:
            self.output_threshold.validate()
        if self.variable_velocity:
            self.variable_velocity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data_display is not None:
            result['dataDisplay'] = self.data_display
        if self.define_id is not None:
            result['defineId'] = self.define_id
        if self.description is not None:
            result['description'] = self.description
        if self.display_type is not None:
            result['displayType'] = self.display_type
        if self.expression_title is not None:
            result['expressionTitle'] = self.expression_title
        if self.favorite_flag is not None:
            result['favoriteFlag'] = self.favorite_flag
        if self.field_detail is not None:
            result['fieldDetail'] = self.field_detail
        if self.field_rank is not None:
            result['fieldRank'] = self.field_rank
        if self.field_source is not None:
            result['fieldSource'] = self.field_source
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.id is not None:
            result['id'] = self.id
        if self.input_field_type is not None:
            result['inputFieldType'] = self.input_field_type
        if self.input_required is not None:
            result['inputRequired'] = self.input_required
        if self.inputs is not None:
            result['inputs'] = self.inputs
        if self.name is not None:
            result['name'] = self.name
        if self.outlier is not None:
            result['outlier'] = self.outlier
        if self.output_threshold is not None:
            result['outputThreshold'] = self.output_threshold.to_map()
        if self.parent_name is not None:
            result['parentName'] = self.parent_name
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        if self.variable_velocity is not None:
            result['variableVelocity'] = self.variable_velocity.to_map()
        if self.x_label is not None:
            result['xLabel'] = self.x_label
        if self.y_label is not None:
            result['yLabel'] = self.y_label
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('dataDisplay') is not None:
            self.data_display = m.get('dataDisplay')
        if m.get('defineId') is not None:
            self.define_id = m.get('defineId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayType') is not None:
            self.display_type = m.get('displayType')
        if m.get('expressionTitle') is not None:
            self.expression_title = m.get('expressionTitle')
        if m.get('favoriteFlag') is not None:
            self.favorite_flag = m.get('favoriteFlag')
        if m.get('fieldDetail') is not None:
            self.field_detail = m.get('fieldDetail')
        if m.get('fieldRank') is not None:
            self.field_rank = m.get('fieldRank')
        if m.get('fieldSource') is not None:
            self.field_source = m.get('fieldSource')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('inputFieldType') is not None:
            self.input_field_type = m.get('inputFieldType')
        if m.get('inputRequired') is not None:
            self.input_required = m.get('inputRequired')
        if m.get('inputs') is not None:
            self.inputs = m.get('inputs')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('outlier') is not None:
            self.outlier = m.get('outlier')
        if m.get('outputThreshold') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectVelocityVariablesOutputThreshold()
            self.output_threshold = temp_model.from_map(m['outputThreshold'])
        if m.get('parentName') is not None:
            self.parent_name = m.get('parentName')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('variableVelocity') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObjectVelocityVariablesVariableVelocity()
            self.variable_velocity = temp_model.from_map(m['variableVelocity'])
        if m.get('xLabel') is not None:
            self.x_label = m.get('xLabel')
        if m.get('yLabel') is not None:
            self.y_label = m.get('yLabel')
        return self


class DescribeEventVariableListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        actions: List[DescribeEventVariableListResponseBodyResultObjectActions] = None,
        device_variables: List[DescribeEventVariableListResponseBodyResultObjectDeviceVariables] = None,
        expression_variables: List[DescribeEventVariableListResponseBodyResultObjectExpressionVariables] = None,
        favorite_variables: List[DescribeEventVariableListResponseBodyResultObjectFavoriteVariables] = None,
        middle_variables: List[DescribeEventVariableListResponseBodyResultObjectMiddleVariables] = None,
        model_variables: List[DescribeEventVariableListResponseBodyResultObjectModelVariables] = None,
        name_list: List[DescribeEventVariableListResponseBodyResultObjectNameList] = None,
        native_variable_functions: List[DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctions] = None,
        native_variables: List[DescribeEventVariableListResponseBodyResultObjectNativeVariables] = None,
        query_variables: List[DescribeEventVariableListResponseBodyResultObjectQueryVariables] = None,
        self_variables: List[DescribeEventVariableListResponseBodyResultObjectSelfVariables] = None,
        sys_variables: List[DescribeEventVariableListResponseBodyResultObjectSysVariables] = None,
        third_variables: Dict[str, Any] = None,
        velocity_variables: List[DescribeEventVariableListResponseBodyResultObjectVelocityVariables] = None,
    ):
        self.actions = actions
        self.device_variables = device_variables
        self.expression_variables = expression_variables
        self.favorite_variables = favorite_variables
        self.middle_variables = middle_variables
        self.model_variables = model_variables
        self.name_list = name_list
        self.native_variable_functions = native_variable_functions
        self.native_variables = native_variables
        self.query_variables = query_variables
        self.self_variables = self_variables
        self.sys_variables = sys_variables
        self.third_variables = third_variables
        self.velocity_variables = velocity_variables

    def validate(self):
        if self.actions:
            for k in self.actions:
                if k:
                    k.validate()
        if self.device_variables:
            for k in self.device_variables:
                if k:
                    k.validate()
        if self.expression_variables:
            for k in self.expression_variables:
                if k:
                    k.validate()
        if self.favorite_variables:
            for k in self.favorite_variables:
                if k:
                    k.validate()
        if self.middle_variables:
            for k in self.middle_variables:
                if k:
                    k.validate()
        if self.model_variables:
            for k in self.model_variables:
                if k:
                    k.validate()
        if self.name_list:
            for k in self.name_list:
                if k:
                    k.validate()
        if self.native_variable_functions:
            for k in self.native_variable_functions:
                if k:
                    k.validate()
        if self.native_variables:
            for k in self.native_variables:
                if k:
                    k.validate()
        if self.query_variables:
            for k in self.query_variables:
                if k:
                    k.validate()
        if self.self_variables:
            for k in self.self_variables:
                if k:
                    k.validate()
        if self.sys_variables:
            for k in self.sys_variables:
                if k:
                    k.validate()
        if self.velocity_variables:
            for k in self.velocity_variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['actions'] = []
        if self.actions is not None:
            for k in self.actions:
                result['actions'].append(k.to_map() if k else None)
        result['deviceVariables'] = []
        if self.device_variables is not None:
            for k in self.device_variables:
                result['deviceVariables'].append(k.to_map() if k else None)
        result['expressionVariables'] = []
        if self.expression_variables is not None:
            for k in self.expression_variables:
                result['expressionVariables'].append(k.to_map() if k else None)
        result['favoriteVariables'] = []
        if self.favorite_variables is not None:
            for k in self.favorite_variables:
                result['favoriteVariables'].append(k.to_map() if k else None)
        result['middleVariables'] = []
        if self.middle_variables is not None:
            for k in self.middle_variables:
                result['middleVariables'].append(k.to_map() if k else None)
        result['modelVariables'] = []
        if self.model_variables is not None:
            for k in self.model_variables:
                result['modelVariables'].append(k.to_map() if k else None)
        result['nameList'] = []
        if self.name_list is not None:
            for k in self.name_list:
                result['nameList'].append(k.to_map() if k else None)
        result['nativeVariableFunctions'] = []
        if self.native_variable_functions is not None:
            for k in self.native_variable_functions:
                result['nativeVariableFunctions'].append(k.to_map() if k else None)
        result['nativeVariables'] = []
        if self.native_variables is not None:
            for k in self.native_variables:
                result['nativeVariables'].append(k.to_map() if k else None)
        result['queryVariables'] = []
        if self.query_variables is not None:
            for k in self.query_variables:
                result['queryVariables'].append(k.to_map() if k else None)
        result['selfVariables'] = []
        if self.self_variables is not None:
            for k in self.self_variables:
                result['selfVariables'].append(k.to_map() if k else None)
        result['sysVariables'] = []
        if self.sys_variables is not None:
            for k in self.sys_variables:
                result['sysVariables'].append(k.to_map() if k else None)
        if self.third_variables is not None:
            result['thirdVariables'] = self.third_variables
        result['velocityVariables'] = []
        if self.velocity_variables is not None:
            for k in self.velocity_variables:
                result['velocityVariables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.actions = []
        if m.get('actions') is not None:
            for k in m.get('actions'):
                temp_model = DescribeEventVariableListResponseBodyResultObjectActions()
                self.actions.append(temp_model.from_map(k))
        self.device_variables = []
        if m.get('deviceVariables') is not None:
            for k in m.get('deviceVariables'):
                temp_model = DescribeEventVariableListResponseBodyResultObjectDeviceVariables()
                self.device_variables.append(temp_model.from_map(k))
        self.expression_variables = []
        if m.get('expressionVariables') is not None:
            for k in m.get('expressionVariables'):
                temp_model = DescribeEventVariableListResponseBodyResultObjectExpressionVariables()
                self.expression_variables.append(temp_model.from_map(k))
        self.favorite_variables = []
        if m.get('favoriteVariables') is not None:
            for k in m.get('favoriteVariables'):
                temp_model = DescribeEventVariableListResponseBodyResultObjectFavoriteVariables()
                self.favorite_variables.append(temp_model.from_map(k))
        self.middle_variables = []
        if m.get('middleVariables') is not None:
            for k in m.get('middleVariables'):
                temp_model = DescribeEventVariableListResponseBodyResultObjectMiddleVariables()
                self.middle_variables.append(temp_model.from_map(k))
        self.model_variables = []
        if m.get('modelVariables') is not None:
            for k in m.get('modelVariables'):
                temp_model = DescribeEventVariableListResponseBodyResultObjectModelVariables()
                self.model_variables.append(temp_model.from_map(k))
        self.name_list = []
        if m.get('nameList') is not None:
            for k in m.get('nameList'):
                temp_model = DescribeEventVariableListResponseBodyResultObjectNameList()
                self.name_list.append(temp_model.from_map(k))
        self.native_variable_functions = []
        if m.get('nativeVariableFunctions') is not None:
            for k in m.get('nativeVariableFunctions'):
                temp_model = DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctions()
                self.native_variable_functions.append(temp_model.from_map(k))
        self.native_variables = []
        if m.get('nativeVariables') is not None:
            for k in m.get('nativeVariables'):
                temp_model = DescribeEventVariableListResponseBodyResultObjectNativeVariables()
                self.native_variables.append(temp_model.from_map(k))
        self.query_variables = []
        if m.get('queryVariables') is not None:
            for k in m.get('queryVariables'):
                temp_model = DescribeEventVariableListResponseBodyResultObjectQueryVariables()
                self.query_variables.append(temp_model.from_map(k))
        self.self_variables = []
        if m.get('selfVariables') is not None:
            for k in m.get('selfVariables'):
                temp_model = DescribeEventVariableListResponseBodyResultObjectSelfVariables()
                self.self_variables.append(temp_model.from_map(k))
        self.sys_variables = []
        if m.get('sysVariables') is not None:
            for k in m.get('sysVariables'):
                temp_model = DescribeEventVariableListResponseBodyResultObjectSysVariables()
                self.sys_variables.append(temp_model.from_map(k))
        if m.get('thirdVariables') is not None:
            self.third_variables = m.get('thirdVariables')
        self.velocity_variables = []
        if m.get('velocityVariables') is not None:
            for k in m.get('velocityVariables'):
                temp_model = DescribeEventVariableListResponseBodyResultObjectVelocityVariables()
                self.velocity_variables.append(temp_model.from_map(k))
        return self


class DescribeEventVariableListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeEventVariableListResponseBodyResultObject = None,
    ):
        self.request_id = request_id
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeEventVariableListResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeEventVariableListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEventVariableListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventVariableListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventVariableTemplateBindRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        inputs: str = None,
        reg_id: str = None,
        template_code: str = None,
        type: str = None,
    ):
        # Sets the language type for requests and received messages. Default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Input parameters, separated by commas if multiple.
        # 
        # This parameter is required.
        self.inputs = inputs
        # Region code
        self.reg_id = reg_id
        # Template code.
        self.template_code = template_code
        # Type
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.inputs is not None:
            result['inputs'] = self.inputs
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.template_code is not None:
            result['templateCode'] = self.template_code
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('inputs') is not None:
            self.inputs = m.get('inputs')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('templateCode') is not None:
            self.template_code = m.get('templateCode')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeEventVariableTemplateBindResponseBodyResultObjectChargeVariables(TeaModel):
    def __init__(
        self,
        code: str = None,
        description: str = None,
        field_type: str = None,
        id: int = None,
        name: str = None,
        title: str = None,
        type: str = None,
    ):
        # Variable code
        self.code = code
        # Description of the variable.
        self.description = description
        # Field type.
        self.field_type = field_type
        # Primary key ID
        self.id = id
        # Variable name
        self.name = name
        # Title.
        self.title = title
        # Variable type.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.description is not None:
            result['description'] = self.description
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeEventVariableTemplateBindResponseBodyResultObjectFreeVariables(TeaModel):
    def __init__(
        self,
        code: str = None,
        description: str = None,
        field_type: str = None,
        id: int = None,
        name: str = None,
        title: str = None,
        type: str = None,
    ):
        # Variable code
        self.code = code
        # Variable description.
        self.description = description
        # Field type.
        self.field_type = field_type
        # Primary key ID
        self.id = id
        # Variable name
        self.name = name
        # Title.
        self.title = title
        # Variable type.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.description is not None:
            result['description'] = self.description
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeEventVariableTemplateBindResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        charge_variables: List[DescribeEventVariableTemplateBindResponseBodyResultObjectChargeVariables] = None,
        free_variables: List[DescribeEventVariableTemplateBindResponseBodyResultObjectFreeVariables] = None,
        template_code: str = None,
        total_count: str = None,
    ):
        # List of chargeable variables
        self.charge_variables = charge_variables
        # List of free variables
        self.free_variables = free_variables
        # Template code
        self.template_code = template_code
        # Total count
        self.total_count = total_count

    def validate(self):
        if self.charge_variables:
            for k in self.charge_variables:
                if k:
                    k.validate()
        if self.free_variables:
            for k in self.free_variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['chargeVariables'] = []
        if self.charge_variables is not None:
            for k in self.charge_variables:
                result['chargeVariables'].append(k.to_map() if k else None)
        result['freeVariables'] = []
        if self.free_variables is not None:
            for k in self.free_variables:
                result['freeVariables'].append(k.to_map() if k else None)
        if self.template_code is not None:
            result['templateCode'] = self.template_code
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.charge_variables = []
        if m.get('chargeVariables') is not None:
            for k in m.get('chargeVariables'):
                temp_model = DescribeEventVariableTemplateBindResponseBodyResultObjectChargeVariables()
                self.charge_variables.append(temp_model.from_map(k))
        self.free_variables = []
        if m.get('freeVariables') is not None:
            for k in m.get('freeVariables'):
                temp_model = DescribeEventVariableTemplateBindResponseBodyResultObjectFreeVariables()
                self.free_variables.append(temp_model.from_map(k))
        if m.get('templateCode') is not None:
            self.template_code = m.get('templateCode')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class DescribeEventVariableTemplateBindResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeEventVariableTemplateBindResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeEventVariableTemplateBindResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeEventVariableTemplateBindResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEventVariableTemplateBindResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventVariableTemplateBindResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventVariableTemplateListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        inputs: str = None,
        reg_id: str = None,
        template_code: str = None,
        type: str = None,
    ):
        # Sets the language type for the request and response messages. The default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Input parameters, separated by commas.
        self.inputs = inputs
        # Region code
        self.reg_id = reg_id
        # Template code.
        self.template_code = template_code
        # Template type.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.inputs is not None:
            result['inputs'] = self.inputs
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.template_code is not None:
            result['templateCode'] = self.template_code
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('inputs') is not None:
            self.inputs = m.get('inputs')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('templateCode') is not None:
            self.template_code = m.get('templateCode')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeEventVariableTemplateListResponseBodyResultObjectVariables(TeaModel):
    def __init__(
        self,
        code: str = None,
        description: str = None,
        field_type: str = None,
        id: int = None,
        name: str = None,
        title: str = None,
        type: str = None,
    ):
        # Variable code
        self.code = code
        # Description information.
        self.description = description
        # Variable input type
        self.field_type = field_type
        # Primary key ID
        self.id = id
        # Variable name
        self.name = name
        # Title.
        self.title = title
        # Variable type.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.description is not None:
            result['description'] = self.description
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeEventVariableTemplateListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        template_code: str = None,
        template_name: str = None,
        variables: List[DescribeEventVariableTemplateListResponseBodyResultObjectVariables] = None,
    ):
        # Template code.
        self.template_code = template_code
        # Template name.
        self.template_name = template_name
        # Variable list.
        self.variables = variables

    def validate(self):
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_code is not None:
            result['templateCode'] = self.template_code
        if self.template_name is not None:
            result['templateName'] = self.template_name
        result['variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('templateCode') is not None:
            self.template_code = m.get('templateCode')
        if m.get('templateName') is not None:
            self.template_name = m.get('templateName')
        self.variables = []
        if m.get('variables') is not None:
            for k in m.get('variables'):
                temp_model = DescribeEventVariableTemplateListResponseBodyResultObjectVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class DescribeEventVariableTemplateListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeEventVariableTemplateListResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeEventVariableTemplateListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeEventVariableTemplateListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEventVariableTemplateListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventVariableTemplateListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventsVariableListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        event_codes: str = None,
        filter_dto: str = None,
        reg_id: str = None,
        scene: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Creation type
        self.create_type = create_type
        # Event code.
        # 
        # This parameter is required.
        self.event_codes = event_codes
        # Filter object
        self.filter_dto = filter_dto
        # Region code
        self.reg_id = reg_id
        # Applicable scene code
        # 
        # This parameter is required.
        self.scene = scene

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.filter_dto is not None:
            result['filterDTO'] = self.filter_dto
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.scene is not None:
            result['scene'] = self.scene
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('filterDTO') is not None:
            self.filter_dto = m.get('filterDTO')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        return self


class DescribeEventsVariableListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeEventsVariableListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEventsVariableListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventsVariableListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExcuteNumRequest(TeaModel):
    def __init__(
        self,
        code: str = None,
        degree: str = None,
        end_date: str = None,
        lang: str = None,
        source_ip: str = None,
        start_date: str = None,
    ):
        # This parameter is required.
        self.code = code
        self.degree = degree
        self.end_date = end_date
        self.lang = lang
        self.source_ip = source_ip
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.degree is not None:
            result['Degree'] = self.degree
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.source_ip is not None:
            result['SourceIp'] = self.source_ip
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Degree') is not None:
            self.degree = m.get('Degree')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SourceIp') is not None:
            self.source_ip = m.get('SourceIp')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        return self


class DescribeExcuteNumResponseBody(TeaModel):
    def __init__(
        self,
        categories: List[str] = None,
        data: List[str] = None,
        request_id: str = None,
    ):
        self.categories = categories
        self.data = data
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.categories is not None:
            result['Categories'] = self.categories
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Categories') is not None:
            self.categories = m.get('Categories')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeExcuteNumResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeExcuteNumResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExcuteNumResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExistNameRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        name: str = None,
        reg_id: str = None,
    ):
        # Set the language type for request and response messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Variable name
        self.name = name
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['name'] = self.name
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeExistNameResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeExistNameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeExistNameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExistNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExistSceneRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        scene_name: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Scene name.
        self.scene_name = scene_name
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.scene_name is not None:
            result['SceneName'] = self.scene_name
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SceneName') is not None:
            self.scene_name = m.get('SceneName')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeExistSceneResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        data: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Data object
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class DescribeExistSceneResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeExistSceneResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExistSceneResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExpressionVariableDetailRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        id: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Primary key ID
        # 
        # This parameter is required.
        self.id = id
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeExpressionVariableDetailResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: Dict[str, Any] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeExpressionVariableDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeExpressionVariableDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExpressionVariableDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExpressionVariableFunctionListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeExpressionVariableFunctionListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        description: str = None,
        key: str = None,
        max_param_size: int = None,
        min_param_size: int = None,
        param_types: str = None,
        redirect: bool = None,
        return_types: str = None,
        value: str = None,
    ):
        # Description information.
        self.description = description
        # Function name
        self.key = key
        # Maximum number of parameters
        self.max_param_size = max_param_size
        # Minimum number of parameters
        self.min_param_size = min_param_size
        # Parameter types
        self.param_types = param_types
        # Whether it is directly invoked
        self.redirect = redirect
        # Method return types
        self.return_types = return_types
        # Function value
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.key is not None:
            result['key'] = self.key
        if self.max_param_size is not None:
            result['maxParamSize'] = self.max_param_size
        if self.min_param_size is not None:
            result['minParamSize'] = self.min_param_size
        if self.param_types is not None:
            result['paramTypes'] = self.param_types
        if self.redirect is not None:
            result['redirect'] = self.redirect
        if self.return_types is not None:
            result['returnTypes'] = self.return_types
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('maxParamSize') is not None:
            self.max_param_size = m.get('maxParamSize')
        if m.get('minParamSize') is not None:
            self.min_param_size = m.get('minParamSize')
        if m.get('paramTypes') is not None:
            self.param_types = m.get('paramTypes')
        if m.get('redirect') is not None:
            self.redirect = m.get('redirect')
        if m.get('returnTypes') is not None:
            self.return_types = m.get('returnTypes')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeExpressionVariableFunctionListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeExpressionVariableFunctionListResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeExpressionVariableFunctionListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeExpressionVariableFunctionListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeExpressionVariableFunctionListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExpressionVariableFunctionListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExpressionVariablePageRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        current_page: str = None,
        event_code: str = None,
        outputs: str = None,
        page_size: str = None,
        reg_id: str = None,
        status: str = None,
        value: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Current page number.
        # 
        # This parameter is required.
        self.current_page = current_page
        # Event code
        self.event_code = event_code
        # Variable return type
        self.outputs = outputs
        # Page size, with a default value of 10
        # 
        # This parameter is required.
        self.page_size = page_size
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Status.
        self.status = status
        # Variable name/description
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.outputs is not None:
            result['outputs'] = self.outputs
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.status is not None:
            result['status'] = self.status
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('outputs') is not None:
            self.outputs = m.get('outputs')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeExpressionVariablePageResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        description: str = None,
        event_name: str = None,
        gmt_modified: int = None,
        id: int = None,
        outputs: str = None,
        status: str = None,
        title: str = None,
        version: int = None,
    ):
        # Description information.
        self.description = description
        # Event name.
        self.event_name = event_name
        # Modification time.
        self.gmt_modified = gmt_modified
        # Primary key of custom variable
        self.id = id
        # Variable return type
        self.outputs = outputs
        # Status.
        self.status = status
        # Title.
        self.title = title
        # Version information.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.outputs is not None:
            result['outputs'] = self.outputs
        if self.status is not None:
            result['status'] = self.status
        if self.title is not None:
            result['title'] = self.title
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('outputs') is not None:
            self.outputs = m.get('outputs')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class DescribeExpressionVariablePageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeExpressionVariablePageResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, with a default value of 10
        self.page_size = page_size
        # Returned object
        self.result_object = result_object
        # Total number of items
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeExpressionVariablePageResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeExpressionVariablePageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeExpressionVariablePageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExpressionVariablePageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeFieldByIdRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        id: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Primary key ID
        self.id = id
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeFieldByIdResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeFieldByIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeFieldByIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeFieldByIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeFieldListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        condition: str = None,
        inputs: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Query input name or title
        self.condition = condition
        # Selected fields
        self.inputs = inputs
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.condition is not None:
            result['condition'] = self.condition
        if self.inputs is not None:
            result['inputs'] = self.inputs
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        if m.get('inputs') is not None:
            self.inputs = m.get('inputs')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeFieldListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        classify: str = None,
        description: str = None,
        enum_data: str = None,
        id: int = None,
        name: str = None,
        source: str = None,
        status: str = None,
        title: str = None,
        type: str = None,
    ):
        # Field classification
        self.classify = classify
        # Description information.
        self.description = description
        # Enum data
        self.enum_data = enum_data
        # Field ID.
        self.id = id
        # Field name
        self.name = name
        # Field source
        self.source = source
        # Status.
        self.status = status
        # Title.
        self.title = title
        # Field type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.classify is not None:
            result['classify'] = self.classify
        if self.description is not None:
            result['description'] = self.description
        if self.enum_data is not None:
            result['enumData'] = self.enum_data
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.source is not None:
            result['source'] = self.source
        if self.status is not None:
            result['status'] = self.status
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('classify') is not None:
            self.classify = m.get('classify')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enumData') is not None:
            self.enum_data = m.get('enumData')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeFieldListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeFieldListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10
        self.page_size = page_size
        # Returned object
        self.result_object = result_object
        # Total number of items
        self.total_item = total_item
        # Total number of pages
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeFieldListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeFieldListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeFieldListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeFieldListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeFieldPageRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        classify: str = None,
        condition: str = None,
        current_page: str = None,
        name: str = None,
        page_size: str = None,
        reg_id: str = None,
        source: str = None,
        status: str = None,
        title: str = None,
        type: str = None,
    ):
        # Set the language type for request and response messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Field classification
        self.classify = classify
        # Query input parameter name or title
        self.condition = condition
        # Current page number
        self.current_page = current_page
        # Field name
        self.name = name
        # Number of items per page, default value is 10
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id
        # Field source
        self.source = source
        # Status.
        self.status = status
        # Title.
        self.title = title
        # Field type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.classify is not None:
            result['classify'] = self.classify
        if self.condition is not None:
            result['condition'] = self.condition
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.name is not None:
            result['name'] = self.name
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.source is not None:
            result['source'] = self.source
        if self.status is not None:
            result['status'] = self.status
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('classify') is not None:
            self.classify = m.get('classify')
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeFieldPageResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        classify: str = None,
        description: str = None,
        enum_data: str = None,
        id: int = None,
        name: str = None,
        source: str = None,
        status: str = None,
        title: str = None,
        type: str = None,
    ):
        # Field classification
        self.classify = classify
        # Description information.
        self.description = description
        # Enum data
        self.enum_data = enum_data
        # Unique table ID.
        self.id = id
        # Field name
        self.name = name
        # File source.
        self.source = source
        # Status.
        self.status = status
        # Title.
        self.title = title
        # Field type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.classify is not None:
            result['classify'] = self.classify
        if self.description is not None:
            result['description'] = self.description
        if self.enum_data is not None:
            result['enumData'] = self.enum_data
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.source is not None:
            result['source'] = self.source
        if self.status is not None:
            result['status'] = self.status
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('classify') is not None:
            self.classify = m.get('classify')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enumData') is not None:
            self.enum_data = m.get('enumData')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeFieldPageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeFieldPageResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number
        self.current_page = current_page
        # Number of items per page, default value is 10
        self.page_size = page_size
        # Returned object
        self.result_object = result_object
        # Total number of items
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeFieldPageResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeFieldPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeFieldPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeFieldPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGroupAccountPageRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        community_no: str = None,
        current_page: str = None,
        direction: str = None,
        field_key: str = None,
        field_val: str = None,
        is_page: bool = None,
        order: str = None,
        page_size: str = None,
        reg_id: str = None,
        task_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Community number.
        self.community_no = community_no
        # Current page number.
        self.current_page = current_page
        # Order direction.
        self.direction = direction
        # fieldKey.
        self.field_key = field_key
        # fieldVal.
        self.field_val = field_val
        # Whether to paginate.
        self.is_page = is_page
        # Sorting condition.
        self.order = order
        # Page size, default value is 10.
        self.page_size = page_size
        # Region code.
        self.reg_id = reg_id
        # Task ID.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.community_no is not None:
            result['communityNo'] = self.community_no
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.direction is not None:
            result['direction'] = self.direction
        if self.field_key is not None:
            result['fieldKey'] = self.field_key
        if self.field_val is not None:
            result['fieldVal'] = self.field_val
        if self.is_page is not None:
            result['isPage'] = self.is_page
        if self.order is not None:
            result['order'] = self.order
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.task_id is not None:
            result['taskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('communityNo') is not None:
            self.community_no = m.get('communityNo')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('direction') is not None:
            self.direction = m.get('direction')
        if m.get('fieldKey') is not None:
            self.field_key = m.get('fieldKey')
        if m.get('fieldVal') is not None:
            self.field_val = m.get('fieldVal')
        if m.get('isPage') is not None:
            self.is_page = m.get('isPage')
        if m.get('order') is not None:
            self.order = m.get('order')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        return self


class DescribeGroupAccountPageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        data: bool = None,
        page_size: int = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Returned data object.
        self.data = data
        # Page size, default value is 10.
        self.page_size = page_size
        # Total number of items.
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.data is not None:
            result['data'] = self.data
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeGroupAccountPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGroupAccountPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGroupAccountPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGroupConditionListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and responses, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeGroupConditionListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        field_key: str = None,
        field_value: str = None,
    ):
        # Field key
        self.field_key = field_key
        # Field value.
        self.field_value = field_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_key is not None:
            result['fieldKey'] = self.field_key
        if self.field_value is not None:
            result['fieldValue'] = self.field_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldKey') is not None:
            self.field_key = m.get('fieldKey')
        if m.get('fieldValue') is not None:
            self.field_value = m.get('fieldValue')
        return self


class DescribeGroupConditionListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeGroupConditionListResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeGroupConditionListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeGroupConditionListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGroupConditionListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGroupConditionListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGroupPageRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        current_page: str = None,
        direction: str = None,
        order: str = None,
        page_size: str = None,
        reg_id: str = None,
        task_id: str = None,
        time_type: str = None,
    ):
        # Sets the language type for requests and responses, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Current page number.
        self.current_page = current_page
        # Order.
        self.direction = direction
        # Sorting condition.
        self.order = order
        # Page size, with a default value of 10.
        self.page_size = page_size
        # Region code.
        self.reg_id = reg_id
        # Task ID.
        self.task_id = task_id
        # Time type.
        self.time_type = time_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.direction is not None:
            result['direction'] = self.direction
        if self.order is not None:
            result['order'] = self.order
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.task_id is not None:
            result['taskId'] = self.task_id
        if self.time_type is not None:
            result['timeType'] = self.time_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('direction') is not None:
            self.direction = m.get('direction')
        if m.get('order') is not None:
            self.order = m.get('order')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        if m.get('timeType') is not None:
            self.time_type = m.get('timeType')
        return self


class DescribeGroupPageResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        community_no: str = None,
        create_time: int = None,
        group_risk: str = None,
        group_scale: str = None,
        id: int = None,
        scene_name: str = None,
        task_id: int = None,
        user_id: str = None,
    ):
        # Community number.
        self.community_no = community_no
        # Creation time.
        self.create_time = create_time
        # Group risk concentration.
        self.group_risk = group_risk
        # Group scale.
        self.group_scale = group_scale
        # Primary key ID.
        self.id = id
        # Scene name.
        self.scene_name = scene_name
        # Task ID.
        self.task_id = task_id
        # User UID.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.community_no is not None:
            result['communityNo'] = self.community_no
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.group_risk is not None:
            result['groupRisk'] = self.group_risk
        if self.group_scale is not None:
            result['groupScale'] = self.group_scale
        if self.id is not None:
            result['id'] = self.id
        if self.scene_name is not None:
            result['sceneName'] = self.scene_name
        if self.task_id is not None:
            result['taskId'] = self.task_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('communityNo') is not None:
            self.community_no = m.get('communityNo')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('groupRisk') is not None:
            self.group_risk = m.get('groupRisk')
        if m.get('groupScale') is not None:
            self.group_scale = m.get('groupScale')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('sceneName') is not None:
            self.scene_name = m.get('sceneName')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class DescribeGroupPageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeGroupPageResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, with a default value of 10.
        self.page_size = page_size
        # Returned object.
        self.result_object = result_object
        # Total number of items.
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeGroupPageResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeGroupPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGroupPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGroupPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGroupStatisticsByTodayRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and responses, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeGroupStatisticsByTodayResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        data: bool = None,
    ):
        # Request ID
        self.request_id = request_id
        # Returned data.
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class DescribeGroupStatisticsByTodayResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGroupStatisticsByTodayResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGroupStatisticsByTodayResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGroupTrendRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        day: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # day
        self.day = day
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.day is not None:
            result['day'] = self.day
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('day') is not None:
            self.day = m.get('day')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeGroupTrendResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        data: bool = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return result.
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class DescribeGroupTrendResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGroupTrendResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGroupTrendResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeHasRuleNameByEventCodeRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        event_code: str = None,
        exclude_rule_id: str = None,
        reg_id: str = None,
        rule_name: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Event code
        self.event_code = event_code
        # Excluded policy ID
        self.exclude_rule_id = exclude_rule_id
        # Region code
        self.reg_id = reg_id
        # Policy name
        self.rule_name = rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.exclude_rule_id is not None:
            result['excludeRuleId'] = self.exclude_rule_id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('excludeRuleId') is not None:
            self.exclude_rule_id = m.get('excludeRuleId')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        return self


class DescribeHasRuleNameByEventCodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeHasRuleNameByEventCodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeHasRuleNameByEventCodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeHasRuleNameByEventCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeHighRiskPieChartRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        begin_time: int = None,
        end_time: int = None,
        event_codes: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages. Default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Start time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.begin_time = begin_time
        # End time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.end_time = end_time
        # Event code.
        self.event_codes = event_codes
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.begin_time is not None:
            result['beginTime'] = self.begin_time
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('beginTime') is not None:
            self.begin_time = m.get('beginTime')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCityGrid(TeaModel):
    def __init__(
        self,
        show: bool = None,
    ):
        # Chart flag, default false
        self.show = show

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.show is not None:
            result['show'] = self.show
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('show') is not None:
            self.show = m.get('show')
        return self


class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeriesData(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # Field name
        self.name = name
        # Data value
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeries(TeaModel):
    def __init__(
        self,
        data: List[DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeriesData] = None,
        name: str = None,
        rose_type: str = None,
    ):
        # Returned data object
        self.data = data
        # Field name
        self.name = name
        # Chart identifier, default is false
        self.rose_type = rose_type

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.rose_type is not None:
            result['roseType'] = self.rose_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeriesData()
                self.data.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('roseType') is not None:
            self.rose_type = m.get('roseType')
        return self


class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCity(TeaModel):
    def __init__(
        self,
        animation: bool = None,
        grid: DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCityGrid = None,
        series: List[DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeries] = None,
    ):
        # Chart flag, default true
        self.animation = animation
        # Belonging grid.
        self.grid = grid
        # Chart data
        self.series = series

    def validate(self):
        if self.grid:
            self.grid.validate()
        if self.series:
            for k in self.series:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.animation is not None:
            result['animation'] = self.animation
        if self.grid is not None:
            result['grid'] = self.grid.to_map()
        result['series'] = []
        if self.series is not None:
            for k in self.series:
                result['series'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('animation') is not None:
            self.animation = m.get('animation')
        if m.get('grid') is not None:
            temp_model = DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCityGrid()
            self.grid = temp_model.from_map(m['grid'])
        self.series = []
        if m.get('series') is not None:
            for k in m.get('series'):
                temp_model = DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeries()
                self.series.append(temp_model.from_map(k))
        return self


class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceGrid(TeaModel):
    def __init__(
        self,
        show: bool = None,
    ):
        # Chart identifier, default is false
        self.show = show

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.show is not None:
            result['show'] = self.show
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('show') is not None:
            self.show = m.get('show')
        return self


class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeriesData(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # Variable name
        self.name = name
        # Data value
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeries(TeaModel):
    def __init__(
        self,
        data: List[DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeriesData] = None,
        name: str = None,
        rose_type: str = None,
    ):
        # Returned data object
        self.data = data
        # Field name
        self.name = name
        # Chart identifier, default is false
        self.rose_type = rose_type

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.rose_type is not None:
            result['roseType'] = self.rose_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeriesData()
                self.data.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('roseType') is not None:
            self.rose_type = m.get('roseType')
        return self


class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvince(TeaModel):
    def __init__(
        self,
        animation: bool = None,
        grid: DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceGrid = None,
        series: List[DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeries] = None,
    ):
        # Chart identifier, default is true
        self.animation = animation
        # Belonging grid.
        self.grid = grid
        # Chart data
        self.series = series

    def validate(self):
        if self.grid:
            self.grid.validate()
        if self.series:
            for k in self.series:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.animation is not None:
            result['animation'] = self.animation
        if self.grid is not None:
            result['grid'] = self.grid.to_map()
        result['series'] = []
        if self.series is not None:
            for k in self.series:
                result['series'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('animation') is not None:
            self.animation = m.get('animation')
        if m.get('grid') is not None:
            temp_model = DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceGrid()
            self.grid = temp_model.from_map(m['grid'])
        self.series = []
        if m.get('series') is not None:
            for k in m.get('series'):
                temp_model = DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeries()
                self.series.append(temp_model.from_map(k))
        return self


class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCityGrid(TeaModel):
    def __init__(
        self,
        show: bool = None,
    ):
        # Chart flag, default is false
        self.show = show

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.show is not None:
            result['show'] = self.show
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('show') is not None:
            self.show = m.get('show')
        return self


class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeriesData(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # Field name
        self.name = name
        # Data value
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeries(TeaModel):
    def __init__(
        self,
        data: List[DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeriesData] = None,
        name: str = None,
        rose_type: str = None,
    ):
        # Returned data object
        self.data = data
        # Field name
        self.name = name
        # Chart flag, default is false
        self.rose_type = rose_type

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.rose_type is not None:
            result['roseType'] = self.rose_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeriesData()
                self.data.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('roseType') is not None:
            self.rose_type = m.get('roseType')
        return self


class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCity(TeaModel):
    def __init__(
        self,
        animation: bool = None,
        grid: DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCityGrid = None,
        series: List[DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeries] = None,
    ):
        # Chart flag, default is true
        self.animation = animation
        # Belongs to grid.
        self.grid = grid
        # Chart data
        self.series = series

    def validate(self):
        if self.grid:
            self.grid.validate()
        if self.series:
            for k in self.series:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.animation is not None:
            result['animation'] = self.animation
        if self.grid is not None:
            result['grid'] = self.grid.to_map()
        result['series'] = []
        if self.series is not None:
            for k in self.series:
                result['series'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('animation') is not None:
            self.animation = m.get('animation')
        if m.get('grid') is not None:
            temp_model = DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCityGrid()
            self.grid = temp_model.from_map(m['grid'])
        self.series = []
        if m.get('series') is not None:
            for k in m.get('series'):
                temp_model = DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeries()
                self.series.append(temp_model.from_map(k))
        return self


class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceGrid(TeaModel):
    def __init__(
        self,
        show: bool = None,
    ):
        # Chart flag, default is false
        self.show = show

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.show is not None:
            result['show'] = self.show
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('show') is not None:
            self.show = m.get('show')
        return self


class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeriesData(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # Field name
        self.name = name
        # Data value
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeries(TeaModel):
    def __init__(
        self,
        data: List[DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeriesData] = None,
        name: str = None,
        rose_type: str = None,
    ):
        # High-risk position data.
        self.data = data
        # Display title
        self.name = name
        # Chart identifier, default false
        self.rose_type = rose_type

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.rose_type is not None:
            result['roseType'] = self.rose_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeriesData()
                self.data.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('roseType') is not None:
            self.rose_type = m.get('roseType')
        return self


class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvince(TeaModel):
    def __init__(
        self,
        animation: bool = None,
        grid: DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceGrid = None,
        series: List[DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeries] = None,
    ):
        # Indicator, default true
        self.animation = animation
        # Belongs to grid.
        self.grid = grid
        # Chart data
        self.series = series

    def validate(self):
        if self.grid:
            self.grid.validate()
        if self.series:
            for k in self.series:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.animation is not None:
            result['animation'] = self.animation
        if self.grid is not None:
            result['grid'] = self.grid.to_map()
        result['series'] = []
        if self.series is not None:
            for k in self.series:
                result['series'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('animation') is not None:
            self.animation = m.get('animation')
        if m.get('grid') is not None:
            temp_model = DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceGrid()
            self.grid = temp_model.from_map(m['grid'])
        self.series = []
        if m.get('series') is not None:
            for k in m.get('series'):
                temp_model = DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeries()
                self.series.append(temp_model.from_map(k))
        return self


class DescribeHighRiskPieChartResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        high_risk_ipcity: DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCity = None,
        high_risk_ipprovince: DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvince = None,
        high_risk_mobile_city: DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCity = None,
        high_risk_mobile_province: DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvince = None,
    ):
        # High-risk IP city
        self.high_risk_ipcity = high_risk_ipcity
        # High-risk IPprovince
        self.high_risk_ipprovince = high_risk_ipprovince
        # High-risk mobile phonecity
        self.high_risk_mobile_city = high_risk_mobile_city
        # High-risk mobile phone\\"s province of origin
        self.high_risk_mobile_province = high_risk_mobile_province

    def validate(self):
        if self.high_risk_ipcity:
            self.high_risk_ipcity.validate()
        if self.high_risk_ipprovince:
            self.high_risk_ipprovince.validate()
        if self.high_risk_mobile_city:
            self.high_risk_mobile_city.validate()
        if self.high_risk_mobile_province:
            self.high_risk_mobile_province.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.high_risk_ipcity is not None:
            result['highRiskIPCity'] = self.high_risk_ipcity.to_map()
        if self.high_risk_ipprovince is not None:
            result['highRiskIPProvince'] = self.high_risk_ipprovince.to_map()
        if self.high_risk_mobile_city is not None:
            result['highRiskMobileCity'] = self.high_risk_mobile_city.to_map()
        if self.high_risk_mobile_province is not None:
            result['highRiskMobileProvince'] = self.high_risk_mobile_province.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('highRiskIPCity') is not None:
            temp_model = DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCity()
            self.high_risk_ipcity = temp_model.from_map(m['highRiskIPCity'])
        if m.get('highRiskIPProvince') is not None:
            temp_model = DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvince()
            self.high_risk_ipprovince = temp_model.from_map(m['highRiskIPProvince'])
        if m.get('highRiskMobileCity') is not None:
            temp_model = DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCity()
            self.high_risk_mobile_city = temp_model.from_map(m['highRiskMobileCity'])
        if m.get('highRiskMobileProvince') is not None:
            temp_model = DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvince()
            self.high_risk_mobile_province = temp_model.from_map(m['highRiskMobileProvince'])
        return self


class DescribeHighRiskPieChartResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: DescribeHighRiskPieChartResponseBodyResultObject = None,
        success: bool = None,
    ):
        # Status code
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error details
        self.message = message
        # Request ID
        self.request_id = request_id
        # Returned object
        self.result_object = result_object
        # Whether the request was successful.
        self.success = success

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeHighRiskPieChartResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeHighRiskPieChartResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeHighRiskPieChartResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeHighRiskPieChartResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeHitRuleFluctuationRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        event_codes: str = None,
        reg_id: str = None,
        rule_status: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Event codes, separated by commas (,).
        self.event_codes = event_codes
        # Region code
        self.reg_id = reg_id
        # Policy status
        self.rule_status = rule_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.rule_status is not None:
            result['ruleStatus'] = self.rule_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('ruleStatus') is not None:
            self.rule_status = m.get('ruleStatus')
        return self


class DescribeHitRuleFluctuationResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        rule_id: str = None,
        rule_name: str = None,
        today_num: int = None,
        within_seven_day_num: str = None,
        within_thirty_day_num: str = None,
        within_three_day_num: str = None,
        yesterday_num: int = None,
    ):
        # Policy ID
        self.rule_id = rule_id
        # Policy name
        self.rule_name = rule_name
        # Today\\"s count
        self.today_num = today_num
        # Count within seven days
        self.within_seven_day_num = within_seven_day_num
        # Count within thirty days
        self.within_thirty_day_num = within_thirty_day_num
        # Count within three days
        self.within_three_day_num = within_three_day_num
        # Yesterday\\"s count
        self.yesterday_num = yesterday_num

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        if self.today_num is not None:
            result['todayNum'] = self.today_num
        if self.within_seven_day_num is not None:
            result['withinSevenDayNum'] = self.within_seven_day_num
        if self.within_thirty_day_num is not None:
            result['withinThirtyDayNum'] = self.within_thirty_day_num
        if self.within_three_day_num is not None:
            result['withinThreeDayNum'] = self.within_three_day_num
        if self.yesterday_num is not None:
            result['yesterdayNum'] = self.yesterday_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        if m.get('todayNum') is not None:
            self.today_num = m.get('todayNum')
        if m.get('withinSevenDayNum') is not None:
            self.within_seven_day_num = m.get('withinSevenDayNum')
        if m.get('withinThirtyDayNum') is not None:
            self.within_thirty_day_num = m.get('withinThirtyDayNum')
        if m.get('withinThreeDayNum') is not None:
            self.within_three_day_num = m.get('withinThreeDayNum')
        if m.get('yesterdayNum') is not None:
            self.yesterday_num = m.get('yesterdayNum')
        return self


class DescribeHitRuleFluctuationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: List[DescribeHitRuleFluctuationResponseBodyResultObject] = None,
        success: bool = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object
        # Whether the request was successful.
        self.success = success

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeHitRuleFluctuationResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeHitRuleFluctuationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeHitRuleFluctuationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeHitRuleFluctuationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeHitRuleListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        begin_time: int = None,
        end_time: int = None,
        event_codes: str = None,
        event_type: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Start time, accurate to milliseconds (ms).
        self.begin_time = begin_time
        # End time, accurate to milliseconds (ms).
        self.end_time = end_time
        # Event codes, separated by commas if multiple.
        self.event_codes = event_codes
        # Event type
        self.event_type = event_type
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.begin_time is not None:
            result['beginTime'] = self.begin_time
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.event_type is not None:
            result['eventType'] = self.event_type
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('beginTime') is not None:
            self.begin_time = m.get('beginTime')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('eventType') is not None:
            self.event_type = m.get('eventType')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeHitRuleListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        hit_count: int = None,
        rule_name: str = None,
    ):
        # Number of hits.
        self.hit_count = hit_count
        # Strategy name
        self.rule_name = rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hit_count is not None:
            result['hitCount'] = self.hit_count
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('hitCount') is not None:
            self.hit_count = m.get('hitCount')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        return self


class DescribeHitRuleListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeHitRuleListResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Response object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeHitRuleListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeHitRuleListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeHitRuleListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeHitRuleListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeHitRuleTrendRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        begin_time: int = None,
        end_time: int = None,
        event_codes: str = None,
        reg_id: str = None,
        rule_status: str = None,
    ):
        # Sets the language type for the request and response messages. Default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Start time, accurate to milliseconds (ms).
        self.begin_time = begin_time
        # End time, accurate to milliseconds (ms).
        self.end_time = end_time
        # Event codes, separated by commas (,).
        self.event_codes = event_codes
        # Region code
        self.reg_id = reg_id
        # Rule status
        self.rule_status = rule_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.begin_time is not None:
            result['beginTime'] = self.begin_time
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.rule_status is not None:
            result['ruleStatus'] = self.rule_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('beginTime') is not None:
            self.begin_time = m.get('beginTime')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('ruleStatus') is not None:
            self.rule_status = m.get('ruleStatus')
        return self


class DescribeHitRuleTrendResponseBodyResultObjectSeriesData(TeaModel):
    def __init__(
        self,
        num: int = None,
        scale: str = None,
    ):
        # Number
        self.num = num
        # Scale
        self.scale = scale

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.num is not None:
            result['num'] = self.num
        if self.scale is not None:
            result['scale'] = self.scale
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('num') is not None:
            self.num = m.get('num')
        if m.get('scale') is not None:
            self.scale = m.get('scale')
        return self


class DescribeHitRuleTrendResponseBodyResultObjectSeries(TeaModel):
    def __init__(
        self,
        data: List[DescribeHitRuleTrendResponseBodyResultObjectSeriesData] = None,
        name: str = None,
    ):
        # Returned data object
        self.data = data
        # Display title
        self.name = name

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = DescribeHitRuleTrendResponseBodyResultObjectSeriesData()
                self.data.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DescribeHitRuleTrendResponseBodyResultObjectXaxis(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
    ):
        # Returned data object
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class DescribeHitRuleTrendResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        series: List[DescribeHitRuleTrendResponseBodyResultObjectSeries] = None,
        xaxis: DescribeHitRuleTrendResponseBodyResultObjectXaxis = None,
    ):
        # Chart data
        self.series = series
        # X-axis data
        self.xaxis = xaxis

    def validate(self):
        if self.series:
            for k in self.series:
                if k:
                    k.validate()
        if self.xaxis:
            self.xaxis.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['series'] = []
        if self.series is not None:
            for k in self.series:
                result['series'].append(k.to_map() if k else None)
        if self.xaxis is not None:
            result['xaxis'] = self.xaxis.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.series = []
        if m.get('series') is not None:
            for k in m.get('series'):
                temp_model = DescribeHitRuleTrendResponseBodyResultObjectSeries()
                self.series.append(temp_model.from_map(k))
        if m.get('xaxis') is not None:
            temp_model = DescribeHitRuleTrendResponseBodyResultObjectXaxis()
            self.xaxis = temp_model.from_map(m['xaxis'])
        return self


class DescribeHitRuleTrendResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: DescribeHitRuleTrendResponseBodyResultObject = None,
        success: bool = None,
    ):
        # Status code
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error details
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Response object
        self.result_object = result_object
        # Indicates whether the operation was successful, where true means success.
        self.success = success

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeHitRuleTrendResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeHitRuleTrendResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeHitRuleTrendResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeHitRuleTrendResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInitDigRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        type: str = None,
    ):
        # Set the language type for request and response messages. Default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id
        # Data source type
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeInitDigResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        tip_info: str = None,
    ):
        # Prompt information
        self.tip_info = tip_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tip_info is not None:
            result['TipInfo'] = self.tip_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TipInfo') is not None:
            self.tip_info = m.get('TipInfo')
        return self


class DescribeInitDigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeInitDigResponseBodyResultObject = None,
    ):
        # ID of the request
        self.request_id = request_id
        # Returned result information
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            temp_model = DescribeInitDigResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['ResultObject'])
        return self


class DescribeInitDigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInitDigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInitDigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInputFeildCountByEventCodeRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        event_code: str = None,
        reg_id: str = None,
    ):
        # Set the language type for request and response, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Creation type
        self.create_type = create_type
        # Event code
        self.event_code = event_code
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeInputFeildCountByEventCodeResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        limit: bool = None,
        max_total_item: int = None,
        total_item: int = None,
    ):
        # Whether it exceeds the maximum quantity
        self.limit = limit
        # Maximum number of created items
        self.max_total_item = max_total_item
        # Total number of items
        self.total_item = total_item

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.limit is not None:
            result['limit'] = self.limit
        if self.max_total_item is not None:
            result['maxTotalItem'] = self.max_total_item
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('maxTotalItem') is not None:
            self.max_total_item = m.get('maxTotalItem')
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        return self


class DescribeInputFeildCountByEventCodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeInputFeildCountByEventCodeResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeInputFeildCountByEventCodeResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeInputFeildCountByEventCodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInputFeildCountByEventCodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInputFeildCountByEventCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeListModelRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        reg_id: str = None,
    ):
        # Current page number.
        self.current_page = current_page
        # Number of items per page.
        self.page_size = page_size
        # Region code.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        return self


class DescribeListModelResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        buc_id: str = None,
        create_time: str = None,
        model_code: str = None,
        model_id: str = None,
        model_name: str = None,
        model_scene: str = None,
        model_status: str = None,
        task_id: str = None,
        update_time: str = None,
        user_id: str = None,
        user_local_file_name: str = None,
    ):
        # Uploader ID.
        self.buc_id = buc_id
        # Creation time.
        self.create_time = create_time
        # Model code.
        self.model_code = model_code
        # Unique identifier of the model in use.
        self.model_id = model_id
        # Model name.
        self.model_name = model_name
        # Model scenario.
        self.model_scene = model_scene
        # Model status, values: -**ENABLED**: Enabled-**DISABLED**: Disabled
        self.model_status = model_status
        # Task ID.
        self.task_id = task_id
        # Last update time of the model.
        self.update_time = update_time
        # User ID.
        self.user_id = user_id
        # File name.
        self.user_local_file_name = user_local_file_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.buc_id is not None:
            result['bucId'] = self.buc_id
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.model_code is not None:
            result['modelCode'] = self.model_code
        if self.model_id is not None:
            result['modelId'] = self.model_id
        if self.model_name is not None:
            result['modelName'] = self.model_name
        if self.model_scene is not None:
            result['modelScene'] = self.model_scene
        if self.model_status is not None:
            result['modelStatus'] = self.model_status
        if self.task_id is not None:
            result['taskId'] = self.task_id
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.user_local_file_name is not None:
            result['userLocalFileName'] = self.user_local_file_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bucId') is not None:
            self.buc_id = m.get('bucId')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('modelCode') is not None:
            self.model_code = m.get('modelCode')
        if m.get('modelId') is not None:
            self.model_id = m.get('modelId')
        if m.get('modelName') is not None:
            self.model_name = m.get('modelName')
        if m.get('modelScene') is not None:
            self.model_scene = m.get('modelScene')
        if m.get('modelStatus') is not None:
            self.model_status = m.get('modelStatus')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('userLocalFileName') is not None:
            self.user_local_file_name = m.get('userLocalFileName')
        return self


class DescribeListModelResponseBody(TeaModel):
    def __init__(
        self,
        current_page: str = None,
        page_size: str = None,
        request_id: str = None,
        result_object: List[DescribeListModelResponseBodyResultObject] = None,
        total_item: str = None,
        total_page: str = None,
    ):
        # Current page number.
        self.current_page = current_page
        # Number of items per page.
        self.page_size = page_size
        # Request ID.
        self.request_id = request_id
        # Returned data.
        self.result_object = result_object
        # Total number of records.
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['ResultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['ResultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['TotalItem'] = self.total_item
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('ResultObject') is not None:
            for k in m.get('ResultObject'):
                temp_model = DescribeListModelResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('TotalItem') is not None:
            self.total_item = m.get('TotalItem')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeListModelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeListModelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeListModelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeListPocRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        lang: str = None,
        page_size: int = None,
        reg_id: str = None,
        type: str = None,
    ):
        # Current page number.
        self.current_page = current_page
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Page size.
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id
        # Type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeListPocResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        current_page: str = None,
        http_status_code: str = None,
        message: str = None,
        page_size: str = None,
        request_id: str = None,
        result_object: bool = None,
        total_item: str = None,
        total_page: str = None,
    ):
        # Status code.
        self.code = code
        # Current page.
        self.current_page = current_page
        # HTTP status code.
        self.http_status_code = http_status_code
        # Return message.
        self.message = message
        # Page size.
        self.page_size = page_size
        # Request ID.
        self.request_id = request_id
        # Return result.
        self.result_object = result_object
        # Total number of items returned.
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object
        if self.total_item is not None:
            result['TotalItem'] = self.total_item
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            self.result_object = m.get('ResultObject')
        if m.get('TotalItem') is not None:
            self.total_item = m.get('TotalItem')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeListPocResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeListPocResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeListPocResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLoanExecListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        batch_no: str = None,
        current_page: str = None,
        monitor_obj: str = None,
        monitor_status: str = None,
        page_size: str = None,
        reg_id: str = None,
    ):
        # Set the language type for request and response messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Import batch number.
        self.batch_no = batch_no
        # Current page number.
        self.current_page = current_page
        # Monitoring metric data.
        self.monitor_obj = monitor_obj
        # Status
        self.monitor_status = monitor_status
        # Page size, with a default value of 10.
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.batch_no is not None:
            result['batchNo'] = self.batch_no
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.monitor_obj is not None:
            result['monitorObj'] = self.monitor_obj
        if self.monitor_status is not None:
            result['monitorStatus'] = self.monitor_status
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('batchNo') is not None:
            self.batch_no = m.get('batchNo')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('monitorObj') is not None:
            self.monitor_obj = m.get('monitorObj')
        if m.get('monitorStatus') is not None:
            self.monitor_status = m.get('monitorStatus')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeLoanExecListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: bool = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, with a default value of 10.
        self.page_size = page_size
        # Return object.
        self.result_object = result_object
        # Total number of items.
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeLoanExecListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLoanExecListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLoanExecListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLoanTaskListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        batch_no: str = None,
        current_page: str = None,
        monitor_status: str = None,
        page_size: str = None,
        reg_id: str = None,
    ):
        # Set the language type for request and response messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Import batch number.
        self.batch_no = batch_no
        # Current page number. Default is: 1.
        self.current_page = current_page
        # Task status.
        self.monitor_status = monitor_status
        # Page size, default value is 10.
        self.page_size = page_size
        # Region code.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.batch_no is not None:
            result['batchNo'] = self.batch_no
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.monitor_status is not None:
            result['monitorStatus'] = self.monitor_status
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('batchNo') is not None:
            self.batch_no = m.get('batchNo')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('monitorStatus') is not None:
            self.monitor_status = m.get('monitorStatus')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeLoanTaskListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: bool = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10.
        self.page_size = page_size
        # Return object.
        self.result_object = result_object
        # Total number of items.
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeLoanTaskListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLoanTaskListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLoanTaskListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMarkPageRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        current_page: str = None,
        direction: str = None,
        is_page: bool = None,
        order: str = None,
        page_size: str = None,
        reg_id: str = None,
        task_log_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Current page number.
        self.current_page = current_page
        # Order direction.
        self.direction = direction
        # Whether to paginate.
        self.is_page = is_page
        # Sorting condition.
        self.order = order
        # Page size, default value is 10.
        self.page_size = page_size
        # Region code.
        self.reg_id = reg_id
        # Task ID.
        self.task_log_id = task_log_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.direction is not None:
            result['direction'] = self.direction
        if self.is_page is not None:
            result['isPage'] = self.is_page
        if self.order is not None:
            result['order'] = self.order
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.task_log_id is not None:
            result['taskLogId'] = self.task_log_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('direction') is not None:
            self.direction = m.get('direction')
        if m.get('isPage') is not None:
            self.is_page = m.get('isPage')
        if m.get('order') is not None:
            self.order = m.get('order')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('taskLogId') is not None:
            self.task_log_id = m.get('taskLogId')
        return self


class DescribeMarkPageResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        field_name: str = None,
        field_value: str = None,
        id: int = None,
        mark_type: str = None,
    ):
        # Field name.
        self.field_name = field_name
        # Field value.
        self.field_value = field_value
        # Primary key ID.
        self.id = id
        # Mark (0 No / 1 Yes).
        self.mark_type = mark_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_name is not None:
            result['fieldName'] = self.field_name
        if self.field_value is not None:
            result['fieldValue'] = self.field_value
        if self.id is not None:
            result['id'] = self.id
        if self.mark_type is not None:
            result['markType'] = self.mark_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldName') is not None:
            self.field_name = m.get('fieldName')
        if m.get('fieldValue') is not None:
            self.field_value = m.get('fieldValue')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('markType') is not None:
            self.mark_type = m.get('markType')
        return self


class DescribeMarkPageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeMarkPageResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10.
        self.page_size = page_size
        # Returned object.
        self.result_object = result_object
        # Total number of items.
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeMarkPageResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeMarkPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeMarkPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMarkPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMenuPermissionRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        permission_type: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and responses, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Permission type
        self.permission_type = permission_type
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.permission_type is not None:
            result['permissionType'] = self.permission_type
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('permissionType') is not None:
            self.permission_type = m.get('permissionType')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeMenuPermissionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeMenuPermissionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeMenuPermissionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMenuPermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeModelDetailsByIdRequest(TeaModel):
    def __init__(
        self,
        model_id: str = None,
        reg_id: str = None,
    ):
        # Model ID.
        # 
        # This parameter is required.
        self.model_id = model_id
        # Region code.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.model_id is not None:
            result['ModelId'] = self.model_id
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ModelId') is not None:
            self.model_id = m.get('ModelId')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        return self


class DescribeModelDetailsByIdResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        model_effect_evaluation: str = None,
    ):
        # Model prediction result.
        self.model_effect_evaluation = model_effect_evaluation

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.model_effect_evaluation is not None:
            result['modelEffectEvaluation'] = self.model_effect_evaluation
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('modelEffectEvaluation') is not None:
            self.model_effect_evaluation = m.get('modelEffectEvaluation')
        return self


class DescribeModelDetailsByIdResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeModelDetailsByIdResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned result information
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['ResultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['ResultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('ResultObject') is not None:
            for k in m.get('ResultObject'):
                temp_model = DescribeModelDetailsByIdResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeModelDetailsByIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeModelDetailsByIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeModelDetailsByIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeModelOssPolicyRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeModelOssPolicyResponseBody(TeaModel):
    def __init__(
        self,
        access_id: str = None,
        host: str = None,
        key: str = None,
        message: str = None,
        policy: str = None,
        request_id: str = None,
        signature: str = None,
        result_object: bool = None,
    ):
        # Access ID for OSS.
        self.access_id = access_id
        # Address.
        self.host = host
        # OSS access key secret.
        self.key = key
        # Error message.
        self.message = message
        # The policy for user form upload, which is a base64-encoded string.
        self.policy = policy
        # Request ID.
        self.request_id = request_id
        # Signature information.
        self.signature = signature
        # Return result.
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_id is not None:
            result['AccessId'] = self.access_id
        if self.host is not None:
            result['Host'] = self.host
        if self.key is not None:
            result['Key'] = self.key
        if self.message is not None:
            result['Message'] = self.message
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.signature is not None:
            result['Signature'] = self.signature
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessId') is not None:
            self.access_id = m.get('AccessId')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Signature') is not None:
            self.signature = m.get('Signature')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeModelOssPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeModelOssPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeModelOssPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMonitorTaskLimitRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeMonitorTaskLimitResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        limit: bool = None,
        max_total_item: int = None,
        total_item: int = None,
    ):
        # Whether the maximum limit has been reached
        self.limit = limit
        # Maximum number of items
        self.max_total_item = max_total_item
        # Total number of items
        self.total_item = total_item

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.limit is not None:
            result['limit'] = self.limit
        if self.max_total_item is not None:
            result['maxTotalItem'] = self.max_total_item
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('maxTotalItem') is not None:
            self.max_total_item = m.get('maxTotalItem')
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        return self


class DescribeMonitorTaskLimitResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeMonitorTaskLimitResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeMonitorTaskLimitResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeMonitorTaskLimitResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeMonitorTaskLimitResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMonitorTaskLimitResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNameListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        current_page: str = None,
        page_size: str = None,
        reg_id: str = None,
        value: str = None,
        variable_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Creation type.
        self.create_type = create_type
        # Current page number.
        self.current_page = current_page
        # Page size, with a default value of 10.
        self.page_size = page_size
        # Region code.
        self.reg_id = reg_id
        # Search value.
        self.value = value
        # Variable ID.
        self.variable_id = variable_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.value is not None:
            result['value'] = self.value
        if self.variable_id is not None:
            result['variableId'] = self.variable_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('variableId') is not None:
            self.variable_id = m.get('variableId')
        return self


class DescribeNameListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        identifier: str = None,
        title: str = None,
        value: str = None,
        variable_id: int = None,
    ):
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time.
        self.gmt_modified = gmt_modified
        # Name list content ID.
        self.id = id
        # Variable identifier.
        self.identifier = identifier
        # Title.
        self.title = title
        # Value.
        self.value = value
        # Variable ID.
        self.variable_id = variable_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.title is not None:
            result['title'] = self.title
        if self.value is not None:
            result['value'] = self.value
        if self.variable_id is not None:
            result['variableId'] = self.variable_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('variableId') is not None:
            self.variable_id = m.get('variableId')
        return self


class DescribeNameListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeNameListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, with a default value of 10.
        self.page_size = page_size
        # Returned object.
        self.result_object = result_object
        # Total number of items.
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeNameListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeNameListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNameListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNameListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNameListDownloadUrlRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        variable_id: int = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id
        # Variable ID.
        # 
        # This parameter is required.
        self.variable_id = variable_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.variable_id is not None:
            result['variableId'] = self.variable_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('variableId') is not None:
            self.variable_id = m.get('variableId')
        return self


class DescribeNameListDownloadUrlResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        download_file_url: str = None,
    ):
        # Download URL.
        self.download_file_url = download_file_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_file_url is not None:
            result['downloadFileUrl'] = self.download_file_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('downloadFileUrl') is not None:
            self.download_file_url = m.get('downloadFileUrl')
        return self


class DescribeNameListDownloadUrlResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeNameListDownloadUrlResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeNameListDownloadUrlResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeNameListDownloadUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNameListDownloadUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNameListDownloadUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNameListLimitRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        reg_id: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Creation type
        self.create_type = create_type
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeNameListLimitResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        limit: bool = None,
        max_total_item: int = None,
        total_item: int = None,
    ):
        # Whether it exceeds the maximum quantity
        self.limit = limit
        # Maximum number of creatable items
        self.max_total_item = max_total_item
        # Total number of items
        self.total_item = total_item

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.limit is not None:
            result['limit'] = self.limit
        if self.max_total_item is not None:
            result['maxTotalItem'] = self.max_total_item
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('maxTotalItem') is not None:
            self.max_total_item = m.get('maxTotalItem')
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        return self


class DescribeNameListLimitResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeNameListLimitResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeNameListLimitResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeNameListLimitResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNameListLimitResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNameListLimitResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNameListPageListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        current_page: int = None,
        page_size: int = None,
        reg_id: str = None,
        update_begin_time: int = None,
        update_end_time: int = None,
        value: str = None,
        variable_id: int = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id
        # Update start time.
        self.update_begin_time = update_begin_time
        # Update end time.
        self.update_end_time = update_end_time
        # Variable name/description
        self.value = value
        # Variable ID
        # 
        # This parameter is required.
        self.variable_id = variable_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.update_begin_time is not None:
            result['updateBeginTime'] = self.update_begin_time
        if self.update_end_time is not None:
            result['updateEndTime'] = self.update_end_time
        if self.value is not None:
            result['value'] = self.value
        if self.variable_id is not None:
            result['variableId'] = self.variable_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('updateBeginTime') is not None:
            self.update_begin_time = m.get('updateBeginTime')
        if m.get('updateEndTime') is not None:
            self.update_end_time = m.get('updateEndTime')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('variableId') is not None:
            self.variable_id = m.get('variableId')
        return self


class DescribeNameListPageListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        memo: str = None,
        name: str = None,
        name_list_type: str = None,
        title: str = None,
        user_id: str = None,
        value: str = None,
        variable_id: int = None,
    ):
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time.
        self.gmt_modified = gmt_modified
        # ID of the list variable content data
        self.id = id
        # NameList Content memo
        self.memo = memo
        # Variable name
        self.name = name
        # Variable type
        self.name_list_type = name_list_type
        # Title.
        self.title = title
        # User UID
        self.user_id = user_id
        # Variable value
        self.value = value
        # Variable ID.
        self.variable_id = variable_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.memo is not None:
            result['memo'] = self.memo
        if self.name is not None:
            result['name'] = self.name
        if self.name_list_type is not None:
            result['nameListType'] = self.name_list_type
        if self.title is not None:
            result['title'] = self.title
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.value is not None:
            result['value'] = self.value
        if self.variable_id is not None:
            result['variableId'] = self.variable_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('memo') is not None:
            self.memo = m.get('memo')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nameListType') is not None:
            self.name_list_type = m.get('nameListType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('variableId') is not None:
            self.variable_id = m.get('variableId')
        return self


class DescribeNameListPageListResponseBody(TeaModel):
    def __init__(
        self,
        current_page: str = None,
        page_size: str = None,
        request_id: str = None,
        result_object: List[DescribeNameListPageListResponseBodyResultObject] = None,
        total_item: str = None,
        total_page: str = None,
    ):
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10
        self.page_size = page_size
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object
        # Total number of items
        self.total_item = total_item
        # Total number of pages
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeNameListPageListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeNameListPageListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNameListPageListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNameListPageListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNameListTypeListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeNameListTypeListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # Match Key.
        self.key = key
        # Variable value
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeNameListTypeListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeNameListTypeListResponseBodyResultObject] = None,
    ):
        # Request ID
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeNameListTypeListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeNameListTypeListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNameListTypeListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNameListTypeListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNameListVariablePageListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        current_page: int = None,
        name: str = None,
        name_list_type: str = None,
        page_size: int = None,
        reg_id: str = None,
        value: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Current page number.
        self.current_page = current_page
        # Variable name
        self.name = name
        # Variable type
        self.name_list_type = name_list_type
        # Page size, default value is 10
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id
        # Name list value
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.name is not None:
            result['name'] = self.name
        if self.name_list_type is not None:
            result['nameListType'] = self.name_list_type
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nameListType') is not None:
            self.name_list_type = m.get('nameListType')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeNameListVariablePageListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        capacity: int = None,
        description: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        left_capacity: int = None,
        name: str = None,
        name_list_type: str = None,
        ref_obj_id: str = None,
        ref_obj_type: int = None,
        source_type: str = None,
        title: str = None,
        type: str = None,
        user_id: int = None,
    ):
        # Used capacity
        self.capacity = capacity
        # Description information.
        self.description = description
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time
        self.gmt_modified = gmt_modified
        # Name list ID
        self.id = id
        # Remaining capacity
        self.left_capacity = left_capacity
        # Parameter name.
        self.name = name
        # Name list type
        self.name_list_type = name_list_type
        # Associated event eventCode
        self.ref_obj_id = ref_obj_id
        # Association type
        self.ref_obj_type = ref_obj_type
        # Data source
        self.source_type = source_type
        # Title.
        self.title = title
        # Variable type
        self.type = type
        # User UID
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.capacity is not None:
            result['capacity'] = self.capacity
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.left_capacity is not None:
            result['leftCapacity'] = self.left_capacity
        if self.name is not None:
            result['name'] = self.name
        if self.name_list_type is not None:
            result['nameListType'] = self.name_list_type
        if self.ref_obj_id is not None:
            result['refObjId'] = self.ref_obj_id
        if self.ref_obj_type is not None:
            result['refObjType'] = self.ref_obj_type
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('capacity') is not None:
            self.capacity = m.get('capacity')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('leftCapacity') is not None:
            self.left_capacity = m.get('leftCapacity')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nameListType') is not None:
            self.name_list_type = m.get('nameListType')
        if m.get('refObjId') is not None:
            self.ref_obj_id = m.get('refObjId')
        if m.get('refObjType') is not None:
            self.ref_obj_type = m.get('refObjType')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class DescribeNameListVariablePageListResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        request_id: str = None,
        result_object: List[DescribeNameListVariablePageListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10
        self.page_size = page_size
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object
        # Total number of items
        self.total_item = total_item
        # Total number of pages
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeNameListVariablePageListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeNameListVariablePageListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNameListVariablePageListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNameListVariablePageListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOperationLogPageListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        current_page: int = None,
        end_date: int = None,
        page_size: int = None,
        reg_id: str = None,
        start_date: int = None,
    ):
        # Set the language type for request and response messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Current page number.
        self.current_page = current_page
        # End time.
        self.end_date = end_date
        # Page size, default value is 10
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id
        # Start time.
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.end_date is not None:
            result['endDate'] = self.end_date
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.start_date is not None:
            result['startDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('endDate') is not None:
            self.end_date = m.get('endDate')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('startDate') is not None:
            self.start_date = m.get('startDate')
        return self


class DescribeOperationLogPageListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        client_ip: str = None,
        gmt_create: int = None,
        new_content: str = None,
        old_content: str = None,
        operation_summary: str = None,
        operation_type: str = None,
        user_name: str = None,
    ):
        # Client IP.
        self.client_ip = client_ip
        # Creation time.
        self.gmt_create = gmt_create
        # Content after operation
        self.new_content = new_content
        # Content before operation
        self.old_content = old_content
        # Operation summary
        self.operation_summary = operation_summary
        # Operation type.
        self.operation_type = operation_type
        # Operator
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_ip is not None:
            result['clientIp'] = self.client_ip
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.new_content is not None:
            result['newContent'] = self.new_content
        if self.old_content is not None:
            result['oldContent'] = self.old_content
        if self.operation_summary is not None:
            result['operationSummary'] = self.operation_summary
        if self.operation_type is not None:
            result['operationType'] = self.operation_type
        if self.user_name is not None:
            result['userName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clientIp') is not None:
            self.client_ip = m.get('clientIp')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('newContent') is not None:
            self.new_content = m.get('newContent')
        if m.get('oldContent') is not None:
            self.old_content = m.get('oldContent')
        if m.get('operationSummary') is not None:
            self.operation_summary = m.get('operationSummary')
        if m.get('operationType') is not None:
            self.operation_type = m.get('operationType')
        if m.get('userName') is not None:
            self.user_name = m.get('userName')
        return self


class DescribeOperationLogPageListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeOperationLogPageListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10
        self.page_size = page_size
        # Returned object
        self.result_object = result_object
        # Total number of items
        self.total_item = total_item
        # Total number of pages
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeOperationLogPageListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeOperationLogPageListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeOperationLogPageListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOperationLogPageListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOperatorListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Set the language type for request and response messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeOperatorListResponseBodyResultObjectOperatorsRightVariables(TeaModel):
    def __init__(
        self,
        field_name: str = None,
        field_type: str = None,
        field_value: str = None,
    ):
        # Field name.
        self.field_name = field_name
        # Field type.
        self.field_type = field_type
        # Field value.
        self.field_value = field_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_name is not None:
            result['fieldName'] = self.field_name
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.field_value is not None:
            result['fieldValue'] = self.field_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldName') is not None:
            self.field_name = m.get('fieldName')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('fieldValue') is not None:
            self.field_value = m.get('fieldValue')
        return self


class DescribeOperatorListResponseBodyResultObjectOperators(TeaModel):
    def __init__(
        self,
        code: str = None,
        has_right_variable: bool = None,
        memo: str = None,
        name: str = None,
        right_variables: List[DescribeOperatorListResponseBodyResultObjectOperatorsRightVariables] = None,
    ):
        # Operator code
        self.code = code
        # Whether it contains a right variable
        self.has_right_variable = has_right_variable
        # Description
        self.memo = memo
        # Operator name
        self.name = name
        # Right variable object
        self.right_variables = right_variables

    def validate(self):
        if self.right_variables:
            for k in self.right_variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.has_right_variable is not None:
            result['hasRightVariable'] = self.has_right_variable
        if self.memo is not None:
            result['memo'] = self.memo
        if self.name is not None:
            result['name'] = self.name
        result['rightVariables'] = []
        if self.right_variables is not None:
            for k in self.right_variables:
                result['rightVariables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('hasRightVariable') is not None:
            self.has_right_variable = m.get('hasRightVariable')
        if m.get('memo') is not None:
            self.memo = m.get('memo')
        if m.get('name') is not None:
            self.name = m.get('name')
        self.right_variables = []
        if m.get('rightVariables') is not None:
            for k in m.get('rightVariables'):
                temp_model = DescribeOperatorListResponseBodyResultObjectOperatorsRightVariables()
                self.right_variables.append(temp_model.from_map(k))
        return self


class DescribeOperatorListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        field_type: str = None,
        operators: List[DescribeOperatorListResponseBodyResultObjectOperators] = None,
    ):
        # Return value type
        self.field_type = field_type
        # Operator list
        self.operators = operators

    def validate(self):
        if self.operators:
            for k in self.operators:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        result['operators'] = []
        if self.operators is not None:
            for k in self.operators:
                result['operators'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        self.operators = []
        if m.get('operators') is not None:
            for k in m.get('operators'):
                temp_model = DescribeOperatorListResponseBodyResultObjectOperators()
                self.operators.append(temp_model.from_map(k))
        return self


class DescribeOperatorListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeOperatorListResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeOperatorListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeOperatorListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeOperatorListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOperatorListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOperatorListBySceneRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        scene: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id
        # Scene type.
        self.scene = scene

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.scene is not None:
            result['scene'] = self.scene
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        return self


class DescribeOperatorListBySceneResponseBodyResultObjectOperatorsRightVariables(TeaModel):
    def __init__(
        self,
        field_name: str = None,
        field_type: str = None,
        field_value: str = None,
    ):
        # Field name.
        self.field_name = field_name
        # Field type.
        self.field_type = field_type
        # Field value.
        self.field_value = field_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_name is not None:
            result['fieldName'] = self.field_name
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.field_value is not None:
            result['fieldValue'] = self.field_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldName') is not None:
            self.field_name = m.get('fieldName')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('fieldValue') is not None:
            self.field_value = m.get('fieldValue')
        return self


class DescribeOperatorListBySceneResponseBodyResultObjectOperators(TeaModel):
    def __init__(
        self,
        code: str = None,
        has_right_variable: bool = None,
        memo: str = None,
        name: str = None,
        right_variables: List[DescribeOperatorListBySceneResponseBodyResultObjectOperatorsRightVariables] = None,
    ):
        # Operator code
        self.code = code
        # Whether it contains a right variable
        self.has_right_variable = has_right_variable
        # Description
        self.memo = memo
        # Operator name
        self.name = name
        # Right variable object
        self.right_variables = right_variables

    def validate(self):
        if self.right_variables:
            for k in self.right_variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.has_right_variable is not None:
            result['hasRightVariable'] = self.has_right_variable
        if self.memo is not None:
            result['memo'] = self.memo
        if self.name is not None:
            result['name'] = self.name
        result['rightVariables'] = []
        if self.right_variables is not None:
            for k in self.right_variables:
                result['rightVariables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('hasRightVariable') is not None:
            self.has_right_variable = m.get('hasRightVariable')
        if m.get('memo') is not None:
            self.memo = m.get('memo')
        if m.get('name') is not None:
            self.name = m.get('name')
        self.right_variables = []
        if m.get('rightVariables') is not None:
            for k in m.get('rightVariables'):
                temp_model = DescribeOperatorListBySceneResponseBodyResultObjectOperatorsRightVariables()
                self.right_variables.append(temp_model.from_map(k))
        return self


class DescribeOperatorListBySceneResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        field_type: str = None,
        operators: List[DescribeOperatorListBySceneResponseBodyResultObjectOperators] = None,
    ):
        # Return value type
        self.field_type = field_type
        # Operator list
        self.operators = operators

    def validate(self):
        if self.operators:
            for k in self.operators:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        result['operators'] = []
        if self.operators is not None:
            for k in self.operators:
                result['operators'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        self.operators = []
        if m.get('operators') is not None:
            for k in m.get('operators'):
                temp_model = DescribeOperatorListBySceneResponseBodyResultObjectOperators()
                self.operators.append(temp_model.from_map(k))
        return self


class DescribeOperatorListBySceneResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeOperatorListBySceneResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeOperatorListBySceneResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeOperatorListBySceneResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeOperatorListBySceneResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOperatorListBySceneResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOperatorListByTypeRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeOperatorListByTypeResponseBodyResultObjectOperators(TeaModel):
    def __init__(
        self,
        code: str = None,
        has_right_variable: bool = None,
        name: str = None,
    ):
        # Operator code
        self.code = code
        # Whether it contains a right variable
        self.has_right_variable = has_right_variable
        # Operator name
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.has_right_variable is not None:
            result['hasRightVariable'] = self.has_right_variable
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('hasRightVariable') is not None:
            self.has_right_variable = m.get('hasRightVariable')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DescribeOperatorListByTypeResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        field_type: str = None,
        operators: List[DescribeOperatorListByTypeResponseBodyResultObjectOperators] = None,
    ):
        # Return value type
        self.field_type = field_type
        # Operator list
        self.operators = operators

    def validate(self):
        if self.operators:
            for k in self.operators:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        result['operators'] = []
        if self.operators is not None:
            for k in self.operators:
                result['operators'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        self.operators = []
        if m.get('operators') is not None:
            for k in m.get('operators'):
                temp_model = DescribeOperatorListByTypeResponseBodyResultObjectOperators()
                self.operators.append(temp_model.from_map(k))
        return self


class DescribeOperatorListByTypeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeOperatorListByTypeResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeOperatorListByTypeResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeOperatorListByTypeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeOperatorListByTypeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOperatorListByTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOssAuthStatusRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and responses, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeOssAuthStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: str = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeOssAuthStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeOssAuthStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOssAuthStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOssPolicyRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        scene: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Scene
        # 
        # This parameter is required.
        self.scene = scene

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.scene is not None:
            result['scene'] = self.scene
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        return self


class DescribeOssPolicyResponseBody(TeaModel):
    def __init__(
        self,
        access_id: str = None,
        host: str = None,
        key: str = None,
        policy: str = None,
        signature: str = None,
        request_id: str = None,
    ):
        # accessId, a parameter used in OSS SDK uploads, corresponding to OSSAccessKeyId
        self.access_id = access_id
        # OSS host ID.
        self.host = host
        # Key required for file upload.
        self.key = key
        # OSS security policy
        self.policy = policy
        # Signature data.
        self.signature = signature
        # Request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_id is not None:
            result['AccessId'] = self.access_id
        if self.host is not None:
            result['Host'] = self.host
        if self.key is not None:
            result['Key'] = self.key
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.signature is not None:
            result['Signature'] = self.signature
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessId') is not None:
            self.access_id = m.get('AccessId')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('Signature') is not None:
            self.signature = m.get('Signature')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DescribeOssPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeOssPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOssPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOssTokenRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        file_name: str = None,
        reg_id: str = None,
        upload_type: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # File name.
        self.file_name = file_name
        # Region code
        self.reg_id = reg_id
        # Upload type
        self.upload_type = upload_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.file_name is not None:
            result['fileName'] = self.file_name
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.upload_type is not None:
            result['uploadType'] = self.upload_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('fileName') is not None:
            self.file_name = m.get('fileName')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('uploadType') is not None:
            self.upload_type = m.get('uploadType')
        return self


class DescribeOssTokenResponseBody(TeaModel):
    def __init__(
        self,
        access_id: str = None,
        host: str = None,
        key: str = None,
        policy: str = None,
        request_id: str = None,
        signature: str = None,
        sts_token: str = None,
    ):
        # AccessKeyId for OSS file upload.
        self.access_id = access_id
        # Host address.
        self.host = host
        # The Key required for file upload.
        self.key = key
        # Permission policy for ossbucket.
        self.policy = policy
        # Request ID.
        self.request_id = request_id
        # OSS signature.
        self.signature = signature
        # Temporary identity credential.
        self.sts_token = sts_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_id is not None:
            result['AccessId'] = self.access_id
        if self.host is not None:
            result['Host'] = self.host
        if self.key is not None:
            result['Key'] = self.key
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.signature is not None:
            result['Signature'] = self.signature
        if self.sts_token is not None:
            result['StsToken'] = self.sts_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessId') is not None:
            self.access_id = m.get('AccessId')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Signature') is not None:
            self.signature = m.get('Signature')
        if m.get('StsToken') is not None:
            self.sts_token = m.get('StsToken')
        return self


class DescribeOssTokenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeOssTokenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOssTokenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeParamByEventCodesRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        event_codes: str = None,
        parma: str = None,
        reg_id: str = None,
    ):
        # Set the language type for request and response, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Event code.
        # 
        # This parameter is required.
        self.event_codes = event_codes
        # Query condition
        self.parma = parma
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.parma is not None:
            result['parma'] = self.parma
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('parma') is not None:
            self.parma = m.get('parma')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeParamByEventCodesResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        code: str = None,
        name: str = None,
    ):
        # Return code.
        self.code = code
        # Name
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DescribeParamByEventCodesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeParamByEventCodesResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeParamByEventCodesResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeParamByEventCodesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeParamByEventCodesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeParamByEventCodesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePocOssTokenRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribePocOssTokenResponseBody(TeaModel):
    def __init__(
        self,
        access_id: str = None,
        host: str = None,
        key: str = None,
        policy: str = None,
        request_id: str = None,
        signature: str = None,
        result_object: bool = None,
    ):
        # AccessKeyId for OSS file upload
        self.access_id = access_id
        # Host address.
        self.host = host
        # The Key required for file upload.
        self.key = key
        # OSS security policy.
        self.policy = policy
        # Request ID.
        self.request_id = request_id
        # Upload signature information.
        self.signature = signature
        # Return result.
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_id is not None:
            result['AccessId'] = self.access_id
        if self.host is not None:
            result['Host'] = self.host
        if self.key is not None:
            result['Key'] = self.key
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.signature is not None:
            result['Signature'] = self.signature
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessId') is not None:
            self.access_id = m.get('AccessId')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Signature') is not None:
            self.signature = m.get('Signature')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribePocOssTokenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePocOssTokenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePocOssTokenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePocTaskListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        current_page: int = None,
        page_size: int = None,
        reg_id: str = None,
        type: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Current page number.
        self.current_page = current_page
        # Page size, with a default value of 10.
        self.page_size = page_size
        # Region code.
        self.reg_id = reg_id
        # Query type.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribePocTaskListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        download_url: str = None,
        file_type: str = None,
        service_name: str = None,
        status: str = None,
        task_id: str = None,
        task_name: str = None,
        update_time: str = None,
    ):
        # Creation time.
        self.create_time = create_time
        # Download URL.
        self.download_url = download_url
        # File type.
        self.file_type = file_type
        # Service name.
        self.service_name = service_name
        # Status.
        self.status = status
        # Task ID.
        self.task_id = task_id
        # Task name.
        self.task_name = task_name
        # Last modified time.
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.download_url is not None:
            result['downloadUrl'] = self.download_url
        if self.file_type is not None:
            result['fileType'] = self.file_type
        if self.service_name is not None:
            result['serviceName'] = self.service_name
        if self.status is not None:
            result['status'] = self.status
        if self.task_id is not None:
            result['taskId'] = self.task_id
        if self.task_name is not None:
            result['taskName'] = self.task_name
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('downloadUrl') is not None:
            self.download_url = m.get('downloadUrl')
        if m.get('fileType') is not None:
            self.file_type = m.get('fileType')
        if m.get('serviceName') is not None:
            self.service_name = m.get('serviceName')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        if m.get('taskName') is not None:
            self.task_name = m.get('taskName')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        return self


class DescribePocTaskListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribePocTaskListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, with a default value of 10.
        self.page_size = page_size
        # Returned object.
        self.result_object = result_object
        # Total number of items.
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribePocTaskListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribePocTaskListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePocTaskListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePocTaskListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePrivateStackRequest(TeaModel):
    def __init__(
        self,
        reg_id: str = None,
    ):
        # Region Code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribePrivateStackResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return Object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribePrivateStackResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePrivateStackResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePrivateStackResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeQueryVariableDetailRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        id: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Variable ID
        # 
        # This parameter is required.
        self.id = id
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeQueryVariableDetailResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        data_source_code: int = None,
        data_source_name: str = None,
        description: str = None,
        event_code: str = None,
        expression: str = None,
        expression_title: str = None,
        expression_variable: str = None,
        id: int = None,
        outlier: str = None,
        outputs: str = None,
        title: str = None,
    ):
        # Data source code.
        self.data_source_code = data_source_code
        # Data source name
        self.data_source_name = data_source_name
        # Description.
        self.description = description
        # Event code
        self.event_code = event_code
        # Expression.
        self.expression = expression
        # Expression title.
        self.expression_title = expression_title
        # Expression variable.
        self.expression_variable = expression_variable
        # Variable ID
        self.id = id
        # Outlier
        self.outlier = outlier
        # Output results.
        self.outputs = outputs
        # Title.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_code is not None:
            result['dataSourceCode'] = self.data_source_code
        if self.data_source_name is not None:
            result['dataSourceName'] = self.data_source_name
        if self.description is not None:
            result['description'] = self.description
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.expression is not None:
            result['expression'] = self.expression
        if self.expression_title is not None:
            result['expressionTitle'] = self.expression_title
        if self.expression_variable is not None:
            result['expressionVariable'] = self.expression_variable
        if self.id is not None:
            result['id'] = self.id
        if self.outlier is not None:
            result['outlier'] = self.outlier
        if self.outputs is not None:
            result['outputs'] = self.outputs
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dataSourceCode') is not None:
            self.data_source_code = m.get('dataSourceCode')
        if m.get('dataSourceName') is not None:
            self.data_source_name = m.get('dataSourceName')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('expression') is not None:
            self.expression = m.get('expression')
        if m.get('expressionTitle') is not None:
            self.expression_title = m.get('expressionTitle')
        if m.get('expressionVariable') is not None:
            self.expression_variable = m.get('expressionVariable')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('outlier') is not None:
            self.outlier = m.get('outlier')
        if m.get('outputs') is not None:
            self.outputs = m.get('outputs')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class DescribeQueryVariableDetailResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeQueryVariableDetailResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeQueryVariableDetailResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeQueryVariableDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeQueryVariableDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeQueryVariableDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeQueryVariablePageListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        current_page: int = None,
        data_source_code: str = None,
        event_code: str = None,
        name: str = None,
        page_size: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Current page number.
        self.current_page = current_page
        # Data source code
        self.data_source_code = data_source_code
        # Event code
        self.event_code = event_code
        # Query variable name
        self.name = name
        # Page size, default value is 10
        self.page_size = page_size
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.data_source_code is not None:
            result['dataSourceCode'] = self.data_source_code
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.name is not None:
            result['name'] = self.name
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('dataSourceCode') is not None:
            self.data_source_code = m.get('dataSourceCode')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeQueryVariablePageListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        data_source_code: int = None,
        data_source_name: str = None,
        description: str = None,
        event_name: str = None,
        field_type: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        name: str = None,
        status: str = None,
        total: int = None,
        version: int = None,
    ):
        # Data source code.
        self.data_source_code = data_source_code
        # Data source name.
        self.data_source_name = data_source_name
        # Description information.
        self.description = description
        # Event name.
        self.event_name = event_name
        # Return value type
        self.field_type = field_type
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time
        self.gmt_modified = gmt_modified
        # Query variable primary key ID
        self.id = id
        # Query variable name
        self.name = name
        # Status.
        self.status = status
        # Total count
        self.total = total
        # Version number.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_code is not None:
            result['dataSourceCode'] = self.data_source_code
        if self.data_source_name is not None:
            result['dataSourceName'] = self.data_source_name
        if self.description is not None:
            result['description'] = self.description
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.status is not None:
            result['status'] = self.status
        if self.total is not None:
            result['total'] = self.total
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dataSourceCode') is not None:
            self.data_source_code = m.get('dataSourceCode')
        if m.get('dataSourceName') is not None:
            self.data_source_name = m.get('dataSourceName')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('total') is not None:
            self.total = m.get('total')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class DescribeQueryVariablePageListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeQueryVariablePageListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Pagination parameter, current page.
        self.current_page = current_page
        # Page size, default value is 10
        self.page_size = page_size
        # Return object
        self.result_object = result_object
        # Total items
        self.total_item = total_item
        # Total pages
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeQueryVariablePageListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeQueryVariablePageListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeQueryVariablePageListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeQueryVariablePageListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRecommendSceneVariablesRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        sample_id: int = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region Code
        self.reg_id = reg_id
        # Sample ID
        # 
        # This parameter is required.
        self.sample_id = sample_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.sample_id is not None:
            result['sampleId'] = self.sample_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('sampleId') is not None:
            self.sample_id = m.get('sampleId')
        return self


class DescribeRecommendSceneVariablesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return Object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeRecommendSceneVariablesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRecommendSceneVariablesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRecommendSceneVariablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRecommendTaskDetailRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        task_id: int = None,
    ):
        # Sets the language type for requests and responses, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code.
        self.reg_id = reg_id
        # Task ID.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.task_id is not None:
            result['taskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        return self


class DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOsRecommendRules(TeaModel):
    def __init__(
        self,
        left: str = None,
        operator: str = None,
        right: str = None,
    ):
        # Left variable
        self.left = left
        # Operator
        self.operator = operator
        # Right variable
        self.right = right

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.left is not None:
            result['left'] = self.left
        if self.operator is not None:
            result['operator'] = self.operator
        if self.right is not None:
            result['right'] = self.right
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('left') is not None:
            self.left = m.get('left')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('right') is not None:
            self.right = m.get('right')
        return self


class DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOs(TeaModel):
    def __init__(
        self,
        compute_expression: str = None,
        hit_sample: int = None,
        id: int = None,
        not_hit_sample: int = None,
        recommend_rules: List[DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOsRecommendRules] = None,
        rule_id: str = None,
        rule_name: str = None,
        status: str = None,
        velocities: str = None,
    ):
        # Calculation path
        self.compute_expression = compute_expression
        # Number of hit samples
        self.hit_sample = hit_sample
        # Primary key ID of the rule
        self.id = id
        # Number of unhit samples
        self.not_hit_sample = not_hit_sample
        # List of candidate rules
        self.recommend_rules = recommend_rules
        # Strategy ID
        self.rule_id = rule_id
        # Rule name
        self.rule_name = rule_name
        # Status
        self.status = status
        # List of indicators in JSON string format
        self.velocities = velocities

    def validate(self):
        if self.recommend_rules:
            for k in self.recommend_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.compute_expression is not None:
            result['computeExpression'] = self.compute_expression
        if self.hit_sample is not None:
            result['hitSample'] = self.hit_sample
        if self.id is not None:
            result['id'] = self.id
        if self.not_hit_sample is not None:
            result['notHitSample'] = self.not_hit_sample
        result['recommendRules'] = []
        if self.recommend_rules is not None:
            for k in self.recommend_rules:
                result['recommendRules'].append(k.to_map() if k else None)
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        if self.status is not None:
            result['status'] = self.status
        if self.velocities is not None:
            result['velocities'] = self.velocities
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('computeExpression') is not None:
            self.compute_expression = m.get('computeExpression')
        if m.get('hitSample') is not None:
            self.hit_sample = m.get('hitSample')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('notHitSample') is not None:
            self.not_hit_sample = m.get('notHitSample')
        self.recommend_rules = []
        if m.get('recommendRules') is not None:
            for k in m.get('recommendRules'):
                temp_model = DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOsRecommendRules()
                self.recommend_rules.append(temp_model.from_map(k))
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('velocities') is not None:
            self.velocities = m.get('velocities')
        return self


class DescribeRecommendTaskDetailResponseBodyResultObjectRecommendVariableDTOs(TeaModel):
    def __init__(
        self,
        id: int = None,
        title: str = None,
    ):
        # Primary key ID
        self.id = id
        # Title
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class DescribeRecommendTaskDetailResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        event_code: str = None,
        event_name: str = None,
        expect_velocities: List[str] = None,
        gmt_create: int = None,
        normal_size: int = None,
        recommend_rule_dtos: List[DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOs] = None,
        recommend_variable_dtos: List[DescribeRecommendTaskDetailResponseBodyResultObjectRecommendVariableDTOs] = None,
        risk_size: int = None,
        sample_name: str = None,
        sample_scene: str = None,
        sample_scene_name: str = None,
        task_id: int = None,
        task_name: str = None,
        task_status: str = None,
    ):
        # Event code
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Comparison indicators
        self.expect_velocities = expect_velocities
        # Creation time
        self.gmt_create = gmt_create
        # Number of normal samples
        self.normal_size = normal_size
        # Recommended strategy list
        self.recommend_rule_dtos = recommend_rule_dtos
        # Selected variable list
        self.recommend_variable_dtos = recommend_variable_dtos
        # Number of risk samples
        self.risk_size = risk_size
        # Sample name
        self.sample_name = sample_name
        # Sample scenario
        self.sample_scene = sample_scene
        # Sample scenario name
        self.sample_scene_name = sample_scene_name
        # Task ID
        self.task_id = task_id
        # Task name
        self.task_name = task_name
        # Task status.
        self.task_status = task_status

    def validate(self):
        if self.recommend_rule_dtos:
            for k in self.recommend_rule_dtos:
                if k:
                    k.validate()
        if self.recommend_variable_dtos:
            for k in self.recommend_variable_dtos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.expect_velocities is not None:
            result['expectVelocities'] = self.expect_velocities
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.normal_size is not None:
            result['normalSize'] = self.normal_size
        result['recommendRuleDTOs'] = []
        if self.recommend_rule_dtos is not None:
            for k in self.recommend_rule_dtos:
                result['recommendRuleDTOs'].append(k.to_map() if k else None)
        result['recommendVariableDTOs'] = []
        if self.recommend_variable_dtos is not None:
            for k in self.recommend_variable_dtos:
                result['recommendVariableDTOs'].append(k.to_map() if k else None)
        if self.risk_size is not None:
            result['riskSize'] = self.risk_size
        if self.sample_name is not None:
            result['sampleName'] = self.sample_name
        if self.sample_scene is not None:
            result['sampleScene'] = self.sample_scene
        if self.sample_scene_name is not None:
            result['sampleSceneName'] = self.sample_scene_name
        if self.task_id is not None:
            result['taskId'] = self.task_id
        if self.task_name is not None:
            result['taskName'] = self.task_name
        if self.task_status is not None:
            result['taskStatus'] = self.task_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('expectVelocities') is not None:
            self.expect_velocities = m.get('expectVelocities')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('normalSize') is not None:
            self.normal_size = m.get('normalSize')
        self.recommend_rule_dtos = []
        if m.get('recommendRuleDTOs') is not None:
            for k in m.get('recommendRuleDTOs'):
                temp_model = DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOs()
                self.recommend_rule_dtos.append(temp_model.from_map(k))
        self.recommend_variable_dtos = []
        if m.get('recommendVariableDTOs') is not None:
            for k in m.get('recommendVariableDTOs'):
                temp_model = DescribeRecommendTaskDetailResponseBodyResultObjectRecommendVariableDTOs()
                self.recommend_variable_dtos.append(temp_model.from_map(k))
        if m.get('riskSize') is not None:
            self.risk_size = m.get('riskSize')
        if m.get('sampleName') is not None:
            self.sample_name = m.get('sampleName')
        if m.get('sampleScene') is not None:
            self.sample_scene = m.get('sampleScene')
        if m.get('sampleSceneName') is not None:
            self.sample_scene_name = m.get('sampleSceneName')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        if m.get('taskName') is not None:
            self.task_name = m.get('taskName')
        if m.get('taskStatus') is not None:
            self.task_status = m.get('taskStatus')
        return self


class DescribeRecommendTaskDetailResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeRecommendTaskDetailResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return result
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeRecommendTaskDetailResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeRecommendTaskDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRecommendTaskDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRecommendTaskDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRecommendTaskPageListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        current_page: str = None,
        page_size: str = None,
        reg_id: str = None,
        task_name: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Current page number
        self.current_page = current_page
        # Page size, with a default value of 10
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id
        # Task name
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.task_name is not None:
            result['taskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('taskName') is not None:
            self.task_name = m.get('taskName')
        return self


class DescribeRecommendTaskPageListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        expect_velocities: List[str] = None,
        gmt_create: int = None,
        normal_count: int = None,
        normal_size: int = None,
        risk_count: int = None,
        risk_size: int = None,
        sample_name: str = None,
        sample_scene: str = None,
        task_id: int = None,
        task_name: str = None,
        task_status: str = None,
    ):
        # Impact indicators
        self.expect_velocities = expect_velocities
        # Creation time.
        self.gmt_create = gmt_create
        # Number of samples
        self.normal_count = normal_count
        # Number of normal samples
        self.normal_size = normal_size
        # Number of records displayed on the current page.
        self.risk_count = risk_count
        # Number of risk samples
        self.risk_size = risk_size
        # Sample name
        self.sample_name = sample_name
        # Sample scenario
        self.sample_scene = sample_scene
        # Task ID.
        self.task_id = task_id
        # Task name.
        self.task_name = task_name
        # Task status.
        self.task_status = task_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expect_velocities is not None:
            result['expectVelocities'] = self.expect_velocities
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.normal_count is not None:
            result['normalCount'] = self.normal_count
        if self.normal_size is not None:
            result['normalSize'] = self.normal_size
        if self.risk_count is not None:
            result['riskCount'] = self.risk_count
        if self.risk_size is not None:
            result['riskSize'] = self.risk_size
        if self.sample_name is not None:
            result['sampleName'] = self.sample_name
        if self.sample_scene is not None:
            result['sampleScene'] = self.sample_scene
        if self.task_id is not None:
            result['taskId'] = self.task_id
        if self.task_name is not None:
            result['taskName'] = self.task_name
        if self.task_status is not None:
            result['taskStatus'] = self.task_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('expectVelocities') is not None:
            self.expect_velocities = m.get('expectVelocities')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('normalCount') is not None:
            self.normal_count = m.get('normalCount')
        if m.get('normalSize') is not None:
            self.normal_size = m.get('normalSize')
        if m.get('riskCount') is not None:
            self.risk_count = m.get('riskCount')
        if m.get('riskSize') is not None:
            self.risk_size = m.get('riskSize')
        if m.get('sampleName') is not None:
            self.sample_name = m.get('sampleName')
        if m.get('sampleScene') is not None:
            self.sample_scene = m.get('sampleScene')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        if m.get('taskName') is not None:
            self.task_name = m.get('taskName')
        if m.get('taskStatus') is not None:
            self.task_status = m.get('taskStatus')
        return self


class DescribeRecommendTaskPageListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeRecommendTaskPageListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID
        self.request_id = request_id
        # Current page number
        self.current_page = current_page
        # Page size, with a default value of 10
        self.page_size = page_size
        # Returned object
        self.result_object = result_object
        # Total number of items
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeRecommendTaskPageListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeRecommendTaskPageListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRecommendTaskPageListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRecommendTaskPageListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRecommendVariablesVelocityRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        task_id: int = None,
        variable_ids_str: str = None,
    ):
        # Set the language type for request and response, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region Code
        self.reg_id = reg_id
        # Task ID
        # 
        # This parameter is required.
        self.task_id = task_id
        # Variable IDs
        self.variable_ids_str = variable_ids_str

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.task_id is not None:
            result['taskId'] = self.task_id
        if self.variable_ids_str is not None:
            result['variableIdsStr'] = self.variable_ids_str
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('taskId') is not None:
            self.task_id = m.get('taskId')
        if m.get('variableIdsStr') is not None:
            self.variable_ids_str = m.get('variableIdsStr')
        return self


class DescribeRecommendVariablesVelocityResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return Object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeRecommendVariablesVelocityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRecommendVariablesVelocityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRecommendVariablesVelocityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRecommendVelocitiesRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        code: str = None,
        reg_id: str = None,
        type: str = None,
    ):
        # Sets the language type for requests and responses, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Metric code
        self.code = code
        # Region ID
        self.reg_id = reg_id
        # Metric type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.code is not None:
            result['code'] = self.code
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeRecommendVelocitiesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeRecommendVelocitiesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRecommendVelocitiesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRecommendVelocitiesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRegionsRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Set the language type for requests and responses. The default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeRegionsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeRegionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRegionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRegionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRequestHitRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        s_request_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id
        # Request ID.
        # 
        # This parameter is required.
        self.s_request_id = s_request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.s_request_id is not None:
            result['sRequestId'] = self.s_request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('sRequestId') is not None:
            self.s_request_id = m.get('sRequestId')
        return self


class DescribeRequestHitResponseBodyResultObjectRuleHitRecords(TeaModel):
    def __init__(
        self,
        cost: int = None,
        hit_successful: bool = None,
        is_show_detail: bool = None,
        order: int = None,
        rule_id: str = None,
        rule_name: str = None,
        rule_snapshot_id: str = None,
        rule_status: str = None,
    ):
        # Duration
        self.cost = cost
        # Whether the rule was hit.
        self.hit_successful = hit_successful
        # Whether to show details
        self.is_show_detail = is_show_detail
        # Order.
        self.order = order
        # Policy ID
        self.rule_id = rule_id
        # Policy name
        self.rule_name = rule_name
        # Rule snapshot ID
        self.rule_snapshot_id = rule_snapshot_id
        # Policy status
        self.rule_status = rule_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cost is not None:
            result['cost'] = self.cost
        if self.hit_successful is not None:
            result['hitSuccessful'] = self.hit_successful
        if self.is_show_detail is not None:
            result['isShowDetail'] = self.is_show_detail
        if self.order is not None:
            result['order'] = self.order
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        if self.rule_snapshot_id is not None:
            result['ruleSnapshotId'] = self.rule_snapshot_id
        if self.rule_status is not None:
            result['ruleStatus'] = self.rule_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cost') is not None:
            self.cost = m.get('cost')
        if m.get('hitSuccessful') is not None:
            self.hit_successful = m.get('hitSuccessful')
        if m.get('isShowDetail') is not None:
            self.is_show_detail = m.get('isShowDetail')
        if m.get('order') is not None:
            self.order = m.get('order')
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        if m.get('ruleSnapshotId') is not None:
            self.rule_snapshot_id = m.get('ruleSnapshotId')
        if m.get('ruleStatus') is not None:
            self.rule_status = m.get('ruleStatus')
        return self


class DescribeRequestHitResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        event_code: str = None,
        event_name: str = None,
        inputs: str = None,
        outputs: str = None,
        request_time: int = None,
        rule_hit_records: List[DescribeRequestHitResponseBodyResultObjectRuleHitRecords] = None,
        s_request_id: str = None,
        total_cost: int = None,
    ):
        # Event code
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Input parameters.
        self.inputs = inputs
        # Output parameters
        self.outputs = outputs
        # Timestamp of the request.
        self.request_time = request_time
        # Details of the executed rules.
        self.rule_hit_records = rule_hit_records
        # Request ID
        self.s_request_id = s_request_id
        # Total amount of the request
        self.total_cost = total_cost

    def validate(self):
        if self.rule_hit_records:
            for k in self.rule_hit_records:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.inputs is not None:
            result['inputs'] = self.inputs
        if self.outputs is not None:
            result['outputs'] = self.outputs
        if self.request_time is not None:
            result['requestTime'] = self.request_time
        result['ruleHitRecords'] = []
        if self.rule_hit_records is not None:
            for k in self.rule_hit_records:
                result['ruleHitRecords'].append(k.to_map() if k else None)
        if self.s_request_id is not None:
            result['sRequestId'] = self.s_request_id
        if self.total_cost is not None:
            result['totalCost'] = self.total_cost
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('inputs') is not None:
            self.inputs = m.get('inputs')
        if m.get('outputs') is not None:
            self.outputs = m.get('outputs')
        if m.get('requestTime') is not None:
            self.request_time = m.get('requestTime')
        self.rule_hit_records = []
        if m.get('ruleHitRecords') is not None:
            for k in m.get('ruleHitRecords'):
                temp_model = DescribeRequestHitResponseBodyResultObjectRuleHitRecords()
                self.rule_hit_records.append(temp_model.from_map(k))
        if m.get('sRequestId') is not None:
            self.s_request_id = m.get('sRequestId')
        if m.get('totalCost') is not None:
            self.total_cost = m.get('totalCost')
        return self


class DescribeRequestHitResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeRequestHitResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeRequestHitResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeRequestHitResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRequestHitResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRequestHitResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRequestPeakReportRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeRequestPeakReportResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        ratio: str = None,
        value: str = None,
    ):
        # Return value
        self.ratio = ratio
        # Return text
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ratio is not None:
            result['ratio'] = self.ratio
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ratio') is not None:
            self.ratio = m.get('ratio')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeRequestPeakReportResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: List[DescribeRequestPeakReportResponseBodyResultObject] = None,
        success: bool = None,
    ):
        # Status code
        self.code = code
        # HTTP status code.
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object
        # Whether the request was successful
        self.success = success

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeRequestPeakReportResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeRequestPeakReportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRequestPeakReportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRequestPeakReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeResultCountRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        begin_time: int = None,
        end_time: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Start time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.begin_time = begin_time
        # End time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.end_time = end_time
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.begin_time is not None:
            result['beginTime'] = self.begin_time
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('beginTime') is not None:
            self.begin_time = m.get('beginTime')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeResultCountResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        result: str = None,
        total: str = None,
    ):
        # Execution result
        self.result = result
        # Quantity
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result is not None:
            result['result'] = self.result
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('result') is not None:
            self.result = m.get('result')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class DescribeResultCountResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: List[DescribeResultCountResponseBodyResultObject] = None,
        success: bool = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeResultCountResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeResultCountResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeResultCountResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeResultCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRiskLineChartRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        begin_time: int = None,
        end_time: int = None,
        event_codes: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Query start time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.begin_time = begin_time
        # End time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.end_time = end_time
        # Event codes, separated by commas (,).
        self.event_codes = event_codes
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.begin_time is not None:
            result['beginTime'] = self.begin_time
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('beginTime') is not None:
            self.begin_time = m.get('beginTime')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeRiskLineChartResponseBodyResultObjectSeries(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
        name: str = None,
    ):
        # Line chart data
        self.data = data
        # Title of the line segment in the line chart
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DescribeRiskLineChartResponseBodyResultObjectXaxis(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
    ):
        # Returns x-axis data points
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class DescribeRiskLineChartResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        series: List[DescribeRiskLineChartResponseBodyResultObjectSeries] = None,
        xaxis: DescribeRiskLineChartResponseBodyResultObjectXaxis = None,
    ):
        # Data list
        self.series = series
        # Details of xaxis node.
        self.xaxis = xaxis

    def validate(self):
        if self.series:
            for k in self.series:
                if k:
                    k.validate()
        if self.xaxis:
            self.xaxis.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['series'] = []
        if self.series is not None:
            for k in self.series:
                result['series'].append(k.to_map() if k else None)
        if self.xaxis is not None:
            result['xaxis'] = self.xaxis.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.series = []
        if m.get('series') is not None:
            for k in m.get('series'):
                temp_model = DescribeRiskLineChartResponseBodyResultObjectSeries()
                self.series.append(temp_model.from_map(k))
        if m.get('xaxis') is not None:
            temp_model = DescribeRiskLineChartResponseBodyResultObjectXaxis()
            self.xaxis = temp_model.from_map(m['xaxis'])
        return self


class DescribeRiskLineChartResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: DescribeRiskLineChartResponseBodyResultObject = None,
        success: bool = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object
        # Whether the request was successful.
        self.success = success

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeRiskLineChartResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeRiskLineChartResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRiskLineChartResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRiskLineChartResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRiskTagsLineChartRequest(TeaModel):
    def __init__(
        self,
        begin_time: int = None,
        end_time: int = None,
        event_codes: str = None,
        lang: str = None,
        reg_id: str = None,
    ):
        # Start time of the query, in milliseconds (ms).
        # 
        # This parameter is required.
        self.begin_time = begin_time
        # End time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.end_time = end_time
        # Event code
        self.event_codes = event_codes
        # Sets the language type for the request and response messages. Default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_time is not None:
            result['BeginTime'] = self.begin_time
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.event_codes is not None:
            result['EventCodes'] = self.event_codes
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BeginTime') is not None:
            self.begin_time = m.get('BeginTime')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EventCodes') is not None:
            self.event_codes = m.get('EventCodes')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        return self


class DescribeRiskTagsLineChartResponseBodyResultObjectSeries(TeaModel):
    def __init__(
        self,
        data: float = None,
        name: str = None,
    ):
        # Data
        self.data = data
        # Name
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeRiskTagsLineChartResponseBodyResultObjectXaxis(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
    ):
        # Data returned by the chart
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        return self


class DescribeRiskTagsLineChartResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        percent: List[float] = None,
        series: List[DescribeRiskTagsLineChartResponseBodyResultObjectSeries] = None,
        total: List[int] = None,
        xaxis: DescribeRiskTagsLineChartResponseBodyResultObjectXaxis = None,
    ):
        # Call percentage, represented as a decimal
        self.percent = percent
        # Chart data
        self.series = series
        # Total number of records.
        self.total = total
        # X-axis data of the chart
        self.xaxis = xaxis

    def validate(self):
        if self.series:
            for k in self.series:
                if k:
                    k.validate()
        if self.xaxis:
            self.xaxis.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.percent is not None:
            result['Percent'] = self.percent
        result['Series'] = []
        if self.series is not None:
            for k in self.series:
                result['Series'].append(k.to_map() if k else None)
        if self.total is not None:
            result['Total'] = self.total
        if self.xaxis is not None:
            result['Xaxis'] = self.xaxis.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        self.series = []
        if m.get('Series') is not None:
            for k in m.get('Series'):
                temp_model = DescribeRiskTagsLineChartResponseBodyResultObjectSeries()
                self.series.append(temp_model.from_map(k))
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Xaxis') is not None:
            temp_model = DescribeRiskTagsLineChartResponseBodyResultObjectXaxis()
            self.xaxis = temp_model.from_map(m['Xaxis'])
        return self


class DescribeRiskTagsLineChartResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: DescribeRiskTagsLineChartResponseBodyResultObject = None,
        success: bool = None,
    ):
        # Status code. Note: 200 indicates success.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID
        self.request_id = request_id
        # Returned result information
        self.result_object = result_object
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            temp_model = DescribeRiskTagsLineChartResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['ResultObject'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeRiskTagsLineChartResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRiskTagsLineChartResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRiskTagsLineChartResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRuleBarChartRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        begin_time: int = None,
        end_time: int = None,
        event_codes: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Query start time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.begin_time = begin_time
        # End time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.end_time = end_time
        # Event codes, separated by commas (,).
        self.event_codes = event_codes
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.begin_time is not None:
            result['beginTime'] = self.begin_time
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('beginTime') is not None:
            self.begin_time = m.get('beginTime')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeRuleBarChartResponseBodyResultObjectSeriesData(TeaModel):
    def __init__(
        self,
        event_name: str = None,
        num: int = None,
        rule_name: str = None,
        status: str = None,
    ):
        # Event name.
        self.event_name = event_name
        # Number.
        self.num = num
        # Policy name
        self.rule_name = rule_name
        # Status.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.num is not None:
            result['num'] = self.num
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('num') is not None:
            self.num = m.get('num')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class DescribeRuleBarChartResponseBodyResultObjectSeries(TeaModel):
    def __init__(
        self,
        data: List[DescribeRuleBarChartResponseBodyResultObjectSeriesData] = None,
        type: str = None,
    ):
        # Response data.
        self.data = data
        # Bar chart type
        self.type = type

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = DescribeRuleBarChartResponseBodyResultObjectSeriesData()
                self.data.append(temp_model.from_map(k))
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeRuleBarChartResponseBodyResultObjectYaxis(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
    ):
        # yaxis data items
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class DescribeRuleBarChartResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        series: List[DescribeRuleBarChartResponseBodyResultObjectSeries] = None,
        yaxis: DescribeRuleBarChartResponseBodyResultObjectYaxis = None,
    ):
        # Data list
        self.series = series
        # yaxis related results.
        self.yaxis = yaxis

    def validate(self):
        if self.series:
            for k in self.series:
                if k:
                    k.validate()
        if self.yaxis:
            self.yaxis.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['series'] = []
        if self.series is not None:
            for k in self.series:
                result['series'].append(k.to_map() if k else None)
        if self.yaxis is not None:
            result['yaxis'] = self.yaxis.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.series = []
        if m.get('series') is not None:
            for k in m.get('series'):
                temp_model = DescribeRuleBarChartResponseBodyResultObjectSeries()
                self.series.append(temp_model.from_map(k))
        if m.get('yaxis') is not None:
            temp_model = DescribeRuleBarChartResponseBodyResultObjectYaxis()
            self.yaxis = temp_model.from_map(m['yaxis'])
        return self


class DescribeRuleBarChartResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: DescribeRuleBarChartResponseBodyResultObject = None,
        success: bool = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code.
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object
        # Whether the request was successful.
        self.success = success

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeRuleBarChartResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeRuleBarChartResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRuleBarChartResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRuleBarChartResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRuleCountByUserIdRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Creation type
        self.create_type = create_type
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeRuleCountByUserIdResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        limit: bool = None,
        max_total_item: int = None,
        total_item: int = None,
    ):
        # Whether the limit condition is reached. Values: -**true**: Yes-**false**: No
        self.limit = limit
        # Maximum number of items
        self.max_total_item = max_total_item
        # Total number of items
        self.total_item = total_item

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.limit is not None:
            result['limit'] = self.limit
        if self.max_total_item is not None:
            result['maxTotalItem'] = self.max_total_item
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('maxTotalItem') is not None:
            self.max_total_item = m.get('maxTotalItem')
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        return self


class DescribeRuleCountByUserIdResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeRuleCountByUserIdResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeRuleCountByUserIdResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeRuleCountByUserIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRuleCountByUserIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRuleCountByUserIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRuleDetailByRuleIdRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        console_rule_id: int = None,
        reg_id: str = None,
        rule_id: str = None,
        rule_version_id: int = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Primary key ID of the policy.
        self.console_rule_id = console_rule_id
        # Region code.
        self.reg_id = reg_id
        # Policy ID.
        self.rule_id = rule_id
        # Primary key ID of the policy version.
        self.rule_version_id = rule_version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.console_rule_id is not None:
            result['consoleRuleId'] = self.console_rule_id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.rule_version_id is not None:
            result['ruleVersionId'] = self.rule_version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('consoleRuleId') is not None:
            self.console_rule_id = m.get('consoleRuleId')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('ruleVersionId') is not None:
            self.rule_version_id = m.get('ruleVersionId')
        return self


class DescribeRuleDetailByRuleIdResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        auth_type: str = None,
        biz_version: str = None,
        console_rule_id: int = None,
        create_type: str = None,
        event_code: str = None,
        event_name: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        logic_expression: str = None,
        main_event_code: str = None,
        memo: str = None,
        rule_action_map: Dict[str, Any] = None,
        rule_actions: str = None,
        rule_auth_type: str = None,
        rule_body: str = None,
        rule_expressions: str = None,
        rule_id: str = None,
        rule_name: str = None,
        rule_status: str = None,
        rule_type: str = None,
        rule_version_id: int = None,
    ):
        # Service authorization type.
        self.auth_type = auth_type
        # Version.
        self.biz_version = biz_version
        # Primary key ID of the policy.
        self.console_rule_id = console_rule_id
        # Creation type.
        self.create_type = create_type
        # Event code.
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time.
        self.gmt_modified = gmt_modified
        # Log expression.
        self.logic_expression = logic_expression
        # Main event code.
        self.main_event_code = main_event_code
        # Memo.
        self.memo = memo
        # Rule action structure.
        self.rule_action_map = rule_action_map
        # Rule actions.
        self.rule_actions = rule_actions
        # Rule authorization type.
        self.rule_auth_type = rule_auth_type
        # DSL policy expression.
        self.rule_body = rule_body
        # Rule expressions.
        self.rule_expressions = rule_expressions
        # Policy ID.
        self.rule_id = rule_id
        # Policy name.
        self.rule_name = rule_name
        # Policy status.
        self.rule_status = rule_status
        # Rule type.
        self.rule_type = rule_type
        # Primary key ID of the policy version.
        self.rule_version_id = rule_version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_type is not None:
            result['authType'] = self.auth_type
        if self.biz_version is not None:
            result['bizVersion'] = self.biz_version
        if self.console_rule_id is not None:
            result['consoleRuleId'] = self.console_rule_id
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.logic_expression is not None:
            result['logicExpression'] = self.logic_expression
        if self.main_event_code is not None:
            result['mainEventCode'] = self.main_event_code
        if self.memo is not None:
            result['memo'] = self.memo
        if self.rule_action_map is not None:
            result['ruleActionMap'] = self.rule_action_map
        if self.rule_actions is not None:
            result['ruleActions'] = self.rule_actions
        if self.rule_auth_type is not None:
            result['ruleAuthType'] = self.rule_auth_type
        if self.rule_body is not None:
            result['ruleBody'] = self.rule_body
        if self.rule_expressions is not None:
            result['ruleExpressions'] = self.rule_expressions
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        if self.rule_status is not None:
            result['ruleStatus'] = self.rule_status
        if self.rule_type is not None:
            result['ruleType'] = self.rule_type
        if self.rule_version_id is not None:
            result['ruleVersionId'] = self.rule_version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('authType') is not None:
            self.auth_type = m.get('authType')
        if m.get('bizVersion') is not None:
            self.biz_version = m.get('bizVersion')
        if m.get('consoleRuleId') is not None:
            self.console_rule_id = m.get('consoleRuleId')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('logicExpression') is not None:
            self.logic_expression = m.get('logicExpression')
        if m.get('mainEventCode') is not None:
            self.main_event_code = m.get('mainEventCode')
        if m.get('memo') is not None:
            self.memo = m.get('memo')
        if m.get('ruleActionMap') is not None:
            self.rule_action_map = m.get('ruleActionMap')
        if m.get('ruleActions') is not None:
            self.rule_actions = m.get('ruleActions')
        if m.get('ruleAuthType') is not None:
            self.rule_auth_type = m.get('ruleAuthType')
        if m.get('ruleBody') is not None:
            self.rule_body = m.get('ruleBody')
        if m.get('ruleExpressions') is not None:
            self.rule_expressions = m.get('ruleExpressions')
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        if m.get('ruleStatus') is not None:
            self.rule_status = m.get('ruleStatus')
        if m.get('ruleType') is not None:
            self.rule_type = m.get('ruleType')
        if m.get('ruleVersionId') is not None:
            self.rule_version_id = m.get('ruleVersionId')
        return self


class DescribeRuleDetailByRuleIdResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeRuleDetailByRuleIdResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object.
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeRuleDetailByRuleIdResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeRuleDetailByRuleIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRuleDetailByRuleIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRuleDetailByRuleIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRuleHitRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        request_time: int = None,
        rule_id: str = None,
        rule_snapshot_id: str = None,
        s_request_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id
        # Execution time
        self.request_time = request_time
        # Rule ID
        self.rule_id = rule_id
        # Snapshot ID.
        self.rule_snapshot_id = rule_snapshot_id
        # Request ID.
        self.s_request_id = s_request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.request_time is not None:
            result['requestTime'] = self.request_time
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.rule_snapshot_id is not None:
            result['ruleSnapshotId'] = self.rule_snapshot_id
        if self.s_request_id is not None:
            result['sRequestId'] = self.s_request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('requestTime') is not None:
            self.request_time = m.get('requestTime')
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('ruleSnapshotId') is not None:
            self.rule_snapshot_id = m.get('ruleSnapshotId')
        if m.get('sRequestId') is not None:
            self.s_request_id = m.get('sRequestId')
        return self


class DescribeRuleHitResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: Dict[str, Any] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeRuleHitResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRuleHitResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRuleHitResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRuleListByEventCodesListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        event_codes: str = None,
        reg_id: str = None,
    ):
        # Set the language type for request and response messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Event codes, JSON array string
        # 
        # This parameter is required.
        self.event_codes = event_codes
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeRuleListByEventCodesListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        rule_id: str = None,
        rule_name: str = None,
    ):
        # Policy ID
        self.rule_id = rule_id
        # Policy name
        self.rule_name = rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        return self


class DescribeRuleListByEventCodesListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeRuleListByEventCodesListResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeRuleListByEventCodesListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeRuleListByEventCodesListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRuleListByEventCodesListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRuleListByEventCodesListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRulePageListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        current_page: str = None,
        event_code: str = None,
        page_size: str = None,
        reg_id: str = None,
        rule_auth_type: str = None,
        rule_name: str = None,
        rule_status: str = None,
        sort: str = None,
    ):
        # Set the language type for requests and responses, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Creation type.
        self.create_type = create_type
        # Current page number.
        self.current_page = current_page
        # Event code.
        self.event_code = event_code
        # Page size, default value is 10.
        self.page_size = page_size
        # Region code.
        self.reg_id = reg_id
        # Policy type.
        self.rule_auth_type = rule_auth_type
        # Policy name.
        self.rule_name = rule_name
        # Policy status.
        self.rule_status = rule_status
        # Sorting method, default value is desc.
        # - desc: descending order
        # - asc: ascending order
        self.sort = sort

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.rule_auth_type is not None:
            result['ruleAuthType'] = self.rule_auth_type
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        if self.rule_status is not None:
            result['ruleStatus'] = self.rule_status
        if self.sort is not None:
            result['sort'] = self.sort
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('ruleAuthType') is not None:
            self.rule_auth_type = m.get('ruleAuthType')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        if m.get('ruleStatus') is not None:
            self.rule_status = m.get('ruleStatus')
        if m.get('sort') is not None:
            self.sort = m.get('sort')
        return self


class DescribeRulePageListResponseBodyResultObjectConsoleAudit(TeaModel):
    def __init__(
        self,
        apply_user_id: str = None,
        apply_user_name: str = None,
        audit_msg: str = None,
        audit_real_user_id: str = None,
        audit_real_user_name: str = None,
        audit_remark: str = None,
        audit_status: str = None,
        audit_time: int = None,
        audit_user_id: str = None,
        audit_user_name: str = None,
        gmt_create: int = None,
        id: int = None,
        relation_ext: str = None,
        relation_id: int = None,
        relation_name: str = None,
        relation_type: str = None,
    ):
        # UID of the user who passed the audit
        self.apply_user_id = apply_user_id
        # Name of the user who passed the audit
        self.apply_user_name = apply_user_name
        # Approval comments
        self.audit_msg = audit_msg
        # UID of the final auditor
        self.audit_real_user_id = audit_real_user_id
        # Name of the final auditor
        self.audit_real_user_name = audit_real_user_name
        # Remarks by the approver.
        self.audit_remark = audit_remark
        # Application audit status
        self.audit_status = audit_status
        # Approval time
        self.audit_time = audit_time
        # UID of the auditor
        self.audit_user_id = audit_user_id
        # Name of the auditor
        self.audit_user_name = audit_user_name
        # Creation time.
        self.gmt_create = gmt_create
        # Primary key ID
        self.id = id
        # Information of other related parties (in JSON format)
        self.relation_ext = relation_ext
        # ID of the related transaction for the approval
        self.relation_id = relation_id
        # Name of the related transaction for the approval (can be null)
        self.relation_name = relation_name
        # Type of the approval (e.g., `rule` represents the approval of a rule)
        self.relation_type = relation_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_user_id is not None:
            result['applyUserId'] = self.apply_user_id
        if self.apply_user_name is not None:
            result['applyUserName'] = self.apply_user_name
        if self.audit_msg is not None:
            result['auditMsg'] = self.audit_msg
        if self.audit_real_user_id is not None:
            result['auditRealUserId'] = self.audit_real_user_id
        if self.audit_real_user_name is not None:
            result['auditRealUserName'] = self.audit_real_user_name
        if self.audit_remark is not None:
            result['auditRemark'] = self.audit_remark
        if self.audit_status is not None:
            result['auditStatus'] = self.audit_status
        if self.audit_time is not None:
            result['auditTime'] = self.audit_time
        if self.audit_user_id is not None:
            result['auditUserId'] = self.audit_user_id
        if self.audit_user_name is not None:
            result['auditUserName'] = self.audit_user_name
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.id is not None:
            result['id'] = self.id
        if self.relation_ext is not None:
            result['relationExt'] = self.relation_ext
        if self.relation_id is not None:
            result['relationId'] = self.relation_id
        if self.relation_name is not None:
            result['relationName'] = self.relation_name
        if self.relation_type is not None:
            result['relationType'] = self.relation_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('applyUserId') is not None:
            self.apply_user_id = m.get('applyUserId')
        if m.get('applyUserName') is not None:
            self.apply_user_name = m.get('applyUserName')
        if m.get('auditMsg') is not None:
            self.audit_msg = m.get('auditMsg')
        if m.get('auditRealUserId') is not None:
            self.audit_real_user_id = m.get('auditRealUserId')
        if m.get('auditRealUserName') is not None:
            self.audit_real_user_name = m.get('auditRealUserName')
        if m.get('auditRemark') is not None:
            self.audit_remark = m.get('auditRemark')
        if m.get('auditStatus') is not None:
            self.audit_status = m.get('auditStatus')
        if m.get('auditTime') is not None:
            self.audit_time = m.get('auditTime')
        if m.get('auditUserId') is not None:
            self.audit_user_id = m.get('auditUserId')
        if m.get('auditUserName') is not None:
            self.audit_user_name = m.get('auditUserName')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('relationExt') is not None:
            self.relation_ext = m.get('relationExt')
        if m.get('relationId') is not None:
            self.relation_id = m.get('relationId')
        if m.get('relationName') is not None:
            self.relation_name = m.get('relationName')
        if m.get('relationType') is not None:
            self.relation_type = m.get('relationType')
        return self


class DescribeRulePageListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        auth_type: str = None,
        console_audit: DescribeRulePageListResponseBodyResultObjectConsoleAudit = None,
        event_code: str = None,
        event_name: str = None,
        event_type: str = None,
        external_rule_name: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        has_new_version: bool = None,
        id: int = None,
        main_rule_id: str = None,
        priority: int = None,
        rule_auth_type: str = None,
        rule_id: str = None,
        rule_memo: str = None,
        rule_name: str = None,
        rule_status: str = None,
        rule_type: str = None,
        rule_version_id: int = None,
        template_id: int = None,
        version: int = None,
    ):
        # Service authorization type
        self.auth_type = auth_type
        # Audit object
        self.console_audit = console_audit
        # Event code.
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Event type
        self.event_type = event_type
        # External name of the rule
        self.external_rule_name = external_rule_name
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time.
        self.gmt_modified = gmt_modified
        # Whether there is a new version
        self.has_new_version = has_new_version
        # Primary key ID of the policy.
        self.id = id
        # Main rule ID
        self.main_rule_id = main_rule_id
        # Policy priority, the higher the number, the higher the priority.
        self.priority = priority
        # Rule type
        self.rule_auth_type = rule_auth_type
        # Policy ID.
        self.rule_id = rule_id
        # Policy description.
        self.rule_memo = rule_memo
        # Policy name.
        self.rule_name = rule_name
        # Policy status.
        self.rule_status = rule_status
        # Rule type
        self.rule_type = rule_type
        # Primary key ID of the rule version.
        self.rule_version_id = rule_version_id
        # Template ID.
        self.template_id = template_id
        # Version number.
        self.version = version

    def validate(self):
        if self.console_audit:
            self.console_audit.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_type is not None:
            result['authType'] = self.auth_type
        if self.console_audit is not None:
            result['consoleAudit'] = self.console_audit.to_map()
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.event_type is not None:
            result['eventType'] = self.event_type
        if self.external_rule_name is not None:
            result['externalRuleName'] = self.external_rule_name
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.has_new_version is not None:
            result['hasNewVersion'] = self.has_new_version
        if self.id is not None:
            result['id'] = self.id
        if self.main_rule_id is not None:
            result['mainRuleId'] = self.main_rule_id
        if self.priority is not None:
            result['priority'] = self.priority
        if self.rule_auth_type is not None:
            result['ruleAuthType'] = self.rule_auth_type
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.rule_memo is not None:
            result['ruleMemo'] = self.rule_memo
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        if self.rule_status is not None:
            result['ruleStatus'] = self.rule_status
        if self.rule_type is not None:
            result['ruleType'] = self.rule_type
        if self.rule_version_id is not None:
            result['ruleVersionId'] = self.rule_version_id
        if self.template_id is not None:
            result['templateId'] = self.template_id
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('authType') is not None:
            self.auth_type = m.get('authType')
        if m.get('consoleAudit') is not None:
            temp_model = DescribeRulePageListResponseBodyResultObjectConsoleAudit()
            self.console_audit = temp_model.from_map(m['consoleAudit'])
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('eventType') is not None:
            self.event_type = m.get('eventType')
        if m.get('externalRuleName') is not None:
            self.external_rule_name = m.get('externalRuleName')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('hasNewVersion') is not None:
            self.has_new_version = m.get('hasNewVersion')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('mainRuleId') is not None:
            self.main_rule_id = m.get('mainRuleId')
        if m.get('priority') is not None:
            self.priority = m.get('priority')
        if m.get('ruleAuthType') is not None:
            self.rule_auth_type = m.get('ruleAuthType')
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('ruleMemo') is not None:
            self.rule_memo = m.get('ruleMemo')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        if m.get('ruleStatus') is not None:
            self.rule_status = m.get('ruleStatus')
        if m.get('ruleType') is not None:
            self.rule_type = m.get('ruleType')
        if m.get('ruleVersionId') is not None:
            self.rule_version_id = m.get('ruleVersionId')
        if m.get('templateId') is not None:
            self.template_id = m.get('templateId')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class DescribeRulePageListResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        request_id: str = None,
        result_object: List[DescribeRulePageListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10.
        self.page_size = page_size
        # Request ID.
        self.request_id = request_id
        # Returned object.
        self.result_object = result_object
        # Total number of items.
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeRulePageListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeRulePageListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRulePageListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRulePageListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRuleSnapshotRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        rule_id: str = None,
        snapshot_version: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id
        # Policy ID
        self.rule_id = rule_id
        # Snapshot version.
        self.snapshot_version = snapshot_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.snapshot_version is not None:
            result['snapshotVersion'] = self.snapshot_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('snapshotVersion') is not None:
            self.snapshot_version = m.get('snapshotVersion')
        return self


class DescribeRuleSnapshotResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        biz_version: str = None,
        event_code: str = None,
        event_name: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        logic_expression: str = None,
        memo: str = None,
        rule_actions: str = None,
        rule_expressions: str = None,
        rule_id: str = None,
        rule_name: str = None,
        rule_status: str = None,
    ):
        # Business version.
        self.biz_version = biz_version
        # Event code
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time.
        self.gmt_modified = gmt_modified
        # Expression for analysis results.
        self.logic_expression = logic_expression
        # Memo.
        self.memo = memo
        # Rule actions.
        self.rule_actions = rule_actions
        # Expression.
        self.rule_expressions = rule_expressions
        # Policy ID
        self.rule_id = rule_id
        # Policy name
        self.rule_name = rule_name
        # Policy status
        self.rule_status = rule_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_version is not None:
            result['bizVersion'] = self.biz_version
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.logic_expression is not None:
            result['logicExpression'] = self.logic_expression
        if self.memo is not None:
            result['memo'] = self.memo
        if self.rule_actions is not None:
            result['ruleActions'] = self.rule_actions
        if self.rule_expressions is not None:
            result['ruleExpressions'] = self.rule_expressions
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        if self.rule_status is not None:
            result['ruleStatus'] = self.rule_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bizVersion') is not None:
            self.biz_version = m.get('bizVersion')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('logicExpression') is not None:
            self.logic_expression = m.get('logicExpression')
        if m.get('memo') is not None:
            self.memo = m.get('memo')
        if m.get('ruleActions') is not None:
            self.rule_actions = m.get('ruleActions')
        if m.get('ruleExpressions') is not None:
            self.rule_expressions = m.get('ruleExpressions')
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        if m.get('ruleStatus') is not None:
            self.rule_status = m.get('ruleStatus')
        return self


class DescribeRuleSnapshotResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeRuleSnapshotResponseBodyResultObject = None,
    ):
        # Request ID
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeRuleSnapshotResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeRuleSnapshotResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRuleSnapshotResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRuleSnapshotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRuleVersionListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        console_rule_id: int = None,
        current_page: int = None,
        page_size: int = None,
        reg_id: str = None,
        rule_id: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Policy primary key ID
        self.console_rule_id = console_rule_id
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id
        # Policy ID
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.console_rule_id is not None:
            result['consoleRuleId'] = self.console_rule_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('consoleRuleId') is not None:
            self.console_rule_id = m.get('consoleRuleId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        return self


class DescribeRuleVersionListResponseBodyResultObjectConsoleAudit(TeaModel):
    def __init__(
        self,
        apply_user_id: str = None,
        apply_user_name: str = None,
        audit_msg: str = None,
        audit_real_user_id: str = None,
        audit_real_user_name: str = None,
        audit_remark: str = None,
        audit_status: str = None,
        audit_time: int = None,
        audit_user_id: str = None,
        audit_user_name: str = None,
        gmt_create: int = None,
        id: int = None,
        relation_ext: str = None,
        relation_id: int = None,
        relation_name: str = None,
        relation_type: str = None,
    ):
        # Initiator UID
        self.apply_user_id = apply_user_id
        # Initiator name
        self.apply_user_name = apply_user_name
        # Approval comment
        self.audit_msg = audit_msg
        # Final approver UID
        self.audit_real_user_id = audit_real_user_id
        # Final approver name
        self.audit_real_user_name = audit_real_user_name
        # Approver\\"s remarks.
        self.audit_remark = audit_remark
        # Approval status
        self.audit_status = audit_status
        # Approval time.
        self.audit_time = audit_time
        # Designated approver UID
        self.audit_user_id = audit_user_id
        # Designated auditor\\"s name
        self.audit_user_name = audit_user_name
        # Creation time.
        self.gmt_create = gmt_create
        # Primary key ID
        self.id = id
        # Information of related others (in JSON format)
        self.relation_ext = relation_ext
        # ID of the associated transaction
        self.relation_id = relation_id
        # Name of the associated item
        self.relation_name = relation_name
        # Type of approval (e.g., `rule` for policy approval)
        self.relation_type = relation_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_user_id is not None:
            result['applyUserId'] = self.apply_user_id
        if self.apply_user_name is not None:
            result['applyUserName'] = self.apply_user_name
        if self.audit_msg is not None:
            result['auditMsg'] = self.audit_msg
        if self.audit_real_user_id is not None:
            result['auditRealUserId'] = self.audit_real_user_id
        if self.audit_real_user_name is not None:
            result['auditRealUserName'] = self.audit_real_user_name
        if self.audit_remark is not None:
            result['auditRemark'] = self.audit_remark
        if self.audit_status is not None:
            result['auditStatus'] = self.audit_status
        if self.audit_time is not None:
            result['auditTime'] = self.audit_time
        if self.audit_user_id is not None:
            result['auditUserId'] = self.audit_user_id
        if self.audit_user_name is not None:
            result['auditUserName'] = self.audit_user_name
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.id is not None:
            result['id'] = self.id
        if self.relation_ext is not None:
            result['relationExt'] = self.relation_ext
        if self.relation_id is not None:
            result['relationId'] = self.relation_id
        if self.relation_name is not None:
            result['relationName'] = self.relation_name
        if self.relation_type is not None:
            result['relationType'] = self.relation_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('applyUserId') is not None:
            self.apply_user_id = m.get('applyUserId')
        if m.get('applyUserName') is not None:
            self.apply_user_name = m.get('applyUserName')
        if m.get('auditMsg') is not None:
            self.audit_msg = m.get('auditMsg')
        if m.get('auditRealUserId') is not None:
            self.audit_real_user_id = m.get('auditRealUserId')
        if m.get('auditRealUserName') is not None:
            self.audit_real_user_name = m.get('auditRealUserName')
        if m.get('auditRemark') is not None:
            self.audit_remark = m.get('auditRemark')
        if m.get('auditStatus') is not None:
            self.audit_status = m.get('auditStatus')
        if m.get('auditTime') is not None:
            self.audit_time = m.get('auditTime')
        if m.get('auditUserId') is not None:
            self.audit_user_id = m.get('auditUserId')
        if m.get('auditUserName') is not None:
            self.audit_user_name = m.get('auditUserName')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('relationExt') is not None:
            self.relation_ext = m.get('relationExt')
        if m.get('relationId') is not None:
            self.relation_id = m.get('relationId')
        if m.get('relationName') is not None:
            self.relation_name = m.get('relationName')
        if m.get('relationType') is not None:
            self.relation_type = m.get('relationType')
        return self


class DescribeRuleVersionListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        console_audit: DescribeRuleVersionListResponseBodyResultObjectConsoleAudit = None,
        console_rule_id: int = None,
        console_rule_memo: str = None,
        console_rule_name: str = None,
        event_code: str = None,
        event_type: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        last_operator: str = None,
        priority: int = None,
        rule_id: str = None,
        rule_status: str = None,
        rule_type: str = None,
        version: int = None,
    ):
        # Audit object
        self.console_audit = console_audit
        # Console rule ID.
        self.console_rule_id = console_rule_id
        # Associated policy remarks
        self.console_rule_memo = console_rule_memo
        # Associated policy name
        self.console_rule_name = console_rule_name
        # Event code
        self.event_code = event_code
        # Event type
        self.event_type = event_type
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time.
        self.gmt_modified = gmt_modified
        # Primary key ID of the policy
        self.id = id
        # The user who last operated.
        self.last_operator = last_operator
        # Policy priority, the higher the number, the higher the priority.
        self.priority = priority
        # Policy ID
        self.rule_id = rule_id
        # Policy status
        self.rule_status = rule_status
        # Rule Type
        self.rule_type = rule_type
        # Version number
        self.version = version

    def validate(self):
        if self.console_audit:
            self.console_audit.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.console_audit is not None:
            result['consoleAudit'] = self.console_audit.to_map()
        if self.console_rule_id is not None:
            result['consoleRuleId'] = self.console_rule_id
        if self.console_rule_memo is not None:
            result['consoleRuleMemo'] = self.console_rule_memo
        if self.console_rule_name is not None:
            result['consoleRuleName'] = self.console_rule_name
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_type is not None:
            result['eventType'] = self.event_type
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.last_operator is not None:
            result['lastOperator'] = self.last_operator
        if self.priority is not None:
            result['priority'] = self.priority
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.rule_status is not None:
            result['ruleStatus'] = self.rule_status
        if self.rule_type is not None:
            result['ruleType'] = self.rule_type
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('consoleAudit') is not None:
            temp_model = DescribeRuleVersionListResponseBodyResultObjectConsoleAudit()
            self.console_audit = temp_model.from_map(m['consoleAudit'])
        if m.get('consoleRuleId') is not None:
            self.console_rule_id = m.get('consoleRuleId')
        if m.get('consoleRuleMemo') is not None:
            self.console_rule_memo = m.get('consoleRuleMemo')
        if m.get('consoleRuleName') is not None:
            self.console_rule_name = m.get('consoleRuleName')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventType') is not None:
            self.event_type = m.get('eventType')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('lastOperator') is not None:
            self.last_operator = m.get('lastOperator')
        if m.get('priority') is not None:
            self.priority = m.get('priority')
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('ruleStatus') is not None:
            self.rule_status = m.get('ruleStatus')
        if m.get('ruleType') is not None:
            self.rule_type = m.get('ruleType')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class DescribeRuleVersionListResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        request_id: str = None,
        result_object: List[DescribeRuleVersionListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10
        self.page_size = page_size
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object
        # Total number of items
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeRuleVersionListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeRuleVersionListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRuleVersionListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRuleVersionListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSDKDownloadListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        device_type: str = None,
        list_type: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Device type.
        self.device_type = device_type
        # Download type
        self.list_type = list_type
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.device_type is not None:
            result['deviceType'] = self.device_type
        if self.list_type is not None:
            result['listType'] = self.list_type
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('deviceType') is not None:
            self.device_type = m.get('deviceType')
        if m.get('listType') is not None:
            self.list_type = m.get('listType')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeSDKDownloadListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        description: str = None,
        developer: str = None,
        device_type: str = None,
        download_url: str = None,
        md_5: str = None,
        package_name: str = None,
        privacy_link: str = None,
        push_time: str = None,
        sdk_version: str = None,
        size: str = None,
    ):
        # Description information.
        self.description = description
        # Developer
        self.developer = developer
        # Device type.
        self.device_type = device_type
        # Download URL.
        self.download_url = download_url
        # File MD5.
        self.md_5 = md_5
        # Package name
        self.package_name = package_name
        # Risk recognition SDK privacy policy link
        self.privacy_link = privacy_link
        # Release time
        self.push_time = push_time
        # SDK version.
        self.sdk_version = sdk_version
        # Size
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.developer is not None:
            result['developer'] = self.developer
        if self.device_type is not None:
            result['deviceType'] = self.device_type
        if self.download_url is not None:
            result['downloadUrl'] = self.download_url
        if self.md_5 is not None:
            result['md5'] = self.md_5
        if self.package_name is not None:
            result['packageName'] = self.package_name
        if self.privacy_link is not None:
            result['privacyLink'] = self.privacy_link
        if self.push_time is not None:
            result['pushTime'] = self.push_time
        if self.sdk_version is not None:
            result['sdkVersion'] = self.sdk_version
        if self.size is not None:
            result['size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('developer') is not None:
            self.developer = m.get('developer')
        if m.get('deviceType') is not None:
            self.device_type = m.get('deviceType')
        if m.get('downloadUrl') is not None:
            self.download_url = m.get('downloadUrl')
        if m.get('md5') is not None:
            self.md_5 = m.get('md5')
        if m.get('packageName') is not None:
            self.package_name = m.get('packageName')
        if m.get('privacyLink') is not None:
            self.privacy_link = m.get('privacyLink')
        if m.get('pushTime') is not None:
            self.push_time = m.get('pushTime')
        if m.get('sdkVersion') is not None:
            self.sdk_version = m.get('sdkVersion')
        if m.get('size') is not None:
            self.size = m.get('size')
        return self


class DescribeSDKDownloadListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeSDKDownloadListResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeSDKDownloadListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeSDKDownloadListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSDKDownloadListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSDKDownloadListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSafConsoleRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        content: str = None,
        service: str = None,
    ):
        self.lang = lang
        self.content = content
        # This parameter is required.
        self.service = service

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.content is not None:
            result['content'] = self.content
        if self.service is not None:
            result['service'] = self.service
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('service') is not None:
            self.service = m.get('service')
        return self


class DescribeSafConsoleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        biz_data: List[str] = None,
    ):
        self.request_id = request_id
        self.biz_data = biz_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.biz_data is not None:
            result['bizData'] = self.biz_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('bizData') is not None:
            self.biz_data = m.get('bizData')
        return self


class DescribeSafConsoleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSafConsoleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSafConsoleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSafDeOrderRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        current_page: int = None,
        end_date: str = None,
        page_size: int = None,
        reg_id: str = None,
        start_date: str = None,
    ):
        # Set the language type for request and response messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Current page number.
        self.current_page = current_page
        # End date
        self.end_date = end_date
        # Page size, default value is 10
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id
        # Start date.
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.end_date is not None:
            result['endDate'] = self.end_date
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.start_date is not None:
            result['startDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('endDate') is not None:
            self.end_date = m.get('endDate')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('startDate') is not None:
            self.start_date = m.get('startDate')
        return self


class DescribeSafDeOrderResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        expiration_date: int = None,
        open_user_type: int = None,
    ):
        # Expiration time
        self.expiration_date = expiration_date
        # Based on the product type subscribed by the customer, the console permissions are divided into three categories:
        # 
        #      1. New Customer: Has not purchased/subscribed to any service.
        #      2. Old Customer (Subscription): Customers who have purchased the SAF product.
        #      3. Pay-As-You-Go: Customers who have purchased the SAF_BAG product or activated SAF_POS.
        self.open_user_type = open_user_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expiration_date is not None:
            result['expirationDate'] = self.expiration_date
        if self.open_user_type is not None:
            result['openUserType'] = self.open_user_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('expirationDate') is not None:
            self.expiration_date = m.get('expirationDate')
        if m.get('openUserType') is not None:
            self.open_user_type = m.get('openUserType')
        return self


class DescribeSafDeOrderResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeSafDeOrderResponseBodyResultObject = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeSafDeOrderResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeSafDeOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSafDeOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSafDeOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSafOrderRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        current_page: int = None,
        end_date: str = None,
        exact_product_code: str = None,
        page_size: int = None,
        reg_id: str = None,
        start_date: str = None,
    ):
        # Set the language type for request and response, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Current page number.
        self.current_page = current_page
        # End date.
        self.end_date = end_date
        # Product code.
        self.exact_product_code = exact_product_code
        # Page size, default value is 10.
        self.page_size = page_size
        # Region code.
        self.reg_id = reg_id
        # Start time.
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.end_date is not None:
            result['endDate'] = self.end_date
        if self.exact_product_code is not None:
            result['exactProductCode'] = self.exact_product_code
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.start_date is not None:
            result['startDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('endDate') is not None:
            self.end_date = m.get('endDate')
        if m.get('exactProductCode') is not None:
            self.exact_product_code = m.get('exactProductCode')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('startDate') is not None:
            self.start_date = m.get('startDate')
        return self


class DescribeSafOrderResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        expiration_date: int = None,
    ):
        # Expiration date (timestamp).
        self.expiration_date = expiration_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expiration_date is not None:
            result['expirationDate'] = self.expiration_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('expirationDate') is not None:
            self.expiration_date = m.get('expirationDate')
        return self


class DescribeSafOrderResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeSafOrderResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object.
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeSafOrderResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeSafOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSafOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSafOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSafStartConfigRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeSafStartConfigResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        device_types: List[str] = None,
        event_codes: List[str] = None,
        languages: List[str] = None,
        server_regions: List[str] = None,
    ):
        # List of device types.
        self.device_types = device_types
        # Event codes.
        self.event_codes = event_codes
        # Configuration language details.
        self.languages = languages
        # Server region
        self.server_regions = server_regions

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_types is not None:
            result['deviceTypes'] = self.device_types
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.languages is not None:
            result['languages'] = self.languages
        if self.server_regions is not None:
            result['serverRegions'] = self.server_regions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('deviceTypes') is not None:
            self.device_types = m.get('deviceTypes')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('languages') is not None:
            self.languages = m.get('languages')
        if m.get('serverRegions') is not None:
            self.server_regions = m.get('serverRegions')
        return self


class DescribeSafStartConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeSafStartConfigResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeSafStartConfigResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeSafStartConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSafStartConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSafStartConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSafStartStepsRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        aliyun_server: bool = None,
        device_types_str: str = None,
        event_code: str = None,
        language: str = None,
        reg_id: str = None,
        server_region: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Whether the server is an Alibaba Cloud server
        # 
        # true or false
        self.aliyun_server = aliyun_server
        # Used to receive a collection of strings from the frontend that POP cannot accept
        #      
        # Device type
        self.device_types_str = device_types_str
        # Event code
        self.event_code = event_code
        # Language, parameters can be passed
        # - zh-CN: Chinese (default)
        # - en-US: English
        self.language = language
        # Region code
        self.reg_id = reg_id
        # Server region
        self.server_region = server_region

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.aliyun_server is not None:
            result['aliyunServer'] = self.aliyun_server
        if self.device_types_str is not None:
            result['deviceTypesStr'] = self.device_types_str
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.language is not None:
            result['language'] = self.language
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.server_region is not None:
            result['serverRegion'] = self.server_region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('aliyunServer') is not None:
            self.aliyun_server = m.get('aliyunServer')
        if m.get('deviceTypesStr') is not None:
            self.device_types_str = m.get('deviceTypesStr')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('language') is not None:
            self.language = m.get('language')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('serverRegion') is not None:
            self.server_region = m.get('serverRegion')
        return self


class DescribeSafStartStepsResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        content: str = None,
        id: str = None,
        type: str = None,
    ):
        # Step content
        self.content = content
        # Step title
        self.id = id
        # Type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.id is not None:
            result['id'] = self.id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeSafStartStepsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeSafStartStepsResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeSafStartStepsResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeSafStartStepsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSafStartStepsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSafStartStepsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSafTagListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        tag_name: str = None,
        api_id: str = None,
        current_page: str = None,
        page_size: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Tag name. Fuzzy search.
        self.tag_name = tag_name
        # API service ID.
        self.api_id = api_id
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10.
        self.page_size = page_size
        # Region code.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.tag_name is not None:
            result['TagName'] = self.tag_name
        if self.api_id is not None:
            result['apiId'] = self.api_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('TagName') is not None:
            self.tag_name = m.get('TagName')
        if m.get('apiId') is not None:
            self.api_id = m.get('apiId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeSafTagListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        tag_desc: str = None,
        tag_mean: str = None,
        tag_name: str = None,
        tag_state: str = None,
        tag_type: str = None,
        tag_uid: str = None,
        update_time: str = None,
    ):
        # Tag description.
        self.tag_desc = tag_desc
        # Tag meaning.
        self.tag_mean = tag_mean
        # Tag name.
        self.tag_name = tag_name
        # Tag identifier.
        self.tag_state = tag_state
        # Tag type.
        self.tag_type = tag_type
        # Unique identifier of the tag key.
        self.tag_uid = tag_uid
        # Update time.
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_desc is not None:
            result['tagDesc'] = self.tag_desc
        if self.tag_mean is not None:
            result['tagMean'] = self.tag_mean
        if self.tag_name is not None:
            result['tagName'] = self.tag_name
        if self.tag_state is not None:
            result['tagState'] = self.tag_state
        if self.tag_type is not None:
            result['tagType'] = self.tag_type
        if self.tag_uid is not None:
            result['tagUid'] = self.tag_uid
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tagDesc') is not None:
            self.tag_desc = m.get('tagDesc')
        if m.get('tagMean') is not None:
            self.tag_mean = m.get('tagMean')
        if m.get('tagName') is not None:
            self.tag_name = m.get('tagName')
        if m.get('tagState') is not None:
            self.tag_state = m.get('tagState')
        if m.get('tagType') is not None:
            self.tag_type = m.get('tagType')
        if m.get('tagUid') is not None:
            self.tag_uid = m.get('tagUid')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        return self


class DescribeSafTagListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeSafTagListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10.
        self.page_size = page_size
        # Returned object.
        self.result_object = result_object
        # Total number of items.
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeSafTagListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeSafTagListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSafTagListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSafTagListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSampleBatchOssPolicyRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        batch_name: str = None,
        reg_id: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Sample batch name
        self.batch_name = batch_name
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.batch_name is not None:
            result['batchName'] = self.batch_name
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('batchName') is not None:
            self.batch_name = m.get('batchName')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeSampleBatchOssPolicyResponseBody(TeaModel):
    def __init__(
        self,
        access_id: str = None,
        host: str = None,
        key: str = None,
        policy: str = None,
        request_id: str = None,
        signature: str = None,
    ):
        # OSS Access ID
        self.access_id = access_id
        # OSS Domain
        self.host = host
        # Key required for file upload.
        self.key = key
        # OSS Security Policy
        self.policy = policy
        # ID of the request
        self.request_id = request_id
        # OSS Signature
        self.signature = signature

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_id is not None:
            result['AccessId'] = self.access_id
        if self.host is not None:
            result['Host'] = self.host
        if self.key is not None:
            result['Key'] = self.key
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.signature is not None:
            result['Signature'] = self.signature
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessId') is not None:
            self.access_id = m.get('AccessId')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Signature') is not None:
            self.signature = m.get('Signature')
        return self


class DescribeSampleBatchOssPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSampleBatchOssPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSampleBatchOssPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSampleDataByBatchUUidPageRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        batch_uuid: str = None,
        current_page: int = None,
        data_value: str = None,
        page_size: int = None,
        reg_id: str = None,
        update_begin_time: int = None,
        update_end_time: int = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Sample batch UUID
        self.batch_uuid = batch_uuid
        # Current page number.
        self.current_page = current_page
        # Content of the list entered in the text box
        self.data_value = data_value
        # Page size, default value is 10
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id
        # Start time
        self.update_begin_time = update_begin_time
        # End time
        self.update_end_time = update_end_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.batch_uuid is not None:
            result['batchUuid'] = self.batch_uuid
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.data_value is not None:
            result['dataValue'] = self.data_value
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.update_begin_time is not None:
            result['updateBeginTime'] = self.update_begin_time
        if self.update_end_time is not None:
            result['updateEndTime'] = self.update_end_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('batchUuid') is not None:
            self.batch_uuid = m.get('batchUuid')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('dataValue') is not None:
            self.data_value = m.get('dataValue')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('updateBeginTime') is not None:
            self.update_begin_time = m.get('updateBeginTime')
        if m.get('updateEndTime') is not None:
            self.update_end_time = m.get('updateEndTime')
        return self


class DescribeSampleDataByBatchUUidPageResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        batch_name: str = None,
        creator: str = None,
        data_tag_type: str = None,
        data_value: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        last_source_type: str = None,
        uuid: str = None,
        version: int = None,
    ):
        # Sample batch name
        self.batch_name = batch_name
        # Creator
        self.creator = creator
        # Sample type
        self.data_tag_type = data_tag_type
        # Data content
        self.data_value = data_value
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time
        self.gmt_modified = gmt_modified
        # Last source
        self.last_source_type = last_source_type
        # Sample batch UUID
        self.uuid = uuid
        # Version
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_name is not None:
            result['batchName'] = self.batch_name
        if self.creator is not None:
            result['creator'] = self.creator
        if self.data_tag_type is not None:
            result['dataTagType'] = self.data_tag_type
        if self.data_value is not None:
            result['dataValue'] = self.data_value
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.last_source_type is not None:
            result['lastSourceType'] = self.last_source_type
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('batchName') is not None:
            self.batch_name = m.get('batchName')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('dataTagType') is not None:
            self.data_tag_type = m.get('dataTagType')
        if m.get('dataValue') is not None:
            self.data_value = m.get('dataValue')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('lastSourceType') is not None:
            self.last_source_type = m.get('lastSourceType')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class DescribeSampleDataByBatchUUidPageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeSampleDataByBatchUUidPageResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # ID of the request
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10
        self.page_size = page_size
        # Returned object
        self.result_object = result_object
        # Total number of items
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeSampleDataByBatchUUidPageResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeSampleDataByBatchUUidPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSampleDataByBatchUUidPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSampleDataByBatchUUidPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSampleDataListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        current_page: str = None,
        delete_tag: str = None,
        page_size: str = None,
        query_content: str = None,
        reg_id: str = None,
        sample_id: int = None,
        scene: str = None,
        status: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Current page number.
        self.current_page = current_page
        # Deletion status
        self.delete_tag = delete_tag
        # Page size, default value is 10.
        self.page_size = page_size
        # Query content
        self.query_content = query_content
        # Region code
        self.reg_id = reg_id
        # Sample ID.
        self.sample_id = sample_id
        # Scene
        self.scene = scene
        # Status.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.delete_tag is not None:
            result['deleteTag'] = self.delete_tag
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.query_content is not None:
            result['queryContent'] = self.query_content
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.sample_id is not None:
            result['sampleId'] = self.sample_id
        if self.scene is not None:
            result['scene'] = self.scene
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('deleteTag') is not None:
            self.delete_tag = m.get('deleteTag')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('queryContent') is not None:
            self.query_content = m.get('queryContent')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('sampleId') is not None:
            self.sample_id = m.get('sampleId')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class DescribeSampleDataListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        classification_type: str = None,
        data_distributed: str = None,
        data_title: str = None,
        delete_tag: str = None,
        description: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        name: str = None,
        normal_size: int = None,
        recall_config: str = None,
        risk_size: int = None,
        risk_value: str = None,
        sample_label_detail: str = None,
        sample_size: int = None,
        scene: str = None,
        status: str = None,
        store_path: str = None,
        store_type: str = None,
        support_recall: str = None,
        user_id: int = None,
        version: int = None,
    ):
        # Classification type, binary or multi-class.
        self.classification_type = classification_type
        # Criterion value for sample data calculation
        self.data_distributed = data_distributed
        # First row of sample data. Used to define the values of each column.
        self.data_title = data_title
        # Deletion tag.
        self.delete_tag = delete_tag
        # Description information.
        self.description = description
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time.
        self.gmt_modified = gmt_modified
        # Primary key ID
        self.id = id
        # Name
        self.name = name
        # Number of normal samples
        self.normal_size = normal_size
        # Recall configuration
        self.recall_config = recall_config
        # Number of risk samples
        self.risk_size = risk_size
        # Specified risk value
        self.risk_value = risk_value
        # Sample label details
        self.sample_label_detail = sample_label_detail
        # Sample size
        self.sample_size = sample_size
        # Scene code
        self.scene = scene
        # Status.
        self.status = status
        # Storage path
        self.store_path = store_path
        # Storage type
        self.store_type = store_type
        # Whether recall is supported
        self.support_recall = support_recall
        # User UID
        self.user_id = user_id
        # Version
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.classification_type is not None:
            result['classificationType'] = self.classification_type
        if self.data_distributed is not None:
            result['dataDistributed'] = self.data_distributed
        if self.data_title is not None:
            result['dataTitle'] = self.data_title
        if self.delete_tag is not None:
            result['deleteTag'] = self.delete_tag
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.normal_size is not None:
            result['normalSize'] = self.normal_size
        if self.recall_config is not None:
            result['recallConfig'] = self.recall_config
        if self.risk_size is not None:
            result['riskSize'] = self.risk_size
        if self.risk_value is not None:
            result['riskValue'] = self.risk_value
        if self.sample_label_detail is not None:
            result['sampleLabelDetail'] = self.sample_label_detail
        if self.sample_size is not None:
            result['sampleSize'] = self.sample_size
        if self.scene is not None:
            result['scene'] = self.scene
        if self.status is not None:
            result['status'] = self.status
        if self.store_path is not None:
            result['storePath'] = self.store_path
        if self.store_type is not None:
            result['storeType'] = self.store_type
        if self.support_recall is not None:
            result['supportRecall'] = self.support_recall
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('classificationType') is not None:
            self.classification_type = m.get('classificationType')
        if m.get('dataDistributed') is not None:
            self.data_distributed = m.get('dataDistributed')
        if m.get('dataTitle') is not None:
            self.data_title = m.get('dataTitle')
        if m.get('deleteTag') is not None:
            self.delete_tag = m.get('deleteTag')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('normalSize') is not None:
            self.normal_size = m.get('normalSize')
        if m.get('recallConfig') is not None:
            self.recall_config = m.get('recallConfig')
        if m.get('riskSize') is not None:
            self.risk_size = m.get('riskSize')
        if m.get('riskValue') is not None:
            self.risk_value = m.get('riskValue')
        if m.get('sampleLabelDetail') is not None:
            self.sample_label_detail = m.get('sampleLabelDetail')
        if m.get('sampleSize') is not None:
            self.sample_size = m.get('sampleSize')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('storePath') is not None:
            self.store_path = m.get('storePath')
        if m.get('storeType') is not None:
            self.store_type = m.get('storeType')
        if m.get('supportRecall') is not None:
            self.support_recall = m.get('supportRecall')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class DescribeSampleDataListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeSampleDataListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10.
        self.page_size = page_size
        # Returned object
        self.result_object = result_object
        # Total number of items.
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeSampleDataListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeSampleDataListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSampleDataListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSampleDataListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSampleDataPageRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        current_page: int = None,
        data_value: str = None,
        page_size: int = None,
        reg_id: str = None,
        update_begin_time: int = None,
        update_end_time: int = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Current page number.
        self.current_page = current_page
        # Content of the list entered in the text box
        self.data_value = data_value
        # Page size, default value is 10
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id
        # Start time
        self.update_begin_time = update_begin_time
        # End time
        self.update_end_time = update_end_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.data_value is not None:
            result['dataValue'] = self.data_value
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.update_begin_time is not None:
            result['updateBeginTime'] = self.update_begin_time
        if self.update_end_time is not None:
            result['updateEndTime'] = self.update_end_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('dataValue') is not None:
            self.data_value = m.get('dataValue')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('updateBeginTime') is not None:
            self.update_begin_time = m.get('updateBeginTime')
        if m.get('updateEndTime') is not None:
            self.update_end_time = m.get('updateEndTime')
        return self


class DescribeSampleDataPageResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        creator: str = None,
        data_tag_type: str = None,
        data_value: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        last_source_type: str = None,
        updator: str = None,
        uuid: str = None,
        version: int = None,
    ):
        # Creator
        self.creator = creator
        # Sample type
        self.data_tag_type = data_tag_type
        # Content of the list entered in the text box
        self.data_value = data_value
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time
        self.gmt_modified = gmt_modified
        # Last source
        self.last_source_type = last_source_type
        # Modifier
        self.updator = updator
        # UUID of the sample batch
        self.uuid = uuid
        # Version number
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator is not None:
            result['creator'] = self.creator
        if self.data_tag_type is not None:
            result['dataTagType'] = self.data_tag_type
        if self.data_value is not None:
            result['dataValue'] = self.data_value
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.last_source_type is not None:
            result['lastSourceType'] = self.last_source_type
        if self.updator is not None:
            result['updator'] = self.updator
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('dataTagType') is not None:
            self.data_tag_type = m.get('dataTagType')
        if m.get('dataValue') is not None:
            self.data_value = m.get('dataValue')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('lastSourceType') is not None:
            self.last_source_type = m.get('lastSourceType')
        if m.get('updator') is not None:
            self.updator = m.get('updator')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class DescribeSampleDataPageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeSampleDataPageResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # ID of the request
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Number of items per page, default is 10.
        self.page_size = page_size
        # Returned object
        self.result_object = result_object
        # Total number of items
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeSampleDataPageResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeSampleDataPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSampleDataPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSampleDataPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSampleDemoDownloadUrlRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        scene: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id
        # Scene code
        # 
        # This parameter is required.
        self.scene = scene

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.scene is not None:
            result['scene'] = self.scene
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        return self


class DescribeSampleDemoDownloadUrlResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeSampleDemoDownloadUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSampleDemoDownloadUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSampleDemoDownloadUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSampleDownloadUrlRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        sample_id: int = None,
    ):
        # Set the language type for request and response, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id
        # Sample ID.
        # 
        # This parameter is required.
        self.sample_id = sample_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.sample_id is not None:
            result['sampleId'] = self.sample_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('sampleId') is not None:
            self.sample_id = m.get('sampleId')
        return self


class DescribeSampleDownloadUrlResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeSampleDownloadUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSampleDownloadUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSampleDownloadUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSampleInfoRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        id: int = None,
        reg_id: str = None,
        versions: int = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Primary key ID
        self.id = id
        # Region code
        self.reg_id = reg_id
        # Version number.
        self.versions = versions

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.versions is not None:
            result['versions'] = self.versions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('versions') is not None:
            self.versions = m.get('versions')
        return self


class DescribeSampleInfoResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        id: int = None,
        sample_tags: str = None,
        sample_type: str = None,
        sample_value: str = None,
        update_time: str = None,
        version: int = None,
    ):
        # Primary key ID
        self.id = id
        # Sample tags.
        self.sample_tags = sample_tags
        # Sample type
        self.sample_type = sample_type
        # Sample value.
        self.sample_value = sample_value
        # Update time.
        self.update_time = update_time
        # Version number.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.sample_tags is not None:
            result['sampleTags'] = self.sample_tags
        if self.sample_type is not None:
            result['sampleType'] = self.sample_type
        if self.sample_value is not None:
            result['sampleValue'] = self.sample_value
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('sampleTags') is not None:
            self.sample_tags = m.get('sampleTags')
        if m.get('sampleType') is not None:
            self.sample_type = m.get('sampleType')
        if m.get('sampleValue') is not None:
            self.sample_value = m.get('sampleValue')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class DescribeSampleInfoResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeSampleInfoResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeSampleInfoResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeSampleInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSampleInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSampleInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSampleListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        current_page: int = None,
        page_size: int = None,
        reg_id: str = None,
        sample_type: str = None,
        sample_value: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Current page number.
        self.current_page = current_page
        # Page size, with a default value of 10
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id
        # Sample type
        self.sample_type = sample_type
        # Sample data value.
        self.sample_value = sample_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.sample_type is not None:
            result['sampleType'] = self.sample_type
        if self.sample_value is not None:
            result['sampleValue'] = self.sample_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('sampleType') is not None:
            self.sample_type = m.get('sampleType')
        if m.get('sampleValue') is not None:
            self.sample_value = m.get('sampleValue')
        return self


class DescribeSampleListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        id: int = None,
        sample_tags: str = None,
        sample_type: int = None,
        sample_value: str = None,
        update_time: int = None,
        version: int = None,
    ):
        # Database ID.
        self.id = id
        # Sample tags.
        self.sample_tags = sample_tags
        # Sample type
        self.sample_type = sample_type
        # Sample value.
        self.sample_value = sample_value
        # Update time.
        self.update_time = update_time
        # Version number.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.sample_tags is not None:
            result['sampleTags'] = self.sample_tags
        if self.sample_type is not None:
            result['sampleType'] = self.sample_type
        if self.sample_value is not None:
            result['sampleValue'] = self.sample_value
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('sampleTags') is not None:
            self.sample_tags = m.get('sampleTags')
        if m.get('sampleType') is not None:
            self.sample_type = m.get('sampleType')
        if m.get('sampleValue') is not None:
            self.sample_value = m.get('sampleValue')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class DescribeSampleListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeSampleListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, with a default value of 10
        self.page_size = page_size
        # Returned object
        self.result_object = result_object
        # Total count.
        self.total_item = total_item
        # Total pages
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeSampleListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeSampleListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSampleListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSampleListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSampleSceneListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Set the language type for request and response messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeSampleSceneListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        biz_type: str = None,
        config_key: str = None,
        config_value: str = None,
        creator: str = None,
        description: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        last_modified_operator: str = None,
        status: str = None,
    ):
        # Business type.
        self.biz_type = biz_type
        # Configuration key.
        self.config_key = config_key
        # Configuration value.
        self.config_value = config_value
        # Creator.
        self.creator = creator
        # Description information.
        self.description = description
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time.
        self.gmt_modified = gmt_modified
        # Task ID.
        self.id = id
        # Last modified by.
        self.last_modified_operator = last_modified_operator
        # Status.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_type is not None:
            result['bizType'] = self.biz_type
        if self.config_key is not None:
            result['configKey'] = self.config_key
        if self.config_value is not None:
            result['configValue'] = self.config_value
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.last_modified_operator is not None:
            result['lastModifiedOperator'] = self.last_modified_operator
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bizType') is not None:
            self.biz_type = m.get('bizType')
        if m.get('configKey') is not None:
            self.config_key = m.get('configKey')
        if m.get('configValue') is not None:
            self.config_value = m.get('configValue')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('lastModifiedOperator') is not None:
            self.last_modified_operator = m.get('lastModifiedOperator')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class DescribeSampleSceneListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeSampleSceneListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10.
        self.page_size = page_size
        # Returned object.
        self.result_object = result_object
        # Total number of items.
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeSampleSceneListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeSampleSceneListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSampleSceneListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSampleSceneListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSampleTagListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and responses, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeSampleTagListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeSampleTagListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSampleTagListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSampleTagListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSampleUploadPolicyRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Set the language type for request and response messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeSampleUploadPolicyResponseBody(TeaModel):
    def __init__(
        self,
        access_id: str = None,
        host: str = None,
        key: str = None,
        policy: str = None,
        request_id: str = None,
        signature: str = None,
        sts_token: str = None,
    ):
        # OSS access key ID.
        self.access_id = access_id
        # OSS domain name.
        self.host = host
        # The key of OSS upload policy.
        self.key = key
        # OSS upload policy.
        self.policy = policy
        # Request ID.
        self.request_id = request_id
        # Signature information.
        self.signature = signature
        # Temporary identity credential.
        self.sts_token = sts_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_id is not None:
            result['AccessId'] = self.access_id
        if self.host is not None:
            result['Host'] = self.host
        if self.key is not None:
            result['Key'] = self.key
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.signature is not None:
            result['Signature'] = self.signature
        if self.sts_token is not None:
            result['StsToken'] = self.sts_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessId') is not None:
            self.access_id = m.get('AccessId')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Signature') is not None:
            self.signature = m.get('Signature')
        if m.get('StsToken') is not None:
            self.sts_token = m.get('StsToken')
        return self


class DescribeSampleUploadPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSampleUploadPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSampleUploadPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSamplebatchPageRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        current_page: int = None,
        data_value: str = None,
        page_size: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Current page number.
        self.current_page = current_page
        # Content of the list entered in the text box
        self.data_value = data_value
        # Page size, with a default value of 10
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.data_value is not None:
            result['dataValue'] = self.data_value
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('dataValue') is not None:
            self.data_value = m.get('dataValue')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeSamplebatchPageResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        batch_name: str = None,
        creator: str = None,
        data_type: str = None,
        description: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        init_valid_file_row: int = None,
        sample_batch_type: str = None,
        services: str = None,
        updator: str = None,
        uuid: str = None,
    ):
        # Sample batch name
        self.batch_name = batch_name
        # Creator.
        self.creator = creator
        # Data type
        self.data_type = data_type
        # Description.
        self.description = description
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time
        self.gmt_modified = gmt_modified
        # Valid sample content data
        self.init_valid_file_row = init_valid_file_row
        # Specific type of the sample list
        self.sample_batch_type = sample_batch_type
        # Service ID
        self.services = services
        # Modifier
        self.updator = updator
        # Sample batch UUID
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_name is not None:
            result['batchName'] = self.batch_name
        if self.creator is not None:
            result['creator'] = self.creator
        if self.data_type is not None:
            result['dataType'] = self.data_type
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.init_valid_file_row is not None:
            result['initValidFileRow'] = self.init_valid_file_row
        if self.sample_batch_type is not None:
            result['sampleBatchType'] = self.sample_batch_type
        if self.services is not None:
            result['services'] = self.services
        if self.updator is not None:
            result['updator'] = self.updator
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('batchName') is not None:
            self.batch_name = m.get('batchName')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('dataType') is not None:
            self.data_type = m.get('dataType')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('initValidFileRow') is not None:
            self.init_valid_file_row = m.get('initValidFileRow')
        if m.get('sampleBatchType') is not None:
            self.sample_batch_type = m.get('sampleBatchType')
        if m.get('services') is not None:
            self.services = m.get('services')
        if m.get('updator') is not None:
            self.updator = m.get('updator')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class DescribeSamplebatchPageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeSamplebatchPageResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # ID of the request
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, with a default value of 10
        self.page_size = page_size
        # Returned object
        self.result_object = result_object
        # Total number of items
        self.total_item = total_item
        # Total number of pages
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeSamplebatchPageResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeSamplebatchPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSamplebatchPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSamplebatchPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSceneAllEventNameCodeListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Creation type
        self.create_type = create_type
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeSceneAllEventNameCodeListResponseBodyResultObjectChildren(TeaModel):
    def __init__(
        self,
        create_type: str = None,
        event_code: str = None,
        event_name: str = None,
        event_type: str = None,
    ):
        # Creation type
        self.create_type = create_type
        # Event code
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Event type
        self.event_type = event_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.event_type is not None:
            result['eventType'] = self.event_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('eventType') is not None:
            self.event_type = m.get('eventType')
        return self


class DescribeSceneAllEventNameCodeListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        children: List[DescribeSceneAllEventNameCodeListResponseBodyResultObjectChildren] = None,
        create_type: str = None,
        event_code: str = None,
        event_name: str = None,
        event_type: str = None,
    ):
        # Child objects
        self.children = children
        # Creation type
        self.create_type = create_type
        # Event code
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Event type
        self.event_type = event_type

    def validate(self):
        if self.children:
            for k in self.children:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['children'] = []
        if self.children is not None:
            for k in self.children:
                result['children'].append(k.to_map() if k else None)
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.event_type is not None:
            result['eventType'] = self.event_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.children = []
        if m.get('children') is not None:
            for k in m.get('children'):
                temp_model = DescribeSceneAllEventNameCodeListResponseBodyResultObjectChildren()
                self.children.append(temp_model.from_map(k))
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('eventType') is not None:
            self.event_type = m.get('eventType')
        return self


class DescribeSceneAllEventNameCodeListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: List[DescribeSceneAllEventNameCodeListResponseBodyResultObject] = None,
        success: bool = None,
    ):
        # Status code
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error details
        self.message = message
        # Request ID, which is unique for each request, facilitating subsequent troubleshooting
        self.request_id = request_id
        # Returned object
        self.result_object = result_object
        # Indicates whether the operation was successful, where true means success.
        self.success = success

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeSceneAllEventNameCodeListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeSceneAllEventNameCodeListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSceneAllEventNameCodeListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSceneAllEventNameCodeListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSceneEventPageListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        current_page: str = None,
        name_or_code: str = None,
        page_size: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Current page number.
        self.current_page = current_page
        # Search name or service code
        self.name_or_code = name_or_code
        # Page size.
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.name_or_code is not None:
            result['nameOrCode'] = self.name_or_code
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('nameOrCode') is not None:
            self.name_or_code = m.get('nameOrCode')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeSceneEventPageListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        common_rule_count: str = None,
        custom_rule_count: str = None,
        event_code: str = None,
        event_name: str = None,
        gmt_modified: str = None,
        modifier: str = None,
        normal_rule_count: str = None,
        service: str = None,
        use_status: str = None,
        white_box_rule_count: str = None,
    ):
        # Number of common rules
        self.common_rule_count = common_rule_count
        # Number of custom rules
        self.custom_rule_count = custom_rule_count
        # Event code
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Modification time
        self.gmt_modified = gmt_modified
        # Modifier
        self.modifier = modifier
        # Number of custom rules
        self.normal_rule_count = normal_rule_count
        # Service code
        self.service = service
        # Usage status
        self.use_status = use_status
        # Number of white-box rules
        self.white_box_rule_count = white_box_rule_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_rule_count is not None:
            result['commonRuleCount'] = self.common_rule_count
        if self.custom_rule_count is not None:
            result['customRuleCount'] = self.custom_rule_count
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.normal_rule_count is not None:
            result['normalRuleCount'] = self.normal_rule_count
        if self.service is not None:
            result['service'] = self.service
        if self.use_status is not None:
            result['useStatus'] = self.use_status
        if self.white_box_rule_count is not None:
            result['whiteBoxRuleCount'] = self.white_box_rule_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonRuleCount') is not None:
            self.common_rule_count = m.get('commonRuleCount')
        if m.get('customRuleCount') is not None:
            self.custom_rule_count = m.get('customRuleCount')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('normalRuleCount') is not None:
            self.normal_rule_count = m.get('normalRuleCount')
        if m.get('service') is not None:
            self.service = m.get('service')
        if m.get('useStatus') is not None:
            self.use_status = m.get('useStatus')
        if m.get('whiteBoxRuleCount') is not None:
            self.white_box_rule_count = m.get('whiteBoxRuleCount')
        return self


class DescribeSceneEventPageListResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        request_id: str = None,
        result_object: List[DescribeSceneEventPageListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Current page number.
        self.current_page = current_page
        # Number of items per page. Default value: 20, minimum value: 1, maximum value: 50.
        self.page_size = page_size
        # Request ID, each request has a unique value, which facilitates subsequent troubleshooting
        self.request_id = request_id
        # Return array
        self.result_object = result_object
        # Total number of items
        self.total_item = total_item
        # Total number of pages
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeSceneEventPageListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeSceneEventPageListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSceneEventPageListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSceneEventPageListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSceneRulePageListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        current_page: str = None,
        event_code: str = None,
        page_size: str = None,
        reg_id: str = None,
        rule_auth_type: str = None,
        rule_name: str = None,
        rule_status: str = None,
    ):
        # Set the language type for requests and received messages. Default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Creation type
        self.create_type = create_type
        # Current page number.
        self.current_page = current_page
        # Event code
        self.event_code = event_code
        # Number of items per page in the returned results. Default value: 20, minimum value: 1, maximum value: 50.
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id
        # Strategy type
        self.rule_auth_type = rule_auth_type
        # Strategy name
        self.rule_name = rule_name
        # Strategy status
        self.rule_status = rule_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.rule_auth_type is not None:
            result['ruleAuthType'] = self.rule_auth_type
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        if self.rule_status is not None:
            result['ruleStatus'] = self.rule_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('ruleAuthType') is not None:
            self.rule_auth_type = m.get('ruleAuthType')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        if m.get('ruleStatus') is not None:
            self.rule_status = m.get('ruleStatus')
        return self


class DescribeSceneRulePageListResponseBodyResultObjectConsoleAudit(TeaModel):
    def __init__(
        self,
        apply_user_id: str = None,
        apply_user_name: str = None,
        audit_msg: str = None,
        audit_real_user_id: str = None,
        audit_real_user_name: str = None,
        audit_remark: str = None,
        audit_status: str = None,
        audit_time: int = None,
        audit_user_id: str = None,
        audit_user_name: str = None,
        gmt_create: int = None,
        id: int = None,
        relation_ext: str = None,
        relation_id: int = None,
        relation_name: str = None,
        relation_type: str = None,
    ):
        # Initiator account ID
        self.apply_user_id = apply_user_id
        # Initiator account name
        self.apply_user_name = apply_user_name
        # Approval comments
        self.audit_msg = audit_msg
        # Final approver ID
        self.audit_real_user_id = audit_real_user_id
        # Approver account name
        self.audit_real_user_name = audit_real_user_name
        # Approval application remarks
        self.audit_remark = audit_remark
        # Status
        self.audit_status = audit_status
        # Approval time
        self.audit_time = audit_time
        # Designated auditor account IDs (comma-separated for multiple)
        self.audit_user_id = audit_user_id
        # Designated auditor account names (comma-separated for multiple)
        self.audit_user_name = audit_user_name
        # Creation time in UTC
        self.gmt_create = gmt_create
        # Primary key ID
        self.id = id
        # Information about other related parties (in JSON format)
        self.relation_ext = relation_ext
        # ID
        self.relation_id = relation_id
        # The name of the associated transaction (can be null)
        self.relation_name = relation_name
        # rule
        self.relation_type = relation_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_user_id is not None:
            result['applyUserId'] = self.apply_user_id
        if self.apply_user_name is not None:
            result['applyUserName'] = self.apply_user_name
        if self.audit_msg is not None:
            result['auditMsg'] = self.audit_msg
        if self.audit_real_user_id is not None:
            result['auditRealUserId'] = self.audit_real_user_id
        if self.audit_real_user_name is not None:
            result['auditRealUserName'] = self.audit_real_user_name
        if self.audit_remark is not None:
            result['auditRemark'] = self.audit_remark
        if self.audit_status is not None:
            result['auditStatus'] = self.audit_status
        if self.audit_time is not None:
            result['auditTime'] = self.audit_time
        if self.audit_user_id is not None:
            result['auditUserId'] = self.audit_user_id
        if self.audit_user_name is not None:
            result['auditUserName'] = self.audit_user_name
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.id is not None:
            result['id'] = self.id
        if self.relation_ext is not None:
            result['relationExt'] = self.relation_ext
        if self.relation_id is not None:
            result['relationId'] = self.relation_id
        if self.relation_name is not None:
            result['relationName'] = self.relation_name
        if self.relation_type is not None:
            result['relationType'] = self.relation_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('applyUserId') is not None:
            self.apply_user_id = m.get('applyUserId')
        if m.get('applyUserName') is not None:
            self.apply_user_name = m.get('applyUserName')
        if m.get('auditMsg') is not None:
            self.audit_msg = m.get('auditMsg')
        if m.get('auditRealUserId') is not None:
            self.audit_real_user_id = m.get('auditRealUserId')
        if m.get('auditRealUserName') is not None:
            self.audit_real_user_name = m.get('auditRealUserName')
        if m.get('auditRemark') is not None:
            self.audit_remark = m.get('auditRemark')
        if m.get('auditStatus') is not None:
            self.audit_status = m.get('auditStatus')
        if m.get('auditTime') is not None:
            self.audit_time = m.get('auditTime')
        if m.get('auditUserId') is not None:
            self.audit_user_id = m.get('auditUserId')
        if m.get('auditUserName') is not None:
            self.audit_user_name = m.get('auditUserName')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('relationExt') is not None:
            self.relation_ext = m.get('relationExt')
        if m.get('relationId') is not None:
            self.relation_id = m.get('relationId')
        if m.get('relationName') is not None:
            self.relation_name = m.get('relationName')
        if m.get('relationType') is not None:
            self.relation_type = m.get('relationType')
        return self


class DescribeSceneRulePageListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        auth_type: str = None,
        console_audit: DescribeSceneRulePageListResponseBodyResultObjectConsoleAudit = None,
        event_code: str = None,
        event_name: str = None,
        event_type: str = None,
        external_rule_name: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        main_rule_id: str = None,
        priority: int = None,
        rule_auth_type: str = None,
        rule_id: str = None,
        rule_memo: str = None,
        rule_name: str = None,
        rule_status: str = None,
        rule_type: str = None,
        rule_version_id: int = None,
        template_id: int = None,
        version: int = None,
    ):
        # Service authorization type
        self.auth_type = auth_type
        # Audit object
        self.console_audit = console_audit
        # Event code
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Event type
        self.event_type = event_type
        # External rule name
        self.external_rule_name = external_rule_name
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time
        self.gmt_modified = gmt_modified
        # Primary key ID of the rule
        self.id = id
        # Main rule ID
        self.main_rule_id = main_rule_id
        # Strategy priority, where a higher number indicates a higher priority.
        self.priority = priority
        # Rule Auth type
        self.rule_auth_type = rule_auth_type
        # Strategy ID
        self.rule_id = rule_id
        # Strategy description
        self.rule_memo = rule_memo
        # Strategy name
        self.rule_name = rule_name
        # Strategy status
        self.rule_status = rule_status
        # Rule type
        self.rule_type = rule_type
        # Primary key ID of the rule version
        self.rule_version_id = rule_version_id
        # Template ID
        self.template_id = template_id
        # Version number
        self.version = version

    def validate(self):
        if self.console_audit:
            self.console_audit.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_type is not None:
            result['authType'] = self.auth_type
        if self.console_audit is not None:
            result['consoleAudit'] = self.console_audit.to_map()
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.event_type is not None:
            result['eventType'] = self.event_type
        if self.external_rule_name is not None:
            result['externalRuleName'] = self.external_rule_name
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.main_rule_id is not None:
            result['mainRuleId'] = self.main_rule_id
        if self.priority is not None:
            result['priority'] = self.priority
        if self.rule_auth_type is not None:
            result['ruleAuthType'] = self.rule_auth_type
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.rule_memo is not None:
            result['ruleMemo'] = self.rule_memo
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        if self.rule_status is not None:
            result['ruleStatus'] = self.rule_status
        if self.rule_type is not None:
            result['ruleType'] = self.rule_type
        if self.rule_version_id is not None:
            result['ruleVersionId'] = self.rule_version_id
        if self.template_id is not None:
            result['templateId'] = self.template_id
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('authType') is not None:
            self.auth_type = m.get('authType')
        if m.get('consoleAudit') is not None:
            temp_model = DescribeSceneRulePageListResponseBodyResultObjectConsoleAudit()
            self.console_audit = temp_model.from_map(m['consoleAudit'])
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('eventType') is not None:
            self.event_type = m.get('eventType')
        if m.get('externalRuleName') is not None:
            self.external_rule_name = m.get('externalRuleName')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('mainRuleId') is not None:
            self.main_rule_id = m.get('mainRuleId')
        if m.get('priority') is not None:
            self.priority = m.get('priority')
        if m.get('ruleAuthType') is not None:
            self.rule_auth_type = m.get('ruleAuthType')
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('ruleMemo') is not None:
            self.rule_memo = m.get('ruleMemo')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        if m.get('ruleStatus') is not None:
            self.rule_status = m.get('ruleStatus')
        if m.get('ruleType') is not None:
            self.rule_type = m.get('ruleType')
        if m.get('ruleVersionId') is not None:
            self.rule_version_id = m.get('ruleVersionId')
        if m.get('templateId') is not None:
            self.template_id = m.get('templateId')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class DescribeSceneRulePageListResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        request_id: str = None,
        result_object: List[DescribeSceneRulePageListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Current page number.
        self.current_page = current_page
        # Number of items per page in the returned results. Default value: 20, minimum value: 1, maximum value: 50.
        self.page_size = page_size
        # Request ID, which is unique for each request, facilitating subsequent troubleshooting
        self.request_id = request_id
        # Returned object
        self.result_object = result_object
        # Total number of items
        self.total_item = total_item
        # Total number of pages
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeSceneRulePageListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeSceneRulePageListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSceneRulePageListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSceneRulePageListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeScoreListRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        lang: str = None,
    ):
        # Primary key ID.
        self.id = id
        # Language type of the returned message. Values:
        # 
        # - **zh** (default): Chinese
        # - **en**: English
        self.lang = lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class DescribeScoreListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: str = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code.
        self.http_status_code = http_status_code
        # Return message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Return result.
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            self.result_object = m.get('ResultObject')
        return self


class DescribeScoreListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeScoreListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeScoreListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeScoreSectionNumLineChartRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        begin_time: str = None,
        by_pass_event_codes: str = None,
        end_time: str = None,
        main_event_codes: str = None,
        reg_id: str = None,
        shunt_event_codes: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Start timestamp, in milliseconds.
        # 
        # This parameter is required.
        self.begin_time = begin_time
        # Bypass event code
        self.by_pass_event_codes = by_pass_event_codes
        # End timestamp, in milliseconds.
        # 
        # This parameter is required.
        self.end_time = end_time
        # Main event code
        self.main_event_codes = main_event_codes
        # Region code
        self.reg_id = reg_id
        # Diversion event code
        self.shunt_event_codes = shunt_event_codes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.begin_time is not None:
            result['beginTime'] = self.begin_time
        if self.by_pass_event_codes is not None:
            result['byPassEventCodes'] = self.by_pass_event_codes
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.main_event_codes is not None:
            result['mainEventCodes'] = self.main_event_codes
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.shunt_event_codes is not None:
            result['shuntEventCodes'] = self.shunt_event_codes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('beginTime') is not None:
            self.begin_time = m.get('beginTime')
        if m.get('byPassEventCodes') is not None:
            self.by_pass_event_codes = m.get('byPassEventCodes')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('mainEventCodes') is not None:
            self.main_event_codes = m.get('mainEventCodes')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('shuntEventCodes') is not None:
            self.shunt_event_codes = m.get('shuntEventCodes')
        return self


class DescribeScoreSectionNumLineChartResponseBodyResultObjectSeries(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
        name: str = None,
    ):
        # List of current category results.
        self.data = data
        # Category name.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DescribeScoreSectionNumLineChartResponseBodyResultObjectXaxis(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
    ):
        # Data structure.
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class DescribeScoreSectionNumLineChartResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        series: List[DescribeScoreSectionNumLineChartResponseBodyResultObjectSeries] = None,
        xaxis: DescribeScoreSectionNumLineChartResponseBodyResultObjectXaxis = None,
    ):
        # Data list
        self.series = series
        # Details of xaxis node.
        self.xaxis = xaxis

    def validate(self):
        if self.series:
            for k in self.series:
                if k:
                    k.validate()
        if self.xaxis:
            self.xaxis.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['series'] = []
        if self.series is not None:
            for k in self.series:
                result['series'].append(k.to_map() if k else None)
        if self.xaxis is not None:
            result['xaxis'] = self.xaxis.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.series = []
        if m.get('series') is not None:
            for k in m.get('series'):
                temp_model = DescribeScoreSectionNumLineChartResponseBodyResultObjectSeries()
                self.series.append(temp_model.from_map(k))
        if m.get('xaxis') is not None:
            temp_model = DescribeScoreSectionNumLineChartResponseBodyResultObjectXaxis()
            self.xaxis = temp_model.from_map(m['xaxis'])
        return self


class DescribeScoreSectionNumLineChartResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeScoreSectionNumLineChartResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeScoreSectionNumLineChartResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeScoreSectionNumLineChartResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeScoreSectionNumLineChartResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeScoreSectionNumLineChartResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeScoreSectionPieChartRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        begin_time: int = None,
        end_time: int = None,
        event_codes: str = None,
        event_type: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Start time, accurate to milliseconds (ms).
        self.begin_time = begin_time
        # End time, accurate to milliseconds (ms).
        self.end_time = end_time
        # Event code.
        self.event_codes = event_codes
        # Event type.
        self.event_type = event_type
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.begin_time is not None:
            result['beginTime'] = self.begin_time
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.event_type is not None:
            result['eventType'] = self.event_type
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('beginTime') is not None:
            self.begin_time = m.get('beginTime')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('eventType') is not None:
            self.event_type = m.get('eventType')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeScoreSectionPieChartResponseBodyResultObjectGrid(TeaModel):
    def __init__(
        self,
        show: bool = None,
    ):
        # Chart field, default false
        self.show = show

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.show is not None:
            result['show'] = self.show
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('show') is not None:
            self.show = m.get('show')
        return self


class DescribeScoreSectionPieChartResponseBodyResultObjectSeriesData(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # Category item name.
        self.name = name
        # Result value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeScoreSectionPieChartResponseBodyResultObjectSeries(TeaModel):
    def __init__(
        self,
        data: List[DescribeScoreSectionPieChartResponseBodyResultObjectSeriesData] = None,
        name: str = None,
        rose_type: bool = None,
    ):
        # Chart data list
        self.data = data
        # Category name.
        self.name = name
        # Chart field, default false
        self.rose_type = rose_type

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.rose_type is not None:
            result['roseType'] = self.rose_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = DescribeScoreSectionPieChartResponseBodyResultObjectSeriesData()
                self.data.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('roseType') is not None:
            self.rose_type = m.get('roseType')
        return self


class DescribeScoreSectionPieChartResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        animation: bool = None,
        grid: DescribeScoreSectionPieChartResponseBodyResultObjectGrid = None,
        series: List[DescribeScoreSectionPieChartResponseBodyResultObjectSeries] = None,
    ):
        # Chart field, default true
        self.animation = animation
        # Belongs to grid.
        self.grid = grid
        # Data list
        self.series = series

    def validate(self):
        if self.grid:
            self.grid.validate()
        if self.series:
            for k in self.series:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.animation is not None:
            result['animation'] = self.animation
        if self.grid is not None:
            result['grid'] = self.grid.to_map()
        result['series'] = []
        if self.series is not None:
            for k in self.series:
                result['series'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('animation') is not None:
            self.animation = m.get('animation')
        if m.get('grid') is not None:
            temp_model = DescribeScoreSectionPieChartResponseBodyResultObjectGrid()
            self.grid = temp_model.from_map(m['grid'])
        self.series = []
        if m.get('series') is not None:
            for k in m.get('series'):
                temp_model = DescribeScoreSectionPieChartResponseBodyResultObjectSeries()
                self.series.append(temp_model.from_map(k))
        return self


class DescribeScoreSectionPieChartResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeScoreSectionPieChartResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeScoreSectionPieChartResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeScoreSectionPieChartResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeScoreSectionPieChartResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeScoreSectionPieChartResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeScoreSectionRatioLineChartRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        begin_time: str = None,
        by_pass_event_codes: str = None,
        end_time: str = None,
        main_event_codes: str = None,
        reg_id: str = None,
        shunt_event_codes: str = None,
    ):
        # Sets the language type for request and response messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Start time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.begin_time = begin_time
        # Bypass event code
        self.by_pass_event_codes = by_pass_event_codes
        # End time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.end_time = end_time
        # Main event code
        self.main_event_codes = main_event_codes
        # Region code
        self.reg_id = reg_id
        # Shunt event code
        self.shunt_event_codes = shunt_event_codes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.begin_time is not None:
            result['beginTime'] = self.begin_time
        if self.by_pass_event_codes is not None:
            result['byPassEventCodes'] = self.by_pass_event_codes
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.main_event_codes is not None:
            result['mainEventCodes'] = self.main_event_codes
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.shunt_event_codes is not None:
            result['shuntEventCodes'] = self.shunt_event_codes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('beginTime') is not None:
            self.begin_time = m.get('beginTime')
        if m.get('byPassEventCodes') is not None:
            self.by_pass_event_codes = m.get('byPassEventCodes')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('mainEventCodes') is not None:
            self.main_event_codes = m.get('mainEventCodes')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('shuntEventCodes') is not None:
            self.shunt_event_codes = m.get('shuntEventCodes')
        return self


class DescribeScoreSectionRatioLineChartResponseBodyResultObjectSeries(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
        name: str = None,
    ):
        # Chart data list
        self.data = data
        # Statistical dimension.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DescribeScoreSectionRatioLineChartResponseBodyResultObjectXaxis(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
    ):
        # Chart data list
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class DescribeScoreSectionRatioLineChartResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        series: List[DescribeScoreSectionRatioLineChartResponseBodyResultObjectSeries] = None,
        xaxis: DescribeScoreSectionRatioLineChartResponseBodyResultObjectXaxis = None,
    ):
        # Data list
        self.series = series
        # Details of the xaxis node.
        self.xaxis = xaxis

    def validate(self):
        if self.series:
            for k in self.series:
                if k:
                    k.validate()
        if self.xaxis:
            self.xaxis.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['series'] = []
        if self.series is not None:
            for k in self.series:
                result['series'].append(k.to_map() if k else None)
        if self.xaxis is not None:
            result['xaxis'] = self.xaxis.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.series = []
        if m.get('series') is not None:
            for k in m.get('series'):
                temp_model = DescribeScoreSectionRatioLineChartResponseBodyResultObjectSeries()
                self.series.append(temp_model.from_map(k))
        if m.get('xaxis') is not None:
            temp_model = DescribeScoreSectionRatioLineChartResponseBodyResultObjectXaxis()
            self.xaxis = temp_model.from_map(m['xaxis'])
        return self


class DescribeScoreSectionRatioLineChartResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeScoreSectionRatioLineChartResponseBodyResultObject = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeScoreSectionRatioLineChartResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeScoreSectionRatioLineChartResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeScoreSectionRatioLineChartResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeScoreSectionRatioLineChartResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSelectItemRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeSelectItemResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        monitor_status_list: List[str] = None,
        task_id_list: List[str] = None,
    ):
        # Monitoring status list.
        self.monitor_status_list = monitor_status_list
        # Task ID list.
        self.task_id_list = task_id_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.monitor_status_list is not None:
            result['monitorStatusList'] = self.monitor_status_list
        if self.task_id_list is not None:
            result['taskIdList'] = self.task_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('monitorStatusList') is not None:
            self.monitor_status_list = m.get('monitorStatusList')
        if m.get('taskIdList') is not None:
            self.task_id_list = m.get('taskIdList')
        return self


class DescribeSelectItemResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeSelectItemResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeSelectItemResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeSelectItemResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSelectItemResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSelectItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeServiceAppKeyRequest(TeaModel):
    def __init__(
        self,
        reg_id: str = None,
    ):
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeServiceAppKeyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: bool = None,
        uccess: bool = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object
        # Whether the request was successful.
        self.uccess = uccess

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        if self.uccess is not None:
            result['uccess'] = self.uccess
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        if m.get('uccess') is not None:
            self.uccess = m.get('uccess')
        return self


class DescribeServiceAppKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeServiceAppKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeServiceAppKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeServiceCodeNameRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        tab: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Scenario.
        self.tab = tab

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.tab is not None:
            result['Tab'] = self.tab
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Tab') is not None:
            self.tab = m.get('Tab')
        return self


class DescribeServiceCodeNameResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: str = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code.
        self.http_status_code = http_status_code
        # Return message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Return result.
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            self.result_object = m.get('ResultObject')
        return self


class DescribeServiceCodeNameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeServiceCodeNameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeServiceCodeNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeServiceListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeServiceListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        service_code: str = None,
        service_name: str = None,
    ):
        # Service code
        self.service_code = service_code
        # Service name.
        self.service_name = service_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.service_code is not None:
            result['serviceCode'] = self.service_code
        if self.service_name is not None:
            result['serviceName'] = self.service_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('serviceCode') is not None:
            self.service_code = m.get('serviceCode')
        if m.get('serviceName') is not None:
            self.service_name = m.get('serviceName')
        return self


class DescribeServiceListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[DescribeServiceListResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeServiceListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class DescribeServiceListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeServiceListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeServiceListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSimulationPreditInfoRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        event_code: str = None,
        reg_id: str = None,
        rules_str: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Event code
        # 
        # This parameter is required.
        self.event_code = event_code
        # Region code
        self.reg_id = reg_id
        # Policy list
        # 
        # This parameter is required.
        self.rules_str = rules_str

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.rules_str is not None:
            result['rulesStr'] = self.rules_str
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('rulesStr') is not None:
            self.rules_str = m.get('rulesStr')
        return self


class DescribeSimulationPreditInfoResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeSimulationPreditInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSimulationPreditInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSimulationPreditInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSimulationTaskCountRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        data_source_config: str = None,
        data_source_type: str = None,
        end_time: int = None,
        event_code: str = None,
        filters_str: str = None,
        reg_id: str = None,
        start_time: int = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Data source configuration
        self.data_source_config = data_source_config
        # Data source type
        self.data_source_type = data_source_type
        # Task end time.
        # 
        # This parameter is required.
        self.end_time = end_time
        # Event code
        # 
        # This parameter is required.
        self.event_code = event_code
        # Filter
        self.filters_str = filters_str
        # Region code
        self.reg_id = reg_id
        # Task start time.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.data_source_config is not None:
            result['dataSourceConfig'] = self.data_source_config
        if self.data_source_type is not None:
            result['dataSourceType'] = self.data_source_type
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.filters_str is not None:
            result['filtersStr'] = self.filters_str
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('dataSourceConfig') is not None:
            self.data_source_config = m.get('dataSourceConfig')
        if m.get('dataSourceType') is not None:
            self.data_source_type = m.get('dataSourceType')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('filtersStr') is not None:
            self.filters_str = m.get('filtersStr')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class DescribeSimulationTaskCountResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeSimulationTaskCountResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSimulationTaskCountResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSimulationTaskCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSimulationTaskListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        current_page: str = None,
        id: str = None,
        name: str = None,
        page_size: str = None,
        reg_id: str = None,
        title: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Current page number.
        self.current_page = current_page
        # Primary key ID
        self.id = id
        # Name
        self.name = name
        # Page size, with a default value of 10
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id
        # Title.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class DescribeSimulationTaskListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: bool = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, with a default value of 10
        self.page_size = page_size
        # Return object
        self.result_object = result_object
        # Total count.
        self.total_item = total_item
        # Total pages
        self.total_page = total_page

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeSimulationTaskListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSimulationTaskListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSimulationTaskListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSlsUrlConfigRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeSlsUrlConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: str = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeSlsUrlConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSlsUrlConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSlsUrlConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSupportRuleListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        event_code: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Event code
        # 
        # This parameter is required.
        self.event_code = event_code
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeSupportRuleListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeSupportRuleListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSupportRuleListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSupportRuleListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTagListRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        lang: str = None,
        reg_id: str = None,
    ):
        # Primary key ID
        self.id = id
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        return self


class DescribeTagListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: str = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Result object.
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            self.result_object = m.get('ResultObject')
        return self


class DescribeTagListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeTagListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTagListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTagsBarChartRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        begin_time: int = None,
        end_time: int = None,
        event_codes: str = None,
        reg_id: str = None,
        result: str = None,
    ):
        # Sets the language type for the request and response messages. Default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Start time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.begin_time = begin_time
        # End time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.end_time = end_time
        # Event code.
        self.event_codes = event_codes
        # Region code
        self.reg_id = reg_id
        # Policy execution result
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.begin_time is not None:
            result['beginTime'] = self.begin_time
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('beginTime') is not None:
            self.begin_time = m.get('beginTime')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class DescribeTagsBarChartResponseBodyResultObjectSeriesData(TeaModel):
    def __init__(
        self,
        num: int = None,
        scale: str = None,
    ):
        # Number.
        self.num = num
        # Scale
        self.scale = scale

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.num is not None:
            result['num'] = self.num
        if self.scale is not None:
            result['scale'] = self.scale
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('num') is not None:
            self.num = m.get('num')
        if m.get('scale') is not None:
            self.scale = m.get('scale')
        return self


class DescribeTagsBarChartResponseBodyResultObjectSeries(TeaModel):
    def __init__(
        self,
        data: List[DescribeTagsBarChartResponseBodyResultObjectSeriesData] = None,
        name: str = None,
        stack: str = None,
    ):
        # Chart data list
        self.data = data
        # Series name.
        self.name = name
        # Chart field, same as name
        self.stack = stack

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.stack is not None:
            result['stack'] = self.stack
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = DescribeTagsBarChartResponseBodyResultObjectSeriesData()
                self.data.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('stack') is not None:
            self.stack = m.get('stack')
        return self


class DescribeTagsBarChartResponseBodyResultObjectXaxis(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
    ):
        # xaxis data items
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class DescribeTagsBarChartResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        series: List[DescribeTagsBarChartResponseBodyResultObjectSeries] = None,
        xaxis: DescribeTagsBarChartResponseBodyResultObjectXaxis = None,
    ):
        # Data list
        self.series = series
        # xaxis interface configuration.
        self.xaxis = xaxis

    def validate(self):
        if self.series:
            for k in self.series:
                if k:
                    k.validate()
        if self.xaxis:
            self.xaxis.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['series'] = []
        if self.series is not None:
            for k in self.series:
                result['series'].append(k.to_map() if k else None)
        if self.xaxis is not None:
            result['xaxis'] = self.xaxis.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.series = []
        if m.get('series') is not None:
            for k in m.get('series'):
                temp_model = DescribeTagsBarChartResponseBodyResultObjectSeries()
                self.series.append(temp_model.from_map(k))
        if m.get('xaxis') is not None:
            temp_model = DescribeTagsBarChartResponseBodyResultObjectXaxis()
            self.xaxis = temp_model.from_map(m['xaxis'])
        return self


class DescribeTagsBarChartResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: DescribeTagsBarChartResponseBodyResultObject = None,
        success: bool = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object
        # Whether the request was successful.
        self.success = success

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeTagsBarChartResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeTagsBarChartResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeTagsBarChartResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTagsBarChartResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTagsFluctuationRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        event_codes: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Event code.
        self.event_codes = event_codes
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeTagsFluctuationResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        table_name: str = None,
        today_num: int = None,
        within_seven_day_num: str = None,
        within_thirty_day_num: str = None,
        within_three_day_num: str = None,
        yesterday_num: int = None,
    ):
        # Tag name
        self.table_name = table_name
        # Data for today
        self.today_num = today_num
        # Data for the last seven days
        self.within_seven_day_num = within_seven_day_num
        # Data for the last thirty days
        self.within_thirty_day_num = within_thirty_day_num
        # Data for the last three days
        self.within_three_day_num = within_three_day_num
        # Data for yesterday
        self.yesterday_num = yesterday_num

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_name is not None:
            result['tableName'] = self.table_name
        if self.today_num is not None:
            result['todayNum'] = self.today_num
        if self.within_seven_day_num is not None:
            result['withinSevenDayNum'] = self.within_seven_day_num
        if self.within_thirty_day_num is not None:
            result['withinThirtyDayNum'] = self.within_thirty_day_num
        if self.within_three_day_num is not None:
            result['withinThreeDayNum'] = self.within_three_day_num
        if self.yesterday_num is not None:
            result['yesterdayNum'] = self.yesterday_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tableName') is not None:
            self.table_name = m.get('tableName')
        if m.get('todayNum') is not None:
            self.today_num = m.get('todayNum')
        if m.get('withinSevenDayNum') is not None:
            self.within_seven_day_num = m.get('withinSevenDayNum')
        if m.get('withinThirtyDayNum') is not None:
            self.within_thirty_day_num = m.get('withinThirtyDayNum')
        if m.get('withinThreeDayNum') is not None:
            self.within_three_day_num = m.get('withinThreeDayNum')
        if m.get('yesterdayNum') is not None:
            self.yesterday_num = m.get('yesterdayNum')
        return self


class DescribeTagsFluctuationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: List[DescribeTagsFluctuationResponseBodyResultObject] = None,
        success: bool = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object
        # Indicates whether the call was successful
        self.success = success

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeTagsFluctuationResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeTagsFluctuationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeTagsFluctuationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTagsFluctuationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTagsListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and responses, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeTagsListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeTagsListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeTagsListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTagsListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTagsNumLineChartRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        begin_time: str = None,
        by_pass_event_codes: str = None,
        end_time: str = None,
        main_event_codes: str = None,
        reg_id: str = None,
        shunt_event_codes: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Start time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.begin_time = begin_time
        # Bypass event code
        self.by_pass_event_codes = by_pass_event_codes
        # End time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.end_time = end_time
        # Main event code
        self.main_event_codes = main_event_codes
        # Region code
        self.reg_id = reg_id
        # Shunt event code
        self.shunt_event_codes = shunt_event_codes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.begin_time is not None:
            result['beginTime'] = self.begin_time
        if self.by_pass_event_codes is not None:
            result['byPassEventCodes'] = self.by_pass_event_codes
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.main_event_codes is not None:
            result['mainEventCodes'] = self.main_event_codes
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.shunt_event_codes is not None:
            result['shuntEventCodes'] = self.shunt_event_codes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('beginTime') is not None:
            self.begin_time = m.get('beginTime')
        if m.get('byPassEventCodes') is not None:
            self.by_pass_event_codes = m.get('byPassEventCodes')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('mainEventCodes') is not None:
            self.main_event_codes = m.get('mainEventCodes')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('shuntEventCodes') is not None:
            self.shunt_event_codes = m.get('shuntEventCodes')
        return self


class DescribeTagsNumLineChartResponseBodyResultObjectSeries(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
        name: str = None,
    ):
        # Chart data list
        self.data = data
        # Series name.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DescribeTagsNumLineChartResponseBodyResultObjectXaxis(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
    ):
        # Chart data list
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class DescribeTagsNumLineChartResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        series: List[DescribeTagsNumLineChartResponseBodyResultObjectSeries] = None,
        xaxis: DescribeTagsNumLineChartResponseBodyResultObjectXaxis = None,
    ):
        # Data list
        self.series = series
        # xaxis node.
        self.xaxis = xaxis

    def validate(self):
        if self.series:
            for k in self.series:
                if k:
                    k.validate()
        if self.xaxis:
            self.xaxis.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['series'] = []
        if self.series is not None:
            for k in self.series:
                result['series'].append(k.to_map() if k else None)
        if self.xaxis is not None:
            result['xaxis'] = self.xaxis.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.series = []
        if m.get('series') is not None:
            for k in m.get('series'):
                temp_model = DescribeTagsNumLineChartResponseBodyResultObjectSeries()
                self.series.append(temp_model.from_map(k))
        if m.get('xaxis') is not None:
            temp_model = DescribeTagsNumLineChartResponseBodyResultObjectXaxis()
            self.xaxis = temp_model.from_map(m['xaxis'])
        return self


class DescribeTagsNumLineChartResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeTagsNumLineChartResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeTagsNumLineChartResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeTagsNumLineChartResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeTagsNumLineChartResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTagsNumLineChartResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTagsRatioLineChartRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        begin_time: int = None,
        by_pass_event_codes: str = None,
        end_time: int = None,
        main_event_codes: str = None,
        reg_id: str = None,
        shunt_event_codes: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Start time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.begin_time = begin_time
        # Bypass event code
        self.by_pass_event_codes = by_pass_event_codes
        # End time, accurate to milliseconds (ms).
        # 
        # This parameter is required.
        self.end_time = end_time
        # Main event code
        self.main_event_codes = main_event_codes
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Shunt event code
        self.shunt_event_codes = shunt_event_codes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.begin_time is not None:
            result['beginTime'] = self.begin_time
        if self.by_pass_event_codes is not None:
            result['byPassEventCodes'] = self.by_pass_event_codes
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.main_event_codes is not None:
            result['mainEventCodes'] = self.main_event_codes
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.shunt_event_codes is not None:
            result['shuntEventCodes'] = self.shunt_event_codes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('beginTime') is not None:
            self.begin_time = m.get('beginTime')
        if m.get('byPassEventCodes') is not None:
            self.by_pass_event_codes = m.get('byPassEventCodes')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('mainEventCodes') is not None:
            self.main_event_codes = m.get('mainEventCodes')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('shuntEventCodes') is not None:
            self.shunt_event_codes = m.get('shuntEventCodes')
        return self


class DescribeTagsRatioLineChartResponseBodyResultObjectSeries(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
        name: str = None,
    ):
        # Result data.
        self.data = data
        # Series name.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DescribeTagsRatioLineChartResponseBodyResultObjectXaxis(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
    ):
        # X-axis data
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class DescribeTagsRatioLineChartResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        series: List[DescribeTagsRatioLineChartResponseBodyResultObjectSeries] = None,
        xaxis: DescribeTagsRatioLineChartResponseBodyResultObjectXaxis = None,
    ):
        # Data list
        self.series = series
        # xaxis node.
        self.xaxis = xaxis

    def validate(self):
        if self.series:
            for k in self.series:
                if k:
                    k.validate()
        if self.xaxis:
            self.xaxis.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['series'] = []
        if self.series is not None:
            for k in self.series:
                result['series'].append(k.to_map() if k else None)
        if self.xaxis is not None:
            result['xaxis'] = self.xaxis.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.series = []
        if m.get('series') is not None:
            for k in m.get('series'):
                temp_model = DescribeTagsRatioLineChartResponseBodyResultObjectSeries()
                self.series.append(temp_model.from_map(k))
        if m.get('xaxis') is not None:
            temp_model = DescribeTagsRatioLineChartResponseBodyResultObjectXaxis()
            self.xaxis = temp_model.from_map(m['xaxis'])
        return self


class DescribeTagsRatioLineChartResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeTagsRatioLineChartResponseBodyResultObject = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeTagsRatioLineChartResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeTagsRatioLineChartResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeTagsRatioLineChartResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTagsRatioLineChartResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTagsTrendRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        begin_time: int = None,
        end_time: int = None,
        event_codes: str = None,
        reg_id: str = None,
        result: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Start time, accurate to milliseconds (ms).
        self.begin_time = begin_time
        # End time, accurate to milliseconds (ms).
        self.end_time = end_time
        # Event code.
        self.event_codes = event_codes
        # Region code
        self.reg_id = reg_id
        # Policy execution result
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.begin_time is not None:
            result['beginTime'] = self.begin_time
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('beginTime') is not None:
            self.begin_time = m.get('beginTime')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class DescribeTagsTrendResponseBodyResultObjectSeriesData(TeaModel):
    def __init__(
        self,
        num: int = None,
        scale: str = None,
    ):
        # The number of items in this category.
        self.num = num
        # Proportion
        self.scale = scale

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.num is not None:
            result['num'] = self.num
        if self.scale is not None:
            result['scale'] = self.scale
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('num') is not None:
            self.num = m.get('num')
        if m.get('scale') is not None:
            self.scale = m.get('scale')
        return self


class DescribeTagsTrendResponseBodyResultObjectSeries(TeaModel):
    def __init__(
        self,
        data: List[DescribeTagsTrendResponseBodyResultObjectSeriesData] = None,
        name: str = None,
    ):
        # Chart data list
        self.data = data
        # Category name.
        self.name = name

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = DescribeTagsTrendResponseBodyResultObjectSeriesData()
                self.data.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DescribeTagsTrendResponseBodyResultObjectXaxis(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
    ):
        # X-axis data
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class DescribeTagsTrendResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        series: List[DescribeTagsTrendResponseBodyResultObjectSeries] = None,
        xaxis: DescribeTagsTrendResponseBodyResultObjectXaxis = None,
    ):
        # Data list
        self.series = series
        # xaxis returned data
        self.xaxis = xaxis

    def validate(self):
        if self.series:
            for k in self.series:
                if k:
                    k.validate()
        if self.xaxis:
            self.xaxis.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['series'] = []
        if self.series is not None:
            for k in self.series:
                result['series'].append(k.to_map() if k else None)
        if self.xaxis is not None:
            result['xaxis'] = self.xaxis.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.series = []
        if m.get('series') is not None:
            for k in m.get('series'):
                temp_model = DescribeTagsTrendResponseBodyResultObjectSeries()
                self.series.append(temp_model.from_map(k))
        if m.get('xaxis') is not None:
            temp_model = DescribeTagsTrendResponseBodyResultObjectXaxis()
            self.xaxis = temp_model.from_map(m['xaxis'])
        return self


class DescribeTagsTrendResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: DescribeTagsTrendResponseBodyResultObject = None,
        success: bool = None,
    ):
        # Status code
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID
        self.request_id = request_id
        # Returned object
        self.result_object = result_object
        # Whether the request was successful.
        self.success = success

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeTagsTrendResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeTagsTrendResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeTagsTrendResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTagsTrendResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTaskListRequest(TeaModel):
    def __init__(
        self,
        current_page: str = None,
        is_page: bool = None,
        lang: str = None,
        page_size: str = None,
        reg_id: str = None,
    ):
        # Current page.
        self.current_page = current_page
        # Whether to paginate.
        self.is_page = is_page
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Page size, with a default value of 10.
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.is_page is not None:
            result['IsPage'] = self.is_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('IsPage') is not None:
            self.is_page = m.get('IsPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeTaskListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        completion_time: int = None,
        create_time: int = None,
        id: int = None,
        mark: int = None,
        remark: str = None,
        scene_name: str = None,
        status: str = None,
        task_log_id: int = None,
        task_type: str = None,
    ):
        # Completion time, in milliseconds.
        self.completion_time = completion_time
        # Creation time.
        self.create_time = create_time
        # Task ID.
        self.id = id
        # Total number of mark information.
        self.mark = mark
        # Remark.
        self.remark = remark
        # Scene name
        self.scene_name = scene_name
        # Data status.
        # 
        # -1: Failed
        # 0: Deleted
        # 1: Pending
        # 2: Success
        self.status = status
        # Task ID.
        self.task_log_id = task_log_id
        # Task type
        # 1: Data upload
        # 2: Supplemental upload
        # 3: Labeling
        self.task_type = task_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.completion_time is not None:
            result['completionTime'] = self.completion_time
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.id is not None:
            result['id'] = self.id
        if self.mark is not None:
            result['mark'] = self.mark
        if self.remark is not None:
            result['remark'] = self.remark
        if self.scene_name is not None:
            result['sceneName'] = self.scene_name
        if self.status is not None:
            result['status'] = self.status
        if self.task_log_id is not None:
            result['taskLogId'] = self.task_log_id
        if self.task_type is not None:
            result['taskType'] = self.task_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('completionTime') is not None:
            self.completion_time = m.get('completionTime')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('mark') is not None:
            self.mark = m.get('mark')
        if m.get('remark') is not None:
            self.remark = m.get('remark')
        if m.get('sceneName') is not None:
            self.scene_name = m.get('sceneName')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('taskLogId') is not None:
            self.task_log_id = m.get('taskLogId')
        if m.get('taskType') is not None:
            self.task_type = m.get('taskType')
        return self


class DescribeTaskListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeTaskListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, with a default value of 10
        self.page_size = page_size
        # Returned object
        self.result_object = result_object
        # Total number of items
        self.total_item = total_item
        # Total number of pages
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeTaskListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeTaskListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeTaskListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTaskListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTaskLogListRequest(TeaModel):
    def __init__(
        self,
        current_page: str = None,
        is_page: bool = None,
        lang: str = None,
        page_size: str = None,
        task_id: str = None,
        task_log_id: str = None,
        reg_id: str = None,
    ):
        # Current page.
        self.current_page = current_page
        # Whether to paginate.
        self.is_page = is_page
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Page size.
        self.page_size = page_size
        # Task ID.
        self.task_id = task_id
        # Task log ID
        self.task_log_id = task_log_id
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.is_page is not None:
            result['IsPage'] = self.is_page
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_log_id is not None:
            result['TaskLogId'] = self.task_log_id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('IsPage') is not None:
            self.is_page = m.get('IsPage')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskLogId') is not None:
            self.task_log_id = m.get('TaskLogId')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeTaskLogListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        completion_time: int = None,
        create_time: int = None,
        id: int = None,
        remark: str = None,
        scene_name: str = None,
        status: str = None,
        task_type: str = None,
    ):
        # Completion time, in milliseconds.
        self.completion_time = completion_time
        # Task creation time.
        self.create_time = create_time
        # Log ID.
        self.id = id
        # Remark.
        self.remark = remark
        # Scene name
        self.scene_name = scene_name
        # Status.
        # 
        # 0: Deleted
        # 1: Normal
        self.status = status
        # Task type
        # 
        # 1: Data upload
        # 2: Supplemental upload
        # 3: Labeling
        self.task_type = task_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.completion_time is not None:
            result['completionTime'] = self.completion_time
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.id is not None:
            result['id'] = self.id
        if self.remark is not None:
            result['remark'] = self.remark
        if self.scene_name is not None:
            result['sceneName'] = self.scene_name
        if self.status is not None:
            result['status'] = self.status
        if self.task_type is not None:
            result['taskType'] = self.task_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('completionTime') is not None:
            self.completion_time = m.get('completionTime')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('remark') is not None:
            self.remark = m.get('remark')
        if m.get('sceneName') is not None:
            self.scene_name = m.get('sceneName')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('taskType') is not None:
            self.task_type = m.get('taskType')
        return self


class DescribeTaskLogListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeTaskLogListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Number of items per page, default value is 10
        self.page_size = page_size
        # Returned object
        self.result_object = result_object
        # Total number of items
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeTaskLogListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeTaskLogListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeTaskLogListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTaskLogListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTemplateCountRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeTemplateCountResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        limit: bool = None,
        max_total_item: int = None,
        total_item: int = None,
    ):
        # Template quantity limit.
        self.limit = limit
        # Maximum count
        self.max_total_item = max_total_item
        # Total count.
        self.total_item = total_item

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.limit is not None:
            result['limit'] = self.limit
        if self.max_total_item is not None:
            result['maxTotalItem'] = self.max_total_item
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('maxTotalItem') is not None:
            self.max_total_item = m.get('maxTotalItem')
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        return self


class DescribeTemplateCountResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeTemplateCountResponseBodyResultObject = None,
    ):
        # Request ID
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeTemplateCountResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeTemplateCountResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeTemplateCountResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTemplateCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTemplateDownloadRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeTemplateDownloadResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        data: bool = None,
    ):
        # Request ID
        self.request_id = request_id
        # Data object
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class DescribeTemplateDownloadResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeTemplateDownloadResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTemplateDownloadResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTemplatePageListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        current_page: str = None,
        event_codes: str = None,
        page_size: str = None,
        reg_id: str = None,
        template_name: str = None,
        template_search_item: str = None,
        template_status: str = None,
        template_type: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Current page number.
        self.current_page = current_page
        # Event code.
        self.event_codes = event_codes
        # Page size, default value is 10
        self.page_size = page_size
        # Region code
        self.reg_id = reg_id
        # Event name
        self.template_name = template_name
        # Event template search field
        self.template_search_item = template_search_item
        # Event status
        self.template_status = template_status
        # Template type
        self.template_type = template_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.template_name is not None:
            result['templateName'] = self.template_name
        if self.template_search_item is not None:
            result['templateSearchItem'] = self.template_search_item
        if self.template_status is not None:
            result['templateStatus'] = self.template_status
        if self.template_type is not None:
            result['templateType'] = self.template_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('templateName') is not None:
            self.template_name = m.get('templateName')
        if m.get('templateSearchItem') is not None:
            self.template_search_item = m.get('templateSearchItem')
        if m.get('templateStatus') is not None:
            self.template_status = m.get('templateStatus')
        if m.get('templateType') is not None:
            self.template_type = m.get('templateType')
        return self


class DescribeTemplatePageListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        description: str = None,
        event_code: str = None,
        event_name: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        rule_count: int = None,
        template_code: str = None,
        template_name: str = None,
        template_status: str = None,
        template_type: str = None,
        user_count: int = None,
        version: int = None,
    ):
        # Description information.
        self.description = description
        # Event code
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time.
        self.gmt_modified = gmt_modified
        # Template ID.
        self.id = id
        # Number of policies
        self.rule_count = rule_count
        # Template code.
        self.template_code = template_code
        # Template name.
        self.template_name = template_name
        # Event status
        self.template_status = template_status
        # Template type
        self.template_type = template_type
        # Number of customer authorizations
        self.user_count = user_count
        # Version number.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.rule_count is not None:
            result['ruleCount'] = self.rule_count
        if self.template_code is not None:
            result['templateCode'] = self.template_code
        if self.template_name is not None:
            result['templateName'] = self.template_name
        if self.template_status is not None:
            result['templateStatus'] = self.template_status
        if self.template_type is not None:
            result['templateType'] = self.template_type
        if self.user_count is not None:
            result['userCount'] = self.user_count
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('ruleCount') is not None:
            self.rule_count = m.get('ruleCount')
        if m.get('templateCode') is not None:
            self.template_code = m.get('templateCode')
        if m.get('templateName') is not None:
            self.template_name = m.get('templateName')
        if m.get('templateStatus') is not None:
            self.template_status = m.get('templateStatus')
        if m.get('templateType') is not None:
            self.template_type = m.get('templateType')
        if m.get('userCount') is not None:
            self.user_count = m.get('userCount')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class DescribeTemplatePageListResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        request_id: str = None,
        result_object: List[DescribeTemplatePageListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Current page number.
        self.current_page = current_page
        # Number of items per page, default value is 10
        self.page_size = page_size
        # Request ID
        self.request_id = request_id
        # Returned object
        self.result_object = result_object
        # Total number of items
        self.total_item = total_item
        # Total number of pages
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeTemplatePageListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeTemplatePageListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeTemplatePageListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTemplatePageListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUsedServiceRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeUsedServiceResponseBodyRecords(TeaModel):
    def __init__(
        self,
        en_name: str = None,
        name: str = None,
        service_code: str = None,
    ):
        # English name
        self.en_name = en_name
        # Service name
        self.name = name
        # Service code
        self.service_code = service_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.en_name is not None:
            result['enName'] = self.en_name
        if self.name is not None:
            result['name'] = self.name
        if self.service_code is not None:
            result['serviceCode'] = self.service_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enName') is not None:
            self.en_name = m.get('enName')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('serviceCode') is not None:
            self.service_code = m.get('serviceCode')
        return self


class DescribeUsedServiceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        records: List[DescribeUsedServiceResponseBodyRecords] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Record details
        self.records = records

    def validate(self):
        if self.records:
            for k in self.records:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['records'] = []
        if self.records is not None:
            for k in self.records:
                result['records'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.records = []
        if m.get('records') is not None:
            for k in m.get('records'):
                temp_model = DescribeUsedServiceResponseBodyRecords()
                self.records.append(temp_model.from_map(k))
        return self


class DescribeUsedServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUsedServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUsedServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUserInfoRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeUserInfoResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        client_ip: str = None,
        sub_id: str = None,
        user_id: int = None,
        user_name: str = None,
    ):
        # Client IP.
        self.client_ip = client_ip
        # Sub-account ID
        self.sub_id = sub_id
        # User UID
        self.user_id = user_id
        # User name
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_ip is not None:
            result['clientIp'] = self.client_ip
        if self.sub_id is not None:
            result['subId'] = self.sub_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.user_name is not None:
            result['userName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clientIp') is not None:
            self.client_ip = m.get('clientIp')
        if m.get('subId') is not None:
            self.sub_id = m.get('subId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('userName') is not None:
            self.user_name = m.get('userName')
        return self


class DescribeUserInfoResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        result_object: DescribeUserInfoResponseBodyResultObject = None,
        success: bool = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message
        self.message = message
        # Returned object
        self.result_object = result_object
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('resultObject') is not None:
            temp_model = DescribeUserInfoResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeUserInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUserInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUserInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVariableBindDetailRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        define_id: int = None,
        id: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Bound variable definition ID
        self.define_id = define_id
        # Primary key ID of the variable, which is empty if it\\"s a new addition
        self.id = id
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.define_id is not None:
            result['defineId'] = self.define_id
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('defineId') is not None:
            self.define_id = m.get('defineId')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeVariableBindDetailResponseBodyResultObjectParams(TeaModel):
    def __init__(
        self,
        event_field_name: str = None,
        required: bool = None,
        variable_name: str = None,
    ):
        # Event field name
        self.event_field_name = event_field_name
        # Whether it is required, default is false
        self.required = required
        # Bound variable name
        self.variable_name = variable_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_field_name is not None:
            result['eventFieldName'] = self.event_field_name
        if self.required is not None:
            result['required'] = self.required
        if self.variable_name is not None:
            result['variableName'] = self.variable_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('eventFieldName') is not None:
            self.event_field_name = m.get('eventFieldName')
        if m.get('required') is not None:
            self.required = m.get('required')
        if m.get('variableName') is not None:
            self.variable_name = m.get('variableName')
        return self


class DescribeVariableBindDetailResponseBodyResultObjectRelationRules(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # Policy rule ID
        self.key = key
        # Policy name
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeVariableBindDetailResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        allow_modify: bool = None,
        define_id: int = None,
        define_title: str = None,
        description: str = None,
        event_code: str = None,
        id: int = None,
        params: List[DescribeVariableBindDetailResponseBodyResultObjectParams] = None,
        relation_rules: List[DescribeVariableBindDetailResponseBodyResultObjectRelationRules] = None,
        title: str = None,
    ):
        # Whether modification is allowed, default is false
        self.allow_modify = allow_modify
        # Variable definition ID
        self.define_id = define_id
        # Variable definition title
        self.define_title = define_title
        # Variable description information
        self.description = description
        # Event code
        self.event_code = event_code
        # Variable ID.
        self.id = id
        # Bound parameters.
        self.params = params
        # List of associated policies
        self.relation_rules = relation_rules
        # Title.
        self.title = title

    def validate(self):
        if self.params:
            for k in self.params:
                if k:
                    k.validate()
        if self.relation_rules:
            for k in self.relation_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_modify is not None:
            result['allowModify'] = self.allow_modify
        if self.define_id is not None:
            result['defineId'] = self.define_id
        if self.define_title is not None:
            result['defineTitle'] = self.define_title
        if self.description is not None:
            result['description'] = self.description
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.id is not None:
            result['id'] = self.id
        result['params'] = []
        if self.params is not None:
            for k in self.params:
                result['params'].append(k.to_map() if k else None)
        result['relationRules'] = []
        if self.relation_rules is not None:
            for k in self.relation_rules:
                result['relationRules'].append(k.to_map() if k else None)
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('allowModify') is not None:
            self.allow_modify = m.get('allowModify')
        if m.get('defineId') is not None:
            self.define_id = m.get('defineId')
        if m.get('defineTitle') is not None:
            self.define_title = m.get('defineTitle')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('id') is not None:
            self.id = m.get('id')
        self.params = []
        if m.get('params') is not None:
            for k in m.get('params'):
                temp_model = DescribeVariableBindDetailResponseBodyResultObjectParams()
                self.params.append(temp_model.from_map(k))
        self.relation_rules = []
        if m.get('relationRules') is not None:
            for k in m.get('relationRules'):
                temp_model = DescribeVariableBindDetailResponseBodyResultObjectRelationRules()
                self.relation_rules.append(temp_model.from_map(k))
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class DescribeVariableBindDetailResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeVariableBindDetailResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeVariableBindDetailResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeVariableBindDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVariableBindDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVariableBindDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVariableDetailRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        id: int = None,
        reg_id: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Variable ID
        # 
        # This parameter is required.
        self.id = id
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeVariableDetailResponseBodyResultObjectBaseInfo(TeaModel):
    def __init__(
        self,
        allow_bind: str = None,
        charging_mode: str = None,
        charging_mode_desc: str = None,
        creator: str = None,
        data_display: str = None,
        data_threshold: str = None,
        deduction_factor: int = None,
        description: str = None,
        front_allow_bind: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        input_required: str = None,
        inputs: str = None,
        inputs_desc: str = None,
        invoke_key: str = None,
        invoke_rt: int = None,
        invoke_success_rate: str = None,
        invoke_times: int = None,
        last_modified_operator: str = None,
        name: str = None,
        outputs: str = None,
        outputs_desc: str = None,
        scene: List[str] = None,
        scene_desc: List[str] = None,
        show_order: str = None,
        source: str = None,
        source_desc: str = None,
        status: str = None,
        support_regions: List[str] = None,
        title: str = None,
        type: str = None,
        type_desc: str = None,
        x_label: str = None,
        y_label: str = None,
    ):
        # Whether variable binding is allowed
        self.allow_bind = allow_bind
        # Charging mode
        self.charging_mode = charging_mode
        # Charging mode description
        self.charging_mode_desc = charging_mode_desc
        # Creator.
        self.creator = creator
        # Data distribution display, in JSON format
        self.data_display = data_display
        # Data valid range, left-closed and right-closed
        self.data_threshold = data_threshold
        # Deduction factor
        self.deduction_factor = deduction_factor
        # Description.
        self.description = description
        # Front-end binding allowed
        self.front_allow_bind = front_allow_bind
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time.
        self.gmt_modified = gmt_modified
        # Primary key ID
        self.id = id
        # Required parameters
        #      
        #      When inputRequired=__all__, it means all parameters are required
        #      When inputRequired=__one__, it means only one input is needed
        #      Required fields are separated by commas, e.g., mobile,ip,email
        self.input_required = input_required
        # Input parameters.
        self.inputs = inputs
        # Input parameter description.
        self.inputs_desc = inputs_desc
        # Invoke key
        self.invoke_key = invoke_key
        # Invoke RT, unit: milliseconds
        self.invoke_rt = invoke_rt
        # Invocation success rate
        self.invoke_success_rate = invoke_success_rate
        # Number of invocations
        self.invoke_times = invoke_times
        # Last modifier.
        self.last_modified_operator = last_modified_operator
        # Variable name
        self.name = name
        # Output
        self.outputs = outputs
        # Output description
        self.outputs_desc = outputs_desc
        # Code of applicable scenarios
        self.scene = scene
        # Applicable scenario description
        self.scene_desc = scene_desc
        # Display order
        self.show_order = show_order
        # Source
        self.source = source
        # Source description
        self.source_desc = source_desc
        # Status.
        self.status = status
        # List of supported regions.
        self.support_regions = support_regions
        # Title.
        self.title = title
        # Type
        self.type = type
        # Category description
        self.type_desc = type_desc
        # X-axis label for data distribution display
        self.x_label = x_label
        # Data distribution display y-axis label
        self.y_label = y_label

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_bind is not None:
            result['allowBind'] = self.allow_bind
        if self.charging_mode is not None:
            result['chargingMode'] = self.charging_mode
        if self.charging_mode_desc is not None:
            result['chargingModeDesc'] = self.charging_mode_desc
        if self.creator is not None:
            result['creator'] = self.creator
        if self.data_display is not None:
            result['dataDisplay'] = self.data_display
        if self.data_threshold is not None:
            result['dataThreshold'] = self.data_threshold
        if self.deduction_factor is not None:
            result['deductionFactor'] = self.deduction_factor
        if self.description is not None:
            result['description'] = self.description
        if self.front_allow_bind is not None:
            result['frontAllowBind'] = self.front_allow_bind
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.input_required is not None:
            result['inputRequired'] = self.input_required
        if self.inputs is not None:
            result['inputs'] = self.inputs
        if self.inputs_desc is not None:
            result['inputsDesc'] = self.inputs_desc
        if self.invoke_key is not None:
            result['invokeKey'] = self.invoke_key
        if self.invoke_rt is not None:
            result['invokeRt'] = self.invoke_rt
        if self.invoke_success_rate is not None:
            result['invokeSuccessRate'] = self.invoke_success_rate
        if self.invoke_times is not None:
            result['invokeTimes'] = self.invoke_times
        if self.last_modified_operator is not None:
            result['lastModifiedOperator'] = self.last_modified_operator
        if self.name is not None:
            result['name'] = self.name
        if self.outputs is not None:
            result['outputs'] = self.outputs
        if self.outputs_desc is not None:
            result['outputsDesc'] = self.outputs_desc
        if self.scene is not None:
            result['scene'] = self.scene
        if self.scene_desc is not None:
            result['sceneDesc'] = self.scene_desc
        if self.show_order is not None:
            result['showOrder'] = self.show_order
        if self.source is not None:
            result['source'] = self.source
        if self.source_desc is not None:
            result['sourceDesc'] = self.source_desc
        if self.status is not None:
            result['status'] = self.status
        if self.support_regions is not None:
            result['supportRegions'] = self.support_regions
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        if self.type_desc is not None:
            result['typeDesc'] = self.type_desc
        if self.x_label is not None:
            result['xLabel'] = self.x_label
        if self.y_label is not None:
            result['yLabel'] = self.y_label
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('allowBind') is not None:
            self.allow_bind = m.get('allowBind')
        if m.get('chargingMode') is not None:
            self.charging_mode = m.get('chargingMode')
        if m.get('chargingModeDesc') is not None:
            self.charging_mode_desc = m.get('chargingModeDesc')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('dataDisplay') is not None:
            self.data_display = m.get('dataDisplay')
        if m.get('dataThreshold') is not None:
            self.data_threshold = m.get('dataThreshold')
        if m.get('deductionFactor') is not None:
            self.deduction_factor = m.get('deductionFactor')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('frontAllowBind') is not None:
            self.front_allow_bind = m.get('frontAllowBind')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('inputRequired') is not None:
            self.input_required = m.get('inputRequired')
        if m.get('inputs') is not None:
            self.inputs = m.get('inputs')
        if m.get('inputsDesc') is not None:
            self.inputs_desc = m.get('inputsDesc')
        if m.get('invokeKey') is not None:
            self.invoke_key = m.get('invokeKey')
        if m.get('invokeRt') is not None:
            self.invoke_rt = m.get('invokeRt')
        if m.get('invokeSuccessRate') is not None:
            self.invoke_success_rate = m.get('invokeSuccessRate')
        if m.get('invokeTimes') is not None:
            self.invoke_times = m.get('invokeTimes')
        if m.get('lastModifiedOperator') is not None:
            self.last_modified_operator = m.get('lastModifiedOperator')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('outputs') is not None:
            self.outputs = m.get('outputs')
        if m.get('outputsDesc') is not None:
            self.outputs_desc = m.get('outputsDesc')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        if m.get('sceneDesc') is not None:
            self.scene_desc = m.get('sceneDesc')
        if m.get('showOrder') is not None:
            self.show_order = m.get('showOrder')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('sourceDesc') is not None:
            self.source_desc = m.get('sourceDesc')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('supportRegions') is not None:
            self.support_regions = m.get('supportRegions')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('typeDesc') is not None:
            self.type_desc = m.get('typeDesc')
        if m.get('xLabel') is not None:
            self.x_label = m.get('xLabel')
        if m.get('yLabel') is not None:
            self.y_label = m.get('yLabel')
        return self


class DescribeVariableDetailResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        base_info: DescribeVariableDetailResponseBodyResultObjectBaseInfo = None,
    ):
        # Basic attributes.
        self.base_info = base_info

    def validate(self):
        if self.base_info:
            self.base_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_info is not None:
            result['baseInfo'] = self.base_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('baseInfo') is not None:
            temp_model = DescribeVariableDetailResponseBodyResultObjectBaseInfo()
            self.base_info = temp_model.from_map(m['baseInfo'])
        return self


class DescribeVariableDetailResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DescribeVariableDetailResponseBodyResultObject = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DescribeVariableDetailResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DescribeVariableDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVariableDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVariableDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVariableFeeRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        ids: List[int] = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Variable ID
        # 
        # This parameter is required.
        self.ids = ids
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.ids is not None:
            result['ids'] = self.ids
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ids') is not None:
            self.ids = m.get('ids')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeVariableFeeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class DescribeVariableFeeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVariableFeeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVariableFeeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVariableListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        current_page: str = None,
        page_size: str = None,
        ref_obj_id: str = None,
        reg_id: str = None,
        source_type: str = None,
        type: str = None,
        types_str: str = None,
        value: str = None,
    ):
        # Set the language type for requests and responses, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Creation type.
        self.create_type = create_type
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10.
        self.page_size = page_size
        # Associated event ID.
        self.ref_obj_id = ref_obj_id
        # Region code.
        self.reg_id = reg_id
        # Source type.
        self.source_type = source_type
        # Type.
        self.type = type
        # JSON array string of types.
        self.types_str = types_str
        # Value for fuzzy search.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.ref_obj_id is not None:
            result['refObjId'] = self.ref_obj_id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.type is not None:
            result['type'] = self.type
        if self.types_str is not None:
            result['typesStr'] = self.types_str
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('refObjId') is not None:
            self.ref_obj_id = m.get('refObjId')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('typesStr') is not None:
            self.types_str = m.get('typesStr')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeVariableListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        capacity: int = None,
        define_id: str = None,
        description: str = None,
        extend_info: Dict[str, Any] = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        left_capacity: int = None,
        name: str = None,
        outputs_type: str = None,
        ref_obj_id: str = None,
        ref_obj_name: str = None,
        ref_obj_type: str = None,
        source_type: str = None,
        title: str = None,
        type: str = None,
        user_id: int = None,
    ):
        # Capacity.
        self.capacity = capacity
        # Variable definition ID.
        self.define_id = define_id
        # Description information.
        self.description = description
        # Extended information.
        self.extend_info = extend_info
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time.
        self.gmt_modified = gmt_modified
        # Variable ID.
        self.id = id
        # Remaining capacity.
        self.left_capacity = left_capacity
        # Variable name
        self.name = name
        # Variable output type
        self.outputs_type = outputs_type
        # Associated event ID.
        self.ref_obj_id = ref_obj_id
        # Associated event name.
        self.ref_obj_name = ref_obj_name
        # Associated object type of the variable
        self.ref_obj_type = ref_obj_type
        # Source type.
        self.source_type = source_type
        # Title.
        self.title = title
        # Variable type.
        self.type = type
        # User ID to which the data belongs.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.capacity is not None:
            result['capacity'] = self.capacity
        if self.define_id is not None:
            result['defineId'] = self.define_id
        if self.description is not None:
            result['description'] = self.description
        if self.extend_info is not None:
            result['extendInfo'] = self.extend_info
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.left_capacity is not None:
            result['leftCapacity'] = self.left_capacity
        if self.name is not None:
            result['name'] = self.name
        if self.outputs_type is not None:
            result['outputsType'] = self.outputs_type
        if self.ref_obj_id is not None:
            result['refObjId'] = self.ref_obj_id
        if self.ref_obj_name is not None:
            result['refObjName'] = self.ref_obj_name
        if self.ref_obj_type is not None:
            result['refObjType'] = self.ref_obj_type
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('capacity') is not None:
            self.capacity = m.get('capacity')
        if m.get('defineId') is not None:
            self.define_id = m.get('defineId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('extendInfo') is not None:
            self.extend_info = m.get('extendInfo')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('leftCapacity') is not None:
            self.left_capacity = m.get('leftCapacity')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('outputsType') is not None:
            self.outputs_type = m.get('outputsType')
        if m.get('refObjId') is not None:
            self.ref_obj_id = m.get('refObjId')
        if m.get('refObjName') is not None:
            self.ref_obj_name = m.get('refObjName')
        if m.get('refObjType') is not None:
            self.ref_obj_type = m.get('refObjType')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class DescribeVariableListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeVariableListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10.
        self.page_size = page_size
        # Returned object.
        self.result_object = result_object
        # Total number of items.
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeVariableListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeVariableListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVariableListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVariableListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVariableMarketListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        charging_mode: str = None,
        current_page: int = None,
        page_size: int = None,
        paging: str = None,
        query_content: str = None,
        reg_id: str = None,
        scenes_str: str = None,
        source: str = None,
        title: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Charging mode
        self.charging_mode = charging_mode
        # Current page number.
        self.current_page = current_page
        # Page size, with a default value of 10.
        self.page_size = page_size
        # Paging indicator, default is true.
        self.paging = paging
        # Query content, supports fuzzy search.
        # 
        #  Title/Description
        self.query_content = query_content
        # Region code
        self.reg_id = reg_id
        # Scenario
        self.scenes_str = scenes_str
        # Source
        self.source = source
        # Title.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.charging_mode is not None:
            result['chargingMode'] = self.charging_mode
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.paging is not None:
            result['paging'] = self.paging
        if self.query_content is not None:
            result['queryContent'] = self.query_content
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.scenes_str is not None:
            result['scenesStr'] = self.scenes_str
        if self.source is not None:
            result['source'] = self.source
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('chargingMode') is not None:
            self.charging_mode = m.get('chargingMode')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('paging') is not None:
            self.paging = m.get('paging')
        if m.get('queryContent') is not None:
            self.query_content = m.get('queryContent')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('scenesStr') is not None:
            self.scenes_str = m.get('scenesStr')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class DescribeVariableMarketListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: bool = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, with a default value of 10.
        self.page_size = page_size
        # Return object
        self.result_object = result_object
        # Total number of items
        self.total_item = total_item
        # Total number of pages
        self.total_page = total_page

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeVariableMarketListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVariableMarketListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVariableMarketListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVariableSceneListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        biz_type: str = None,
        config_key: str = None,
        current_page: str = None,
        page_size: str = None,
        paging: bool = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Business type.
        # 
        # This parameter is required.
        self.biz_type = biz_type
        # Configuration key.
        self.config_key = config_key
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10.
        self.page_size = page_size
        # Paging flag, default is true.
        # 
        # This parameter is required.
        self.paging = paging
        # Region code.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.biz_type is not None:
            result['bizType'] = self.biz_type
        if self.config_key is not None:
            result['configKey'] = self.config_key
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.paging is not None:
            result['paging'] = self.paging
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('bizType') is not None:
            self.biz_type = m.get('bizType')
        if m.get('configKey') is not None:
            self.config_key = m.get('configKey')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('paging') is not None:
            self.paging = m.get('paging')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DescribeVariableSceneListResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        biz_type: str = None,
        config_key: str = None,
        config_value: str = None,
        creator: str = None,
        description: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        last_modified_operator: str = None,
        status: str = None,
    ):
        # Business category identifier.
        self.biz_type = biz_type
        # Configuration key.
        self.config_key = config_key
        # Configuration value.
        self.config_value = config_value
        # Created by.
        self.creator = creator
        # Description information.
        self.description = description
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time.
        self.gmt_modified = gmt_modified
        # Primary key ID of the configuration.
        self.id = id
        # Last modified by.
        self.last_modified_operator = last_modified_operator
        # Status.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_type is not None:
            result['bizType'] = self.biz_type
        if self.config_key is not None:
            result['configKey'] = self.config_key
        if self.config_value is not None:
            result['configValue'] = self.config_value
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.last_modified_operator is not None:
            result['lastModifiedOperator'] = self.last_modified_operator
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bizType') is not None:
            self.biz_type = m.get('bizType')
        if m.get('configKey') is not None:
            self.config_key = m.get('configKey')
        if m.get('configValue') is not None:
            self.config_value = m.get('configValue')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('lastModifiedOperator') is not None:
            self.last_modified_operator = m.get('lastModifiedOperator')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class DescribeVariableSceneListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: List[DescribeVariableSceneListResponseBodyResultObject] = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10.
        self.page_size = page_size
        # Returned object.
        self.result_object = result_object
        # Total number of items.
        self.total_item = total_item
        # Total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = DescribeVariableSceneListResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class DescribeVariableSceneListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVariableSceneListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVariableSceneListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DownloadSmapleBatchRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        batch_uuid: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Sample batch UUID
        self.batch_uuid = batch_uuid
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.batch_uuid is not None:
            result['batchUuid'] = self.batch_uuid
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('batchUuid') is not None:
            self.batch_uuid = m.get('batchUuid')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class DownloadSmapleBatchResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        file_download_url: str = None,
    ):
        # Download URL
        self.file_download_url = file_download_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_download_url is not None:
            result['fileDownloadURL'] = self.file_download_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fileDownloadURL') is not None:
            self.file_download_url = m.get('fileDownloadURL')
        return self


class DownloadSmapleBatchResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: DownloadSmapleBatchResponseBodyResultObject = None,
    ):
        # ID of the request
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = DownloadSmapleBatchResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class DownloadSmapleBatchResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DownloadSmapleBatchResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DownloadSmapleBatchResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExpressionTestRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        expression: str = None,
        expression_variable: str = None,
        expression_variable_ids: str = None,
        id: int = None,
        reg_id: str = None,
        scene: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Test expression.
        # 
        # This parameter is required.
        self.expression = expression
        # Calculation expression variable
        # 
        # This parameter is required.
        self.expression_variable = expression_variable
        # Associated variable ID
        self.expression_variable_ids = expression_variable_ids
        # Variable ID
        self.id = id
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Scene
        # 
        # This parameter is required.
        self.scene = scene

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.expression is not None:
            result['expression'] = self.expression
        if self.expression_variable is not None:
            result['expressionVariable'] = self.expression_variable
        if self.expression_variable_ids is not None:
            result['expressionVariableIds'] = self.expression_variable_ids
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.scene is not None:
            result['scene'] = self.scene
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('expression') is not None:
            self.expression = m.get('expression')
        if m.get('expressionVariable') is not None:
            self.expression_variable = m.get('expressionVariable')
        if m.get('expressionVariableIds') is not None:
            self.expression_variable_ids = m.get('expressionVariableIds')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        return self


class ExpressionTestResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class ExpressionTestResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExpressionTestResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExpressionTestResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class FileUploadRequest(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        file_url: str = None,
        lang: str = None,
        tab: str = None,
    ):
        # File name.
        self.file_name = file_name
        # File URL
        self.file_url = file_url
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Scenario.
        self.tab = tab

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.tab is not None:
            result['Tab'] = self.tab
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Tab') is not None:
            self.tab = m.get('Tab')
        return self


class FileUploadResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: str = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code.
        self.http_status_code = http_status_code
        # Information returned by the API request.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Return result.
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            self.result_object = m.get('ResultObject')
        return self


class FileUploadResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: FileUploadResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = FileUploadResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportFieldRequest(TeaModel):
    def __init__(
        self,
        file_url: str = None,
        lang: str = None,
        reg_id: str = None,
    ):
        # Attachment download URL.
        # 
        # This parameter is required.
        self.file_url = file_url
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        return self


class ImportFieldResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        fail_field_names: str = None,
        success_num: int = None,
        total_num: int = None,
    ):
        # Names of fields that failed to upload
        self.fail_field_names = fail_field_names
        # Number of successful executions.
        self.success_num = success_num
        # Total number of records.
        self.total_num = total_num

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fail_field_names is not None:
            result['FailFieldNames'] = self.fail_field_names
        if self.success_num is not None:
            result['SuccessNum'] = self.success_num
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailFieldNames') is not None:
            self.fail_field_names = m.get('FailFieldNames')
        if m.get('SuccessNum') is not None:
            self.success_num = m.get('SuccessNum')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        return self


class ImportFieldResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: ImportFieldResponseBodyResultObject = None,
        success: bool = None,
    ):
        # API status code.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Returned result
        self.result_object = result_object
        # Indicator of whether the request was successful.
        self.success = success

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            temp_model = ImportFieldResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['ResultObject'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ImportFieldResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportFieldResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportFieldResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportNameListRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        data: str = None,
        description: str = None,
        import_type: str = None,
        memo: str = None,
        name_list_type: str = None,
        reg_id: str = None,
        title: str = None,
        variable_id: int = None,
    ):
        # Set the language type for request and response messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Creation type
        self.create_type = create_type
        # Import name list.
        self.data = data
        # Description information.
        self.description = description
        # Document import type:
        # 
        # 
        # INPUT: Text input
        # CSV: CSV upload
        # NONE: Do not upload for now
        # 
        # This parameter is required.
        self.import_type = import_type
        # name content memo
        self.memo = memo
        # nameListType
        self.name_list_type = name_list_type
        # Region code
        self.reg_id = reg_id
        # Title.
        # 
        # This parameter is required.
        self.title = title
        # Variable ID
        self.variable_id = variable_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.data is not None:
            result['data'] = self.data
        if self.description is not None:
            result['description'] = self.description
        if self.import_type is not None:
            result['importType'] = self.import_type
        if self.memo is not None:
            result['memo'] = self.memo
        if self.name_list_type is not None:
            result['nameListType'] = self.name_list_type
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.title is not None:
            result['title'] = self.title
        if self.variable_id is not None:
            result['variableId'] = self.variable_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('importType') is not None:
            self.import_type = m.get('importType')
        if m.get('memo') is not None:
            self.memo = m.get('memo')
        if m.get('nameListType') is not None:
            self.name_list_type = m.get('nameListType')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('variableId') is not None:
            self.variable_id = m.get('variableId')
        return self


class ImportNameListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class ImportNameListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportNameListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportNameListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportTemplateEventRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        event_template_ids: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # The template ID of the event.
        self.event_template_ids = event_template_ids
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.event_template_ids is not None:
            result['eventTemplateIds'] = self.event_template_ids
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('eventTemplateIds') is not None:
            self.event_template_ids = m.get('eventTemplateIds')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class ImportTemplateEventResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        data: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned data object
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class ImportTemplateEventResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportTemplateEventResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportTemplateEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListVariableDefineRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        allow_bind: str = None,
        charging_mode: str = None,
        current_page: int = None,
        page_size: int = None,
        paging: str = None,
        query_content: str = None,
        reg_id: str = None,
        role_type: str = None,
        scenes_str: str = None,
        source: str = None,
        status: str = None,
        title: str = None,
        types_str: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Whether binding is allowed, default is ENABLE
        self.allow_bind = allow_bind
        # Charging mode
        self.charging_mode = charging_mode
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10
        self.page_size = page_size
        # Paging identifier
        self.paging = paging
        # Query content
        self.query_content = query_content
        # Region code
        self.reg_id = reg_id
        # Authorization type
        self.role_type = role_type
        # Scenario
        self.scenes_str = scenes_str
        # Source
        self.source = source
        # Status.
        self.status = status
        # Title.
        self.title = title
        # Type
        self.types_str = types_str

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.allow_bind is not None:
            result['allowBind'] = self.allow_bind
        if self.charging_mode is not None:
            result['chargingMode'] = self.charging_mode
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.paging is not None:
            result['paging'] = self.paging
        if self.query_content is not None:
            result['queryContent'] = self.query_content
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.role_type is not None:
            result['roleType'] = self.role_type
        if self.scenes_str is not None:
            result['scenesStr'] = self.scenes_str
        if self.source is not None:
            result['source'] = self.source
        if self.status is not None:
            result['status'] = self.status
        if self.title is not None:
            result['title'] = self.title
        if self.types_str is not None:
            result['typesStr'] = self.types_str
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('allowBind') is not None:
            self.allow_bind = m.get('allowBind')
        if m.get('chargingMode') is not None:
            self.charging_mode = m.get('chargingMode')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('paging') is not None:
            self.paging = m.get('paging')
        if m.get('queryContent') is not None:
            self.query_content = m.get('queryContent')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('roleType') is not None:
            self.role_type = m.get('roleType')
        if m.get('scenesStr') is not None:
            self.scenes_str = m.get('scenesStr')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('typesStr') is not None:
            self.types_str = m.get('typesStr')
        return self


class ListVariableDefineResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        current_page: int = None,
        page_size: int = None,
        result_object: bool = None,
        total_item: int = None,
        total_page: int = None,
    ):
        # Request ID
        self.request_id = request_id
        # Current page number.
        self.current_page = current_page
        # Page size, default value is 10
        self.page_size = page_size
        # Returned object
        self.result_object = result_object
        # Total items
        self.total_item = total_item
        # Total pages.
        self.total_page = total_page

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.current_page is not None:
            result['currentPage'] = self.current_page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        if self.total_item is not None:
            result['totalItem'] = self.total_item
        if self.total_page is not None:
            result['totalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('currentPage') is not None:
            self.current_page = m.get('currentPage')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        if m.get('totalItem') is not None:
            self.total_item = m.get('totalItem')
        if m.get('totalPage') is not None:
            self.total_page = m.get('totalPage')
        return self


class ListVariableDefineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListVariableDefineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListVariableDefineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModelDeleteRequest(TeaModel):
    def __init__(
        self,
        model_name: str = None,
        reg_id: str = None,
    ):
        # Model name.
        # 
        # This parameter is required.
        self.model_name = model_name
        # Region code.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.model_name is not None:
            result['ModelName'] = self.model_name
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ModelName') is not None:
            self.model_name = m.get('ModelName')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        return self


class ModelDeleteResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Deletion result.
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            self.result_object = m.get('ResultObject')
        return self


class ModelDeleteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModelDeleteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModelDeleteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModelFileUploadRequest(TeaModel):
    def __init__(
        self,
        object_name: str = None,
        reg_id: str = None,
    ):
        # File name.
        # 
        # This parameter is required.
        self.object_name = object_name
        # Region code.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.object_name is not None:
            result['ObjectName'] = self.object_name
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ObjectName') is not None:
            self.object_name = m.get('ObjectName')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        return self


class ModelFileUploadResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return result.
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            self.result_object = m.get('ResultObject')
        return self


class ModelFileUploadResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModelFileUploadResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModelFileUploadResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModelIsUsingRequest(TeaModel):
    def __init__(
        self,
        model_code: str = None,
        model_id: str = None,
        model_name: str = None,
        reg_id: str = None,
        status: str = None,
    ):
        # Model code.
        # 
        # This parameter is required.
        self.model_code = model_code
        # Model ID.
        # 
        # This parameter is required.
        self.model_id = model_id
        # Model name.
        # 
        # This parameter is required.
        self.model_name = model_name
        # Region code.
        self.reg_id = reg_id
        # Model status.
        # 
        # This parameter is required.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.model_code is not None:
            result['ModelCode'] = self.model_code
        if self.model_id is not None:
            result['ModelId'] = self.model_id
        if self.model_name is not None:
            result['ModelName'] = self.model_name
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ModelCode') is not None:
            self.model_code = m.get('ModelCode')
        if m.get('ModelId') is not None:
            self.model_id = m.get('ModelId')
        if m.get('ModelName') is not None:
            self.model_name = m.get('ModelName')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ModelIsUsingResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Result object.
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            self.result_object = m.get('ResultObject')
        return self


class ModelIsUsingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModelIsUsingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModelIsUsingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModelNameIsDuplicationRequest(TeaModel):
    def __init__(
        self,
        model_name: str = None,
        reg_id: str = None,
    ):
        # Model name.
        # 
        # This parameter is required.
        self.model_name = model_name
        # Region code.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.model_name is not None:
            result['ModelName'] = self.model_name
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ModelName') is not None:
            self.model_name = m.get('ModelName')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        return self


class ModelNameIsDuplicationResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return result.
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            self.result_object = m.get('ResultObject')
        return self


class ModelNameIsDuplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModelNameIsDuplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModelNameIsDuplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModelSampleDownloadRequest(TeaModel):
    def __init__(
        self,
        reg_id: str = None,
    ):
        # Region code.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        return self


class ModelSampleDownloadResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Request result.
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            self.result_object = m.get('ResultObject')
        return self


class ModelSampleDownloadResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModelSampleDownloadResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModelSampleDownloadResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAppKeyRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        app_key: str = None,
        memo: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # appkey information.
        self.app_key = app_key
        # Application memo information.
        self.memo = memo
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.app_key is not None:
            result['appKey'] = self.app_key
        if self.memo is not None:
            result['memo'] = self.memo
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('appKey') is not None:
            self.app_key = m.get('appKey')
        if m.get('memo') is not None:
            self.memo = m.get('memo')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class ModifyAppKeyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        data: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned data object.
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class ModifyAppKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyAppKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAppKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCustVariableRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        condition: str = None,
        data_version: int = None,
        description: str = None,
        event_codes: str = None,
        id: int = None,
        name: str = None,
        outputs: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Condition value.
        self.condition = condition
        # Data version.
        # 
        # This parameter is required.
        self.data_version = data_version
        # Description information.
        self.description = description
        # Event code.
        self.event_codes = event_codes
        # Variable ID
        # 
        # This parameter is required.
        self.id = id
        # Variable name
        # 
        # This parameter is required.
        self.name = name
        # Output
        self.outputs = outputs
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.condition is not None:
            result['condition'] = self.condition
        if self.data_version is not None:
            result['dataVersion'] = self.data_version
        if self.description is not None:
            result['description'] = self.description
        if self.event_codes is not None:
            result['eventCodes'] = self.event_codes
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.outputs is not None:
            result['outputs'] = self.outputs
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        if m.get('dataVersion') is not None:
            self.data_version = m.get('dataVersion')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('eventCodes') is not None:
            self.event_codes = m.get('eventCodes')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('outputs') is not None:
            self.outputs = m.get('outputs')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class ModifyCustVariableResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        fail_type: str = None,
        message: str = None,
        success: bool = None,
    ):
        # Failure type
        self.fail_type = fail_type
        # Detailed information.
        self.message = message
        # Whether the operation was successful
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fail_type is not None:
            result['failType'] = self.fail_type
        if self.message is not None:
            result['message'] = self.message
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('failType') is not None:
            self.fail_type = m.get('failType')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ModifyCustVariableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: List[ModifyCustVariableResponseBodyResultObject] = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            for k in self.result_object:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['resultObject'] = []
        if self.result_object is not None:
            for k in self.result_object:
                result['resultObject'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result_object = []
        if m.get('resultObject') is not None:
            for k in m.get('resultObject'):
                temp_model = ModifyCustVariableResponseBodyResultObject()
                self.result_object.append(temp_model.from_map(k))
        return self


class ModifyCustVariableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyCustVariableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCustVariableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyEventRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        biz_version: int = None,
        create_type: str = None,
        event_code: str = None,
        event_name: str = None,
        input_fields_str: str = None,
        memo: str = None,
        reg_id: str = None,
        template_type: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Version number (latest).
        self.biz_version = biz_version
        # Creation type
        self.create_type = create_type
        # Event code
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Input parameters, JSON string.
        self.input_fields_str = input_fields_str
        # Memo.
        self.memo = memo
        # Region code
        self.reg_id = reg_id
        # Template type
        self.template_type = template_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.biz_version is not None:
            result['bizVersion'] = self.biz_version
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.input_fields_str is not None:
            result['inputFieldsStr'] = self.input_fields_str
        if self.memo is not None:
            result['memo'] = self.memo
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.template_type is not None:
            result['templateType'] = self.template_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('bizVersion') is not None:
            self.biz_version = m.get('bizVersion')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('inputFieldsStr') is not None:
            self.input_fields_str = m.get('inputFieldsStr')
        if m.get('memo') is not None:
            self.memo = m.get('memo')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('templateType') is not None:
            self.template_type = m.get('templateType')
        return self


class ModifyEventResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class ModifyEventResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyEventResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyEventStatusRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        event_code: str = None,
        from_event_satus: str = None,
        reg_id: str = None,
        to_event_satus: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Creation type
        self.create_type = create_type
        # Event code
        self.event_code = event_code
        # Initial event status, to avoid duplicate submissions or historical replays
        self.from_event_satus = from_event_satus
        # Region code
        self.reg_id = reg_id
        # Updated event status
        self.to_event_satus = to_event_satus

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.from_event_satus is not None:
            result['fromEventSatus'] = self.from_event_satus
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.to_event_satus is not None:
            result['toEventSatus'] = self.to_event_satus
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('fromEventSatus') is not None:
            self.from_event_satus = m.get('fromEventSatus')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('toEventSatus') is not None:
            self.to_event_satus = m.get('toEventSatus')
        return self


class ModifyEventStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class ModifyEventStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyEventStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyEventStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyExpressionVariableRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        data_version: int = None,
        description: str = None,
        event_code: str = None,
        expression: str = None,
        expression_title: str = None,
        expression_variable: str = None,
        id: int = None,
        name: str = None,
        outlier: str = None,
        outputs: str = None,
        reg_id: str = None,
        title: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Data version.
        # 
        # This parameter is required.
        self.data_version = data_version
        # Description.
        self.description = description
        # Event code
        # 
        # This parameter is required.
        self.event_code = event_code
        # Expression
        # 
        # This parameter is required.
        self.expression = expression
        # Expression display
        # 
        # This parameter is required.
        self.expression_title = expression_title
        # Calculation expression variable
        self.expression_variable = expression_variable
        # Variable ID
        # 
        # This parameter is required.
        self.id = id
        # Variable name
        self.name = name
        # Outlier
        # 
        # This parameter is required.
        self.outlier = outlier
        # Output
        # 
        # This parameter is required.
        self.outputs = outputs
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Title.
        # 
        # This parameter is required.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.data_version is not None:
            result['dataVersion'] = self.data_version
        if self.description is not None:
            result['description'] = self.description
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.expression is not None:
            result['expression'] = self.expression
        if self.expression_title is not None:
            result['expressionTitle'] = self.expression_title
        if self.expression_variable is not None:
            result['expressionVariable'] = self.expression_variable
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.outlier is not None:
            result['outlier'] = self.outlier
        if self.outputs is not None:
            result['outputs'] = self.outputs
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('dataVersion') is not None:
            self.data_version = m.get('dataVersion')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('expression') is not None:
            self.expression = m.get('expression')
        if m.get('expressionTitle') is not None:
            self.expression_title = m.get('expressionTitle')
        if m.get('expressionVariable') is not None:
            self.expression_variable = m.get('expressionVariable')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('outlier') is not None:
            self.outlier = m.get('outlier')
        if m.get('outputs') is not None:
            self.outputs = m.get('outputs')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class ModifyExpressionVariableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class ModifyExpressionVariableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyExpressionVariableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyExpressionVariableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyFieldRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        classify: str = None,
        description: str = None,
        enum_data: str = None,
        id: int = None,
        name: str = None,
        reg_id: str = None,
        title: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Field classification
        self.classify = classify
        # Description information.
        self.description = description
        # Enum type
        self.enum_data = enum_data
        # Variable ID
        self.id = id
        # Variable name
        self.name = name
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Title.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.classify is not None:
            result['classify'] = self.classify
        if self.description is not None:
            result['description'] = self.description
        if self.enum_data is not None:
            result['enumData'] = self.enum_data
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('classify') is not None:
            self.classify = m.get('classify')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enumData') is not None:
            self.enum_data = m.get('enumData')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class ModifyFieldResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class ModifyFieldResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyFieldResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyFieldResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyRulePriorityRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        console_rule_id: int = None,
        priority: int = None,
        reg_id: str = None,
        rule_id: int = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Primary key ID of the policy
        self.console_rule_id = console_rule_id
        # Policy priority, the higher the number, the higher the priority.
        self.priority = priority
        # Region code
        self.reg_id = reg_id
        # Policy ID
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.console_rule_id is not None:
            result['consoleRuleId'] = self.console_rule_id
        if self.priority is not None:
            result['priority'] = self.priority
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('consoleRuleId') is not None:
            self.console_rule_id = m.get('consoleRuleId')
        if m.get('priority') is not None:
            self.priority = m.get('priority')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        return self


class ModifyRulePriorityResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class ModifyRulePriorityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyRulePriorityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyRulePriorityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyRuleStatusRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        apply_user_id: str = None,
        apply_user_name: str = None,
        audit_remark: str = None,
        audit_user_id: str = None,
        audit_user_name: str = None,
        console_rule_id: int = None,
        event_type: str = None,
        reg_id: str = None,
        rule_audit_type: str = None,
        rule_id: str = None,
        rule_version_id: int = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # UID of the applicant.
        self.apply_user_id = apply_user_id
        # Name of the applicant.
        self.apply_user_name = apply_user_name
        # Approval remarks.
        self.audit_remark = audit_remark
        # UID of the auditor.
        self.audit_user_id = audit_user_id
        # Name of the auditor.
        self.audit_user_name = audit_user_name
        # Primary key ID of the policy.
        self.console_rule_id = console_rule_id
        # Event type.
        self.event_type = event_type
        # Region code.
        self.reg_id = reg_id
        # Audit status.
        self.rule_audit_type = rule_audit_type
        # Policy ID.
        self.rule_id = rule_id
        # Primary key ID of the policy version.
        self.rule_version_id = rule_version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.apply_user_id is not None:
            result['applyUserId'] = self.apply_user_id
        if self.apply_user_name is not None:
            result['applyUserName'] = self.apply_user_name
        if self.audit_remark is not None:
            result['auditRemark'] = self.audit_remark
        if self.audit_user_id is not None:
            result['auditUserId'] = self.audit_user_id
        if self.audit_user_name is not None:
            result['auditUserName'] = self.audit_user_name
        if self.console_rule_id is not None:
            result['consoleRuleId'] = self.console_rule_id
        if self.event_type is not None:
            result['eventType'] = self.event_type
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.rule_audit_type is not None:
            result['ruleAuditType'] = self.rule_audit_type
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.rule_version_id is not None:
            result['ruleVersionId'] = self.rule_version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('applyUserId') is not None:
            self.apply_user_id = m.get('applyUserId')
        if m.get('applyUserName') is not None:
            self.apply_user_name = m.get('applyUserName')
        if m.get('auditRemark') is not None:
            self.audit_remark = m.get('auditRemark')
        if m.get('auditUserId') is not None:
            self.audit_user_id = m.get('auditUserId')
        if m.get('auditUserName') is not None:
            self.audit_user_name = m.get('auditUserName')
        if m.get('consoleRuleId') is not None:
            self.console_rule_id = m.get('consoleRuleId')
        if m.get('eventType') is not None:
            self.event_type = m.get('eventType')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('ruleAuditType') is not None:
            self.rule_audit_type = m.get('ruleAuditType')
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('ruleVersionId') is not None:
            self.rule_version_id = m.get('ruleVersionId')
        return self


class ModifyRuleStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object.
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class ModifyRuleStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyRuleStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyRuleStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OpenConsoleSlsRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        scene: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code
        self.reg_id = reg_id
        # Scene
        self.scene = scene

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.scene is not None:
            result['scene'] = self.scene
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        return self


class OpenConsoleSlsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: str = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class OpenConsoleSlsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OpenConsoleSlsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OpenConsoleSlsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateFavoriteVariableRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        id: int = None,
        operate: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Variable ID
        # 
        # This parameter is required.
        self.id = id
        # Favorite operation
        # 
        # This parameter is required.
        self.operate = operate
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.id is not None:
            result['id'] = self.id
        if self.operate is not None:
            result['operate'] = self.operate
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('operate') is not None:
            self.operate = m.get('operate')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class OperateFavoriteVariableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class OperateFavoriteVariableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OperateFavoriteVariableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateFavoriteVariableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PermissionCheckRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        return self


class PermissionCheckResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: str = None,
    ):
        # Return code.
        self.code = code
        # HTTP status code.
        self.http_status_code = http_status_code
        # Return message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Return result.
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            self.result_object = m.get('ResultObject')
        return self


class PermissionCheckResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PermissionCheckResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PermissionCheckResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PocCreateTaskRequest(TeaModel):
    def __init__(
        self,
        date_format: str = None,
        lang: str = None,
        reg_id: str = None,
        task_name: str = None,
        token: str = None,
    ):
        # Date format
        self.date_format = date_format
        # Set the language type for request and response messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code.
        self.reg_id = reg_id
        # Task name.
        self.task_name = task_name
        # Task token.
        # 
        # This parameter is required.
        self.token = token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date_format is not None:
            result['DateFormat'] = self.date_format
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.token is not None:
            result['Token'] = self.token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DateFormat') is not None:
            self.date_format = m.get('DateFormat')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        return self


class PocCreateTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        success: str = None,
    ):
        # Status code.
        self.code = code
        # Task creation result
        self.data = data
        # HTTP status code
        self.http_status_code = http_status_code
        # Response message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Whether the task was successful. **true** indicates success, **false** indicates failure.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PocCreateTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PocCreateTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PocCreateTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PocGetDownloadUrlRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        token: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Task token.
        self.token = token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.token is not None:
            result['Token'] = self.token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        return self


class PocGetDownloadUrlResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        success: str = None,
    ):
        # Status code.
        self.code = code
        # Data
        self.data = data
        # HTTP status code
        self.http_status_code = http_status_code
        # Response message
        self.message = message
        # ID of the request
        self.request_id = request_id
        # Indicates whether the call was successful. true: Call succeeded. false: Call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PocGetDownloadUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PocGetDownloadUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PocGetDownloadUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PocGetTokenRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        service_code: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code.
        self.reg_id = reg_id
        # Service code.
        # 
        # This parameter is required.
        self.service_code = service_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        if self.service_code is not None:
            result['ServiceCode'] = self.service_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        if m.get('ServiceCode') is not None:
            self.service_code = m.get('ServiceCode')
        return self


class PocGetTokenResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        success: str = None,
    ):
        # Status code
        self.code = code
        # Returned data
        self.data = data
        # HTTP status code
        self.http_status_code = http_status_code
        # Return message
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Whether the call was successful. true: Call succeeded. false: Call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PocGetTokenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PocGetTokenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PocGetTokenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PocSendDataRequest(TeaModel):
    def __init__(
        self,
        batch_no: int = None,
        lang: str = None,
        params_list: str = None,
        reg_id: str = None,
        token: str = None,
    ):
        # Starting position for batch operations, starting from 0.
        # 
        # This parameter is required.
        self.batch_no = batch_no
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Return parameters, in JSON format.
        # 
        # This parameter is required.
        self.params_list = params_list
        # Region code.
        self.reg_id = reg_id
        # Task token.
        # 
        # This parameter is required.
        self.token = token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_no is not None:
            result['BatchNo'] = self.batch_no
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.params_list is not None:
            result['ParamsList'] = self.params_list
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        if self.token is not None:
            result['Token'] = self.token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BatchNo') is not None:
            self.batch_no = m.get('BatchNo')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ParamsList') is not None:
            self.params_list = m.get('ParamsList')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        return self


class PocSendDataResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        success: str = None,
    ):
        # API status code.
        self.code = code
        # Returned data result.
        self.data = data
        # HTTP status code.
        self.http_status_code = http_status_code
        # Return message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Whether the operation was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PocSendDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PocSendDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PocSendDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryAuthRuleDetailByRuleIdRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        console_rule_id: int = None,
        reg_id: str = None,
        rule_id: str = None,
        rule_version_id: int = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Primary key ID of the strategy
        self.console_rule_id = console_rule_id
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Strategy ID
        self.rule_id = rule_id
        # Primary key ID of the strategy version
        self.rule_version_id = rule_version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.console_rule_id is not None:
            result['consoleRuleId'] = self.console_rule_id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.rule_version_id is not None:
            result['ruleVersionId'] = self.rule_version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('consoleRuleId') is not None:
            self.console_rule_id = m.get('consoleRuleId')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('ruleVersionId') is not None:
            self.rule_version_id = m.get('ruleVersionId')
        return self


class QueryAuthRuleDetailByRuleIdResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        audit_id: int = None,
        auth_type: str = None,
        auth_users: str = None,
        console_rule_id: int = None,
        event_code: str = None,
        event_name: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        logic_expression: str = None,
        memo: str = None,
        priority: int = None,
        rule_action_map: Dict[str, str] = None,
        rule_actions: str = None,
        rule_auth_type: str = None,
        rule_expressions: str = None,
        rule_id: str = None,
        rule_name: str = None,
        rule_status: str = None,
        rule_type: str = None,
        rule_version_id: int = None,
        template_type: str = None,
        version: int = None,
    ):
        # Audit ID
        self.audit_id = audit_id
        # Authorization type
        self.auth_type = auth_type
        # Authorized user UID
        self.auth_users = auth_users
        # Primary key ID of the strategy
        self.console_rule_id = console_rule_id
        # Event code
        self.event_code = event_code
        # Event name.
        self.event_name = event_name
        # Creation time.
        self.gmt_create = gmt_create
        # Modification time
        self.gmt_modified = gmt_modified
        # Execution logic
        self.logic_expression = logic_expression
        # Description
        self.memo = memo
        # Rule priority, the higher the number, the higher the priority.
        self.priority = priority
        # Returned rule action structure.
        self.rule_action_map = rule_action_map
        # Output actions
        self.rule_actions = rule_actions
        # Rule authorization type
        self.rule_auth_type = rule_auth_type
        # Rule expressions.
        self.rule_expressions = rule_expressions
        # Strategy ID
        self.rule_id = rule_id
        # Strategy name
        self.rule_name = rule_name
        # Strategy status
        self.rule_status = rule_status
        # Rule type
        self.rule_type = rule_type
        # Primary key ID of the strategy version
        self.rule_version_id = rule_version_id
        # Template type
        self.template_type = template_type
        # Version number
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_id is not None:
            result['auditId'] = self.audit_id
        if self.auth_type is not None:
            result['authType'] = self.auth_type
        if self.auth_users is not None:
            result['authUsers'] = self.auth_users
        if self.console_rule_id is not None:
            result['consoleRuleId'] = self.console_rule_id
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.logic_expression is not None:
            result['logicExpression'] = self.logic_expression
        if self.memo is not None:
            result['memo'] = self.memo
        if self.priority is not None:
            result['priority'] = self.priority
        if self.rule_action_map is not None:
            result['ruleActionMap'] = self.rule_action_map
        if self.rule_actions is not None:
            result['ruleActions'] = self.rule_actions
        if self.rule_auth_type is not None:
            result['ruleAuthType'] = self.rule_auth_type
        if self.rule_expressions is not None:
            result['ruleExpressions'] = self.rule_expressions
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        if self.rule_status is not None:
            result['ruleStatus'] = self.rule_status
        if self.rule_type is not None:
            result['ruleType'] = self.rule_type
        if self.rule_version_id is not None:
            result['ruleVersionId'] = self.rule_version_id
        if self.template_type is not None:
            result['templateType'] = self.template_type
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auditId') is not None:
            self.audit_id = m.get('auditId')
        if m.get('authType') is not None:
            self.auth_type = m.get('authType')
        if m.get('authUsers') is not None:
            self.auth_users = m.get('authUsers')
        if m.get('consoleRuleId') is not None:
            self.console_rule_id = m.get('consoleRuleId')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('logicExpression') is not None:
            self.logic_expression = m.get('logicExpression')
        if m.get('memo') is not None:
            self.memo = m.get('memo')
        if m.get('priority') is not None:
            self.priority = m.get('priority')
        if m.get('ruleActionMap') is not None:
            self.rule_action_map = m.get('ruleActionMap')
        if m.get('ruleActions') is not None:
            self.rule_actions = m.get('ruleActions')
        if m.get('ruleAuthType') is not None:
            self.rule_auth_type = m.get('ruleAuthType')
        if m.get('ruleExpressions') is not None:
            self.rule_expressions = m.get('ruleExpressions')
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        if m.get('ruleStatus') is not None:
            self.rule_status = m.get('ruleStatus')
        if m.get('ruleType') is not None:
            self.rule_type = m.get('ruleType')
        if m.get('ruleVersionId') is not None:
            self.rule_version_id = m.get('ruleVersionId')
        if m.get('templateType') is not None:
            self.template_type = m.get('templateType')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class QueryAuthRuleDetailByRuleIdResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: QueryAuthRuleDetailByRuleIdResponseBodyResultObject = None,
    ):
        # Request ID
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = QueryAuthRuleDetailByRuleIdResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class QueryAuthRuleDetailByRuleIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryAuthRuleDetailByRuleIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryAuthRuleDetailByRuleIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RecallRuleAuditRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        reg_id: str = None,
    ):
        # Primary key ID
        # 
        # This parameter is required.
        self.id = id
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class RecallRuleAuditResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class RecallRuleAuditResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RecallRuleAuditResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RecallRuleAuditResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveEventRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        create_type: str = None,
        event_code: str = None,
        id: int = None,
        reg_id: str = None,
        template_code: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Creation type
        self.create_type = create_type
        # Event code
        self.event_code = event_code
        # Event ID
        self.id = id
        # Region code
        self.reg_id = reg_id
        # Input field template type
        self.template_code = template_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.create_type is not None:
            result['createType'] = self.create_type
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.template_code is not None:
            result['templateCode'] = self.template_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('createType') is not None:
            self.create_type = m.get('createType')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('templateCode') is not None:
            self.template_code = m.get('templateCode')
        return self


class RemoveEventResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class RemoveEventResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveEventResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SampleFileDownloadRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        tab: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code.
        self.reg_id = reg_id
        # Scenario.
        self.tab = tab

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        if self.tab is not None:
            result['Tab'] = self.tab
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        if m.get('Tab') is not None:
            self.tab = m.get('Tab')
        return self


class SampleFileDownloadResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: str = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code.
        self.http_status_code = http_status_code
        # Return message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Request result.
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            self.result_object = m.get('ResultObject')
        return self


class SampleFileDownloadResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SampleFileDownloadResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SampleFileDownloadResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveAnalysisColumnRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        columns: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Custom columns
        # 
        # This parameter is required.
        self.columns = columns
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.columns is not None:
            result['columns'] = self.columns
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('columns') is not None:
            self.columns = m.get('columns')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class SaveAnalysisColumnResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class SaveAnalysisColumnResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SaveAnalysisColumnResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveAnalysisColumnResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveByPassOrShuntEventRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        event_id: int = None,
        event_name: str = None,
        event_type: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Event ID.
        self.event_id = event_id
        # Event name.
        self.event_name = event_name
        # Event type
        self.event_type = event_type
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.event_id is not None:
            result['eventId'] = self.event_id
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.event_type is not None:
            result['eventType'] = self.event_type
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('eventId') is not None:
            self.event_id = m.get('eventId')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('eventType') is not None:
            self.event_type = m.get('eventType')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class SaveByPassOrShuntEventResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: bool = None,
        success: bool = None,
    ):
        # Status code
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object
        # Whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class SaveByPassOrShuntEventResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SaveByPassOrShuntEventResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveByPassOrShuntEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartOrStopByPassShuntEventRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        event_id: int = None,
        reg_id: str = None,
        status: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Event ID.
        self.event_id = event_id
        # Region code
        self.reg_id = reg_id
        # Status.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.event_id is not None:
            result['eventId'] = self.event_id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('eventId') is not None:
            self.event_id = m.get('eventId')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class StartOrStopByPassShuntEventResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: bool = None,
        success: bool = None,
    ):
        # Status code
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object
        # Whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class StartOrStopByPassShuntEventResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartOrStopByPassShuntEventResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartOrStopByPassShuntEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartSimulationTaskRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        id: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Primary key ID
        # 
        # This parameter is required.
        self.id = id
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class StartSimulationTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class StartSimulationTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartSimulationTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartSimulationTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopSimulationTaskRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        id: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Task ID.
        # 
        # This parameter is required.
        self.id = id
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class StopSimulationTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class StopSimulationTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopSimulationTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopSimulationTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SwitchExpressionVariableRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        data_version: int = None,
        id: int = None,
        reg_id: str = None,
        status: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Data version.
        # 
        # This parameter is required.
        self.data_version = data_version
        # Variable ID
        # 
        # This parameter is required.
        self.id = id
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Status.
        # 
        # This parameter is required.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.data_version is not None:
            result['dataVersion'] = self.data_version
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('dataVersion') is not None:
            self.data_version = m.get('dataVersion')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class SwitchExpressionVariableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class SwitchExpressionVariableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SwitchExpressionVariableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SwitchExpressionVariableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SwitchFieldRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        id: int = None,
        name: str = None,
        reg_id: str = None,
        source: str = None,
        status: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Primary Key ID
        self.id = id
        # Parameter Name.
        self.name = name
        # Region Code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Field Source
        self.source = source
        # Status.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.source is not None:
            result['source'] = self.source
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class SwitchFieldResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return Object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class SwitchFieldResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SwitchFieldResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SwitchFieldResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SwitchQueryVariableRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        id: int = None,
        reg_id: str = None,
        status: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Primary key ID
        # 
        # This parameter is required.
        self.id = id
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Status.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class SwitchQueryVariableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class SwitchQueryVariableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SwitchQueryVariableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SwitchQueryVariableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SwitchToOnlineRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        event_id: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # The event ID to switch to.
        # 
        # This parameter is required.
        self.event_id = event_id
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.event_id is not None:
            result['eventId'] = self.event_id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('eventId') is not None:
            self.event_id = m.get('eventId')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class SwitchToOnlineResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: bool = None,
        success: bool = None,
    ):
        # Status code
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object
        # Indicates whether this operation was successful, `true` means success.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class SwitchToOnlineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SwitchToOnlineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SwitchToOnlineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SwitchVariableRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        data_version: int = None,
        id: int = None,
        name: str = None,
        reg_id: str = None,
        status: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Data version.
        self.data_version = data_version
        # Primary key ID of the cumulative variable
        self.id = id
        # Cumulative variable name: generated by the backend
        self.name = name
        # Region code
        self.reg_id = reg_id
        # Status.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.data_version is not None:
            result['dataVersion'] = self.data_version
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('dataVersion') is not None:
            self.data_version = m.get('dataVersion')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class SwitchVariableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class SwitchVariableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SwitchVariableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SwitchVariableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TaskNameByUserIdRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        reg_id: str = None,
        task_name: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Region code.
        self.reg_id = reg_id
        # Task name.
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.reg_id is not None:
            result['RegId'] = self.reg_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RegId') is not None:
            self.reg_id = m.get('RegId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        return self


class TaskNameByUserIdResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Response code.
        self.code = code
        # HTTP status code.
        self.http_status_code = http_status_code
        # Return message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Return result.
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['ResultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResultObject') is not None:
            self.result_object = m.get('ResultObject')
        return self


class TaskNameByUserIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TaskNameByUserIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TaskNameByUserIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAnalysisConditionFavoriteRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        condition: str = None,
        event_begin_time: int = None,
        event_code: str = None,
        event_end_time: int = None,
        field_name: str = None,
        field_value: str = None,
        id: int = None,
        name: str = None,
        reg_id: str = None,
        type: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Condition value.
        self.condition = condition
        # Start time, accurate to milliseconds (ms).
        self.event_begin_time = event_begin_time
        # Event code
        self.event_code = event_code
        # End time, accurate to milliseconds (ms).
        self.event_end_time = event_end_time
        # Field name
        self.field_name = field_name
        # Field value
        self.field_value = field_value
        # Primary key ID
        # 
        # This parameter is required.
        self.id = id
        # Condition name
        self.name = name
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Type, BASIC: Basic query, ADVANCE: Advanced query, BATCH: Batch query
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.condition is not None:
            result['condition'] = self.condition
        if self.event_begin_time is not None:
            result['eventBeginTime'] = self.event_begin_time
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.event_end_time is not None:
            result['eventEndTime'] = self.event_end_time
        if self.field_name is not None:
            result['fieldName'] = self.field_name
        if self.field_value is not None:
            result['fieldValue'] = self.field_value
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        if m.get('eventBeginTime') is not None:
            self.event_begin_time = m.get('eventBeginTime')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('eventEndTime') is not None:
            self.event_end_time = m.get('eventEndTime')
        if m.get('fieldName') is not None:
            self.field_name = m.get('fieldName')
        if m.get('fieldValue') is not None:
            self.field_value = m.get('fieldValue')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class UpdateAnalysisConditionFavoriteResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class UpdateAnalysisConditionFavoriteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAnalysisConditionFavoriteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAnalysisConditionFavoriteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAuditRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        audit_msg: str = None,
        audit_relation_type: str = None,
        audit_status: str = None,
        id: int = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Approval comments
        self.audit_msg = audit_msg
        # Associated type
        self.audit_relation_type = audit_relation_type
        # Status
        self.audit_status = audit_status
        # The ID of the approval to be updated.
        self.id = id
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.audit_msg is not None:
            result['auditMsg'] = self.audit_msg
        if self.audit_relation_type is not None:
            result['auditRelationType'] = self.audit_relation_type
        if self.audit_status is not None:
            result['auditStatus'] = self.audit_status
        if self.id is not None:
            result['id'] = self.id
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('auditMsg') is not None:
            self.audit_msg = m.get('auditMsg')
        if m.get('auditRelationType') is not None:
            self.audit_relation_type = m.get('auditRelationType')
        if m.get('auditStatus') is not None:
            self.audit_status = m.get('auditStatus')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class UpdateAuditResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        result_object: bool = None,
        success: bool = None,
    ):
        # Status code
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Returned object
        self.result_object = result_object
        # Whether the call was successful
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateAuditResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAuditResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAuditResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAuthRuleRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        console_rule_id: int = None,
        event_code: str = None,
        reg_id: str = None,
        rule_actions: str = None,
        rule_expressions: str = None,
        rule_id: str = None,
        rule_version_id: int = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Policy primary key ID
        self.console_rule_id = console_rule_id
        # Event code
        self.event_code = event_code
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Policy output action
        self.rule_actions = rule_actions
        # Expression
        # 
        # This parameter is required.
        self.rule_expressions = rule_expressions
        # Policy ID
        # 
        # This parameter is required.
        self.rule_id = rule_id
        # Policy version primary key ID
        self.rule_version_id = rule_version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.console_rule_id is not None:
            result['consoleRuleId'] = self.console_rule_id
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.rule_actions is not None:
            result['ruleActions'] = self.rule_actions
        if self.rule_expressions is not None:
            result['ruleExpressions'] = self.rule_expressions
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.rule_version_id is not None:
            result['ruleVersionId'] = self.rule_version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('consoleRuleId') is not None:
            self.console_rule_id = m.get('consoleRuleId')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('ruleActions') is not None:
            self.rule_actions = m.get('ruleActions')
        if m.get('ruleExpressions') is not None:
            self.rule_expressions = m.get('ruleExpressions')
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('ruleVersionId') is not None:
            self.rule_version_id = m.get('ruleVersionId')
        return self


class UpdateAuthRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class UpdateAuthRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAuthRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAuthRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateByPassShuntEventRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        event_id: int = None,
        event_name: str = None,
        reg_id: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Event ID.
        self.event_id = event_id
        # Event name.
        self.event_name = event_name
        # Region code
        self.reg_id = reg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.event_id is not None:
            result['eventId'] = self.event_id
        if self.event_name is not None:
            result['eventName'] = self.event_name
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('eventId') is not None:
            self.event_id = m.get('eventId')
        if m.get('eventName') is not None:
            self.event_name = m.get('eventName')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        return self


class UpdateByPassShuntEventResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        result_object: bool = None,
        success: bool = None,
    ):
        # Status code.
        self.code = code
        # HTTP status code
        self.http_status_code = http_status_code
        # Error message.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object
        # Whether it was successful
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.http_status_code is not None:
            result['httpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('httpStatusCode') is not None:
            self.http_status_code = m.get('httpStatusCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateByPassShuntEventResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateByPassShuntEventResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateByPassShuntEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDataSourceRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        description: str = None,
        id: int = None,
        name: str = None,
        oss_key: str = None,
        reg_id: str = None,
        type: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Description information.
        self.description = description
        # Primary key ID
        # 
        # This parameter is required.
        self.id = id
        # Data source name.
        self.name = name
        # OSS file key.
        self.oss_key = oss_key
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Data source type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.oss_key is not None:
            result['ossKey'] = self.oss_key
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('ossKey') is not None:
            self.oss_key = m.get('ossKey')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class UpdateDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class UpdateDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateQueryVariableRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        data_source_code: str = None,
        description: str = None,
        event_code: str = None,
        expression: str = None,
        expression_title: str = None,
        expression_variable: str = None,
        id: int = None,
        outlier: str = None,
        outputs: str = None,
        reg_id: str = None,
        title: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Data source code
        # 
        # This parameter is required.
        self.data_source_code = data_source_code
        # Description.
        self.description = description
        # Event code
        # 
        # This parameter is required.
        self.event_code = event_code
        # Expression.
        # 
        # This parameter is required.
        self.expression = expression
        # Display expression
        # 
        # This parameter is required.
        self.expression_title = expression_title
        # Expression associated variable
        # 
        # This parameter is required.
        self.expression_variable = expression_variable
        # Primary key ID
        # 
        # This parameter is required.
        self.id = id
        # Outlier
        # 
        # This parameter is required.
        self.outlier = outlier
        # Variable return type
        # 
        # This parameter is required.
        self.outputs = outputs
        # Region code
        # 
        # This parameter is required.
        self.reg_id = reg_id
        # Title.
        # 
        # This parameter is required.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.data_source_code is not None:
            result['dataSourceCode'] = self.data_source_code
        if self.description is not None:
            result['description'] = self.description
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.expression is not None:
            result['expression'] = self.expression
        if self.expression_title is not None:
            result['expressionTitle'] = self.expression_title
        if self.expression_variable is not None:
            result['expressionVariable'] = self.expression_variable
        if self.id is not None:
            result['id'] = self.id
        if self.outlier is not None:
            result['outlier'] = self.outlier
        if self.outputs is not None:
            result['outputs'] = self.outputs
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('dataSourceCode') is not None:
            self.data_source_code = m.get('dataSourceCode')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('expression') is not None:
            self.expression = m.get('expression')
        if m.get('expressionTitle') is not None:
            self.expression_title = m.get('expressionTitle')
        if m.get('expressionVariable') is not None:
            self.expression_variable = m.get('expressionVariable')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('outlier') is not None:
            self.outlier = m.get('outlier')
        if m.get('outputs') is not None:
            self.outputs = m.get('outputs')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class UpdateQueryVariableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class UpdateQueryVariableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateQueryVariableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateQueryVariableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateRuleRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        console_rule_id: int = None,
        event_code: str = None,
        logic_expression: str = None,
        memo: str = None,
        reg_id: str = None,
        rule_actions: str = None,
        rule_body: str = None,
        rule_expressions: str = None,
        rule_id: str = None,
        rule_name: str = None,
        rule_status: str = None,
        rule_type: str = None,
        rule_version_id: int = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values: 
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Primary key ID of the policy
        self.console_rule_id = console_rule_id
        # Event code
        self.event_code = event_code
        # Execution logic
        self.logic_expression = logic_expression
        # Description
        self.memo = memo
        # Region code
        self.reg_id = reg_id
        # Output action
        self.rule_actions = rule_actions
        # DSL policy expression
        self.rule_body = rule_body
        # Policy expression
        self.rule_expressions = rule_expressions
        # Policy ID
        self.rule_id = rule_id
        # Policy name
        self.rule_name = rule_name
        # Policy status
        self.rule_status = rule_status
        # Policy type
        self.rule_type = rule_type
        # Primary key ID of the policy version
        self.rule_version_id = rule_version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.console_rule_id is not None:
            result['consoleRuleId'] = self.console_rule_id
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.logic_expression is not None:
            result['logicExpression'] = self.logic_expression
        if self.memo is not None:
            result['memo'] = self.memo
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.rule_actions is not None:
            result['ruleActions'] = self.rule_actions
        if self.rule_body is not None:
            result['ruleBody'] = self.rule_body
        if self.rule_expressions is not None:
            result['ruleExpressions'] = self.rule_expressions
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        if self.rule_status is not None:
            result['ruleStatus'] = self.rule_status
        if self.rule_type is not None:
            result['ruleType'] = self.rule_type
        if self.rule_version_id is not None:
            result['ruleVersionId'] = self.rule_version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('consoleRuleId') is not None:
            self.console_rule_id = m.get('consoleRuleId')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('logicExpression') is not None:
            self.logic_expression = m.get('logicExpression')
        if m.get('memo') is not None:
            self.memo = m.get('memo')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('ruleActions') is not None:
            self.rule_actions = m.get('ruleActions')
        if m.get('ruleBody') is not None:
            self.rule_body = m.get('ruleBody')
        if m.get('ruleExpressions') is not None:
            self.rule_expressions = m.get('ruleExpressions')
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        if m.get('ruleStatus') is not None:
            self.rule_status = m.get('ruleStatus')
        if m.get('ruleType') is not None:
            self.rule_type = m.get('ruleType')
        if m.get('ruleVersionId') is not None:
            self.rule_version_id = m.get('ruleVersionId')
        return self


class UpdateRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class UpdateRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateRuleBaseRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        console_rule_id: int = None,
        event_code: str = None,
        memo: str = None,
        reg_id: str = None,
        rule_id: str = None,
        rule_name: str = None,
    ):
        # Set the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Policy primary key ID
        self.console_rule_id = console_rule_id
        # Event code
        self.event_code = event_code
        # Description
        self.memo = memo
        # Region code
        self.reg_id = reg_id
        # Policy ID
        self.rule_id = rule_id
        # Policy name
        self.rule_name = rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.console_rule_id is not None:
            result['consoleRuleId'] = self.console_rule_id
        if self.event_code is not None:
            result['eventCode'] = self.event_code
        if self.memo is not None:
            result['memo'] = self.memo
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        if self.rule_name is not None:
            result['ruleName'] = self.rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('consoleRuleId') is not None:
            self.console_rule_id = m.get('consoleRuleId')
        if m.get('eventCode') is not None:
            self.event_code = m.get('eventCode')
        if m.get('memo') is not None:
            self.memo = m.get('memo')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        if m.get('ruleName') is not None:
            self.rule_name = m.get('ruleName')
        return self


class UpdateRuleBaseResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Return object
        self.result_object = result_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObject') is not None:
            self.result_object = m.get('resultObject')
        return self


class UpdateRuleBaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateRuleBaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateRuleBaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSampleBatchRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        ids: str = None,
        reg_id: str = None,
        tags: str = None,
        versions: str = None,
    ):
        # Sets the language type for requests and received messages, default value is **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Batch operation IDs.
        self.ids = ids
        # Region code.
        self.reg_id = reg_id
        # Tags (comma-separated).
        self.tags = tags
        # Version number (latest).
        self.versions = versions

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.ids is not None:
            result['ids'] = self.ids
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.tags is not None:
            result['tags'] = self.tags
        if self.versions is not None:
            result['versions'] = self.versions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('ids') is not None:
            self.ids = m.get('ids')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('tags') is not None:
            self.tags = m.get('tags')
        if m.get('versions') is not None:
            self.versions = m.get('versions')
        return self


class UpdateSampleBatchResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        data: bool = None,
    ):
        # Request ID.
        self.request_id = request_id
        # Returned data.
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class UpdateSampleBatchResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSampleBatchResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSampleBatchResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UploadFileCheckRequest(TeaModel):
    def __init__(
        self,
        lang: str = None,
        batch_name: str = None,
        data_type: str = None,
        oss_file_name: str = None,
        reg_id: str = None,
        sample_tag_type: str = None,
        service_list: str = None,
    ):
        # Sets the language type for requests and received messages, with a default value of **zh**. Values:
        # - **zh**: Chinese
        # - **en**: English
        self.lang = lang
        # Sample batch name
        self.batch_name = batch_name
        # Data type
        self.data_type = data_type
        # Uploaded OSS address.
        self.oss_file_name = oss_file_name
        # Region code
        self.reg_id = reg_id
        # Sample type
        self.sample_tag_type = sample_tag_type
        # Service list
        self.service_list = service_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.batch_name is not None:
            result['batchName'] = self.batch_name
        if self.data_type is not None:
            result['dataType'] = self.data_type
        if self.oss_file_name is not None:
            result['ossFileName'] = self.oss_file_name
        if self.reg_id is not None:
            result['regId'] = self.reg_id
        if self.sample_tag_type is not None:
            result['sampleTagType'] = self.sample_tag_type
        if self.service_list is not None:
            result['serviceList'] = self.service_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('batchName') is not None:
            self.batch_name = m.get('batchName')
        if m.get('dataType') is not None:
            self.data_type = m.get('dataType')
        if m.get('ossFileName') is not None:
            self.oss_file_name = m.get('ossFileName')
        if m.get('regId') is not None:
            self.reg_id = m.get('regId')
        if m.get('sampleTagType') is not None:
            self.sample_tag_type = m.get('sampleTagType')
        if m.get('serviceList') is not None:
            self.service_list = m.get('serviceList')
        return self


class UploadFileCheckResponseBodyResultObject(TeaModel):
    def __init__(
        self,
        effective_number: int = None,
        result_list: List[str] = None,
        total_number: int = None,
    ):
        # Number of effective rows
        self.effective_number = effective_number
        # Valid sample data
        self.result_list = result_list
        # Total number of rows
        self.total_number = total_number

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.effective_number is not None:
            result['effectiveNumber'] = self.effective_number
        if self.result_list is not None:
            result['resultList'] = self.result_list
        if self.total_number is not None:
            result['totalNumber'] = self.total_number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('effectiveNumber') is not None:
            self.effective_number = m.get('effectiveNumber')
        if m.get('resultList') is not None:
            self.result_list = m.get('resultList')
        if m.get('totalNumber') is not None:
            self.total_number = m.get('totalNumber')
        return self


class UploadFileCheckResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result_object: UploadFileCheckResponseBodyResultObject = None,
    ):
        # ID of the request
        self.request_id = request_id
        # Returned object
        self.result_object = result_object

    def validate(self):
        if self.result_object:
            self.result_object.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result_object is not None:
            result['resultObject'] = self.result_object.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('resultObject') is not None:
            temp_model = UploadFileCheckResponseBodyResultObject()
            self.result_object = temp_model.from_map(m['resultObject'])
        return self


class UploadFileCheckResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UploadFileCheckResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UploadFileCheckResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


