# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from typing import Dict
from Tea.core import TeaCore

from alibabacloud_tea_openapi.client import Client as OpenApiClient
from alibabacloud_tea_openapi import models as open_api_models
from alibabacloud_tea_util.client import Client as UtilClient
from alibabacloud_endpoint_util.client import Client as EndpointUtilClient
from alibabacloud_vpc20160428 import models as vpc_20160428_models
from alibabacloud_tea_util import models as util_models
from alibabacloud_openapi_util.client import Client as OpenApiUtilClient


class Client(OpenApiClient):
    """
    *\
    """
    def __init__(
        self, 
        config: open_api_models.Config,
    ):
        super().__init__(config)
        self._endpoint_rule = 'regional'
        self._endpoint_map = {
            'cn-hangzhou': 'vpc.aliyuncs.com',
            'cn-shanghai-finance-1': 'vpc.aliyuncs.com',
            'cn-shenzhen-finance-1': 'vpc.aliyuncs.com',
            'cn-north-2-gov-1': 'vpc.aliyuncs.com',
            'ap-northeast-2-pop': 'vpc.aliyuncs.com',
            'cn-beijing-finance-pop': 'vpc.aliyuncs.com',
            'cn-beijing-gov-1': 'vpc.aliyuncs.com',
            'cn-beijing-nu16-b01': 'vpc.aliyuncs.com',
            'cn-edge-1': 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
            'cn-fujian': 'vpc.aliyuncs.com',
            'cn-haidian-cm12-c01': 'vpc.aliyuncs.com',
            'cn-hangzhou-bj-b01': 'vpc.aliyuncs.com',
            'cn-hangzhou-finance': 'vpc.aliyuncs.com',
            'cn-hangzhou-internal-prod-1': 'vpc.aliyuncs.com',
            'cn-hangzhou-internal-test-1': 'vpc-pre.cn-hangzhou.aliyuncs.com',
            'cn-hangzhou-internal-test-2': 'vpc-inner-pre.cn-hangzhou.aliyuncs.com',
            'cn-hangzhou-internal-test-3': 'vpc-pre.cn-hangzhou.aliyuncs.com',
            'cn-hangzhou-test-306': 'vpc-pre.cn-hangzhou.aliyuncs.com',
            'cn-hongkong-finance-pop': 'vpc.aliyuncs.com',
            'cn-huhehaote-nebula-1': 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
            'cn-qingdao-nebula': 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
            'cn-shanghai-et15-b01': 'vpc-pre.cn-hangzhou.aliyuncs.com',
            'cn-shanghai-et2-b01': 'vpc.aliyuncs.com',
            'cn-shanghai-inner': 'vpc.aliyuncs.com',
            'cn-shanghai-internal-test-1': 'vpc-pre.cn-hangzhou.aliyuncs.com',
            'cn-shenzhen-inner': 'vpc.aliyuncs.com',
            'cn-shenzhen-st4-d01': 'vpc.aliyuncs.com',
            'cn-shenzhen-su18-b01': 'vpc.aliyuncs.com',
            'cn-wuhan': 'vpc.aliyuncs.com',
            'cn-yushanfang': 'vpc.aliyuncs.com',
            'cn-zhangbei': 'vpc.aliyuncs.com',
            'cn-zhangbei-na61-b01': 'vpc.aliyuncs.com',
            'cn-zhangjiakou-na62-a01': 'vpc.cn-zhangjiakou.aliyuncs.com',
            'cn-zhengzhou-nebula-1': 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
            'eu-west-1-oxs': 'vpc-nebula.cn-shenzhen-cloudstone.aliyuncs.com',
            'rus-west-1-pop': 'vpc.aliyuncs.com'
        }
        self.check_config(config)
        self._endpoint = self.get_endpoint('vpc', self._region_id, self._endpoint_rule, self._network, self._suffix, self._endpoint_map, self._endpoint)

    def get_endpoint(
        self,
        product_id: str,
        region_id: str,
        endpoint_rule: str,
        network: str,
        suffix: str,
        endpoint_map: Dict[str, str],
        endpoint: str,
    ) -> str:
        if not UtilClient.empty(endpoint):
            return endpoint
        if not UtilClient.is_unset(endpoint_map) and not UtilClient.empty(endpoint_map.get(region_id)):
            return endpoint_map.get(region_id)
        return EndpointUtilClient.get_endpoint_rules(product_id, region_id, endpoint_rule, network, suffix)

    def activate_router_interface_with_options(
        self,
        request: vpc_20160428_models.ActivateRouterInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ActivateRouterInterfaceResponse:
        """
        @summary Activates a router interface that is in the Inactive state.
        
        @description After you call this operation, the router interface enters the *Activating** state. After the router interface is activated, it enters the **Active** state.
        >  You cannot activate a router interface that has overdue payments.
        
        @param request: ActivateRouterInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ActivateRouterInterfaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ActivateRouterInterface',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ActivateRouterInterfaceResponse(),
            self.call_api(params, req, runtime)
        )

    async def activate_router_interface_with_options_async(
        self,
        request: vpc_20160428_models.ActivateRouterInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ActivateRouterInterfaceResponse:
        """
        @summary Activates a router interface that is in the Inactive state.
        
        @description After you call this operation, the router interface enters the *Activating** state. After the router interface is activated, it enters the **Active** state.
        >  You cannot activate a router interface that has overdue payments.
        
        @param request: ActivateRouterInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ActivateRouterInterfaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ActivateRouterInterface',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ActivateRouterInterfaceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def activate_router_interface(
        self,
        request: vpc_20160428_models.ActivateRouterInterfaceRequest,
    ) -> vpc_20160428_models.ActivateRouterInterfaceResponse:
        """
        @summary Activates a router interface that is in the Inactive state.
        
        @description After you call this operation, the router interface enters the *Activating** state. After the router interface is activated, it enters the **Active** state.
        >  You cannot activate a router interface that has overdue payments.
        
        @param request: ActivateRouterInterfaceRequest
        @return: ActivateRouterInterfaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.activate_router_interface_with_options(request, runtime)

    async def activate_router_interface_async(
        self,
        request: vpc_20160428_models.ActivateRouterInterfaceRequest,
    ) -> vpc_20160428_models.ActivateRouterInterfaceResponse:
        """
        @summary Activates a router interface that is in the Inactive state.
        
        @description After you call this operation, the router interface enters the *Activating** state. After the router interface is activated, it enters the **Active** state.
        >  You cannot activate a router interface that has overdue payments.
        
        @param request: ActivateRouterInterfaceRequest
        @return: ActivateRouterInterfaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.activate_router_interface_with_options_async(request, runtime)

    def active_flow_log_with_options(
        self,
        request: vpc_20160428_models.ActiveFlowLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ActiveFlowLogResponse:
        """
        @summary Enables a flow log. After the flow log is enabled, traffic information about a resource is captured.
        
        @description    The **ActiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
        If the flow log is in the **Activating** state, the flow log is being started.
        If the flow log is in the **Active** state, the flow log is started.
        You cannot repeatedly call the **ActiveFlowLog** operation to start a flow log within the specified period of time.
        
        @param request: ActiveFlowLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ActiveFlowLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.flow_log_id):
            query['FlowLogId'] = request.flow_log_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ActiveFlowLog',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ActiveFlowLogResponse(),
            self.call_api(params, req, runtime)
        )

    async def active_flow_log_with_options_async(
        self,
        request: vpc_20160428_models.ActiveFlowLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ActiveFlowLogResponse:
        """
        @summary Enables a flow log. After the flow log is enabled, traffic information about a resource is captured.
        
        @description    The **ActiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
        If the flow log is in the **Activating** state, the flow log is being started.
        If the flow log is in the **Active** state, the flow log is started.
        You cannot repeatedly call the **ActiveFlowLog** operation to start a flow log within the specified period of time.
        
        @param request: ActiveFlowLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ActiveFlowLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.flow_log_id):
            query['FlowLogId'] = request.flow_log_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ActiveFlowLog',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ActiveFlowLogResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def active_flow_log(
        self,
        request: vpc_20160428_models.ActiveFlowLogRequest,
    ) -> vpc_20160428_models.ActiveFlowLogResponse:
        """
        @summary Enables a flow log. After the flow log is enabled, traffic information about a resource is captured.
        
        @description    The **ActiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
        If the flow log is in the **Activating** state, the flow log is being started.
        If the flow log is in the **Active** state, the flow log is started.
        You cannot repeatedly call the **ActiveFlowLog** operation to start a flow log within the specified period of time.
        
        @param request: ActiveFlowLogRequest
        @return: ActiveFlowLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.active_flow_log_with_options(request, runtime)

    async def active_flow_log_async(
        self,
        request: vpc_20160428_models.ActiveFlowLogRequest,
    ) -> vpc_20160428_models.ActiveFlowLogResponse:
        """
        @summary Enables a flow log. After the flow log is enabled, traffic information about a resource is captured.
        
        @description    The **ActiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
        If the flow log is in the **Activating** state, the flow log is being started.
        If the flow log is in the **Active** state, the flow log is started.
        You cannot repeatedly call the **ActiveFlowLog** operation to start a flow log within the specified period of time.
        
        @param request: ActiveFlowLogRequest
        @return: ActiveFlowLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.active_flow_log_with_options_async(request, runtime)

    def add_bgp_network_with_options(
        self,
        request: vpc_20160428_models.AddBgpNetworkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AddBgpNetworkResponse:
        """
        @summary Advertises a Border Gateway Protocol (BGP) network.
        
        @param request: AddBgpNetworkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddBgpNetworkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dst_cidr_block):
            query['DstCidrBlock'] = request.dst_cidr_block
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddBgpNetwork',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AddBgpNetworkResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_bgp_network_with_options_async(
        self,
        request: vpc_20160428_models.AddBgpNetworkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AddBgpNetworkResponse:
        """
        @summary Advertises a Border Gateway Protocol (BGP) network.
        
        @param request: AddBgpNetworkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddBgpNetworkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dst_cidr_block):
            query['DstCidrBlock'] = request.dst_cidr_block
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddBgpNetwork',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AddBgpNetworkResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_bgp_network(
        self,
        request: vpc_20160428_models.AddBgpNetworkRequest,
    ) -> vpc_20160428_models.AddBgpNetworkResponse:
        """
        @summary Advertises a Border Gateway Protocol (BGP) network.
        
        @param request: AddBgpNetworkRequest
        @return: AddBgpNetworkResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_bgp_network_with_options(request, runtime)

    async def add_bgp_network_async(
        self,
        request: vpc_20160428_models.AddBgpNetworkRequest,
    ) -> vpc_20160428_models.AddBgpNetworkResponse:
        """
        @summary Advertises a Border Gateway Protocol (BGP) network.
        
        @param request: AddBgpNetworkRequest
        @return: AddBgpNetworkResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_bgp_network_with_options_async(request, runtime)

    def add_common_bandwidth_package_ip_with_options(
        self,
        request: vpc_20160428_models.AddCommonBandwidthPackageIpRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AddCommonBandwidthPackageIpResponse:
        """
        @summary Associates an elastic IP address (EIP) with an Internet Shared Bandwidth instance.
        
        @description Before you call this operation, take note of the following items:
        When you call this operation to associate an EIP with an Internet Shared Bandwidth instance, make sure that the EIP meets the following requirements:
        The EIP uses the pay-as-you-go billing method.
        The EIP and the Internet Shared Bandwidth instance belong to the same region.
        The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
        **AddCommonBandwidthPackageIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the operation.
        If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
        If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
        
        @param request: AddCommonBandwidthPackageIpRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCommonBandwidthPackageIpResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ip_instance_id):
            query['IpInstanceId'] = request.ip_instance_id
        if not UtilClient.is_unset(request.ip_type):
            query['IpType'] = request.ip_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCommonBandwidthPackageIp',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AddCommonBandwidthPackageIpResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_common_bandwidth_package_ip_with_options_async(
        self,
        request: vpc_20160428_models.AddCommonBandwidthPackageIpRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AddCommonBandwidthPackageIpResponse:
        """
        @summary Associates an elastic IP address (EIP) with an Internet Shared Bandwidth instance.
        
        @description Before you call this operation, take note of the following items:
        When you call this operation to associate an EIP with an Internet Shared Bandwidth instance, make sure that the EIP meets the following requirements:
        The EIP uses the pay-as-you-go billing method.
        The EIP and the Internet Shared Bandwidth instance belong to the same region.
        The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
        **AddCommonBandwidthPackageIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the operation.
        If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
        If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
        
        @param request: AddCommonBandwidthPackageIpRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCommonBandwidthPackageIpResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ip_instance_id):
            query['IpInstanceId'] = request.ip_instance_id
        if not UtilClient.is_unset(request.ip_type):
            query['IpType'] = request.ip_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCommonBandwidthPackageIp',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AddCommonBandwidthPackageIpResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_common_bandwidth_package_ip(
        self,
        request: vpc_20160428_models.AddCommonBandwidthPackageIpRequest,
    ) -> vpc_20160428_models.AddCommonBandwidthPackageIpResponse:
        """
        @summary Associates an elastic IP address (EIP) with an Internet Shared Bandwidth instance.
        
        @description Before you call this operation, take note of the following items:
        When you call this operation to associate an EIP with an Internet Shared Bandwidth instance, make sure that the EIP meets the following requirements:
        The EIP uses the pay-as-you-go billing method.
        The EIP and the Internet Shared Bandwidth instance belong to the same region.
        The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
        **AddCommonBandwidthPackageIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the operation.
        If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
        If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
        
        @param request: AddCommonBandwidthPackageIpRequest
        @return: AddCommonBandwidthPackageIpResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_common_bandwidth_package_ip_with_options(request, runtime)

    async def add_common_bandwidth_package_ip_async(
        self,
        request: vpc_20160428_models.AddCommonBandwidthPackageIpRequest,
    ) -> vpc_20160428_models.AddCommonBandwidthPackageIpResponse:
        """
        @summary Associates an elastic IP address (EIP) with an Internet Shared Bandwidth instance.
        
        @description Before you call this operation, take note of the following items:
        When you call this operation to associate an EIP with an Internet Shared Bandwidth instance, make sure that the EIP meets the following requirements:
        The EIP uses the pay-as-you-go billing method.
        The EIP and the Internet Shared Bandwidth instance belong to the same region.
        The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
        **AddCommonBandwidthPackageIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the operation.
        If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
        If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
        
        @param request: AddCommonBandwidthPackageIpRequest
        @return: AddCommonBandwidthPackageIpResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_common_bandwidth_package_ip_with_options_async(request, runtime)

    def add_common_bandwidth_package_ips_with_options(
        self,
        request: vpc_20160428_models.AddCommonBandwidthPackageIpsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AddCommonBandwidthPackageIpsResponse:
        """
        @summary Associates multiple elastic IP addresses (EIPs) with an Internet Shared Bandwidth instance.
        
        @description    When you call this operation to associate EIPs with an Internet Shared Bandwidth instance, make sure that the EIPs meet the following requirements:
        The EIPs use the pay-as-you-go billing method.
        The EIP and the Internet Shared Bandwidth instance belong to the same region.
        The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
        **AddCommonBandwidthPackageIps** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](~~DescribeCommonBandwidthPackages~~) operation to query the status of the task.
        If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
        If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
        
        @param request: AddCommonBandwidthPackageIpsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCommonBandwidthPackageIpsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ip_instance_ids):
            query['IpInstanceIds'] = request.ip_instance_ids
        if not UtilClient.is_unset(request.ip_type):
            query['IpType'] = request.ip_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCommonBandwidthPackageIps',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AddCommonBandwidthPackageIpsResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_common_bandwidth_package_ips_with_options_async(
        self,
        request: vpc_20160428_models.AddCommonBandwidthPackageIpsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AddCommonBandwidthPackageIpsResponse:
        """
        @summary Associates multiple elastic IP addresses (EIPs) with an Internet Shared Bandwidth instance.
        
        @description    When you call this operation to associate EIPs with an Internet Shared Bandwidth instance, make sure that the EIPs meet the following requirements:
        The EIPs use the pay-as-you-go billing method.
        The EIP and the Internet Shared Bandwidth instance belong to the same region.
        The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
        **AddCommonBandwidthPackageIps** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](~~DescribeCommonBandwidthPackages~~) operation to query the status of the task.
        If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
        If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
        
        @param request: AddCommonBandwidthPackageIpsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCommonBandwidthPackageIpsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ip_instance_ids):
            query['IpInstanceIds'] = request.ip_instance_ids
        if not UtilClient.is_unset(request.ip_type):
            query['IpType'] = request.ip_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCommonBandwidthPackageIps',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AddCommonBandwidthPackageIpsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_common_bandwidth_package_ips(
        self,
        request: vpc_20160428_models.AddCommonBandwidthPackageIpsRequest,
    ) -> vpc_20160428_models.AddCommonBandwidthPackageIpsResponse:
        """
        @summary Associates multiple elastic IP addresses (EIPs) with an Internet Shared Bandwidth instance.
        
        @description    When you call this operation to associate EIPs with an Internet Shared Bandwidth instance, make sure that the EIPs meet the following requirements:
        The EIPs use the pay-as-you-go billing method.
        The EIP and the Internet Shared Bandwidth instance belong to the same region.
        The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
        **AddCommonBandwidthPackageIps** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](~~DescribeCommonBandwidthPackages~~) operation to query the status of the task.
        If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
        If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
        
        @param request: AddCommonBandwidthPackageIpsRequest
        @return: AddCommonBandwidthPackageIpsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_common_bandwidth_package_ips_with_options(request, runtime)

    async def add_common_bandwidth_package_ips_async(
        self,
        request: vpc_20160428_models.AddCommonBandwidthPackageIpsRequest,
    ) -> vpc_20160428_models.AddCommonBandwidthPackageIpsResponse:
        """
        @summary Associates multiple elastic IP addresses (EIPs) with an Internet Shared Bandwidth instance.
        
        @description    When you call this operation to associate EIPs with an Internet Shared Bandwidth instance, make sure that the EIPs meet the following requirements:
        The EIPs use the pay-as-you-go billing method.
        The EIP and the Internet Shared Bandwidth instance belong to the same region.
        The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
        **AddCommonBandwidthPackageIps** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](~~DescribeCommonBandwidthPackages~~) operation to query the status of the task.
        If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
        If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
        
        @param request: AddCommonBandwidthPackageIpsRequest
        @return: AddCommonBandwidthPackageIpsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_common_bandwidth_package_ips_with_options_async(request, runtime)

    def add_global_acceleration_instance_ip_with_options(
        self,
        request: vpc_20160428_models.AddGlobalAccelerationInstanceIpRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AddGlobalAccelerationInstanceIpResponse:
        """
        @summary Associates an elastic IP address (EIP) with a shared-bandwidth Global Accelerator (GA) instance.
        
        @param request: AddGlobalAccelerationInstanceIpRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddGlobalAccelerationInstanceIpResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.global_acceleration_instance_id):
            query['GlobalAccelerationInstanceId'] = request.global_acceleration_instance_id
        if not UtilClient.is_unset(request.ip_instance_id):
            query['IpInstanceId'] = request.ip_instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddGlobalAccelerationInstanceIp',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AddGlobalAccelerationInstanceIpResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_global_acceleration_instance_ip_with_options_async(
        self,
        request: vpc_20160428_models.AddGlobalAccelerationInstanceIpRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AddGlobalAccelerationInstanceIpResponse:
        """
        @summary Associates an elastic IP address (EIP) with a shared-bandwidth Global Accelerator (GA) instance.
        
        @param request: AddGlobalAccelerationInstanceIpRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddGlobalAccelerationInstanceIpResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.global_acceleration_instance_id):
            query['GlobalAccelerationInstanceId'] = request.global_acceleration_instance_id
        if not UtilClient.is_unset(request.ip_instance_id):
            query['IpInstanceId'] = request.ip_instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddGlobalAccelerationInstanceIp',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AddGlobalAccelerationInstanceIpResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_global_acceleration_instance_ip(
        self,
        request: vpc_20160428_models.AddGlobalAccelerationInstanceIpRequest,
    ) -> vpc_20160428_models.AddGlobalAccelerationInstanceIpResponse:
        """
        @summary Associates an elastic IP address (EIP) with a shared-bandwidth Global Accelerator (GA) instance.
        
        @param request: AddGlobalAccelerationInstanceIpRequest
        @return: AddGlobalAccelerationInstanceIpResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_global_acceleration_instance_ip_with_options(request, runtime)

    async def add_global_acceleration_instance_ip_async(
        self,
        request: vpc_20160428_models.AddGlobalAccelerationInstanceIpRequest,
    ) -> vpc_20160428_models.AddGlobalAccelerationInstanceIpResponse:
        """
        @summary Associates an elastic IP address (EIP) with a shared-bandwidth Global Accelerator (GA) instance.
        
        @param request: AddGlobalAccelerationInstanceIpRequest
        @return: AddGlobalAccelerationInstanceIpResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_global_acceleration_instance_ip_with_options_async(request, runtime)

    def add_ipv_6translator_acl_list_entry_with_options(
        self,
        request: vpc_20160428_models.AddIPv6TranslatorAclListEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AddIPv6TranslatorAclListEntryResponse:
        """
        @deprecated OpenAPI AddIPv6TranslatorAclListEntry is deprecated
        
        @summary Adds an IP entry to an access control list (ACL).
        
        @param request: AddIPv6TranslatorAclListEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddIPv6TranslatorAclListEntryResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_entry_comment):
            query['AclEntryComment'] = request.acl_entry_comment
        if not UtilClient.is_unset(request.acl_entry_ip):
            query['AclEntryIp'] = request.acl_entry_ip
        if not UtilClient.is_unset(request.acl_id):
            query['AclId'] = request.acl_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddIPv6TranslatorAclListEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AddIPv6TranslatorAclListEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_ipv_6translator_acl_list_entry_with_options_async(
        self,
        request: vpc_20160428_models.AddIPv6TranslatorAclListEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AddIPv6TranslatorAclListEntryResponse:
        """
        @deprecated OpenAPI AddIPv6TranslatorAclListEntry is deprecated
        
        @summary Adds an IP entry to an access control list (ACL).
        
        @param request: AddIPv6TranslatorAclListEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddIPv6TranslatorAclListEntryResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_entry_comment):
            query['AclEntryComment'] = request.acl_entry_comment
        if not UtilClient.is_unset(request.acl_entry_ip):
            query['AclEntryIp'] = request.acl_entry_ip
        if not UtilClient.is_unset(request.acl_id):
            query['AclId'] = request.acl_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddIPv6TranslatorAclListEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AddIPv6TranslatorAclListEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_ipv_6translator_acl_list_entry(
        self,
        request: vpc_20160428_models.AddIPv6TranslatorAclListEntryRequest,
    ) -> vpc_20160428_models.AddIPv6TranslatorAclListEntryResponse:
        """
        @deprecated OpenAPI AddIPv6TranslatorAclListEntry is deprecated
        
        @summary Adds an IP entry to an access control list (ACL).
        
        @param request: AddIPv6TranslatorAclListEntryRequest
        @return: AddIPv6TranslatorAclListEntryResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.add_ipv_6translator_acl_list_entry_with_options(request, runtime)

    async def add_ipv_6translator_acl_list_entry_async(
        self,
        request: vpc_20160428_models.AddIPv6TranslatorAclListEntryRequest,
    ) -> vpc_20160428_models.AddIPv6TranslatorAclListEntryResponse:
        """
        @deprecated OpenAPI AddIPv6TranslatorAclListEntry is deprecated
        
        @summary Adds an IP entry to an access control list (ACL).
        
        @param request: AddIPv6TranslatorAclListEntryRequest
        @return: AddIPv6TranslatorAclListEntryResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_ipv_6translator_acl_list_entry_with_options_async(request, runtime)

    def add_public_ip_address_pool_cidr_block_with_options(
        self,
        request: vpc_20160428_models.AddPublicIpAddressPoolCidrBlockRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AddPublicIpAddressPoolCidrBlockResponse:
        """
        @summary Adds a CIDR block to an IP address pool.
        
        @description Before you call this operation, take note of the following limits:
        The CIDR block and the IP address pool must belong to the same region.
        The CIDR block and the IP address pool must use the same line type.
        **AddPublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
        If the CIDR block is in the **Modifying** state, the CIDR block is being added. In this state, you can only query the CIDR block and cannot perform other operations.
        If the CIDR block is in the **Created** state, the CIDR block is added.
        You cannot repeatedly call the **AddPublicIpAddressPoolCidrBlock** operation to add a CIDR block to an IP address pool within the specified period of time.
        
        @param request: AddPublicIpAddressPoolCidrBlockRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddPublicIpAddressPoolCidrBlockResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cidr_block):
            query['CidrBlock'] = request.cidr_block
        if not UtilClient.is_unset(request.cidr_mask):
            query['CidrMask'] = request.cidr_mask
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.public_ip_address_pool_id):
            query['PublicIpAddressPoolId'] = request.public_ip_address_pool_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddPublicIpAddressPoolCidrBlock',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AddPublicIpAddressPoolCidrBlockResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_public_ip_address_pool_cidr_block_with_options_async(
        self,
        request: vpc_20160428_models.AddPublicIpAddressPoolCidrBlockRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AddPublicIpAddressPoolCidrBlockResponse:
        """
        @summary Adds a CIDR block to an IP address pool.
        
        @description Before you call this operation, take note of the following limits:
        The CIDR block and the IP address pool must belong to the same region.
        The CIDR block and the IP address pool must use the same line type.
        **AddPublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
        If the CIDR block is in the **Modifying** state, the CIDR block is being added. In this state, you can only query the CIDR block and cannot perform other operations.
        If the CIDR block is in the **Created** state, the CIDR block is added.
        You cannot repeatedly call the **AddPublicIpAddressPoolCidrBlock** operation to add a CIDR block to an IP address pool within the specified period of time.
        
        @param request: AddPublicIpAddressPoolCidrBlockRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddPublicIpAddressPoolCidrBlockResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cidr_block):
            query['CidrBlock'] = request.cidr_block
        if not UtilClient.is_unset(request.cidr_mask):
            query['CidrMask'] = request.cidr_mask
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.public_ip_address_pool_id):
            query['PublicIpAddressPoolId'] = request.public_ip_address_pool_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddPublicIpAddressPoolCidrBlock',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AddPublicIpAddressPoolCidrBlockResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_public_ip_address_pool_cidr_block(
        self,
        request: vpc_20160428_models.AddPublicIpAddressPoolCidrBlockRequest,
    ) -> vpc_20160428_models.AddPublicIpAddressPoolCidrBlockResponse:
        """
        @summary Adds a CIDR block to an IP address pool.
        
        @description Before you call this operation, take note of the following limits:
        The CIDR block and the IP address pool must belong to the same region.
        The CIDR block and the IP address pool must use the same line type.
        **AddPublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
        If the CIDR block is in the **Modifying** state, the CIDR block is being added. In this state, you can only query the CIDR block and cannot perform other operations.
        If the CIDR block is in the **Created** state, the CIDR block is added.
        You cannot repeatedly call the **AddPublicIpAddressPoolCidrBlock** operation to add a CIDR block to an IP address pool within the specified period of time.
        
        @param request: AddPublicIpAddressPoolCidrBlockRequest
        @return: AddPublicIpAddressPoolCidrBlockResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_public_ip_address_pool_cidr_block_with_options(request, runtime)

    async def add_public_ip_address_pool_cidr_block_async(
        self,
        request: vpc_20160428_models.AddPublicIpAddressPoolCidrBlockRequest,
    ) -> vpc_20160428_models.AddPublicIpAddressPoolCidrBlockResponse:
        """
        @summary Adds a CIDR block to an IP address pool.
        
        @description Before you call this operation, take note of the following limits:
        The CIDR block and the IP address pool must belong to the same region.
        The CIDR block and the IP address pool must use the same line type.
        **AddPublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
        If the CIDR block is in the **Modifying** state, the CIDR block is being added. In this state, you can only query the CIDR block and cannot perform other operations.
        If the CIDR block is in the **Created** state, the CIDR block is added.
        You cannot repeatedly call the **AddPublicIpAddressPoolCidrBlock** operation to add a CIDR block to an IP address pool within the specified period of time.
        
        @param request: AddPublicIpAddressPoolCidrBlockRequest
        @return: AddPublicIpAddressPoolCidrBlockResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_public_ip_address_pool_cidr_block_with_options_async(request, runtime)

    def add_sources_to_traffic_mirror_session_with_options(
        self,
        request: vpc_20160428_models.AddSourcesToTrafficMirrorSessionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AddSourcesToTrafficMirrorSessionResponse:
        """
        @summary Adds a traffic mirror source to a traffic mirror session.
        
        @description    **AddSourcesToTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
        If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being added to the traffic mirror session.
        If the traffic mirror session is in the **Created** state, the traffic mirror source is added to the traffic mirror session.
        You cannot repeatedly call the **AddSourcesToTrafficMirrorSession** operation to add a traffic mirror source to a traffic mirror session within the specified period of time.
        
        @param request: AddSourcesToTrafficMirrorSessionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddSourcesToTrafficMirrorSessionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.traffic_mirror_session_id):
            query['TrafficMirrorSessionId'] = request.traffic_mirror_session_id
        if not UtilClient.is_unset(request.traffic_mirror_source_ids):
            query['TrafficMirrorSourceIds'] = request.traffic_mirror_source_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddSourcesToTrafficMirrorSession',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AddSourcesToTrafficMirrorSessionResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_sources_to_traffic_mirror_session_with_options_async(
        self,
        request: vpc_20160428_models.AddSourcesToTrafficMirrorSessionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AddSourcesToTrafficMirrorSessionResponse:
        """
        @summary Adds a traffic mirror source to a traffic mirror session.
        
        @description    **AddSourcesToTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
        If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being added to the traffic mirror session.
        If the traffic mirror session is in the **Created** state, the traffic mirror source is added to the traffic mirror session.
        You cannot repeatedly call the **AddSourcesToTrafficMirrorSession** operation to add a traffic mirror source to a traffic mirror session within the specified period of time.
        
        @param request: AddSourcesToTrafficMirrorSessionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddSourcesToTrafficMirrorSessionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.traffic_mirror_session_id):
            query['TrafficMirrorSessionId'] = request.traffic_mirror_session_id
        if not UtilClient.is_unset(request.traffic_mirror_source_ids):
            query['TrafficMirrorSourceIds'] = request.traffic_mirror_source_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddSourcesToTrafficMirrorSession',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AddSourcesToTrafficMirrorSessionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_sources_to_traffic_mirror_session(
        self,
        request: vpc_20160428_models.AddSourcesToTrafficMirrorSessionRequest,
    ) -> vpc_20160428_models.AddSourcesToTrafficMirrorSessionResponse:
        """
        @summary Adds a traffic mirror source to a traffic mirror session.
        
        @description    **AddSourcesToTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
        If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being added to the traffic mirror session.
        If the traffic mirror session is in the **Created** state, the traffic mirror source is added to the traffic mirror session.
        You cannot repeatedly call the **AddSourcesToTrafficMirrorSession** operation to add a traffic mirror source to a traffic mirror session within the specified period of time.
        
        @param request: AddSourcesToTrafficMirrorSessionRequest
        @return: AddSourcesToTrafficMirrorSessionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_sources_to_traffic_mirror_session_with_options(request, runtime)

    async def add_sources_to_traffic_mirror_session_async(
        self,
        request: vpc_20160428_models.AddSourcesToTrafficMirrorSessionRequest,
    ) -> vpc_20160428_models.AddSourcesToTrafficMirrorSessionResponse:
        """
        @summary Adds a traffic mirror source to a traffic mirror session.
        
        @description    **AddSourcesToTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
        If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being added to the traffic mirror session.
        If the traffic mirror session is in the **Created** state, the traffic mirror source is added to the traffic mirror session.
        You cannot repeatedly call the **AddSourcesToTrafficMirrorSession** operation to add a traffic mirror source to a traffic mirror session within the specified period of time.
        
        @param request: AddSourcesToTrafficMirrorSessionRequest
        @return: AddSourcesToTrafficMirrorSessionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_sources_to_traffic_mirror_session_with_options_async(request, runtime)

    def allocate_eip_address_with_options(
        self,
        request: vpc_20160428_models.AllocateEipAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AllocateEipAddressResponse:
        """
        @summary Applies for an elastic IP address (EIP).
        
        @description Before you call this operation, make sure that you are familiar with the billing methods and pricing of EIPs. For more information, see [Billing overview](https://help.aliyun.com/document_detail/122035.html).
        After you call this operation, the system randomly allocates an EIP that is in the *Available** state in the specified region. EIPs support only the ICMP, TCP, and UDP transport layer protocols. The IGMP and SCTP protocols are not supported.
        
        @param request: AllocateEipAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AllocateEipAddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.activity_id):
            query['ActivityId'] = request.activity_id
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.isp):
            query['ISP'] = request.isp
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.ip_address):
            query['IpAddress'] = request.ip_address
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.netmode):
            query['Netmode'] = request.netmode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.pricing_cycle):
            query['PricingCycle'] = request.pricing_cycle
        if not UtilClient.is_unset(request.public_ip_address_pool_id):
            query['PublicIpAddressPoolId'] = request.public_ip_address_pool_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_protection_types):
            query['SecurityProtectionTypes'] = request.security_protection_types
        if not UtilClient.is_unset(request.zone):
            query['Zone'] = request.zone
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AllocateEipAddress',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AllocateEipAddressResponse(),
            self.call_api(params, req, runtime)
        )

    async def allocate_eip_address_with_options_async(
        self,
        request: vpc_20160428_models.AllocateEipAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AllocateEipAddressResponse:
        """
        @summary Applies for an elastic IP address (EIP).
        
        @description Before you call this operation, make sure that you are familiar with the billing methods and pricing of EIPs. For more information, see [Billing overview](https://help.aliyun.com/document_detail/122035.html).
        After you call this operation, the system randomly allocates an EIP that is in the *Available** state in the specified region. EIPs support only the ICMP, TCP, and UDP transport layer protocols. The IGMP and SCTP protocols are not supported.
        
        @param request: AllocateEipAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AllocateEipAddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.activity_id):
            query['ActivityId'] = request.activity_id
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.isp):
            query['ISP'] = request.isp
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.ip_address):
            query['IpAddress'] = request.ip_address
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.netmode):
            query['Netmode'] = request.netmode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.pricing_cycle):
            query['PricingCycle'] = request.pricing_cycle
        if not UtilClient.is_unset(request.public_ip_address_pool_id):
            query['PublicIpAddressPoolId'] = request.public_ip_address_pool_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_protection_types):
            query['SecurityProtectionTypes'] = request.security_protection_types
        if not UtilClient.is_unset(request.zone):
            query['Zone'] = request.zone
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AllocateEipAddress',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AllocateEipAddressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def allocate_eip_address(
        self,
        request: vpc_20160428_models.AllocateEipAddressRequest,
    ) -> vpc_20160428_models.AllocateEipAddressResponse:
        """
        @summary Applies for an elastic IP address (EIP).
        
        @description Before you call this operation, make sure that you are familiar with the billing methods and pricing of EIPs. For more information, see [Billing overview](https://help.aliyun.com/document_detail/122035.html).
        After you call this operation, the system randomly allocates an EIP that is in the *Available** state in the specified region. EIPs support only the ICMP, TCP, and UDP transport layer protocols. The IGMP and SCTP protocols are not supported.
        
        @param request: AllocateEipAddressRequest
        @return: AllocateEipAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.allocate_eip_address_with_options(request, runtime)

    async def allocate_eip_address_async(
        self,
        request: vpc_20160428_models.AllocateEipAddressRequest,
    ) -> vpc_20160428_models.AllocateEipAddressResponse:
        """
        @summary Applies for an elastic IP address (EIP).
        
        @description Before you call this operation, make sure that you are familiar with the billing methods and pricing of EIPs. For more information, see [Billing overview](https://help.aliyun.com/document_detail/122035.html).
        After you call this operation, the system randomly allocates an EIP that is in the *Available** state in the specified region. EIPs support only the ICMP, TCP, and UDP transport layer protocols. The IGMP and SCTP protocols are not supported.
        
        @param request: AllocateEipAddressRequest
        @return: AllocateEipAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.allocate_eip_address_with_options_async(request, runtime)

    def allocate_eip_address_pro_with_options(
        self,
        request: vpc_20160428_models.AllocateEipAddressProRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AllocateEipAddressProResponse:
        """
        @summary Requests a specified elastic IP address (EIP).
        
        @param request: AllocateEipAddressProRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AllocateEipAddressProResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.isp):
            query['ISP'] = request.isp
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.ip_address):
            query['IpAddress'] = request.ip_address
        if not UtilClient.is_unset(request.netmode):
            query['Netmode'] = request.netmode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.pricing_cycle):
            query['PricingCycle'] = request.pricing_cycle
        if not UtilClient.is_unset(request.public_ip_address_pool_id):
            query['PublicIpAddressPoolId'] = request.public_ip_address_pool_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_protection_types):
            query['SecurityProtectionTypes'] = request.security_protection_types
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AllocateEipAddressPro',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AllocateEipAddressProResponse(),
            self.call_api(params, req, runtime)
        )

    async def allocate_eip_address_pro_with_options_async(
        self,
        request: vpc_20160428_models.AllocateEipAddressProRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AllocateEipAddressProResponse:
        """
        @summary Requests a specified elastic IP address (EIP).
        
        @param request: AllocateEipAddressProRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AllocateEipAddressProResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.isp):
            query['ISP'] = request.isp
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.ip_address):
            query['IpAddress'] = request.ip_address
        if not UtilClient.is_unset(request.netmode):
            query['Netmode'] = request.netmode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.pricing_cycle):
            query['PricingCycle'] = request.pricing_cycle
        if not UtilClient.is_unset(request.public_ip_address_pool_id):
            query['PublicIpAddressPoolId'] = request.public_ip_address_pool_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_protection_types):
            query['SecurityProtectionTypes'] = request.security_protection_types
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AllocateEipAddressPro',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AllocateEipAddressProResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def allocate_eip_address_pro(
        self,
        request: vpc_20160428_models.AllocateEipAddressProRequest,
    ) -> vpc_20160428_models.AllocateEipAddressProResponse:
        """
        @summary Requests a specified elastic IP address (EIP).
        
        @param request: AllocateEipAddressProRequest
        @return: AllocateEipAddressProResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.allocate_eip_address_pro_with_options(request, runtime)

    async def allocate_eip_address_pro_async(
        self,
        request: vpc_20160428_models.AllocateEipAddressProRequest,
    ) -> vpc_20160428_models.AllocateEipAddressProResponse:
        """
        @summary Requests a specified elastic IP address (EIP).
        
        @param request: AllocateEipAddressProRequest
        @return: AllocateEipAddressProResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.allocate_eip_address_pro_with_options_async(request, runtime)

    def allocate_eip_segment_address_with_options(
        self,
        request: vpc_20160428_models.AllocateEipSegmentAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AllocateEipSegmentAddressResponse:
        """
        @summary Applies for contiguous elastic IP addresses (EIPs).
        
        @description *AllocateEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns the ID of a contiguous EIP group and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
        If the contiguous EIP group is in the **Allocating** state, the EIPs are being allocated. In this case, you can only perform the query operation and cannot perform other operations.
        If the contiguous EIP group is in the **Allocated** state, the EIPs are allocated.
        
        @param request: AllocateEipSegmentAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AllocateEipSegmentAddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.eip_mask):
            query['EipMask'] = request.eip_mask
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.isp):
            query['Isp'] = request.isp
        if not UtilClient.is_unset(request.netmode):
            query['Netmode'] = request.netmode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.zone):
            query['Zone'] = request.zone
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AllocateEipSegmentAddress',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AllocateEipSegmentAddressResponse(),
            self.call_api(params, req, runtime)
        )

    async def allocate_eip_segment_address_with_options_async(
        self,
        request: vpc_20160428_models.AllocateEipSegmentAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AllocateEipSegmentAddressResponse:
        """
        @summary Applies for contiguous elastic IP addresses (EIPs).
        
        @description *AllocateEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns the ID of a contiguous EIP group and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
        If the contiguous EIP group is in the **Allocating** state, the EIPs are being allocated. In this case, you can only perform the query operation and cannot perform other operations.
        If the contiguous EIP group is in the **Allocated** state, the EIPs are allocated.
        
        @param request: AllocateEipSegmentAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AllocateEipSegmentAddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.eip_mask):
            query['EipMask'] = request.eip_mask
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.isp):
            query['Isp'] = request.isp
        if not UtilClient.is_unset(request.netmode):
            query['Netmode'] = request.netmode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.zone):
            query['Zone'] = request.zone
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AllocateEipSegmentAddress',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AllocateEipSegmentAddressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def allocate_eip_segment_address(
        self,
        request: vpc_20160428_models.AllocateEipSegmentAddressRequest,
    ) -> vpc_20160428_models.AllocateEipSegmentAddressResponse:
        """
        @summary Applies for contiguous elastic IP addresses (EIPs).
        
        @description *AllocateEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns the ID of a contiguous EIP group and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
        If the contiguous EIP group is in the **Allocating** state, the EIPs are being allocated. In this case, you can only perform the query operation and cannot perform other operations.
        If the contiguous EIP group is in the **Allocated** state, the EIPs are allocated.
        
        @param request: AllocateEipSegmentAddressRequest
        @return: AllocateEipSegmentAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.allocate_eip_segment_address_with_options(request, runtime)

    async def allocate_eip_segment_address_async(
        self,
        request: vpc_20160428_models.AllocateEipSegmentAddressRequest,
    ) -> vpc_20160428_models.AllocateEipSegmentAddressResponse:
        """
        @summary Applies for contiguous elastic IP addresses (EIPs).
        
        @description *AllocateEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns the ID of a contiguous EIP group and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
        If the contiguous EIP group is in the **Allocating** state, the EIPs are being allocated. In this case, you can only perform the query operation and cannot perform other operations.
        If the contiguous EIP group is in the **Allocated** state, the EIPs are allocated.
        
        @param request: AllocateEipSegmentAddressRequest
        @return: AllocateEipSegmentAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.allocate_eip_segment_address_with_options_async(request, runtime)

    def allocate_ipv_6address_with_options(
        self,
        request: vpc_20160428_models.AllocateIpv6AddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AllocateIpv6AddressResponse:
        """
        @summary Assigns an IPv6 address.
        
        @param request: AllocateIpv6AddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AllocateIpv6AddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.address_type):
            query['AddressType'] = request.address_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.ipv_6address):
            query['Ipv6Address'] = request.ipv_6address
        if not UtilClient.is_unset(request.ipv_6address_description):
            query['Ipv6AddressDescription'] = request.ipv_6address_description
        if not UtilClient.is_unset(request.ipv_6address_name):
            query['Ipv6AddressName'] = request.ipv_6address_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AllocateIpv6Address',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AllocateIpv6AddressResponse(),
            self.call_api(params, req, runtime)
        )

    async def allocate_ipv_6address_with_options_async(
        self,
        request: vpc_20160428_models.AllocateIpv6AddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AllocateIpv6AddressResponse:
        """
        @summary Assigns an IPv6 address.
        
        @param request: AllocateIpv6AddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AllocateIpv6AddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.address_type):
            query['AddressType'] = request.address_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.ipv_6address):
            query['Ipv6Address'] = request.ipv_6address
        if not UtilClient.is_unset(request.ipv_6address_description):
            query['Ipv6AddressDescription'] = request.ipv_6address_description
        if not UtilClient.is_unset(request.ipv_6address_name):
            query['Ipv6AddressName'] = request.ipv_6address_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AllocateIpv6Address',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AllocateIpv6AddressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def allocate_ipv_6address(
        self,
        request: vpc_20160428_models.AllocateIpv6AddressRequest,
    ) -> vpc_20160428_models.AllocateIpv6AddressResponse:
        """
        @summary Assigns an IPv6 address.
        
        @param request: AllocateIpv6AddressRequest
        @return: AllocateIpv6AddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.allocate_ipv_6address_with_options(request, runtime)

    async def allocate_ipv_6address_async(
        self,
        request: vpc_20160428_models.AllocateIpv6AddressRequest,
    ) -> vpc_20160428_models.AllocateIpv6AddressResponse:
        """
        @summary Assigns an IPv6 address.
        
        @param request: AllocateIpv6AddressRequest
        @return: AllocateIpv6AddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.allocate_ipv_6address_with_options_async(request, runtime)

    def allocate_ipv_6internet_bandwidth_with_options(
        self,
        request: vpc_20160428_models.AllocateIpv6InternetBandwidthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AllocateIpv6InternetBandwidthResponse:
        """
        @summary Default IPv6 gateways support only private communication. You can call the AllocateIpv6InternetBandwidth operation to purchase Internet bandwidth resources for an IPv6 address. This way, ECS instances in a VPC can access the Internet through the IPv6 address. IPv6 clients can also access the ECS instances over the Internet.
        
        @description You cannot repeatedly call the *AllocateIpv6InternetBandwidth** operation within a specific time period.
        
        @param request: AllocateIpv6InternetBandwidthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AllocateIpv6InternetBandwidthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.ipv_6address_id):
            query['Ipv6AddressId'] = request.ipv_6address_id
        if not UtilClient.is_unset(request.ipv_6gateway_id):
            query['Ipv6GatewayId'] = request.ipv_6gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AllocateIpv6InternetBandwidth',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AllocateIpv6InternetBandwidthResponse(),
            self.call_api(params, req, runtime)
        )

    async def allocate_ipv_6internet_bandwidth_with_options_async(
        self,
        request: vpc_20160428_models.AllocateIpv6InternetBandwidthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AllocateIpv6InternetBandwidthResponse:
        """
        @summary Default IPv6 gateways support only private communication. You can call the AllocateIpv6InternetBandwidth operation to purchase Internet bandwidth resources for an IPv6 address. This way, ECS instances in a VPC can access the Internet through the IPv6 address. IPv6 clients can also access the ECS instances over the Internet.
        
        @description You cannot repeatedly call the *AllocateIpv6InternetBandwidth** operation within a specific time period.
        
        @param request: AllocateIpv6InternetBandwidthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AllocateIpv6InternetBandwidthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.ipv_6address_id):
            query['Ipv6AddressId'] = request.ipv_6address_id
        if not UtilClient.is_unset(request.ipv_6gateway_id):
            query['Ipv6GatewayId'] = request.ipv_6gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AllocateIpv6InternetBandwidth',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AllocateIpv6InternetBandwidthResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def allocate_ipv_6internet_bandwidth(
        self,
        request: vpc_20160428_models.AllocateIpv6InternetBandwidthRequest,
    ) -> vpc_20160428_models.AllocateIpv6InternetBandwidthResponse:
        """
        @summary Default IPv6 gateways support only private communication. You can call the AllocateIpv6InternetBandwidth operation to purchase Internet bandwidth resources for an IPv6 address. This way, ECS instances in a VPC can access the Internet through the IPv6 address. IPv6 clients can also access the ECS instances over the Internet.
        
        @description You cannot repeatedly call the *AllocateIpv6InternetBandwidth** operation within a specific time period.
        
        @param request: AllocateIpv6InternetBandwidthRequest
        @return: AllocateIpv6InternetBandwidthResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.allocate_ipv_6internet_bandwidth_with_options(request, runtime)

    async def allocate_ipv_6internet_bandwidth_async(
        self,
        request: vpc_20160428_models.AllocateIpv6InternetBandwidthRequest,
    ) -> vpc_20160428_models.AllocateIpv6InternetBandwidthResponse:
        """
        @summary Default IPv6 gateways support only private communication. You can call the AllocateIpv6InternetBandwidth operation to purchase Internet bandwidth resources for an IPv6 address. This way, ECS instances in a VPC can access the Internet through the IPv6 address. IPv6 clients can also access the ECS instances over the Internet.
        
        @description You cannot repeatedly call the *AllocateIpv6InternetBandwidth** operation within a specific time period.
        
        @param request: AllocateIpv6InternetBandwidthRequest
        @return: AllocateIpv6InternetBandwidthResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.allocate_ipv_6internet_bandwidth_with_options_async(request, runtime)

    def allocate_vpc_ipv_6cidr_with_options(
        self,
        request: vpc_20160428_models.AllocateVpcIpv6CidrRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AllocateVpcIpv6CidrResponse:
        """
        @summary Reserves an IPv6 CIDR block.
        
        @description # [](#)
        The following section describes how to allocate an IPv6 CIDR block to a virtual private cloud (VPC):
        1.  Call the AllocateVpcIpv6Cidr operation to reserve the IPv6 CIDR block.
        2.  To allocate an IPv6 CIDR block to an existing VPC, call the [AssociateVpcCidrBlock](https://help.aliyun.com/document_detail/146745.html) operation. Set *RegionId**, **VpcId**, and **IPv6CidrBlock** to the IPv6 CIDR bock, and set **IpVersion** to **ipv6**. To allocate an IPv6 CIDR block when you create a VPC, call the [CreateVpc](https://help.aliyun.com/document_detail/35737.html) operation. Set **RegionId** and **Ipv6CidrBlock** to the IPv6 CIDR block, and set **EnableIpv6** to **true**.
        
        @param request: AllocateVpcIpv6CidrRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AllocateVpcIpv6CidrResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.address_pool_type):
            query['AddressPoolType'] = request.address_pool_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ipv_6cidr_block):
            query['Ipv6CidrBlock'] = request.ipv_6cidr_block
        if not UtilClient.is_unset(request.ipv_6isp):
            query['Ipv6Isp'] = request.ipv_6isp
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AllocateVpcIpv6Cidr',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AllocateVpcIpv6CidrResponse(),
            self.call_api(params, req, runtime)
        )

    async def allocate_vpc_ipv_6cidr_with_options_async(
        self,
        request: vpc_20160428_models.AllocateVpcIpv6CidrRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AllocateVpcIpv6CidrResponse:
        """
        @summary Reserves an IPv6 CIDR block.
        
        @description # [](#)
        The following section describes how to allocate an IPv6 CIDR block to a virtual private cloud (VPC):
        1.  Call the AllocateVpcIpv6Cidr operation to reserve the IPv6 CIDR block.
        2.  To allocate an IPv6 CIDR block to an existing VPC, call the [AssociateVpcCidrBlock](https://help.aliyun.com/document_detail/146745.html) operation. Set *RegionId**, **VpcId**, and **IPv6CidrBlock** to the IPv6 CIDR bock, and set **IpVersion** to **ipv6**. To allocate an IPv6 CIDR block when you create a VPC, call the [CreateVpc](https://help.aliyun.com/document_detail/35737.html) operation. Set **RegionId** and **Ipv6CidrBlock** to the IPv6 CIDR block, and set **EnableIpv6** to **true**.
        
        @param request: AllocateVpcIpv6CidrRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AllocateVpcIpv6CidrResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.address_pool_type):
            query['AddressPoolType'] = request.address_pool_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ipv_6cidr_block):
            query['Ipv6CidrBlock'] = request.ipv_6cidr_block
        if not UtilClient.is_unset(request.ipv_6isp):
            query['Ipv6Isp'] = request.ipv_6isp
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AllocateVpcIpv6Cidr',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AllocateVpcIpv6CidrResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def allocate_vpc_ipv_6cidr(
        self,
        request: vpc_20160428_models.AllocateVpcIpv6CidrRequest,
    ) -> vpc_20160428_models.AllocateVpcIpv6CidrResponse:
        """
        @summary Reserves an IPv6 CIDR block.
        
        @description # [](#)
        The following section describes how to allocate an IPv6 CIDR block to a virtual private cloud (VPC):
        1.  Call the AllocateVpcIpv6Cidr operation to reserve the IPv6 CIDR block.
        2.  To allocate an IPv6 CIDR block to an existing VPC, call the [AssociateVpcCidrBlock](https://help.aliyun.com/document_detail/146745.html) operation. Set *RegionId**, **VpcId**, and **IPv6CidrBlock** to the IPv6 CIDR bock, and set **IpVersion** to **ipv6**. To allocate an IPv6 CIDR block when you create a VPC, call the [CreateVpc](https://help.aliyun.com/document_detail/35737.html) operation. Set **RegionId** and **Ipv6CidrBlock** to the IPv6 CIDR block, and set **EnableIpv6** to **true**.
        
        @param request: AllocateVpcIpv6CidrRequest
        @return: AllocateVpcIpv6CidrResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.allocate_vpc_ipv_6cidr_with_options(request, runtime)

    async def allocate_vpc_ipv_6cidr_async(
        self,
        request: vpc_20160428_models.AllocateVpcIpv6CidrRequest,
    ) -> vpc_20160428_models.AllocateVpcIpv6CidrResponse:
        """
        @summary Reserves an IPv6 CIDR block.
        
        @description # [](#)
        The following section describes how to allocate an IPv6 CIDR block to a virtual private cloud (VPC):
        1.  Call the AllocateVpcIpv6Cidr operation to reserve the IPv6 CIDR block.
        2.  To allocate an IPv6 CIDR block to an existing VPC, call the [AssociateVpcCidrBlock](https://help.aliyun.com/document_detail/146745.html) operation. Set *RegionId**, **VpcId**, and **IPv6CidrBlock** to the IPv6 CIDR bock, and set **IpVersion** to **ipv6**. To allocate an IPv6 CIDR block when you create a VPC, call the [CreateVpc](https://help.aliyun.com/document_detail/35737.html) operation. Set **RegionId** and **Ipv6CidrBlock** to the IPv6 CIDR block, and set **EnableIpv6** to **true**.
        
        @param request: AllocateVpcIpv6CidrRequest
        @return: AllocateVpcIpv6CidrResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.allocate_vpc_ipv_6cidr_with_options_async(request, runtime)

    def apply_physical_connection_loawith_options(
        self,
        request: vpc_20160428_models.ApplyPhysicalConnectionLOARequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ApplyPhysicalConnectionLOAResponse:
        """
        @summary Applies for a Letter of Authorization (LOA) for an Express Connect circuit.
        
        @param request: ApplyPhysicalConnectionLOARequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ApplyPhysicalConnectionLOAResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.company_name):
            query['CompanyName'] = request.company_name
        if not UtilClient.is_unset(request.construction_time):
            query['ConstructionTime'] = request.construction_time
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.line_type):
            query['LineType'] = request.line_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pminfo):
            query['PMInfo'] = request.pminfo
        if not UtilClient.is_unset(request.peer_location):
            query['PeerLocation'] = request.peer_location
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.si):
            query['Si'] = request.si
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ApplyPhysicalConnectionLOA',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ApplyPhysicalConnectionLOAResponse(),
            self.call_api(params, req, runtime)
        )

    async def apply_physical_connection_loawith_options_async(
        self,
        request: vpc_20160428_models.ApplyPhysicalConnectionLOARequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ApplyPhysicalConnectionLOAResponse:
        """
        @summary Applies for a Letter of Authorization (LOA) for an Express Connect circuit.
        
        @param request: ApplyPhysicalConnectionLOARequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ApplyPhysicalConnectionLOAResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.company_name):
            query['CompanyName'] = request.company_name
        if not UtilClient.is_unset(request.construction_time):
            query['ConstructionTime'] = request.construction_time
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.line_type):
            query['LineType'] = request.line_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pminfo):
            query['PMInfo'] = request.pminfo
        if not UtilClient.is_unset(request.peer_location):
            query['PeerLocation'] = request.peer_location
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.si):
            query['Si'] = request.si
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ApplyPhysicalConnectionLOA',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ApplyPhysicalConnectionLOAResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def apply_physical_connection_loa(
        self,
        request: vpc_20160428_models.ApplyPhysicalConnectionLOARequest,
    ) -> vpc_20160428_models.ApplyPhysicalConnectionLOAResponse:
        """
        @summary Applies for a Letter of Authorization (LOA) for an Express Connect circuit.
        
        @param request: ApplyPhysicalConnectionLOARequest
        @return: ApplyPhysicalConnectionLOAResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.apply_physical_connection_loawith_options(request, runtime)

    async def apply_physical_connection_loa_async(
        self,
        request: vpc_20160428_models.ApplyPhysicalConnectionLOARequest,
    ) -> vpc_20160428_models.ApplyPhysicalConnectionLOAResponse:
        """
        @summary Applies for a Letter of Authorization (LOA) for an Express Connect circuit.
        
        @param request: ApplyPhysicalConnectionLOARequest
        @return: ApplyPhysicalConnectionLOAResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.apply_physical_connection_loawith_options_async(request, runtime)

    def associate_eip_address_with_options(
        self,
        request: vpc_20160428_models.AssociateEipAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AssociateEipAddressResponse:
        """
        @summary Associates an elastic IP address (EIP) with an instance in the same region.
        
        @description    You can associate an EIP with an Elastic Compute Service (ECS) instance, a Classic Load Balancer (CLB) instance, a secondary elastic network interface (ENI), a NAT gateway, or a high-availability virtual IP address (HAVIP) in the same region. The ECS instance and CLB instance must be deployed in a virtual private cloud (VPC).
        **AssociateEipAddress** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
        If the EIP is in the **Associating** state, the EIP is being associated. In this state, you can only query the EIP and cannot perform other operations.
        If the EIP is in the **InUse** state, the EIP is associated.
        You cannot call the **AssociateEipAddress** operation to associate an EIP with multiple instances at a time.
        
        @param request: AssociateEipAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateEipAddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_region_id):
            query['InstanceRegionId'] = request.instance_region_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.mode):
            query['Mode'] = request.mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateEipAddress',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AssociateEipAddressResponse(),
            self.call_api(params, req, runtime)
        )

    async def associate_eip_address_with_options_async(
        self,
        request: vpc_20160428_models.AssociateEipAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AssociateEipAddressResponse:
        """
        @summary Associates an elastic IP address (EIP) with an instance in the same region.
        
        @description    You can associate an EIP with an Elastic Compute Service (ECS) instance, a Classic Load Balancer (CLB) instance, a secondary elastic network interface (ENI), a NAT gateway, or a high-availability virtual IP address (HAVIP) in the same region. The ECS instance and CLB instance must be deployed in a virtual private cloud (VPC).
        **AssociateEipAddress** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
        If the EIP is in the **Associating** state, the EIP is being associated. In this state, you can only query the EIP and cannot perform other operations.
        If the EIP is in the **InUse** state, the EIP is associated.
        You cannot call the **AssociateEipAddress** operation to associate an EIP with multiple instances at a time.
        
        @param request: AssociateEipAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateEipAddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_region_id):
            query['InstanceRegionId'] = request.instance_region_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.mode):
            query['Mode'] = request.mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateEipAddress',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AssociateEipAddressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def associate_eip_address(
        self,
        request: vpc_20160428_models.AssociateEipAddressRequest,
    ) -> vpc_20160428_models.AssociateEipAddressResponse:
        """
        @summary Associates an elastic IP address (EIP) with an instance in the same region.
        
        @description    You can associate an EIP with an Elastic Compute Service (ECS) instance, a Classic Load Balancer (CLB) instance, a secondary elastic network interface (ENI), a NAT gateway, or a high-availability virtual IP address (HAVIP) in the same region. The ECS instance and CLB instance must be deployed in a virtual private cloud (VPC).
        **AssociateEipAddress** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
        If the EIP is in the **Associating** state, the EIP is being associated. In this state, you can only query the EIP and cannot perform other operations.
        If the EIP is in the **InUse** state, the EIP is associated.
        You cannot call the **AssociateEipAddress** operation to associate an EIP with multiple instances at a time.
        
        @param request: AssociateEipAddressRequest
        @return: AssociateEipAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.associate_eip_address_with_options(request, runtime)

    async def associate_eip_address_async(
        self,
        request: vpc_20160428_models.AssociateEipAddressRequest,
    ) -> vpc_20160428_models.AssociateEipAddressResponse:
        """
        @summary Associates an elastic IP address (EIP) with an instance in the same region.
        
        @description    You can associate an EIP with an Elastic Compute Service (ECS) instance, a Classic Load Balancer (CLB) instance, a secondary elastic network interface (ENI), a NAT gateway, or a high-availability virtual IP address (HAVIP) in the same region. The ECS instance and CLB instance must be deployed in a virtual private cloud (VPC).
        **AssociateEipAddress** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
        If the EIP is in the **Associating** state, the EIP is being associated. In this state, you can only query the EIP and cannot perform other operations.
        If the EIP is in the **InUse** state, the EIP is associated.
        You cannot call the **AssociateEipAddress** operation to associate an EIP with multiple instances at a time.
        
        @param request: AssociateEipAddressRequest
        @return: AssociateEipAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.associate_eip_address_with_options_async(request, runtime)

    def associate_eip_address_batch_with_options(
        self,
        request: vpc_20160428_models.AssociateEipAddressBatchRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AssociateEipAddressBatchResponse:
        """
        @summary Associates multiple elastic IP addresses (EIPs) with an instance in the same region.
        
        @description    You can call the **AssociateEipAddressBatch** operation to associate EIPs with an instance in the same region. The instance must be a NAT gateway or a secondary elastic network interface (ENI). For more information about how to associate EIPs with other instances, see [AssociateEipAddress](https://help.aliyun.com/document_detail/120195.html).
        **AssociateEipAddressBatch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
        If the EIP is in the **Associating** state, the EIP is being associated. You can only query the EIP and cannot perform other operations.
        If the EIP is in the **InUse** state, the EIP is associated.
        You cannot call the **AssociateEipAddressBatch** operation to associate an EIP with multiple instances at a time.
        
        @param request: AssociateEipAddressBatchRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateEipAddressBatchResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.binded_instance_id):
            query['BindedInstanceId'] = request.binded_instance_id
        if not UtilClient.is_unset(request.binded_instance_type):
            query['BindedInstanceType'] = request.binded_instance_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.instance_ids):
            query['InstanceIds'] = request.instance_ids
        if not UtilClient.is_unset(request.mode):
            query['Mode'] = request.mode
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateEipAddressBatch',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AssociateEipAddressBatchResponse(),
            self.call_api(params, req, runtime)
        )

    async def associate_eip_address_batch_with_options_async(
        self,
        request: vpc_20160428_models.AssociateEipAddressBatchRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AssociateEipAddressBatchResponse:
        """
        @summary Associates multiple elastic IP addresses (EIPs) with an instance in the same region.
        
        @description    You can call the **AssociateEipAddressBatch** operation to associate EIPs with an instance in the same region. The instance must be a NAT gateway or a secondary elastic network interface (ENI). For more information about how to associate EIPs with other instances, see [AssociateEipAddress](https://help.aliyun.com/document_detail/120195.html).
        **AssociateEipAddressBatch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
        If the EIP is in the **Associating** state, the EIP is being associated. You can only query the EIP and cannot perform other operations.
        If the EIP is in the **InUse** state, the EIP is associated.
        You cannot call the **AssociateEipAddressBatch** operation to associate an EIP with multiple instances at a time.
        
        @param request: AssociateEipAddressBatchRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateEipAddressBatchResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.binded_instance_id):
            query['BindedInstanceId'] = request.binded_instance_id
        if not UtilClient.is_unset(request.binded_instance_type):
            query['BindedInstanceType'] = request.binded_instance_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.instance_ids):
            query['InstanceIds'] = request.instance_ids
        if not UtilClient.is_unset(request.mode):
            query['Mode'] = request.mode
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateEipAddressBatch',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AssociateEipAddressBatchResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def associate_eip_address_batch(
        self,
        request: vpc_20160428_models.AssociateEipAddressBatchRequest,
    ) -> vpc_20160428_models.AssociateEipAddressBatchResponse:
        """
        @summary Associates multiple elastic IP addresses (EIPs) with an instance in the same region.
        
        @description    You can call the **AssociateEipAddressBatch** operation to associate EIPs with an instance in the same region. The instance must be a NAT gateway or a secondary elastic network interface (ENI). For more information about how to associate EIPs with other instances, see [AssociateEipAddress](https://help.aliyun.com/document_detail/120195.html).
        **AssociateEipAddressBatch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
        If the EIP is in the **Associating** state, the EIP is being associated. You can only query the EIP and cannot perform other operations.
        If the EIP is in the **InUse** state, the EIP is associated.
        You cannot call the **AssociateEipAddressBatch** operation to associate an EIP with multiple instances at a time.
        
        @param request: AssociateEipAddressBatchRequest
        @return: AssociateEipAddressBatchResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.associate_eip_address_batch_with_options(request, runtime)

    async def associate_eip_address_batch_async(
        self,
        request: vpc_20160428_models.AssociateEipAddressBatchRequest,
    ) -> vpc_20160428_models.AssociateEipAddressBatchResponse:
        """
        @summary Associates multiple elastic IP addresses (EIPs) with an instance in the same region.
        
        @description    You can call the **AssociateEipAddressBatch** operation to associate EIPs with an instance in the same region. The instance must be a NAT gateway or a secondary elastic network interface (ENI). For more information about how to associate EIPs with other instances, see [AssociateEipAddress](https://help.aliyun.com/document_detail/120195.html).
        **AssociateEipAddressBatch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
        If the EIP is in the **Associating** state, the EIP is being associated. You can only query the EIP and cannot perform other operations.
        If the EIP is in the **InUse** state, the EIP is associated.
        You cannot call the **AssociateEipAddressBatch** operation to associate an EIP with multiple instances at a time.
        
        @param request: AssociateEipAddressBatchRequest
        @return: AssociateEipAddressBatchResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.associate_eip_address_batch_with_options_async(request, runtime)

    def associate_ha_vip_with_options(
        self,
        request: vpc_20160428_models.AssociateHaVipRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AssociateHaVipResponse:
        """
        @summary Associates a high-availability virtual IP address (HAVIP) with an Elastic Compute Service (ECS) instance or an elastic network interface (ENI).
        
        @description When you call this operation, take note of the following limits:
        An HAVIP immediately takes effect after it is associated. You do not need to restart the ECS instance. However, you must associate the HAVIP with the ENI of the ECS instance.
        The HAVIP and ECS instance must belong to the same vSwitch.
        You can associate an HAVIP with at most two ECS instances.
        The ECS instance must be in the **Running** or **Stopped** state.
        The HAVIP must be in the **Available** or **InUse** state.
        The **AssociateHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HAVIP:
        If the HAVIP is in the **Associating** state, the HAVIP is being associated.
        If the HAVIP is in the **InUse** state, the HAVIP is associated.
        You cannot repeatedly call the **AssociateHaVip** operation to associate an HAVIP within the specified period of time.
        
        @param request: AssociateHaVipRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateHaVipResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ha_vip_id):
            query['HaVipId'] = request.ha_vip_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateHaVip',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AssociateHaVipResponse(),
            self.call_api(params, req, runtime)
        )

    async def associate_ha_vip_with_options_async(
        self,
        request: vpc_20160428_models.AssociateHaVipRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AssociateHaVipResponse:
        """
        @summary Associates a high-availability virtual IP address (HAVIP) with an Elastic Compute Service (ECS) instance or an elastic network interface (ENI).
        
        @description When you call this operation, take note of the following limits:
        An HAVIP immediately takes effect after it is associated. You do not need to restart the ECS instance. However, you must associate the HAVIP with the ENI of the ECS instance.
        The HAVIP and ECS instance must belong to the same vSwitch.
        You can associate an HAVIP with at most two ECS instances.
        The ECS instance must be in the **Running** or **Stopped** state.
        The HAVIP must be in the **Available** or **InUse** state.
        The **AssociateHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HAVIP:
        If the HAVIP is in the **Associating** state, the HAVIP is being associated.
        If the HAVIP is in the **InUse** state, the HAVIP is associated.
        You cannot repeatedly call the **AssociateHaVip** operation to associate an HAVIP within the specified period of time.
        
        @param request: AssociateHaVipRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateHaVipResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ha_vip_id):
            query['HaVipId'] = request.ha_vip_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateHaVip',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AssociateHaVipResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def associate_ha_vip(
        self,
        request: vpc_20160428_models.AssociateHaVipRequest,
    ) -> vpc_20160428_models.AssociateHaVipResponse:
        """
        @summary Associates a high-availability virtual IP address (HAVIP) with an Elastic Compute Service (ECS) instance or an elastic network interface (ENI).
        
        @description When you call this operation, take note of the following limits:
        An HAVIP immediately takes effect after it is associated. You do not need to restart the ECS instance. However, you must associate the HAVIP with the ENI of the ECS instance.
        The HAVIP and ECS instance must belong to the same vSwitch.
        You can associate an HAVIP with at most two ECS instances.
        The ECS instance must be in the **Running** or **Stopped** state.
        The HAVIP must be in the **Available** or **InUse** state.
        The **AssociateHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HAVIP:
        If the HAVIP is in the **Associating** state, the HAVIP is being associated.
        If the HAVIP is in the **InUse** state, the HAVIP is associated.
        You cannot repeatedly call the **AssociateHaVip** operation to associate an HAVIP within the specified period of time.
        
        @param request: AssociateHaVipRequest
        @return: AssociateHaVipResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.associate_ha_vip_with_options(request, runtime)

    async def associate_ha_vip_async(
        self,
        request: vpc_20160428_models.AssociateHaVipRequest,
    ) -> vpc_20160428_models.AssociateHaVipResponse:
        """
        @summary Associates a high-availability virtual IP address (HAVIP) with an Elastic Compute Service (ECS) instance or an elastic network interface (ENI).
        
        @description When you call this operation, take note of the following limits:
        An HAVIP immediately takes effect after it is associated. You do not need to restart the ECS instance. However, you must associate the HAVIP with the ENI of the ECS instance.
        The HAVIP and ECS instance must belong to the same vSwitch.
        You can associate an HAVIP with at most two ECS instances.
        The ECS instance must be in the **Running** or **Stopped** state.
        The HAVIP must be in the **Available** or **InUse** state.
        The **AssociateHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HAVIP:
        If the HAVIP is in the **Associating** state, the HAVIP is being associated.
        If the HAVIP is in the **InUse** state, the HAVIP is associated.
        You cannot repeatedly call the **AssociateHaVip** operation to associate an HAVIP within the specified period of time.
        
        @param request: AssociateHaVipRequest
        @return: AssociateHaVipResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.associate_ha_vip_with_options_async(request, runtime)

    def associate_network_acl_with_options(
        self,
        request: vpc_20160428_models.AssociateNetworkAclRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AssociateNetworkAclResponse:
        """
        @summary Associates a network access control list (ACL) with a vSwitch.
        
        @description ## [](#)Description
        **AssociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
        If the network ACL is in the **BINDING** state, the network ACL is being associated.
        If the network ACL is in the **BINDED** state, the network ACL is associated.
        You cannot repeatedly call the **AssociateNetworkAcl** operation to associate a network ACL within the specified period of time.
        
        @param request: AssociateNetworkAclRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateNetworkAclResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.network_acl_id):
            query['NetworkAclId'] = request.network_acl_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource):
            query['Resource'] = request.resource
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateNetworkAcl',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AssociateNetworkAclResponse(),
            self.call_api(params, req, runtime)
        )

    async def associate_network_acl_with_options_async(
        self,
        request: vpc_20160428_models.AssociateNetworkAclRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AssociateNetworkAclResponse:
        """
        @summary Associates a network access control list (ACL) with a vSwitch.
        
        @description ## [](#)Description
        **AssociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
        If the network ACL is in the **BINDING** state, the network ACL is being associated.
        If the network ACL is in the **BINDED** state, the network ACL is associated.
        You cannot repeatedly call the **AssociateNetworkAcl** operation to associate a network ACL within the specified period of time.
        
        @param request: AssociateNetworkAclRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateNetworkAclResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.network_acl_id):
            query['NetworkAclId'] = request.network_acl_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource):
            query['Resource'] = request.resource
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateNetworkAcl',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AssociateNetworkAclResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def associate_network_acl(
        self,
        request: vpc_20160428_models.AssociateNetworkAclRequest,
    ) -> vpc_20160428_models.AssociateNetworkAclResponse:
        """
        @summary Associates a network access control list (ACL) with a vSwitch.
        
        @description ## [](#)Description
        **AssociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
        If the network ACL is in the **BINDING** state, the network ACL is being associated.
        If the network ACL is in the **BINDED** state, the network ACL is associated.
        You cannot repeatedly call the **AssociateNetworkAcl** operation to associate a network ACL within the specified period of time.
        
        @param request: AssociateNetworkAclRequest
        @return: AssociateNetworkAclResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.associate_network_acl_with_options(request, runtime)

    async def associate_network_acl_async(
        self,
        request: vpc_20160428_models.AssociateNetworkAclRequest,
    ) -> vpc_20160428_models.AssociateNetworkAclResponse:
        """
        @summary Associates a network access control list (ACL) with a vSwitch.
        
        @description ## [](#)Description
        **AssociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
        If the network ACL is in the **BINDING** state, the network ACL is being associated.
        If the network ACL is in the **BINDED** state, the network ACL is associated.
        You cannot repeatedly call the **AssociateNetworkAcl** operation to associate a network ACL within the specified period of time.
        
        @param request: AssociateNetworkAclRequest
        @return: AssociateNetworkAclResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.associate_network_acl_with_options_async(request, runtime)

    def associate_physical_connection_to_virtual_border_router_with_options(
        self,
        request: vpc_20160428_models.AssociatePhysicalConnectionToVirtualBorderRouterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AssociatePhysicalConnectionToVirtualBorderRouterResponse:
        """
        @summary Associates a virtual border router (VBR) with a specified Express Connect circuit.
        
        @param request: AssociatePhysicalConnectionToVirtualBorderRouterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociatePhysicalConnectionToVirtualBorderRouterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.circuit_code):
            query['CircuitCode'] = request.circuit_code
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.enable_ipv_6):
            query['EnableIpv6'] = request.enable_ipv_6
        if not UtilClient.is_unset(request.local_gateway_ip):
            query['LocalGatewayIp'] = request.local_gateway_ip
        if not UtilClient.is_unset(request.local_ipv_6gateway_ip):
            query['LocalIpv6GatewayIp'] = request.local_ipv_6gateway_ip
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_gateway_ip):
            query['PeerGatewayIp'] = request.peer_gateway_ip
        if not UtilClient.is_unset(request.peer_ipv_6gateway_ip):
            query['PeerIpv6GatewayIp'] = request.peer_ipv_6gateway_ip
        if not UtilClient.is_unset(request.peering_ipv_6subnet_mask):
            query['PeeringIpv6SubnetMask'] = request.peering_ipv_6subnet_mask
        if not UtilClient.is_unset(request.peering_subnet_mask):
            query['PeeringSubnetMask'] = request.peering_subnet_mask
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        if not UtilClient.is_unset(request.vlan_id):
            query['VlanId'] = request.vlan_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociatePhysicalConnectionToVirtualBorderRouter',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AssociatePhysicalConnectionToVirtualBorderRouterResponse(),
            self.call_api(params, req, runtime)
        )

    async def associate_physical_connection_to_virtual_border_router_with_options_async(
        self,
        request: vpc_20160428_models.AssociatePhysicalConnectionToVirtualBorderRouterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AssociatePhysicalConnectionToVirtualBorderRouterResponse:
        """
        @summary Associates a virtual border router (VBR) with a specified Express Connect circuit.
        
        @param request: AssociatePhysicalConnectionToVirtualBorderRouterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociatePhysicalConnectionToVirtualBorderRouterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.circuit_code):
            query['CircuitCode'] = request.circuit_code
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.enable_ipv_6):
            query['EnableIpv6'] = request.enable_ipv_6
        if not UtilClient.is_unset(request.local_gateway_ip):
            query['LocalGatewayIp'] = request.local_gateway_ip
        if not UtilClient.is_unset(request.local_ipv_6gateway_ip):
            query['LocalIpv6GatewayIp'] = request.local_ipv_6gateway_ip
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_gateway_ip):
            query['PeerGatewayIp'] = request.peer_gateway_ip
        if not UtilClient.is_unset(request.peer_ipv_6gateway_ip):
            query['PeerIpv6GatewayIp'] = request.peer_ipv_6gateway_ip
        if not UtilClient.is_unset(request.peering_ipv_6subnet_mask):
            query['PeeringIpv6SubnetMask'] = request.peering_ipv_6subnet_mask
        if not UtilClient.is_unset(request.peering_subnet_mask):
            query['PeeringSubnetMask'] = request.peering_subnet_mask
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        if not UtilClient.is_unset(request.vlan_id):
            query['VlanId'] = request.vlan_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociatePhysicalConnectionToVirtualBorderRouter',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AssociatePhysicalConnectionToVirtualBorderRouterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def associate_physical_connection_to_virtual_border_router(
        self,
        request: vpc_20160428_models.AssociatePhysicalConnectionToVirtualBorderRouterRequest,
    ) -> vpc_20160428_models.AssociatePhysicalConnectionToVirtualBorderRouterResponse:
        """
        @summary Associates a virtual border router (VBR) with a specified Express Connect circuit.
        
        @param request: AssociatePhysicalConnectionToVirtualBorderRouterRequest
        @return: AssociatePhysicalConnectionToVirtualBorderRouterResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.associate_physical_connection_to_virtual_border_router_with_options(request, runtime)

    async def associate_physical_connection_to_virtual_border_router_async(
        self,
        request: vpc_20160428_models.AssociatePhysicalConnectionToVirtualBorderRouterRequest,
    ) -> vpc_20160428_models.AssociatePhysicalConnectionToVirtualBorderRouterResponse:
        """
        @summary Associates a virtual border router (VBR) with a specified Express Connect circuit.
        
        @param request: AssociatePhysicalConnectionToVirtualBorderRouterRequest
        @return: AssociatePhysicalConnectionToVirtualBorderRouterResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.associate_physical_connection_to_virtual_border_router_with_options_async(request, runtime)

    def associate_route_table_with_options(
        self,
        request: vpc_20160428_models.AssociateRouteTableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AssociateRouteTableResponse:
        """
        @summary Associates a custom route table with a vSwitch in the same VPC.
        
        @description *AssociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
        If the vSwitch is in the **Pending** state, the route table is being associated with the vSwitch.
        If the vSwitch is in the **Available** state, the route table is associated with the vSwitch.
        
        @param request: AssociateRouteTableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateRouteTableResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateRouteTable',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AssociateRouteTableResponse(),
            self.call_api(params, req, runtime)
        )

    async def associate_route_table_with_options_async(
        self,
        request: vpc_20160428_models.AssociateRouteTableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AssociateRouteTableResponse:
        """
        @summary Associates a custom route table with a vSwitch in the same VPC.
        
        @description *AssociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
        If the vSwitch is in the **Pending** state, the route table is being associated with the vSwitch.
        If the vSwitch is in the **Available** state, the route table is associated with the vSwitch.
        
        @param request: AssociateRouteTableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateRouteTableResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateRouteTable',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AssociateRouteTableResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def associate_route_table(
        self,
        request: vpc_20160428_models.AssociateRouteTableRequest,
    ) -> vpc_20160428_models.AssociateRouteTableResponse:
        """
        @summary Associates a custom route table with a vSwitch in the same VPC.
        
        @description *AssociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
        If the vSwitch is in the **Pending** state, the route table is being associated with the vSwitch.
        If the vSwitch is in the **Available** state, the route table is associated with the vSwitch.
        
        @param request: AssociateRouteTableRequest
        @return: AssociateRouteTableResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.associate_route_table_with_options(request, runtime)

    async def associate_route_table_async(
        self,
        request: vpc_20160428_models.AssociateRouteTableRequest,
    ) -> vpc_20160428_models.AssociateRouteTableResponse:
        """
        @summary Associates a custom route table with a vSwitch in the same VPC.
        
        @description *AssociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
        If the vSwitch is in the **Pending** state, the route table is being associated with the vSwitch.
        If the vSwitch is in the **Available** state, the route table is associated with the vSwitch.
        
        @param request: AssociateRouteTableRequest
        @return: AssociateRouteTableResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.associate_route_table_with_options_async(request, runtime)

    def associate_route_table_with_gateway_with_options(
        self,
        request: vpc_20160428_models.AssociateRouteTableWithGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AssociateRouteTableWithGatewayResponse:
        """
        @summary Associates a gateway route table with an IPv4 gateway in the same virtual private cloud (VPC).
        
        @param request: AssociateRouteTableWithGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateRouteTableWithGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.gateway_id):
            query['GatewayId'] = request.gateway_id
        if not UtilClient.is_unset(request.gateway_type):
            query['GatewayType'] = request.gateway_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateRouteTableWithGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AssociateRouteTableWithGatewayResponse(),
            self.call_api(params, req, runtime)
        )

    async def associate_route_table_with_gateway_with_options_async(
        self,
        request: vpc_20160428_models.AssociateRouteTableWithGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AssociateRouteTableWithGatewayResponse:
        """
        @summary Associates a gateway route table with an IPv4 gateway in the same virtual private cloud (VPC).
        
        @param request: AssociateRouteTableWithGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateRouteTableWithGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.gateway_id):
            query['GatewayId'] = request.gateway_id
        if not UtilClient.is_unset(request.gateway_type):
            query['GatewayType'] = request.gateway_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateRouteTableWithGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AssociateRouteTableWithGatewayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def associate_route_table_with_gateway(
        self,
        request: vpc_20160428_models.AssociateRouteTableWithGatewayRequest,
    ) -> vpc_20160428_models.AssociateRouteTableWithGatewayResponse:
        """
        @summary Associates a gateway route table with an IPv4 gateway in the same virtual private cloud (VPC).
        
        @param request: AssociateRouteTableWithGatewayRequest
        @return: AssociateRouteTableWithGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.associate_route_table_with_gateway_with_options(request, runtime)

    async def associate_route_table_with_gateway_async(
        self,
        request: vpc_20160428_models.AssociateRouteTableWithGatewayRequest,
    ) -> vpc_20160428_models.AssociateRouteTableWithGatewayResponse:
        """
        @summary Associates a gateway route table with an IPv4 gateway in the same virtual private cloud (VPC).
        
        @param request: AssociateRouteTableWithGatewayRequest
        @return: AssociateRouteTableWithGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.associate_route_table_with_gateway_with_options_async(request, runtime)

    def associate_route_tables_with_vpc_gateway_endpoint_with_options(
        self,
        request: vpc_20160428_models.AssociateRouteTablesWithVpcGatewayEndpointRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AssociateRouteTablesWithVpcGatewayEndpointResponse:
        """
        @summary Associates a route table with a gateway endpoint.
        
        @description When you call this operation, take note of the following limits:
        The gateway endpoint to be associated with the route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
        The route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
        The gateway endpoint and route table must belong to the same virtual private cloud (VPC).
        The route table cannot be shared.
        You cannot associate a gateway endpoint with a virtual border router (VBR) route table.
        You can associate a gateway endpoint with at most 20 route tables at a time.
        **AssociateRouteTablesWithVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query whether a route table is associated with a gateway endpoint.
        If the **Associating** status is returned, the route table is being associated with the gateway endpoint.
        If the **Created** status is returned, the route table is associated with the gateway endpoint.
        You cannot repeatedly call the **AssociateRouteTablesWithVpcGatewayEndpoint** operation within a specific period of time.
        
        @param request: AssociateRouteTablesWithVpcGatewayEndpointRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateRouteTablesWithVpcGatewayEndpointResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.endpoint_id):
            query['EndpointId'] = request.endpoint_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_ids):
            query['RouteTableIds'] = request.route_table_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateRouteTablesWithVpcGatewayEndpoint',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AssociateRouteTablesWithVpcGatewayEndpointResponse(),
            self.call_api(params, req, runtime)
        )

    async def associate_route_tables_with_vpc_gateway_endpoint_with_options_async(
        self,
        request: vpc_20160428_models.AssociateRouteTablesWithVpcGatewayEndpointRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AssociateRouteTablesWithVpcGatewayEndpointResponse:
        """
        @summary Associates a route table with a gateway endpoint.
        
        @description When you call this operation, take note of the following limits:
        The gateway endpoint to be associated with the route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
        The route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
        The gateway endpoint and route table must belong to the same virtual private cloud (VPC).
        The route table cannot be shared.
        You cannot associate a gateway endpoint with a virtual border router (VBR) route table.
        You can associate a gateway endpoint with at most 20 route tables at a time.
        **AssociateRouteTablesWithVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query whether a route table is associated with a gateway endpoint.
        If the **Associating** status is returned, the route table is being associated with the gateway endpoint.
        If the **Created** status is returned, the route table is associated with the gateway endpoint.
        You cannot repeatedly call the **AssociateRouteTablesWithVpcGatewayEndpoint** operation within a specific period of time.
        
        @param request: AssociateRouteTablesWithVpcGatewayEndpointRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateRouteTablesWithVpcGatewayEndpointResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.endpoint_id):
            query['EndpointId'] = request.endpoint_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_ids):
            query['RouteTableIds'] = request.route_table_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateRouteTablesWithVpcGatewayEndpoint',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AssociateRouteTablesWithVpcGatewayEndpointResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def associate_route_tables_with_vpc_gateway_endpoint(
        self,
        request: vpc_20160428_models.AssociateRouteTablesWithVpcGatewayEndpointRequest,
    ) -> vpc_20160428_models.AssociateRouteTablesWithVpcGatewayEndpointResponse:
        """
        @summary Associates a route table with a gateway endpoint.
        
        @description When you call this operation, take note of the following limits:
        The gateway endpoint to be associated with the route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
        The route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
        The gateway endpoint and route table must belong to the same virtual private cloud (VPC).
        The route table cannot be shared.
        You cannot associate a gateway endpoint with a virtual border router (VBR) route table.
        You can associate a gateway endpoint with at most 20 route tables at a time.
        **AssociateRouteTablesWithVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query whether a route table is associated with a gateway endpoint.
        If the **Associating** status is returned, the route table is being associated with the gateway endpoint.
        If the **Created** status is returned, the route table is associated with the gateway endpoint.
        You cannot repeatedly call the **AssociateRouteTablesWithVpcGatewayEndpoint** operation within a specific period of time.
        
        @param request: AssociateRouteTablesWithVpcGatewayEndpointRequest
        @return: AssociateRouteTablesWithVpcGatewayEndpointResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.associate_route_tables_with_vpc_gateway_endpoint_with_options(request, runtime)

    async def associate_route_tables_with_vpc_gateway_endpoint_async(
        self,
        request: vpc_20160428_models.AssociateRouteTablesWithVpcGatewayEndpointRequest,
    ) -> vpc_20160428_models.AssociateRouteTablesWithVpcGatewayEndpointResponse:
        """
        @summary Associates a route table with a gateway endpoint.
        
        @description When you call this operation, take note of the following limits:
        The gateway endpoint to be associated with the route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
        The route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
        The gateway endpoint and route table must belong to the same virtual private cloud (VPC).
        The route table cannot be shared.
        You cannot associate a gateway endpoint with a virtual border router (VBR) route table.
        You can associate a gateway endpoint with at most 20 route tables at a time.
        **AssociateRouteTablesWithVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query whether a route table is associated with a gateway endpoint.
        If the **Associating** status is returned, the route table is being associated with the gateway endpoint.
        If the **Created** status is returned, the route table is associated with the gateway endpoint.
        You cannot repeatedly call the **AssociateRouteTablesWithVpcGatewayEndpoint** operation within a specific period of time.
        
        @param request: AssociateRouteTablesWithVpcGatewayEndpointRequest
        @return: AssociateRouteTablesWithVpcGatewayEndpointResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.associate_route_tables_with_vpc_gateway_endpoint_with_options_async(request, runtime)

    def associate_vpc_cidr_block_with_options(
        self,
        request: vpc_20160428_models.AssociateVpcCidrBlockRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AssociateVpcCidrBlockResponse:
        """
        @summary Adds a secondary CIDR block to a virtual private cloud (VPC).
        
        @description ## [](#)
        Take note of the following limits:
        Each VPC can contain up to five secondary IPv4 CIDR blocks.
        Each VPC can contain up to five secondary IPv6 CIDR blocks.
        You cannot repeatedly call the **AssociateVpcCidrBlock** operation to add secondary CIDR blocks to a VPC within the specified period of time.
        
        @param request: AssociateVpcCidrBlockRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateVpcCidrBlockResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipv_6cidr_block):
            query['IPv6CidrBlock'] = request.ipv_6cidr_block
        if not UtilClient.is_unset(request.ip_version):
            query['IpVersion'] = request.ip_version
        if not UtilClient.is_unset(request.ipam_pool_id):
            query['IpamPoolId'] = request.ipam_pool_id
        if not UtilClient.is_unset(request.ipv_6isp):
            query['Ipv6Isp'] = request.ipv_6isp
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.secondary_cidr_block):
            query['SecondaryCidrBlock'] = request.secondary_cidr_block
        if not UtilClient.is_unset(request.secondary_cidr_mask):
            query['SecondaryCidrMask'] = request.secondary_cidr_mask
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateVpcCidrBlock',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AssociateVpcCidrBlockResponse(),
            self.call_api(params, req, runtime)
        )

    async def associate_vpc_cidr_block_with_options_async(
        self,
        request: vpc_20160428_models.AssociateVpcCidrBlockRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AssociateVpcCidrBlockResponse:
        """
        @summary Adds a secondary CIDR block to a virtual private cloud (VPC).
        
        @description ## [](#)
        Take note of the following limits:
        Each VPC can contain up to five secondary IPv4 CIDR blocks.
        Each VPC can contain up to five secondary IPv6 CIDR blocks.
        You cannot repeatedly call the **AssociateVpcCidrBlock** operation to add secondary CIDR blocks to a VPC within the specified period of time.
        
        @param request: AssociateVpcCidrBlockRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateVpcCidrBlockResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipv_6cidr_block):
            query['IPv6CidrBlock'] = request.ipv_6cidr_block
        if not UtilClient.is_unset(request.ip_version):
            query['IpVersion'] = request.ip_version
        if not UtilClient.is_unset(request.ipam_pool_id):
            query['IpamPoolId'] = request.ipam_pool_id
        if not UtilClient.is_unset(request.ipv_6isp):
            query['Ipv6Isp'] = request.ipv_6isp
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.secondary_cidr_block):
            query['SecondaryCidrBlock'] = request.secondary_cidr_block
        if not UtilClient.is_unset(request.secondary_cidr_mask):
            query['SecondaryCidrMask'] = request.secondary_cidr_mask
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateVpcCidrBlock',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AssociateVpcCidrBlockResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def associate_vpc_cidr_block(
        self,
        request: vpc_20160428_models.AssociateVpcCidrBlockRequest,
    ) -> vpc_20160428_models.AssociateVpcCidrBlockResponse:
        """
        @summary Adds a secondary CIDR block to a virtual private cloud (VPC).
        
        @description ## [](#)
        Take note of the following limits:
        Each VPC can contain up to five secondary IPv4 CIDR blocks.
        Each VPC can contain up to five secondary IPv6 CIDR blocks.
        You cannot repeatedly call the **AssociateVpcCidrBlock** operation to add secondary CIDR blocks to a VPC within the specified period of time.
        
        @param request: AssociateVpcCidrBlockRequest
        @return: AssociateVpcCidrBlockResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.associate_vpc_cidr_block_with_options(request, runtime)

    async def associate_vpc_cidr_block_async(
        self,
        request: vpc_20160428_models.AssociateVpcCidrBlockRequest,
    ) -> vpc_20160428_models.AssociateVpcCidrBlockResponse:
        """
        @summary Adds a secondary CIDR block to a virtual private cloud (VPC).
        
        @description ## [](#)
        Take note of the following limits:
        Each VPC can contain up to five secondary IPv4 CIDR blocks.
        Each VPC can contain up to five secondary IPv6 CIDR blocks.
        You cannot repeatedly call the **AssociateVpcCidrBlock** operation to add secondary CIDR blocks to a VPC within the specified period of time.
        
        @param request: AssociateVpcCidrBlockRequest
        @return: AssociateVpcCidrBlockResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.associate_vpc_cidr_block_with_options_async(request, runtime)

    def associate_vpn_gateway_with_certificate_with_options(
        self,
        request: vpc_20160428_models.AssociateVpnGatewayWithCertificateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AssociateVpnGatewayWithCertificateResponse:
        """
        @summary Associates a VPN gateway with a certificate.
        
        @description Before you associate a VPN gateway with an SSL certificate, take note of the following items:
        You can associate only VPN gateways of the ShangMi (SM) type with SSL certificates. You need to associate a VPN gateway of the SM type with two SSL certificates, one as the encryption certificate and the other as the signature certificate.
        The SSL certificates must use the SM algorithm.
        You cannot specify one SSL certificate as both the encryption certificate and signature certificate for one VPN gateway.
        **AssociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the task.
        If the VPN gateway is in the **updating** state, the SSL certificate is being associated.
        If the VPN gateway is in the **active** state, the SSL certificate is being associated.
        You cannot call **AssociateVpnGatewayWithCertificate** within a specific period of time.
        ### [](#)Prerequisites
        Make sure that you have two SSL certificates that use the SM algorithm in the Certificate Management Service console. For more information about SSL certificates, see [What is Certificate Management Service?](https://help.aliyun.com/document_detail/28535.html).
        
        @param request: AssociateVpnGatewayWithCertificateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateVpnGatewayWithCertificateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.certificate_id):
            query['CertificateId'] = request.certificate_id
        if not UtilClient.is_unset(request.certificate_type):
            query['CertificateType'] = request.certificate_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateVpnGatewayWithCertificate',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AssociateVpnGatewayWithCertificateResponse(),
            self.call_api(params, req, runtime)
        )

    async def associate_vpn_gateway_with_certificate_with_options_async(
        self,
        request: vpc_20160428_models.AssociateVpnGatewayWithCertificateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AssociateVpnGatewayWithCertificateResponse:
        """
        @summary Associates a VPN gateway with a certificate.
        
        @description Before you associate a VPN gateway with an SSL certificate, take note of the following items:
        You can associate only VPN gateways of the ShangMi (SM) type with SSL certificates. You need to associate a VPN gateway of the SM type with two SSL certificates, one as the encryption certificate and the other as the signature certificate.
        The SSL certificates must use the SM algorithm.
        You cannot specify one SSL certificate as both the encryption certificate and signature certificate for one VPN gateway.
        **AssociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the task.
        If the VPN gateway is in the **updating** state, the SSL certificate is being associated.
        If the VPN gateway is in the **active** state, the SSL certificate is being associated.
        You cannot call **AssociateVpnGatewayWithCertificate** within a specific period of time.
        ### [](#)Prerequisites
        Make sure that you have two SSL certificates that use the SM algorithm in the Certificate Management Service console. For more information about SSL certificates, see [What is Certificate Management Service?](https://help.aliyun.com/document_detail/28535.html).
        
        @param request: AssociateVpnGatewayWithCertificateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssociateVpnGatewayWithCertificateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.certificate_id):
            query['CertificateId'] = request.certificate_id
        if not UtilClient.is_unset(request.certificate_type):
            query['CertificateType'] = request.certificate_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssociateVpnGatewayWithCertificate',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AssociateVpnGatewayWithCertificateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def associate_vpn_gateway_with_certificate(
        self,
        request: vpc_20160428_models.AssociateVpnGatewayWithCertificateRequest,
    ) -> vpc_20160428_models.AssociateVpnGatewayWithCertificateResponse:
        """
        @summary Associates a VPN gateway with a certificate.
        
        @description Before you associate a VPN gateway with an SSL certificate, take note of the following items:
        You can associate only VPN gateways of the ShangMi (SM) type with SSL certificates. You need to associate a VPN gateway of the SM type with two SSL certificates, one as the encryption certificate and the other as the signature certificate.
        The SSL certificates must use the SM algorithm.
        You cannot specify one SSL certificate as both the encryption certificate and signature certificate for one VPN gateway.
        **AssociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the task.
        If the VPN gateway is in the **updating** state, the SSL certificate is being associated.
        If the VPN gateway is in the **active** state, the SSL certificate is being associated.
        You cannot call **AssociateVpnGatewayWithCertificate** within a specific period of time.
        ### [](#)Prerequisites
        Make sure that you have two SSL certificates that use the SM algorithm in the Certificate Management Service console. For more information about SSL certificates, see [What is Certificate Management Service?](https://help.aliyun.com/document_detail/28535.html).
        
        @param request: AssociateVpnGatewayWithCertificateRequest
        @return: AssociateVpnGatewayWithCertificateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.associate_vpn_gateway_with_certificate_with_options(request, runtime)

    async def associate_vpn_gateway_with_certificate_async(
        self,
        request: vpc_20160428_models.AssociateVpnGatewayWithCertificateRequest,
    ) -> vpc_20160428_models.AssociateVpnGatewayWithCertificateResponse:
        """
        @summary Associates a VPN gateway with a certificate.
        
        @description Before you associate a VPN gateway with an SSL certificate, take note of the following items:
        You can associate only VPN gateways of the ShangMi (SM) type with SSL certificates. You need to associate a VPN gateway of the SM type with two SSL certificates, one as the encryption certificate and the other as the signature certificate.
        The SSL certificates must use the SM algorithm.
        You cannot specify one SSL certificate as both the encryption certificate and signature certificate for one VPN gateway.
        **AssociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the task.
        If the VPN gateway is in the **updating** state, the SSL certificate is being associated.
        If the VPN gateway is in the **active** state, the SSL certificate is being associated.
        You cannot call **AssociateVpnGatewayWithCertificate** within a specific period of time.
        ### [](#)Prerequisites
        Make sure that you have two SSL certificates that use the SM algorithm in the Certificate Management Service console. For more information about SSL certificates, see [What is Certificate Management Service?](https://help.aliyun.com/document_detail/28535.html).
        
        @param request: AssociateVpnGatewayWithCertificateRequest
        @return: AssociateVpnGatewayWithCertificateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.associate_vpn_gateway_with_certificate_with_options_async(request, runtime)

    def attach_dhcp_options_set_to_vpc_with_options(
        self,
        request: vpc_20160428_models.AttachDhcpOptionsSetToVpcRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AttachDhcpOptionsSetToVpcResponse:
        """
        @description    The **AttachDhcpOptionsSetToVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
        If the DHCP options set is in the **Pending** state, the DHCP options set is being associated.
        If the DHCP options set is in the **InUse** state, the DHCP options set is associated.
        You cannot repeatedly call the **AttachDhcpOptionsSetToVpc** operation to associate DHCP options sets with a VPC within the specified period of time.
        
        @param request: AttachDhcpOptionsSetToVpcRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AttachDhcpOptionsSetToVpcResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dhcp_options_set_id):
            query['DhcpOptionsSetId'] = request.dhcp_options_set_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AttachDhcpOptionsSetToVpc',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AttachDhcpOptionsSetToVpcResponse(),
            self.call_api(params, req, runtime)
        )

    async def attach_dhcp_options_set_to_vpc_with_options_async(
        self,
        request: vpc_20160428_models.AttachDhcpOptionsSetToVpcRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AttachDhcpOptionsSetToVpcResponse:
        """
        @description    The **AttachDhcpOptionsSetToVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
        If the DHCP options set is in the **Pending** state, the DHCP options set is being associated.
        If the DHCP options set is in the **InUse** state, the DHCP options set is associated.
        You cannot repeatedly call the **AttachDhcpOptionsSetToVpc** operation to associate DHCP options sets with a VPC within the specified period of time.
        
        @param request: AttachDhcpOptionsSetToVpcRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AttachDhcpOptionsSetToVpcResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dhcp_options_set_id):
            query['DhcpOptionsSetId'] = request.dhcp_options_set_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AttachDhcpOptionsSetToVpc',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AttachDhcpOptionsSetToVpcResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def attach_dhcp_options_set_to_vpc(
        self,
        request: vpc_20160428_models.AttachDhcpOptionsSetToVpcRequest,
    ) -> vpc_20160428_models.AttachDhcpOptionsSetToVpcResponse:
        """
        @description    The **AttachDhcpOptionsSetToVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
        If the DHCP options set is in the **Pending** state, the DHCP options set is being associated.
        If the DHCP options set is in the **InUse** state, the DHCP options set is associated.
        You cannot repeatedly call the **AttachDhcpOptionsSetToVpc** operation to associate DHCP options sets with a VPC within the specified period of time.
        
        @param request: AttachDhcpOptionsSetToVpcRequest
        @return: AttachDhcpOptionsSetToVpcResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.attach_dhcp_options_set_to_vpc_with_options(request, runtime)

    async def attach_dhcp_options_set_to_vpc_async(
        self,
        request: vpc_20160428_models.AttachDhcpOptionsSetToVpcRequest,
    ) -> vpc_20160428_models.AttachDhcpOptionsSetToVpcResponse:
        """
        @description    The **AttachDhcpOptionsSetToVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
        If the DHCP options set is in the **Pending** state, the DHCP options set is being associated.
        If the DHCP options set is in the **InUse** state, the DHCP options set is associated.
        You cannot repeatedly call the **AttachDhcpOptionsSetToVpc** operation to associate DHCP options sets with a VPC within the specified period of time.
        
        @param request: AttachDhcpOptionsSetToVpcRequest
        @return: AttachDhcpOptionsSetToVpcResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.attach_dhcp_options_set_to_vpc_with_options_async(request, runtime)

    def attach_vbr_to_vpconn_with_options(
        self,
        request: vpc_20160428_models.AttachVbrToVpconnRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AttachVbrToVpconnResponse:
        """
        @summary Associates a virtual border router (VBR) with a hosted connection.
        
        @param request: AttachVbrToVpconnRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AttachVbrToVpconnResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.token):
            query['Token'] = request.token
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        if not UtilClient.is_unset(request.vpconn_id):
            query['VpconnId'] = request.vpconn_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AttachVbrToVpconn',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AttachVbrToVpconnResponse(),
            self.call_api(params, req, runtime)
        )

    async def attach_vbr_to_vpconn_with_options_async(
        self,
        request: vpc_20160428_models.AttachVbrToVpconnRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.AttachVbrToVpconnResponse:
        """
        @summary Associates a virtual border router (VBR) with a hosted connection.
        
        @param request: AttachVbrToVpconnRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AttachVbrToVpconnResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.token):
            query['Token'] = request.token
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        if not UtilClient.is_unset(request.vpconn_id):
            query['VpconnId'] = request.vpconn_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AttachVbrToVpconn',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.AttachVbrToVpconnResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def attach_vbr_to_vpconn(
        self,
        request: vpc_20160428_models.AttachVbrToVpconnRequest,
    ) -> vpc_20160428_models.AttachVbrToVpconnResponse:
        """
        @summary Associates a virtual border router (VBR) with a hosted connection.
        
        @param request: AttachVbrToVpconnRequest
        @return: AttachVbrToVpconnResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.attach_vbr_to_vpconn_with_options(request, runtime)

    async def attach_vbr_to_vpconn_async(
        self,
        request: vpc_20160428_models.AttachVbrToVpconnRequest,
    ) -> vpc_20160428_models.AttachVbrToVpconnResponse:
        """
        @summary Associates a virtual border router (VBR) with a hosted connection.
        
        @param request: AttachVbrToVpconnRequest
        @return: AttachVbrToVpconnResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.attach_vbr_to_vpconn_with_options_async(request, runtime)

    def cancel_common_bandwidth_package_ip_bandwidth_with_options(
        self,
        request: vpc_20160428_models.CancelCommonBandwidthPackageIpBandwidthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CancelCommonBandwidthPackageIpBandwidthResponse:
        """
        @summary Cancels the maximum bandwidth configured for an elastic IP address (EIP) that is associated with an Internet Shared Bandwidth instance.
        
        @description Before you call this operation, take note of the following items:
        After this operation is performed, the maximum bandwidth of the EIP equals that of the Internet Shared Bandwidth instance.
        You cannot repeatedly call the **CancelCommonBandwidthPackageIpBandwidth** operation within a specific time period.
        
        @param request: CancelCommonBandwidthPackageIpBandwidthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelCommonBandwidthPackageIpBandwidthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.eip_id):
            query['EipId'] = request.eip_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelCommonBandwidthPackageIpBandwidth',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CancelCommonBandwidthPackageIpBandwidthResponse(),
            self.call_api(params, req, runtime)
        )

    async def cancel_common_bandwidth_package_ip_bandwidth_with_options_async(
        self,
        request: vpc_20160428_models.CancelCommonBandwidthPackageIpBandwidthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CancelCommonBandwidthPackageIpBandwidthResponse:
        """
        @summary Cancels the maximum bandwidth configured for an elastic IP address (EIP) that is associated with an Internet Shared Bandwidth instance.
        
        @description Before you call this operation, take note of the following items:
        After this operation is performed, the maximum bandwidth of the EIP equals that of the Internet Shared Bandwidth instance.
        You cannot repeatedly call the **CancelCommonBandwidthPackageIpBandwidth** operation within a specific time period.
        
        @param request: CancelCommonBandwidthPackageIpBandwidthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelCommonBandwidthPackageIpBandwidthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.eip_id):
            query['EipId'] = request.eip_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelCommonBandwidthPackageIpBandwidth',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CancelCommonBandwidthPackageIpBandwidthResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def cancel_common_bandwidth_package_ip_bandwidth(
        self,
        request: vpc_20160428_models.CancelCommonBandwidthPackageIpBandwidthRequest,
    ) -> vpc_20160428_models.CancelCommonBandwidthPackageIpBandwidthResponse:
        """
        @summary Cancels the maximum bandwidth configured for an elastic IP address (EIP) that is associated with an Internet Shared Bandwidth instance.
        
        @description Before you call this operation, take note of the following items:
        After this operation is performed, the maximum bandwidth of the EIP equals that of the Internet Shared Bandwidth instance.
        You cannot repeatedly call the **CancelCommonBandwidthPackageIpBandwidth** operation within a specific time period.
        
        @param request: CancelCommonBandwidthPackageIpBandwidthRequest
        @return: CancelCommonBandwidthPackageIpBandwidthResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.cancel_common_bandwidth_package_ip_bandwidth_with_options(request, runtime)

    async def cancel_common_bandwidth_package_ip_bandwidth_async(
        self,
        request: vpc_20160428_models.CancelCommonBandwidthPackageIpBandwidthRequest,
    ) -> vpc_20160428_models.CancelCommonBandwidthPackageIpBandwidthResponse:
        """
        @summary Cancels the maximum bandwidth configured for an elastic IP address (EIP) that is associated with an Internet Shared Bandwidth instance.
        
        @description Before you call this operation, take note of the following items:
        After this operation is performed, the maximum bandwidth of the EIP equals that of the Internet Shared Bandwidth instance.
        You cannot repeatedly call the **CancelCommonBandwidthPackageIpBandwidth** operation within a specific time period.
        
        @param request: CancelCommonBandwidthPackageIpBandwidthRequest
        @return: CancelCommonBandwidthPackageIpBandwidthResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.cancel_common_bandwidth_package_ip_bandwidth_with_options_async(request, runtime)

    def cancel_physical_connection_with_options(
        self,
        request: vpc_20160428_models.CancelPhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CancelPhysicalConnectionResponse:
        """
        @summary Cancels an Express Connect circuit before it is enabled. After you perform this operation, the Express Connect circuit enters the Canceled state.
        
        @description You can cancel only an Express Connect circuit that is in the *Initial**, **Approved**, **Allocated**, or **Confirmed** state.
        
        @param request: CancelPhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelPhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelPhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CancelPhysicalConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def cancel_physical_connection_with_options_async(
        self,
        request: vpc_20160428_models.CancelPhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CancelPhysicalConnectionResponse:
        """
        @summary Cancels an Express Connect circuit before it is enabled. After you perform this operation, the Express Connect circuit enters the Canceled state.
        
        @description You can cancel only an Express Connect circuit that is in the *Initial**, **Approved**, **Allocated**, or **Confirmed** state.
        
        @param request: CancelPhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelPhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelPhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CancelPhysicalConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def cancel_physical_connection(
        self,
        request: vpc_20160428_models.CancelPhysicalConnectionRequest,
    ) -> vpc_20160428_models.CancelPhysicalConnectionResponse:
        """
        @summary Cancels an Express Connect circuit before it is enabled. After you perform this operation, the Express Connect circuit enters the Canceled state.
        
        @description You can cancel only an Express Connect circuit that is in the *Initial**, **Approved**, **Allocated**, or **Confirmed** state.
        
        @param request: CancelPhysicalConnectionRequest
        @return: CancelPhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.cancel_physical_connection_with_options(request, runtime)

    async def cancel_physical_connection_async(
        self,
        request: vpc_20160428_models.CancelPhysicalConnectionRequest,
    ) -> vpc_20160428_models.CancelPhysicalConnectionResponse:
        """
        @summary Cancels an Express Connect circuit before it is enabled. After you perform this operation, the Express Connect circuit enters the Canceled state.
        
        @description You can cancel only an Express Connect circuit that is in the *Initial**, **Approved**, **Allocated**, or **Confirmed** state.
        
        @param request: CancelPhysicalConnectionRequest
        @return: CancelPhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.cancel_physical_connection_with_options_async(request, runtime)

    def change_resource_group_with_options(
        self,
        request: vpc_20160428_models.ChangeResourceGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ChangeResourceGroupResponse:
        """
        @summary Moves an Express Connect circuit to a new resource group.
        
        @description ## [](#)
        You cannot repeatedly call the *ChangeResourceGroup** operation to modify the resource group of the same Express Connect circuit.
        
        @param request: ChangeResourceGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ChangeResourceGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.new_resource_group_id):
            query['NewResourceGroupId'] = request.new_resource_group_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ChangeResourceGroup',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ChangeResourceGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def change_resource_group_with_options_async(
        self,
        request: vpc_20160428_models.ChangeResourceGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ChangeResourceGroupResponse:
        """
        @summary Moves an Express Connect circuit to a new resource group.
        
        @description ## [](#)
        You cannot repeatedly call the *ChangeResourceGroup** operation to modify the resource group of the same Express Connect circuit.
        
        @param request: ChangeResourceGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ChangeResourceGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.new_resource_group_id):
            query['NewResourceGroupId'] = request.new_resource_group_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ChangeResourceGroup',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ChangeResourceGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def change_resource_group(
        self,
        request: vpc_20160428_models.ChangeResourceGroupRequest,
    ) -> vpc_20160428_models.ChangeResourceGroupResponse:
        """
        @summary Moves an Express Connect circuit to a new resource group.
        
        @description ## [](#)
        You cannot repeatedly call the *ChangeResourceGroup** operation to modify the resource group of the same Express Connect circuit.
        
        @param request: ChangeResourceGroupRequest
        @return: ChangeResourceGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.change_resource_group_with_options(request, runtime)

    async def change_resource_group_async(
        self,
        request: vpc_20160428_models.ChangeResourceGroupRequest,
    ) -> vpc_20160428_models.ChangeResourceGroupResponse:
        """
        @summary Moves an Express Connect circuit to a new resource group.
        
        @description ## [](#)
        You cannot repeatedly call the *ChangeResourceGroup** operation to modify the resource group of the same Express Connect circuit.
        
        @param request: ChangeResourceGroupRequest
        @return: ChangeResourceGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.change_resource_group_with_options_async(request, runtime)

    def check_can_allocate_vpc_private_ip_address_with_options(
        self,
        request: vpc_20160428_models.CheckCanAllocateVpcPrivateIpAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CheckCanAllocateVpcPrivateIpAddressResponse:
        """
        @summary Checks whether a private IP address in a specified vSwitch is available.
        
        @param request: CheckCanAllocateVpcPrivateIpAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CheckCanAllocateVpcPrivateIpAddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ip_version):
            query['IpVersion'] = request.ip_version
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CheckCanAllocateVpcPrivateIpAddress',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CheckCanAllocateVpcPrivateIpAddressResponse(),
            self.call_api(params, req, runtime)
        )

    async def check_can_allocate_vpc_private_ip_address_with_options_async(
        self,
        request: vpc_20160428_models.CheckCanAllocateVpcPrivateIpAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CheckCanAllocateVpcPrivateIpAddressResponse:
        """
        @summary Checks whether a private IP address in a specified vSwitch is available.
        
        @param request: CheckCanAllocateVpcPrivateIpAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CheckCanAllocateVpcPrivateIpAddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ip_version):
            query['IpVersion'] = request.ip_version
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CheckCanAllocateVpcPrivateIpAddress',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CheckCanAllocateVpcPrivateIpAddressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def check_can_allocate_vpc_private_ip_address(
        self,
        request: vpc_20160428_models.CheckCanAllocateVpcPrivateIpAddressRequest,
    ) -> vpc_20160428_models.CheckCanAllocateVpcPrivateIpAddressResponse:
        """
        @summary Checks whether a private IP address in a specified vSwitch is available.
        
        @param request: CheckCanAllocateVpcPrivateIpAddressRequest
        @return: CheckCanAllocateVpcPrivateIpAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.check_can_allocate_vpc_private_ip_address_with_options(request, runtime)

    async def check_can_allocate_vpc_private_ip_address_async(
        self,
        request: vpc_20160428_models.CheckCanAllocateVpcPrivateIpAddressRequest,
    ) -> vpc_20160428_models.CheckCanAllocateVpcPrivateIpAddressResponse:
        """
        @summary Checks whether a private IP address in a specified vSwitch is available.
        
        @param request: CheckCanAllocateVpcPrivateIpAddressRequest
        @return: CheckCanAllocateVpcPrivateIpAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.check_can_allocate_vpc_private_ip_address_with_options_async(request, runtime)

    def check_vpn_bgp_enabled_with_options(
        self,
        request: vpc_20160428_models.CheckVpnBgpEnabledRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CheckVpnBgpEnabledResponse:
        """
        @summary Checks whether the region of an IPsec-VPN connection supports BGP.
        
        @param request: CheckVpnBgpEnabledRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CheckVpnBgpEnabledResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CheckVpnBgpEnabled',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CheckVpnBgpEnabledResponse(),
            self.call_api(params, req, runtime)
        )

    async def check_vpn_bgp_enabled_with_options_async(
        self,
        request: vpc_20160428_models.CheckVpnBgpEnabledRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CheckVpnBgpEnabledResponse:
        """
        @summary Checks whether the region of an IPsec-VPN connection supports BGP.
        
        @param request: CheckVpnBgpEnabledRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CheckVpnBgpEnabledResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CheckVpnBgpEnabled',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CheckVpnBgpEnabledResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def check_vpn_bgp_enabled(
        self,
        request: vpc_20160428_models.CheckVpnBgpEnabledRequest,
    ) -> vpc_20160428_models.CheckVpnBgpEnabledResponse:
        """
        @summary Checks whether the region of an IPsec-VPN connection supports BGP.
        
        @param request: CheckVpnBgpEnabledRequest
        @return: CheckVpnBgpEnabledResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.check_vpn_bgp_enabled_with_options(request, runtime)

    async def check_vpn_bgp_enabled_async(
        self,
        request: vpc_20160428_models.CheckVpnBgpEnabledRequest,
    ) -> vpc_20160428_models.CheckVpnBgpEnabledResponse:
        """
        @summary Checks whether the region of an IPsec-VPN connection supports BGP.
        
        @param request: CheckVpnBgpEnabledRequest
        @return: CheckVpnBgpEnabledResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.check_vpn_bgp_enabled_with_options_async(request, runtime)

    def complete_physical_connection_loawith_options(
        self,
        request: vpc_20160428_models.CompletePhysicalConnectionLOARequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CompletePhysicalConnectionLOAResponse:
        """
        @summary LOA
        
        @param request: CompletePhysicalConnectionLOARequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CompletePhysicalConnectionLOAResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.finish_work):
            query['FinishWork'] = request.finish_work
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.line_code):
            query['LineCode'] = request.line_code
        if not UtilClient.is_unset(request.line_label):
            query['LineLabel'] = request.line_label
        if not UtilClient.is_unset(request.line_spcontact_info):
            query['LineSPContactInfo'] = request.line_spcontact_info
        if not UtilClient.is_unset(request.line_service_provider):
            query['LineServiceProvider'] = request.line_service_provider
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CompletePhysicalConnectionLOA',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CompletePhysicalConnectionLOAResponse(),
            self.call_api(params, req, runtime)
        )

    async def complete_physical_connection_loawith_options_async(
        self,
        request: vpc_20160428_models.CompletePhysicalConnectionLOARequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CompletePhysicalConnectionLOAResponse:
        """
        @summary LOA
        
        @param request: CompletePhysicalConnectionLOARequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CompletePhysicalConnectionLOAResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.finish_work):
            query['FinishWork'] = request.finish_work
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.line_code):
            query['LineCode'] = request.line_code
        if not UtilClient.is_unset(request.line_label):
            query['LineLabel'] = request.line_label
        if not UtilClient.is_unset(request.line_spcontact_info):
            query['LineSPContactInfo'] = request.line_spcontact_info
        if not UtilClient.is_unset(request.line_service_provider):
            query['LineServiceProvider'] = request.line_service_provider
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CompletePhysicalConnectionLOA',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CompletePhysicalConnectionLOAResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def complete_physical_connection_loa(
        self,
        request: vpc_20160428_models.CompletePhysicalConnectionLOARequest,
    ) -> vpc_20160428_models.CompletePhysicalConnectionLOAResponse:
        """
        @summary LOA
        
        @param request: CompletePhysicalConnectionLOARequest
        @return: CompletePhysicalConnectionLOAResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.complete_physical_connection_loawith_options(request, runtime)

    async def complete_physical_connection_loa_async(
        self,
        request: vpc_20160428_models.CompletePhysicalConnectionLOARequest,
    ) -> vpc_20160428_models.CompletePhysicalConnectionLOAResponse:
        """
        @summary LOA
        
        @param request: CompletePhysicalConnectionLOARequest
        @return: CompletePhysicalConnectionLOAResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.complete_physical_connection_loawith_options_async(request, runtime)

    def confirm_physical_connection_with_options(
        self,
        request: vpc_20160428_models.ConfirmPhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ConfirmPhysicalConnectionResponse:
        """
        @summary Changes the status of an Express Connect circuit to Confirmed.
        
        @param request: ConfirmPhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ConfirmPhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ConfirmPhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ConfirmPhysicalConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def confirm_physical_connection_with_options_async(
        self,
        request: vpc_20160428_models.ConfirmPhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ConfirmPhysicalConnectionResponse:
        """
        @summary Changes the status of an Express Connect circuit to Confirmed.
        
        @param request: ConfirmPhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ConfirmPhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ConfirmPhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ConfirmPhysicalConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def confirm_physical_connection(
        self,
        request: vpc_20160428_models.ConfirmPhysicalConnectionRequest,
    ) -> vpc_20160428_models.ConfirmPhysicalConnectionResponse:
        """
        @summary Changes the status of an Express Connect circuit to Confirmed.
        
        @param request: ConfirmPhysicalConnectionRequest
        @return: ConfirmPhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.confirm_physical_connection_with_options(request, runtime)

    async def confirm_physical_connection_async(
        self,
        request: vpc_20160428_models.ConfirmPhysicalConnectionRequest,
    ) -> vpc_20160428_models.ConfirmPhysicalConnectionResponse:
        """
        @summary Changes the status of an Express Connect circuit to Confirmed.
        
        @param request: ConfirmPhysicalConnectionRequest
        @return: ConfirmPhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.confirm_physical_connection_with_options_async(request, runtime)

    def connect_router_interface_with_options(
        self,
        request: vpc_20160428_models.ConnectRouterInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ConnectRouterInterfaceResponse:
        """
        @summary Initiates a connection from the router interface of an initiator to the router interface of an accepter.
        
        @description After you call this operation, the router interface enters the *Connecting** state. When the connection is established, it enters the **Active** state.
        When you call this operation, take note of the following items:
        Only an initiator router interface in the **Idle** state can initiate a connection.
        You can create only one pair of connected router interfaces between two routers.
        You cannot initiate a connection if your Alibaba Cloud account has a router interface with overdue payments.
        
        @param request: ConnectRouterInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ConnectRouterInterfaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ConnectRouterInterface',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ConnectRouterInterfaceResponse(),
            self.call_api(params, req, runtime)
        )

    async def connect_router_interface_with_options_async(
        self,
        request: vpc_20160428_models.ConnectRouterInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ConnectRouterInterfaceResponse:
        """
        @summary Initiates a connection from the router interface of an initiator to the router interface of an accepter.
        
        @description After you call this operation, the router interface enters the *Connecting** state. When the connection is established, it enters the **Active** state.
        When you call this operation, take note of the following items:
        Only an initiator router interface in the **Idle** state can initiate a connection.
        You can create only one pair of connected router interfaces between two routers.
        You cannot initiate a connection if your Alibaba Cloud account has a router interface with overdue payments.
        
        @param request: ConnectRouterInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ConnectRouterInterfaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ConnectRouterInterface',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ConnectRouterInterfaceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def connect_router_interface(
        self,
        request: vpc_20160428_models.ConnectRouterInterfaceRequest,
    ) -> vpc_20160428_models.ConnectRouterInterfaceResponse:
        """
        @summary Initiates a connection from the router interface of an initiator to the router interface of an accepter.
        
        @description After you call this operation, the router interface enters the *Connecting** state. When the connection is established, it enters the **Active** state.
        When you call this operation, take note of the following items:
        Only an initiator router interface in the **Idle** state can initiate a connection.
        You can create only one pair of connected router interfaces between two routers.
        You cannot initiate a connection if your Alibaba Cloud account has a router interface with overdue payments.
        
        @param request: ConnectRouterInterfaceRequest
        @return: ConnectRouterInterfaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.connect_router_interface_with_options(request, runtime)

    async def connect_router_interface_async(
        self,
        request: vpc_20160428_models.ConnectRouterInterfaceRequest,
    ) -> vpc_20160428_models.ConnectRouterInterfaceResponse:
        """
        @summary Initiates a connection from the router interface of an initiator to the router interface of an accepter.
        
        @description After you call this operation, the router interface enters the *Connecting** state. When the connection is established, it enters the **Active** state.
        When you call this operation, take note of the following items:
        Only an initiator router interface in the **Idle** state can initiate a connection.
        You can create only one pair of connected router interfaces between two routers.
        You cannot initiate a connection if your Alibaba Cloud account has a router interface with overdue payments.
        
        @param request: ConnectRouterInterfaceRequest
        @return: ConnectRouterInterfaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.connect_router_interface_with_options_async(request, runtime)

    def convert_bandwidth_package_with_options(
        self,
        request: vpc_20160428_models.ConvertBandwidthPackageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ConvertBandwidthPackageResponse:
        """
        @summary Converts a NAT service plan to an Internet Shared Bandwidth instance.
        
        @description Before you convert a NAT service plan to an Internet Shared Bandwidth instance, take note of the following limits:
        You are not charged for the conversion.
        When you convert a NAT service plan to an Internet Shared Bandwidth instance, you can continue to use the SNAT and DNAT features of the NAT gateway, and your workloads are not affected. However, we recommend that you convert your NAT service plan during off-peak hours.
        After the NAT service plan is converted to an Internet Shared Bandwidth instance, the public IP addresses in the NAT service plan are converted to elastic IP addresses (EIPs). The maximum bandwidth and billing method of the Internet Shared Bandwidth instance are the same as those of the NAT service plan.
        
        @param request: ConvertBandwidthPackageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ConvertBandwidthPackageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ConvertBandwidthPackage',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ConvertBandwidthPackageResponse(),
            self.call_api(params, req, runtime)
        )

    async def convert_bandwidth_package_with_options_async(
        self,
        request: vpc_20160428_models.ConvertBandwidthPackageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ConvertBandwidthPackageResponse:
        """
        @summary Converts a NAT service plan to an Internet Shared Bandwidth instance.
        
        @description Before you convert a NAT service plan to an Internet Shared Bandwidth instance, take note of the following limits:
        You are not charged for the conversion.
        When you convert a NAT service plan to an Internet Shared Bandwidth instance, you can continue to use the SNAT and DNAT features of the NAT gateway, and your workloads are not affected. However, we recommend that you convert your NAT service plan during off-peak hours.
        After the NAT service plan is converted to an Internet Shared Bandwidth instance, the public IP addresses in the NAT service plan are converted to elastic IP addresses (EIPs). The maximum bandwidth and billing method of the Internet Shared Bandwidth instance are the same as those of the NAT service plan.
        
        @param request: ConvertBandwidthPackageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ConvertBandwidthPackageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ConvertBandwidthPackage',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ConvertBandwidthPackageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def convert_bandwidth_package(
        self,
        request: vpc_20160428_models.ConvertBandwidthPackageRequest,
    ) -> vpc_20160428_models.ConvertBandwidthPackageResponse:
        """
        @summary Converts a NAT service plan to an Internet Shared Bandwidth instance.
        
        @description Before you convert a NAT service plan to an Internet Shared Bandwidth instance, take note of the following limits:
        You are not charged for the conversion.
        When you convert a NAT service plan to an Internet Shared Bandwidth instance, you can continue to use the SNAT and DNAT features of the NAT gateway, and your workloads are not affected. However, we recommend that you convert your NAT service plan during off-peak hours.
        After the NAT service plan is converted to an Internet Shared Bandwidth instance, the public IP addresses in the NAT service plan are converted to elastic IP addresses (EIPs). The maximum bandwidth and billing method of the Internet Shared Bandwidth instance are the same as those of the NAT service plan.
        
        @param request: ConvertBandwidthPackageRequest
        @return: ConvertBandwidthPackageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.convert_bandwidth_package_with_options(request, runtime)

    async def convert_bandwidth_package_async(
        self,
        request: vpc_20160428_models.ConvertBandwidthPackageRequest,
    ) -> vpc_20160428_models.ConvertBandwidthPackageResponse:
        """
        @summary Converts a NAT service plan to an Internet Shared Bandwidth instance.
        
        @description Before you convert a NAT service plan to an Internet Shared Bandwidth instance, take note of the following limits:
        You are not charged for the conversion.
        When you convert a NAT service plan to an Internet Shared Bandwidth instance, you can continue to use the SNAT and DNAT features of the NAT gateway, and your workloads are not affected. However, we recommend that you convert your NAT service plan during off-peak hours.
        After the NAT service plan is converted to an Internet Shared Bandwidth instance, the public IP addresses in the NAT service plan are converted to elastic IP addresses (EIPs). The maximum bandwidth and billing method of the Internet Shared Bandwidth instance are the same as those of the NAT service plan.
        
        @param request: ConvertBandwidthPackageRequest
        @return: ConvertBandwidthPackageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.convert_bandwidth_package_with_options_async(request, runtime)

    def copy_network_acl_entries_with_options(
        self,
        request: vpc_20160428_models.CopyNetworkAclEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CopyNetworkAclEntriesResponse:
        """
        @summary Copies rules of a network access control list (ACL).
        
        @description ## [](#)Description
        **CopyNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
        If the network ACL is in the **Modifying** state, the rules of the network ACL are being copied.
        If the network ACL is in the **Available** state, the rules of the network ACL are copied.
        You cannot repeatedly call the **CopyNetworkAclEntries** operation within the specified period of time.
        
        @param request: CopyNetworkAclEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CopyNetworkAclEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.network_acl_id):
            query['NetworkAclId'] = request.network_acl_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.source_network_acl_id):
            query['SourceNetworkAclId'] = request.source_network_acl_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CopyNetworkAclEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CopyNetworkAclEntriesResponse(),
            self.call_api(params, req, runtime)
        )

    async def copy_network_acl_entries_with_options_async(
        self,
        request: vpc_20160428_models.CopyNetworkAclEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CopyNetworkAclEntriesResponse:
        """
        @summary Copies rules of a network access control list (ACL).
        
        @description ## [](#)Description
        **CopyNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
        If the network ACL is in the **Modifying** state, the rules of the network ACL are being copied.
        If the network ACL is in the **Available** state, the rules of the network ACL are copied.
        You cannot repeatedly call the **CopyNetworkAclEntries** operation within the specified period of time.
        
        @param request: CopyNetworkAclEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CopyNetworkAclEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.network_acl_id):
            query['NetworkAclId'] = request.network_acl_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.source_network_acl_id):
            query['SourceNetworkAclId'] = request.source_network_acl_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CopyNetworkAclEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CopyNetworkAclEntriesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def copy_network_acl_entries(
        self,
        request: vpc_20160428_models.CopyNetworkAclEntriesRequest,
    ) -> vpc_20160428_models.CopyNetworkAclEntriesResponse:
        """
        @summary Copies rules of a network access control list (ACL).
        
        @description ## [](#)Description
        **CopyNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
        If the network ACL is in the **Modifying** state, the rules of the network ACL are being copied.
        If the network ACL is in the **Available** state, the rules of the network ACL are copied.
        You cannot repeatedly call the **CopyNetworkAclEntries** operation within the specified period of time.
        
        @param request: CopyNetworkAclEntriesRequest
        @return: CopyNetworkAclEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.copy_network_acl_entries_with_options(request, runtime)

    async def copy_network_acl_entries_async(
        self,
        request: vpc_20160428_models.CopyNetworkAclEntriesRequest,
    ) -> vpc_20160428_models.CopyNetworkAclEntriesResponse:
        """
        @summary Copies rules of a network access control list (ACL).
        
        @description ## [](#)Description
        **CopyNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
        If the network ACL is in the **Modifying** state, the rules of the network ACL are being copied.
        If the network ACL is in the **Available** state, the rules of the network ACL are copied.
        You cannot repeatedly call the **CopyNetworkAclEntries** operation within the specified period of time.
        
        @param request: CopyNetworkAclEntriesRequest
        @return: CopyNetworkAclEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.copy_network_acl_entries_with_options_async(request, runtime)

    def create_bgp_group_with_options(
        self,
        request: vpc_20160428_models.CreateBgpGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateBgpGroupResponse:
        """
        @summary Creates a BGP group for a virtual border router (VBR).
        
        @description You can connect a VBR to a data center through BGP. Each BGP group is associated with a VBR. You can add a BGP peer that needs to communicate with a VBR to a BGP group and advertise the BGP network in the VBR.
        BGP groups are used to simplify BGP configurations. You can add BGP peers that use the same configurations to one BGP group. Before you start, you must create a BGP group with the requested autonomous system number (ASN).
        When you call this operation, take note of the following limits:
        You can specify only the data center that is connected to the VBR through an Express Connect circuit as a BGP peer.
        VBRs support only BGP-4.
        You can create at most eight BGP peers for each VBR.
        Each BGP peer supports at most 110 dynamic routes.
        The ASN of Alibaba Cloud is 45104. You can specify a 2-byte or 4-byte ASN for the data center.
        
        @param request: CreateBgpGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateBgpGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auth_key):
            query['AuthKey'] = request.auth_key
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ip_version):
            query['IpVersion'] = request.ip_version
        if not UtilClient.is_unset(request.is_fake_asn):
            query['IsFakeAsn'] = request.is_fake_asn
        if not UtilClient.is_unset(request.local_asn):
            query['LocalAsn'] = request.local_asn
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_asn):
            query['PeerAsn'] = request.peer_asn
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_quota):
            query['RouteQuota'] = request.route_quota
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateBgpGroup',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateBgpGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_bgp_group_with_options_async(
        self,
        request: vpc_20160428_models.CreateBgpGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateBgpGroupResponse:
        """
        @summary Creates a BGP group for a virtual border router (VBR).
        
        @description You can connect a VBR to a data center through BGP. Each BGP group is associated with a VBR. You can add a BGP peer that needs to communicate with a VBR to a BGP group and advertise the BGP network in the VBR.
        BGP groups are used to simplify BGP configurations. You can add BGP peers that use the same configurations to one BGP group. Before you start, you must create a BGP group with the requested autonomous system number (ASN).
        When you call this operation, take note of the following limits:
        You can specify only the data center that is connected to the VBR through an Express Connect circuit as a BGP peer.
        VBRs support only BGP-4.
        You can create at most eight BGP peers for each VBR.
        Each BGP peer supports at most 110 dynamic routes.
        The ASN of Alibaba Cloud is 45104. You can specify a 2-byte or 4-byte ASN for the data center.
        
        @param request: CreateBgpGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateBgpGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auth_key):
            query['AuthKey'] = request.auth_key
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ip_version):
            query['IpVersion'] = request.ip_version
        if not UtilClient.is_unset(request.is_fake_asn):
            query['IsFakeAsn'] = request.is_fake_asn
        if not UtilClient.is_unset(request.local_asn):
            query['LocalAsn'] = request.local_asn
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_asn):
            query['PeerAsn'] = request.peer_asn
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_quota):
            query['RouteQuota'] = request.route_quota
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateBgpGroup',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateBgpGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_bgp_group(
        self,
        request: vpc_20160428_models.CreateBgpGroupRequest,
    ) -> vpc_20160428_models.CreateBgpGroupResponse:
        """
        @summary Creates a BGP group for a virtual border router (VBR).
        
        @description You can connect a VBR to a data center through BGP. Each BGP group is associated with a VBR. You can add a BGP peer that needs to communicate with a VBR to a BGP group and advertise the BGP network in the VBR.
        BGP groups are used to simplify BGP configurations. You can add BGP peers that use the same configurations to one BGP group. Before you start, you must create a BGP group with the requested autonomous system number (ASN).
        When you call this operation, take note of the following limits:
        You can specify only the data center that is connected to the VBR through an Express Connect circuit as a BGP peer.
        VBRs support only BGP-4.
        You can create at most eight BGP peers for each VBR.
        Each BGP peer supports at most 110 dynamic routes.
        The ASN of Alibaba Cloud is 45104. You can specify a 2-byte or 4-byte ASN for the data center.
        
        @param request: CreateBgpGroupRequest
        @return: CreateBgpGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_bgp_group_with_options(request, runtime)

    async def create_bgp_group_async(
        self,
        request: vpc_20160428_models.CreateBgpGroupRequest,
    ) -> vpc_20160428_models.CreateBgpGroupResponse:
        """
        @summary Creates a BGP group for a virtual border router (VBR).
        
        @description You can connect a VBR to a data center through BGP. Each BGP group is associated with a VBR. You can add a BGP peer that needs to communicate with a VBR to a BGP group and advertise the BGP network in the VBR.
        BGP groups are used to simplify BGP configurations. You can add BGP peers that use the same configurations to one BGP group. Before you start, you must create a BGP group with the requested autonomous system number (ASN).
        When you call this operation, take note of the following limits:
        You can specify only the data center that is connected to the VBR through an Express Connect circuit as a BGP peer.
        VBRs support only BGP-4.
        You can create at most eight BGP peers for each VBR.
        Each BGP peer supports at most 110 dynamic routes.
        The ASN of Alibaba Cloud is 45104. You can specify a 2-byte or 4-byte ASN for the data center.
        
        @param request: CreateBgpGroupRequest
        @return: CreateBgpGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_bgp_group_with_options_async(request, runtime)

    def create_bgp_peer_with_options(
        self,
        request: vpc_20160428_models.CreateBgpPeerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateBgpPeerResponse:
        """
        @summary Adds a Border Gateway Protocol (BGP) peer to a BGP group.
        
        @param request: CreateBgpPeerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateBgpPeerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bfd_multi_hop):
            query['BfdMultiHop'] = request.bfd_multi_hop
        if not UtilClient.is_unset(request.bgp_group_id):
            query['BgpGroupId'] = request.bgp_group_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.enable_bfd):
            query['EnableBfd'] = request.enable_bfd
        if not UtilClient.is_unset(request.ip_version):
            query['IpVersion'] = request.ip_version
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_ip_address):
            query['PeerIpAddress'] = request.peer_ip_address
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateBgpPeer',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateBgpPeerResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_bgp_peer_with_options_async(
        self,
        request: vpc_20160428_models.CreateBgpPeerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateBgpPeerResponse:
        """
        @summary Adds a Border Gateway Protocol (BGP) peer to a BGP group.
        
        @param request: CreateBgpPeerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateBgpPeerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bfd_multi_hop):
            query['BfdMultiHop'] = request.bfd_multi_hop
        if not UtilClient.is_unset(request.bgp_group_id):
            query['BgpGroupId'] = request.bgp_group_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.enable_bfd):
            query['EnableBfd'] = request.enable_bfd
        if not UtilClient.is_unset(request.ip_version):
            query['IpVersion'] = request.ip_version
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_ip_address):
            query['PeerIpAddress'] = request.peer_ip_address
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateBgpPeer',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateBgpPeerResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_bgp_peer(
        self,
        request: vpc_20160428_models.CreateBgpPeerRequest,
    ) -> vpc_20160428_models.CreateBgpPeerResponse:
        """
        @summary Adds a Border Gateway Protocol (BGP) peer to a BGP group.
        
        @param request: CreateBgpPeerRequest
        @return: CreateBgpPeerResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_bgp_peer_with_options(request, runtime)

    async def create_bgp_peer_async(
        self,
        request: vpc_20160428_models.CreateBgpPeerRequest,
    ) -> vpc_20160428_models.CreateBgpPeerResponse:
        """
        @summary Adds a Border Gateway Protocol (BGP) peer to a BGP group.
        
        @param request: CreateBgpPeerRequest
        @return: CreateBgpPeerResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_bgp_peer_with_options_async(request, runtime)

    def create_common_bandwidth_package_with_options(
        self,
        request: vpc_20160428_models.CreateCommonBandwidthPackageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateCommonBandwidthPackageResponse:
        """
        @summary Creates an Internet Shared Bandwidth instance.
        
        @param request: CreateCommonBandwidthPackageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateCommonBandwidthPackageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.isp):
            query['ISP'] = request.isp
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.ratio):
            query['Ratio'] = request.ratio
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_protection_types):
            query['SecurityProtectionTypes'] = request.security_protection_types
        if not UtilClient.is_unset(request.zone):
            query['Zone'] = request.zone
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateCommonBandwidthPackage',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateCommonBandwidthPackageResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_common_bandwidth_package_with_options_async(
        self,
        request: vpc_20160428_models.CreateCommonBandwidthPackageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateCommonBandwidthPackageResponse:
        """
        @summary Creates an Internet Shared Bandwidth instance.
        
        @param request: CreateCommonBandwidthPackageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateCommonBandwidthPackageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.isp):
            query['ISP'] = request.isp
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.ratio):
            query['Ratio'] = request.ratio
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_protection_types):
            query['SecurityProtectionTypes'] = request.security_protection_types
        if not UtilClient.is_unset(request.zone):
            query['Zone'] = request.zone
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateCommonBandwidthPackage',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateCommonBandwidthPackageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_common_bandwidth_package(
        self,
        request: vpc_20160428_models.CreateCommonBandwidthPackageRequest,
    ) -> vpc_20160428_models.CreateCommonBandwidthPackageResponse:
        """
        @summary Creates an Internet Shared Bandwidth instance.
        
        @param request: CreateCommonBandwidthPackageRequest
        @return: CreateCommonBandwidthPackageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_common_bandwidth_package_with_options(request, runtime)

    async def create_common_bandwidth_package_async(
        self,
        request: vpc_20160428_models.CreateCommonBandwidthPackageRequest,
    ) -> vpc_20160428_models.CreateCommonBandwidthPackageResponse:
        """
        @summary Creates an Internet Shared Bandwidth instance.
        
        @param request: CreateCommonBandwidthPackageRequest
        @return: CreateCommonBandwidthPackageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_common_bandwidth_package_with_options_async(request, runtime)

    def create_customer_gateway_with_options(
        self,
        request: vpc_20160428_models.CreateCustomerGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateCustomerGatewayResponse:
        """
        @summary Creates a customer gateway.
        
        @param request: CreateCustomerGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateCustomerGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.asn):
            query['Asn'] = request.asn
        if not UtilClient.is_unset(request.auth_key):
            query['AuthKey'] = request.auth_key
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ip_address):
            query['IpAddress'] = request.ip_address
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateCustomerGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateCustomerGatewayResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_customer_gateway_with_options_async(
        self,
        request: vpc_20160428_models.CreateCustomerGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateCustomerGatewayResponse:
        """
        @summary Creates a customer gateway.
        
        @param request: CreateCustomerGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateCustomerGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.asn):
            query['Asn'] = request.asn
        if not UtilClient.is_unset(request.auth_key):
            query['AuthKey'] = request.auth_key
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ip_address):
            query['IpAddress'] = request.ip_address
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateCustomerGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateCustomerGatewayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_customer_gateway(
        self,
        request: vpc_20160428_models.CreateCustomerGatewayRequest,
    ) -> vpc_20160428_models.CreateCustomerGatewayResponse:
        """
        @summary Creates a customer gateway.
        
        @param request: CreateCustomerGatewayRequest
        @return: CreateCustomerGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_customer_gateway_with_options(request, runtime)

    async def create_customer_gateway_async(
        self,
        request: vpc_20160428_models.CreateCustomerGatewayRequest,
    ) -> vpc_20160428_models.CreateCustomerGatewayResponse:
        """
        @summary Creates a customer gateway.
        
        @param request: CreateCustomerGatewayRequest
        @return: CreateCustomerGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_customer_gateway_with_options_async(request, runtime)

    def create_default_vswitch_with_options(
        self,
        request: vpc_20160428_models.CreateDefaultVSwitchRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateDefaultVSwitchResponse:
        """
        @summary Creates a default vSwitch.
        
        @description When you call this operation, take note of the following limits:
        The first IP address and last three IP addresses of a vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
        The number of instances in the default vSwitch cannot exceed the remaining number of instances supported by the VPC (15,000 minus the number of existing instances).
        Default vSwitches do not support multicasting or broadcasting.
        After you create a default vSwitch, you cannot modify its CIDR block.
        **CreateDefaultVSwitch** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of a default vSwitch:
        If a default vSwitch is in the **Pending** state, it is being configured.
        If a default vSwitch is in the **Available** state, it is available.
        If a default vSwitch already exists in a region, you cannot call this operation to create a default vSwitch in this region.
        Before you create a default vSwitch, make sure that a default VPC is created. You can call the [CreateDefaultVpc](https://help.aliyun.com/document_detail/609152.html) operation to create a default VPC.
        
        @param request: CreateDefaultVSwitchRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDefaultVSwitchResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ipv_6cidr_block):
            query['Ipv6CidrBlock'] = request.ipv_6cidr_block
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDefaultVSwitch',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateDefaultVSwitchResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_default_vswitch_with_options_async(
        self,
        request: vpc_20160428_models.CreateDefaultVSwitchRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateDefaultVSwitchResponse:
        """
        @summary Creates a default vSwitch.
        
        @description When you call this operation, take note of the following limits:
        The first IP address and last three IP addresses of a vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
        The number of instances in the default vSwitch cannot exceed the remaining number of instances supported by the VPC (15,000 minus the number of existing instances).
        Default vSwitches do not support multicasting or broadcasting.
        After you create a default vSwitch, you cannot modify its CIDR block.
        **CreateDefaultVSwitch** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of a default vSwitch:
        If a default vSwitch is in the **Pending** state, it is being configured.
        If a default vSwitch is in the **Available** state, it is available.
        If a default vSwitch already exists in a region, you cannot call this operation to create a default vSwitch in this region.
        Before you create a default vSwitch, make sure that a default VPC is created. You can call the [CreateDefaultVpc](https://help.aliyun.com/document_detail/609152.html) operation to create a default VPC.
        
        @param request: CreateDefaultVSwitchRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDefaultVSwitchResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ipv_6cidr_block):
            query['Ipv6CidrBlock'] = request.ipv_6cidr_block
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDefaultVSwitch',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateDefaultVSwitchResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_default_vswitch(
        self,
        request: vpc_20160428_models.CreateDefaultVSwitchRequest,
    ) -> vpc_20160428_models.CreateDefaultVSwitchResponse:
        """
        @summary Creates a default vSwitch.
        
        @description When you call this operation, take note of the following limits:
        The first IP address and last three IP addresses of a vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
        The number of instances in the default vSwitch cannot exceed the remaining number of instances supported by the VPC (15,000 minus the number of existing instances).
        Default vSwitches do not support multicasting or broadcasting.
        After you create a default vSwitch, you cannot modify its CIDR block.
        **CreateDefaultVSwitch** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of a default vSwitch:
        If a default vSwitch is in the **Pending** state, it is being configured.
        If a default vSwitch is in the **Available** state, it is available.
        If a default vSwitch already exists in a region, you cannot call this operation to create a default vSwitch in this region.
        Before you create a default vSwitch, make sure that a default VPC is created. You can call the [CreateDefaultVpc](https://help.aliyun.com/document_detail/609152.html) operation to create a default VPC.
        
        @param request: CreateDefaultVSwitchRequest
        @return: CreateDefaultVSwitchResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_default_vswitch_with_options(request, runtime)

    async def create_default_vswitch_async(
        self,
        request: vpc_20160428_models.CreateDefaultVSwitchRequest,
    ) -> vpc_20160428_models.CreateDefaultVSwitchResponse:
        """
        @summary Creates a default vSwitch.
        
        @description When you call this operation, take note of the following limits:
        The first IP address and last three IP addresses of a vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
        The number of instances in the default vSwitch cannot exceed the remaining number of instances supported by the VPC (15,000 minus the number of existing instances).
        Default vSwitches do not support multicasting or broadcasting.
        After you create a default vSwitch, you cannot modify its CIDR block.
        **CreateDefaultVSwitch** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of a default vSwitch:
        If a default vSwitch is in the **Pending** state, it is being configured.
        If a default vSwitch is in the **Available** state, it is available.
        If a default vSwitch already exists in a region, you cannot call this operation to create a default vSwitch in this region.
        Before you create a default vSwitch, make sure that a default VPC is created. You can call the [CreateDefaultVpc](https://help.aliyun.com/document_detail/609152.html) operation to create a default VPC.
        
        @param request: CreateDefaultVSwitchRequest
        @return: CreateDefaultVSwitchResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_default_vswitch_with_options_async(request, runtime)

    def create_default_vpc_with_options(
        self,
        request: vpc_20160428_models.CreateDefaultVpcRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateDefaultVpcResponse:
        """
        @summary Creates a default virtual private cloud (VPC).
        
        @description ## Usage notes
        When you call this operation, take note of the following items:
        After you create a default VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to it.
        In each default VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
        After you create a default VPC, a vRouter and a route table are automatically created for the VPC.
        At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
        **CreateDefaultVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
        If the default VPC is in the **Pending** state, the VPC is being configured.
        If the default VPC is in the **Available** state, the VPC is available.
        You cannot repeatedly call the **CreateDefaultVpc** operation within a specific time period.
        You can create only one default VPC in each region.
        
        @param request: CreateDefaultVpcRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDefaultVpcResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.enable_ipv_6):
            query['EnableIpv6'] = request.enable_ipv_6
        if not UtilClient.is_unset(request.ipv_6cidr_block):
            query['Ipv6CidrBlock'] = request.ipv_6cidr_block
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDefaultVpc',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateDefaultVpcResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_default_vpc_with_options_async(
        self,
        request: vpc_20160428_models.CreateDefaultVpcRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateDefaultVpcResponse:
        """
        @summary Creates a default virtual private cloud (VPC).
        
        @description ## Usage notes
        When you call this operation, take note of the following items:
        After you create a default VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to it.
        In each default VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
        After you create a default VPC, a vRouter and a route table are automatically created for the VPC.
        At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
        **CreateDefaultVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
        If the default VPC is in the **Pending** state, the VPC is being configured.
        If the default VPC is in the **Available** state, the VPC is available.
        You cannot repeatedly call the **CreateDefaultVpc** operation within a specific time period.
        You can create only one default VPC in each region.
        
        @param request: CreateDefaultVpcRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDefaultVpcResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.enable_ipv_6):
            query['EnableIpv6'] = request.enable_ipv_6
        if not UtilClient.is_unset(request.ipv_6cidr_block):
            query['Ipv6CidrBlock'] = request.ipv_6cidr_block
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDefaultVpc',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateDefaultVpcResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_default_vpc(
        self,
        request: vpc_20160428_models.CreateDefaultVpcRequest,
    ) -> vpc_20160428_models.CreateDefaultVpcResponse:
        """
        @summary Creates a default virtual private cloud (VPC).
        
        @description ## Usage notes
        When you call this operation, take note of the following items:
        After you create a default VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to it.
        In each default VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
        After you create a default VPC, a vRouter and a route table are automatically created for the VPC.
        At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
        **CreateDefaultVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
        If the default VPC is in the **Pending** state, the VPC is being configured.
        If the default VPC is in the **Available** state, the VPC is available.
        You cannot repeatedly call the **CreateDefaultVpc** operation within a specific time period.
        You can create only one default VPC in each region.
        
        @param request: CreateDefaultVpcRequest
        @return: CreateDefaultVpcResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_default_vpc_with_options(request, runtime)

    async def create_default_vpc_async(
        self,
        request: vpc_20160428_models.CreateDefaultVpcRequest,
    ) -> vpc_20160428_models.CreateDefaultVpcResponse:
        """
        @summary Creates a default virtual private cloud (VPC).
        
        @description ## Usage notes
        When you call this operation, take note of the following items:
        After you create a default VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to it.
        In each default VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
        After you create a default VPC, a vRouter and a route table are automatically created for the VPC.
        At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
        **CreateDefaultVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
        If the default VPC is in the **Pending** state, the VPC is being configured.
        If the default VPC is in the **Available** state, the VPC is available.
        You cannot repeatedly call the **CreateDefaultVpc** operation within a specific time period.
        You can create only one default VPC in each region.
        
        @param request: CreateDefaultVpcRequest
        @return: CreateDefaultVpcResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_default_vpc_with_options_async(request, runtime)

    def create_dhcp_options_set_with_options(
        self,
        request: vpc_20160428_models.CreateDhcpOptionsSetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateDhcpOptionsSetResponse:
        """
        @summary Creates a DHCP options set.
        
        @description    **CreateDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/448820.html) to query the status of the task.
        If the vSwitch is in the **Pending** state, the DHCP options set is being configured.
        If the vSwitch is in the **Available** state, the DHCP options set is available.
        
        @param request: CreateDhcpOptionsSetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDhcpOptionsSetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dhcp_options_set_description):
            query['DhcpOptionsSetDescription'] = request.dhcp_options_set_description
        if not UtilClient.is_unset(request.dhcp_options_set_name):
            query['DhcpOptionsSetName'] = request.dhcp_options_set_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.domain_name_servers):
            query['DomainNameServers'] = request.domain_name_servers
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.ipv_6lease_time):
            query['Ipv6LeaseTime'] = request.ipv_6lease_time
        if not UtilClient.is_unset(request.lease_time):
            query['LeaseTime'] = request.lease_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDhcpOptionsSet',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateDhcpOptionsSetResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_dhcp_options_set_with_options_async(
        self,
        request: vpc_20160428_models.CreateDhcpOptionsSetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateDhcpOptionsSetResponse:
        """
        @summary Creates a DHCP options set.
        
        @description    **CreateDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/448820.html) to query the status of the task.
        If the vSwitch is in the **Pending** state, the DHCP options set is being configured.
        If the vSwitch is in the **Available** state, the DHCP options set is available.
        
        @param request: CreateDhcpOptionsSetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDhcpOptionsSetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dhcp_options_set_description):
            query['DhcpOptionsSetDescription'] = request.dhcp_options_set_description
        if not UtilClient.is_unset(request.dhcp_options_set_name):
            query['DhcpOptionsSetName'] = request.dhcp_options_set_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.domain_name_servers):
            query['DomainNameServers'] = request.domain_name_servers
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.ipv_6lease_time):
            query['Ipv6LeaseTime'] = request.ipv_6lease_time
        if not UtilClient.is_unset(request.lease_time):
            query['LeaseTime'] = request.lease_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDhcpOptionsSet',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateDhcpOptionsSetResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_dhcp_options_set(
        self,
        request: vpc_20160428_models.CreateDhcpOptionsSetRequest,
    ) -> vpc_20160428_models.CreateDhcpOptionsSetResponse:
        """
        @summary Creates a DHCP options set.
        
        @description    **CreateDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/448820.html) to query the status of the task.
        If the vSwitch is in the **Pending** state, the DHCP options set is being configured.
        If the vSwitch is in the **Available** state, the DHCP options set is available.
        
        @param request: CreateDhcpOptionsSetRequest
        @return: CreateDhcpOptionsSetResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_dhcp_options_set_with_options(request, runtime)

    async def create_dhcp_options_set_async(
        self,
        request: vpc_20160428_models.CreateDhcpOptionsSetRequest,
    ) -> vpc_20160428_models.CreateDhcpOptionsSetResponse:
        """
        @summary Creates a DHCP options set.
        
        @description    **CreateDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/448820.html) to query the status of the task.
        If the vSwitch is in the **Pending** state, the DHCP options set is being configured.
        If the vSwitch is in the **Available** state, the DHCP options set is available.
        
        @param request: CreateDhcpOptionsSetRequest
        @return: CreateDhcpOptionsSetResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_dhcp_options_set_with_options_async(request, runtime)

    def create_express_cloud_connection_with_options(
        self,
        request: vpc_20160428_models.CreateExpressCloudConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateExpressCloudConnectionResponse:
        """
        @summary Creates an Express Cloud Connect (ECC) instance.
        
        @param request: CreateExpressCloudConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateExpressCloudConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.contact_mail):
            query['ContactMail'] = request.contact_mail
        if not UtilClient.is_unset(request.contact_tel):
            query['ContactTel'] = request.contact_tel
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.idcard_no):
            query['IDCardNo'] = request.idcard_no
        if not UtilClient.is_unset(request.idc_sp):
            query['IdcSP'] = request.idc_sp
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_city):
            query['PeerCity'] = request.peer_city
        if not UtilClient.is_unset(request.peer_location):
            query['PeerLocation'] = request.peer_location
        if not UtilClient.is_unset(request.port_type):
            query['PortType'] = request.port_type
        if not UtilClient.is_unset(request.redundant_ecc_id):
            query['RedundantEccId'] = request.redundant_ecc_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateExpressCloudConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateExpressCloudConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_express_cloud_connection_with_options_async(
        self,
        request: vpc_20160428_models.CreateExpressCloudConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateExpressCloudConnectionResponse:
        """
        @summary Creates an Express Cloud Connect (ECC) instance.
        
        @param request: CreateExpressCloudConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateExpressCloudConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.contact_mail):
            query['ContactMail'] = request.contact_mail
        if not UtilClient.is_unset(request.contact_tel):
            query['ContactTel'] = request.contact_tel
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.idcard_no):
            query['IDCardNo'] = request.idcard_no
        if not UtilClient.is_unset(request.idc_sp):
            query['IdcSP'] = request.idc_sp
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_city):
            query['PeerCity'] = request.peer_city
        if not UtilClient.is_unset(request.peer_location):
            query['PeerLocation'] = request.peer_location
        if not UtilClient.is_unset(request.port_type):
            query['PortType'] = request.port_type
        if not UtilClient.is_unset(request.redundant_ecc_id):
            query['RedundantEccId'] = request.redundant_ecc_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateExpressCloudConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateExpressCloudConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_express_cloud_connection(
        self,
        request: vpc_20160428_models.CreateExpressCloudConnectionRequest,
    ) -> vpc_20160428_models.CreateExpressCloudConnectionResponse:
        """
        @summary Creates an Express Cloud Connect (ECC) instance.
        
        @param request: CreateExpressCloudConnectionRequest
        @return: CreateExpressCloudConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_express_cloud_connection_with_options(request, runtime)

    async def create_express_cloud_connection_async(
        self,
        request: vpc_20160428_models.CreateExpressCloudConnectionRequest,
    ) -> vpc_20160428_models.CreateExpressCloudConnectionResponse:
        """
        @summary Creates an Express Cloud Connect (ECC) instance.
        
        @param request: CreateExpressCloudConnectionRequest
        @return: CreateExpressCloudConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_express_cloud_connection_with_options_async(request, runtime)

    def create_express_connect_traffic_qos_with_options(
        self,
        request: vpc_20160428_models.CreateExpressConnectTrafficQosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateExpressConnectTrafficQosResponse:
        """
        @summary Qos
        
        @param request: CreateExpressConnectTrafficQosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateExpressConnectTrafficQosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.qos_description):
            query['QosDescription'] = request.qos_description
        if not UtilClient.is_unset(request.qos_name):
            query['QosName'] = request.qos_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateExpressConnectTrafficQos',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateExpressConnectTrafficQosResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_express_connect_traffic_qos_with_options_async(
        self,
        request: vpc_20160428_models.CreateExpressConnectTrafficQosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateExpressConnectTrafficQosResponse:
        """
        @summary Qos
        
        @param request: CreateExpressConnectTrafficQosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateExpressConnectTrafficQosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.qos_description):
            query['QosDescription'] = request.qos_description
        if not UtilClient.is_unset(request.qos_name):
            query['QosName'] = request.qos_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateExpressConnectTrafficQos',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateExpressConnectTrafficQosResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_express_connect_traffic_qos(
        self,
        request: vpc_20160428_models.CreateExpressConnectTrafficQosRequest,
    ) -> vpc_20160428_models.CreateExpressConnectTrafficQosResponse:
        """
        @summary Qos
        
        @param request: CreateExpressConnectTrafficQosRequest
        @return: CreateExpressConnectTrafficQosResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_express_connect_traffic_qos_with_options(request, runtime)

    async def create_express_connect_traffic_qos_async(
        self,
        request: vpc_20160428_models.CreateExpressConnectTrafficQosRequest,
    ) -> vpc_20160428_models.CreateExpressConnectTrafficQosResponse:
        """
        @summary Qos
        
        @param request: CreateExpressConnectTrafficQosRequest
        @return: CreateExpressConnectTrafficQosResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_express_connect_traffic_qos_with_options_async(request, runtime)

    def create_express_connect_traffic_qos_queue_with_options(
        self,
        request: vpc_20160428_models.CreateExpressConnectTrafficQosQueueRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateExpressConnectTrafficQosQueueResponse:
        """
        @summary Qos
        
        @param request: CreateExpressConnectTrafficQosQueueRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateExpressConnectTrafficQosQueueResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_percent):
            query['BandwidthPercent'] = request.bandwidth_percent
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.qos_id):
            query['QosId'] = request.qos_id
        if not UtilClient.is_unset(request.queue_description):
            query['QueueDescription'] = request.queue_description
        if not UtilClient.is_unset(request.queue_name):
            query['QueueName'] = request.queue_name
        if not UtilClient.is_unset(request.queue_type):
            query['QueueType'] = request.queue_type
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateExpressConnectTrafficQosQueue',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateExpressConnectTrafficQosQueueResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_express_connect_traffic_qos_queue_with_options_async(
        self,
        request: vpc_20160428_models.CreateExpressConnectTrafficQosQueueRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateExpressConnectTrafficQosQueueResponse:
        """
        @summary Qos
        
        @param request: CreateExpressConnectTrafficQosQueueRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateExpressConnectTrafficQosQueueResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_percent):
            query['BandwidthPercent'] = request.bandwidth_percent
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.qos_id):
            query['QosId'] = request.qos_id
        if not UtilClient.is_unset(request.queue_description):
            query['QueueDescription'] = request.queue_description
        if not UtilClient.is_unset(request.queue_name):
            query['QueueName'] = request.queue_name
        if not UtilClient.is_unset(request.queue_type):
            query['QueueType'] = request.queue_type
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateExpressConnectTrafficQosQueue',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateExpressConnectTrafficQosQueueResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_express_connect_traffic_qos_queue(
        self,
        request: vpc_20160428_models.CreateExpressConnectTrafficQosQueueRequest,
    ) -> vpc_20160428_models.CreateExpressConnectTrafficQosQueueResponse:
        """
        @summary Qos
        
        @param request: CreateExpressConnectTrafficQosQueueRequest
        @return: CreateExpressConnectTrafficQosQueueResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_express_connect_traffic_qos_queue_with_options(request, runtime)

    async def create_express_connect_traffic_qos_queue_async(
        self,
        request: vpc_20160428_models.CreateExpressConnectTrafficQosQueueRequest,
    ) -> vpc_20160428_models.CreateExpressConnectTrafficQosQueueResponse:
        """
        @summary Qos
        
        @param request: CreateExpressConnectTrafficQosQueueRequest
        @return: CreateExpressConnectTrafficQosQueueResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_express_connect_traffic_qos_queue_with_options_async(request, runtime)

    def create_express_connect_traffic_qos_rule_with_options(
        self,
        request: vpc_20160428_models.CreateExpressConnectTrafficQosRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateExpressConnectTrafficQosRuleResponse:
        """
        @summary Qos
        
        @param request: CreateExpressConnectTrafficQosRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateExpressConnectTrafficQosRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dst_cidr):
            query['DstCidr'] = request.dst_cidr
        if not UtilClient.is_unset(request.dst_ipv_6cidr):
            query['DstIPv6Cidr'] = request.dst_ipv_6cidr
        if not UtilClient.is_unset(request.dst_port_range):
            query['DstPortRange'] = request.dst_port_range
        if not UtilClient.is_unset(request.match_dscp):
            query['MatchDscp'] = request.match_dscp
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.protocol):
            query['Protocol'] = request.protocol
        if not UtilClient.is_unset(request.qos_id):
            query['QosId'] = request.qos_id
        if not UtilClient.is_unset(request.queue_id):
            query['QueueId'] = request.queue_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remarking_dscp):
            query['RemarkingDscp'] = request.remarking_dscp
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.rule_description):
            query['RuleDescription'] = request.rule_description
        if not UtilClient.is_unset(request.rule_name):
            query['RuleName'] = request.rule_name
        if not UtilClient.is_unset(request.src_cidr):
            query['SrcCidr'] = request.src_cidr
        if not UtilClient.is_unset(request.src_ipv_6cidr):
            query['SrcIPv6Cidr'] = request.src_ipv_6cidr
        if not UtilClient.is_unset(request.src_port_range):
            query['SrcPortRange'] = request.src_port_range
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateExpressConnectTrafficQosRule',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateExpressConnectTrafficQosRuleResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_express_connect_traffic_qos_rule_with_options_async(
        self,
        request: vpc_20160428_models.CreateExpressConnectTrafficQosRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateExpressConnectTrafficQosRuleResponse:
        """
        @summary Qos
        
        @param request: CreateExpressConnectTrafficQosRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateExpressConnectTrafficQosRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dst_cidr):
            query['DstCidr'] = request.dst_cidr
        if not UtilClient.is_unset(request.dst_ipv_6cidr):
            query['DstIPv6Cidr'] = request.dst_ipv_6cidr
        if not UtilClient.is_unset(request.dst_port_range):
            query['DstPortRange'] = request.dst_port_range
        if not UtilClient.is_unset(request.match_dscp):
            query['MatchDscp'] = request.match_dscp
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.protocol):
            query['Protocol'] = request.protocol
        if not UtilClient.is_unset(request.qos_id):
            query['QosId'] = request.qos_id
        if not UtilClient.is_unset(request.queue_id):
            query['QueueId'] = request.queue_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remarking_dscp):
            query['RemarkingDscp'] = request.remarking_dscp
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.rule_description):
            query['RuleDescription'] = request.rule_description
        if not UtilClient.is_unset(request.rule_name):
            query['RuleName'] = request.rule_name
        if not UtilClient.is_unset(request.src_cidr):
            query['SrcCidr'] = request.src_cidr
        if not UtilClient.is_unset(request.src_ipv_6cidr):
            query['SrcIPv6Cidr'] = request.src_ipv_6cidr
        if not UtilClient.is_unset(request.src_port_range):
            query['SrcPortRange'] = request.src_port_range
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateExpressConnectTrafficQosRule',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateExpressConnectTrafficQosRuleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_express_connect_traffic_qos_rule(
        self,
        request: vpc_20160428_models.CreateExpressConnectTrafficQosRuleRequest,
    ) -> vpc_20160428_models.CreateExpressConnectTrafficQosRuleResponse:
        """
        @summary Qos
        
        @param request: CreateExpressConnectTrafficQosRuleRequest
        @return: CreateExpressConnectTrafficQosRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_express_connect_traffic_qos_rule_with_options(request, runtime)

    async def create_express_connect_traffic_qos_rule_async(
        self,
        request: vpc_20160428_models.CreateExpressConnectTrafficQosRuleRequest,
    ) -> vpc_20160428_models.CreateExpressConnectTrafficQosRuleResponse:
        """
        @summary Qos
        
        @param request: CreateExpressConnectTrafficQosRuleRequest
        @return: CreateExpressConnectTrafficQosRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_express_connect_traffic_qos_rule_with_options_async(request, runtime)

    def create_failover_test_job_with_options(
        self,
        request: vpc_20160428_models.CreateFailoverTestJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateFailoverTestJobResponse:
        """
        @summary 
        
        @param request: CreateFailoverTestJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateFailoverTestJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.job_duration):
            query['JobDuration'] = request.job_duration
        if not UtilClient.is_unset(request.job_type):
            query['JobType'] = request.job_type
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateFailoverTestJob',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateFailoverTestJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_failover_test_job_with_options_async(
        self,
        request: vpc_20160428_models.CreateFailoverTestJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateFailoverTestJobResponse:
        """
        @summary 
        
        @param request: CreateFailoverTestJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateFailoverTestJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.job_duration):
            query['JobDuration'] = request.job_duration
        if not UtilClient.is_unset(request.job_type):
            query['JobType'] = request.job_type
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateFailoverTestJob',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateFailoverTestJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_failover_test_job(
        self,
        request: vpc_20160428_models.CreateFailoverTestJobRequest,
    ) -> vpc_20160428_models.CreateFailoverTestJobResponse:
        """
        @summary 
        
        @param request: CreateFailoverTestJobRequest
        @return: CreateFailoverTestJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_failover_test_job_with_options(request, runtime)

    async def create_failover_test_job_async(
        self,
        request: vpc_20160428_models.CreateFailoverTestJobRequest,
    ) -> vpc_20160428_models.CreateFailoverTestJobResponse:
        """
        @summary 
        
        @param request: CreateFailoverTestJobRequest
        @return: CreateFailoverTestJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_failover_test_job_with_options_async(request, runtime)

    def create_flow_log_with_options(
        self,
        request: vpc_20160428_models.CreateFlowLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateFlowLogResponse:
        """
        @summary Creates a flow log.
        
        @description *CreateFlowLog** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of the flow log.
        If the flow log is in the **Activating** state, the flow log is being created.
        If the flow log is in the **Active** state, the flow log is created and started.
        
        @param request: CreateFlowLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateFlowLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aggregation_interval):
            query['AggregationInterval'] = request.aggregation_interval
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.flow_log_name):
            query['FlowLogName'] = request.flow_log_name
        if not UtilClient.is_unset(request.log_store_name):
            query['LogStoreName'] = request.log_store_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.project_name):
            query['ProjectName'] = request.project_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.traffic_path):
            query['TrafficPath'] = request.traffic_path
        if not UtilClient.is_unset(request.traffic_type):
            query['TrafficType'] = request.traffic_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateFlowLog',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateFlowLogResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_flow_log_with_options_async(
        self,
        request: vpc_20160428_models.CreateFlowLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateFlowLogResponse:
        """
        @summary Creates a flow log.
        
        @description *CreateFlowLog** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of the flow log.
        If the flow log is in the **Activating** state, the flow log is being created.
        If the flow log is in the **Active** state, the flow log is created and started.
        
        @param request: CreateFlowLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateFlowLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aggregation_interval):
            query['AggregationInterval'] = request.aggregation_interval
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.flow_log_name):
            query['FlowLogName'] = request.flow_log_name
        if not UtilClient.is_unset(request.log_store_name):
            query['LogStoreName'] = request.log_store_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.project_name):
            query['ProjectName'] = request.project_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.traffic_path):
            query['TrafficPath'] = request.traffic_path
        if not UtilClient.is_unset(request.traffic_type):
            query['TrafficType'] = request.traffic_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateFlowLog',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateFlowLogResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_flow_log(
        self,
        request: vpc_20160428_models.CreateFlowLogRequest,
    ) -> vpc_20160428_models.CreateFlowLogResponse:
        """
        @summary Creates a flow log.
        
        @description *CreateFlowLog** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of the flow log.
        If the flow log is in the **Activating** state, the flow log is being created.
        If the flow log is in the **Active** state, the flow log is created and started.
        
        @param request: CreateFlowLogRequest
        @return: CreateFlowLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_flow_log_with_options(request, runtime)

    async def create_flow_log_async(
        self,
        request: vpc_20160428_models.CreateFlowLogRequest,
    ) -> vpc_20160428_models.CreateFlowLogResponse:
        """
        @summary Creates a flow log.
        
        @description *CreateFlowLog** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of the flow log.
        If the flow log is in the **Activating** state, the flow log is being created.
        If the flow log is in the **Active** state, the flow log is created and started.
        
        @param request: CreateFlowLogRequest
        @return: CreateFlowLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_flow_log_with_options_async(request, runtime)

    def create_forward_entry_with_options(
        self,
        request: vpc_20160428_models.CreateForwardEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateForwardEntryResponse:
        """
        @summary Adds a DNAT entry to a DNAT table.
        
        @description ## [](#)
        Each DNAT entry consists of the following parameters: *ExternalIp**, **ExternalPort**, **IpProtocol**, **InternalIp**, and **InternalPort**. After you add a DNAT entry, the NAT gateway forwards packets over the specified protocol from **ExternalIp:ExternalPort** to **InternalIp:InternalPort** and sends responses back through the same route.
        When you call this operation, take note of the following limits:
        **CreateForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
        If the DNAT entry is in the **Pending** state, the system is adding the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
        If the DNAT entry is in the **Available** state, the DNAT entry is added.
        You cannot repeatedly call the **CreateForwardEntry** operation to add a DNAT entry within a specific period of time.
        All combinations of **ExternalIp**, **ExternalPort**, and **IpProtocol** used in DNAT entries must be unique. You cannot distribute requests to more than one Elastic Compute Service (ECS) instance if these requests are initiated from the same source IP address, received on the same port, and use the same protocol.
        The combinations of **IpProtocol**, **InternalIp**, and **InternalPort** must be unique.
        If one or more DNAT entries in the DNAT table are in the **Pending** or **Modifying** state, you cannot add DNAT entries to the DNAT table.
        You can add at most 100 DNAT entries to a DNAT table.
        For an elastic IP address (EIP) used by an Internet NAT gateway or a NAT IP address used by a Virtual Private Cloud (VPC) NAT gateway, take note of the following limit: If the IP address has IP mapping enabled and is specified in a DNAT entry, the IP address cannot be used by another DNAT or SNAT entry.
        
        @param request: CreateForwardEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateForwardEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.external_ip):
            query['ExternalIp'] = request.external_ip
        if not UtilClient.is_unset(request.external_port):
            query['ExternalPort'] = request.external_port
        if not UtilClient.is_unset(request.forward_entry_name):
            query['ForwardEntryName'] = request.forward_entry_name
        if not UtilClient.is_unset(request.forward_table_id):
            query['ForwardTableId'] = request.forward_table_id
        if not UtilClient.is_unset(request.internal_ip):
            query['InternalIp'] = request.internal_ip
        if not UtilClient.is_unset(request.internal_port):
            query['InternalPort'] = request.internal_port
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port_break):
            query['PortBreak'] = request.port_break
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateForwardEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateForwardEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_forward_entry_with_options_async(
        self,
        request: vpc_20160428_models.CreateForwardEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateForwardEntryResponse:
        """
        @summary Adds a DNAT entry to a DNAT table.
        
        @description ## [](#)
        Each DNAT entry consists of the following parameters: *ExternalIp**, **ExternalPort**, **IpProtocol**, **InternalIp**, and **InternalPort**. After you add a DNAT entry, the NAT gateway forwards packets over the specified protocol from **ExternalIp:ExternalPort** to **InternalIp:InternalPort** and sends responses back through the same route.
        When you call this operation, take note of the following limits:
        **CreateForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
        If the DNAT entry is in the **Pending** state, the system is adding the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
        If the DNAT entry is in the **Available** state, the DNAT entry is added.
        You cannot repeatedly call the **CreateForwardEntry** operation to add a DNAT entry within a specific period of time.
        All combinations of **ExternalIp**, **ExternalPort**, and **IpProtocol** used in DNAT entries must be unique. You cannot distribute requests to more than one Elastic Compute Service (ECS) instance if these requests are initiated from the same source IP address, received on the same port, and use the same protocol.
        The combinations of **IpProtocol**, **InternalIp**, and **InternalPort** must be unique.
        If one or more DNAT entries in the DNAT table are in the **Pending** or **Modifying** state, you cannot add DNAT entries to the DNAT table.
        You can add at most 100 DNAT entries to a DNAT table.
        For an elastic IP address (EIP) used by an Internet NAT gateway or a NAT IP address used by a Virtual Private Cloud (VPC) NAT gateway, take note of the following limit: If the IP address has IP mapping enabled and is specified in a DNAT entry, the IP address cannot be used by another DNAT or SNAT entry.
        
        @param request: CreateForwardEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateForwardEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.external_ip):
            query['ExternalIp'] = request.external_ip
        if not UtilClient.is_unset(request.external_port):
            query['ExternalPort'] = request.external_port
        if not UtilClient.is_unset(request.forward_entry_name):
            query['ForwardEntryName'] = request.forward_entry_name
        if not UtilClient.is_unset(request.forward_table_id):
            query['ForwardTableId'] = request.forward_table_id
        if not UtilClient.is_unset(request.internal_ip):
            query['InternalIp'] = request.internal_ip
        if not UtilClient.is_unset(request.internal_port):
            query['InternalPort'] = request.internal_port
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port_break):
            query['PortBreak'] = request.port_break
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateForwardEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateForwardEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_forward_entry(
        self,
        request: vpc_20160428_models.CreateForwardEntryRequest,
    ) -> vpc_20160428_models.CreateForwardEntryResponse:
        """
        @summary Adds a DNAT entry to a DNAT table.
        
        @description ## [](#)
        Each DNAT entry consists of the following parameters: *ExternalIp**, **ExternalPort**, **IpProtocol**, **InternalIp**, and **InternalPort**. After you add a DNAT entry, the NAT gateway forwards packets over the specified protocol from **ExternalIp:ExternalPort** to **InternalIp:InternalPort** and sends responses back through the same route.
        When you call this operation, take note of the following limits:
        **CreateForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
        If the DNAT entry is in the **Pending** state, the system is adding the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
        If the DNAT entry is in the **Available** state, the DNAT entry is added.
        You cannot repeatedly call the **CreateForwardEntry** operation to add a DNAT entry within a specific period of time.
        All combinations of **ExternalIp**, **ExternalPort**, and **IpProtocol** used in DNAT entries must be unique. You cannot distribute requests to more than one Elastic Compute Service (ECS) instance if these requests are initiated from the same source IP address, received on the same port, and use the same protocol.
        The combinations of **IpProtocol**, **InternalIp**, and **InternalPort** must be unique.
        If one or more DNAT entries in the DNAT table are in the **Pending** or **Modifying** state, you cannot add DNAT entries to the DNAT table.
        You can add at most 100 DNAT entries to a DNAT table.
        For an elastic IP address (EIP) used by an Internet NAT gateway or a NAT IP address used by a Virtual Private Cloud (VPC) NAT gateway, take note of the following limit: If the IP address has IP mapping enabled and is specified in a DNAT entry, the IP address cannot be used by another DNAT or SNAT entry.
        
        @param request: CreateForwardEntryRequest
        @return: CreateForwardEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_forward_entry_with_options(request, runtime)

    async def create_forward_entry_async(
        self,
        request: vpc_20160428_models.CreateForwardEntryRequest,
    ) -> vpc_20160428_models.CreateForwardEntryResponse:
        """
        @summary Adds a DNAT entry to a DNAT table.
        
        @description ## [](#)
        Each DNAT entry consists of the following parameters: *ExternalIp**, **ExternalPort**, **IpProtocol**, **InternalIp**, and **InternalPort**. After you add a DNAT entry, the NAT gateway forwards packets over the specified protocol from **ExternalIp:ExternalPort** to **InternalIp:InternalPort** and sends responses back through the same route.
        When you call this operation, take note of the following limits:
        **CreateForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
        If the DNAT entry is in the **Pending** state, the system is adding the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
        If the DNAT entry is in the **Available** state, the DNAT entry is added.
        You cannot repeatedly call the **CreateForwardEntry** operation to add a DNAT entry within a specific period of time.
        All combinations of **ExternalIp**, **ExternalPort**, and **IpProtocol** used in DNAT entries must be unique. You cannot distribute requests to more than one Elastic Compute Service (ECS) instance if these requests are initiated from the same source IP address, received on the same port, and use the same protocol.
        The combinations of **IpProtocol**, **InternalIp**, and **InternalPort** must be unique.
        If one or more DNAT entries in the DNAT table are in the **Pending** or **Modifying** state, you cannot add DNAT entries to the DNAT table.
        You can add at most 100 DNAT entries to a DNAT table.
        For an elastic IP address (EIP) used by an Internet NAT gateway or a NAT IP address used by a Virtual Private Cloud (VPC) NAT gateway, take note of the following limit: If the IP address has IP mapping enabled and is specified in a DNAT entry, the IP address cannot be used by another DNAT or SNAT entry.
        
        @param request: CreateForwardEntryRequest
        @return: CreateForwardEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_forward_entry_with_options_async(request, runtime)

    def create_full_nat_entry_with_options(
        self,
        request: vpc_20160428_models.CreateFullNatEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateFullNatEntryResponse:
        """
        @summary Adds a FULLNAT entry to the FULLNAT table.
        
        @description    **CreateFullNatEntry** is an asynchronous operation. After you send a request to call this operation, the system returns a FULLNAT entry and the FULLNAT entry is being added in the backend. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
        If the FULLNAT entry is in the **Creating** state, the system is adding the FULLNAT entry. You can only query the status of the FULLNAT entry, but cannot perform other operations.
        If the FULLNAT entry is in the **Available** state, the FULLNAT entry is added.
        You cannot repeatedly call the **CreateFullNatEntry** operation for the same VPN gateway within the specified period of time.
        
        @param request: CreateFullNatEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateFullNatEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.access_ip):
            query['AccessIp'] = request.access_ip
        if not UtilClient.is_unset(request.access_port):
            query['AccessPort'] = request.access_port
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.full_nat_entry_description):
            query['FullNatEntryDescription'] = request.full_nat_entry_description
        if not UtilClient.is_unset(request.full_nat_entry_name):
            query['FullNatEntryName'] = request.full_nat_entry_name
        if not UtilClient.is_unset(request.full_nat_table_id):
            query['FullNatTableId'] = request.full_nat_table_id
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.nat_ip):
            query['NatIp'] = request.nat_ip
        if not UtilClient.is_unset(request.nat_ip_port):
            query['NatIpPort'] = request.nat_ip_port
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateFullNatEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateFullNatEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_full_nat_entry_with_options_async(
        self,
        request: vpc_20160428_models.CreateFullNatEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateFullNatEntryResponse:
        """
        @summary Adds a FULLNAT entry to the FULLNAT table.
        
        @description    **CreateFullNatEntry** is an asynchronous operation. After you send a request to call this operation, the system returns a FULLNAT entry and the FULLNAT entry is being added in the backend. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
        If the FULLNAT entry is in the **Creating** state, the system is adding the FULLNAT entry. You can only query the status of the FULLNAT entry, but cannot perform other operations.
        If the FULLNAT entry is in the **Available** state, the FULLNAT entry is added.
        You cannot repeatedly call the **CreateFullNatEntry** operation for the same VPN gateway within the specified period of time.
        
        @param request: CreateFullNatEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateFullNatEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.access_ip):
            query['AccessIp'] = request.access_ip
        if not UtilClient.is_unset(request.access_port):
            query['AccessPort'] = request.access_port
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.full_nat_entry_description):
            query['FullNatEntryDescription'] = request.full_nat_entry_description
        if not UtilClient.is_unset(request.full_nat_entry_name):
            query['FullNatEntryName'] = request.full_nat_entry_name
        if not UtilClient.is_unset(request.full_nat_table_id):
            query['FullNatTableId'] = request.full_nat_table_id
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.nat_ip):
            query['NatIp'] = request.nat_ip
        if not UtilClient.is_unset(request.nat_ip_port):
            query['NatIpPort'] = request.nat_ip_port
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateFullNatEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateFullNatEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_full_nat_entry(
        self,
        request: vpc_20160428_models.CreateFullNatEntryRequest,
    ) -> vpc_20160428_models.CreateFullNatEntryResponse:
        """
        @summary Adds a FULLNAT entry to the FULLNAT table.
        
        @description    **CreateFullNatEntry** is an asynchronous operation. After you send a request to call this operation, the system returns a FULLNAT entry and the FULLNAT entry is being added in the backend. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
        If the FULLNAT entry is in the **Creating** state, the system is adding the FULLNAT entry. You can only query the status of the FULLNAT entry, but cannot perform other operations.
        If the FULLNAT entry is in the **Available** state, the FULLNAT entry is added.
        You cannot repeatedly call the **CreateFullNatEntry** operation for the same VPN gateway within the specified period of time.
        
        @param request: CreateFullNatEntryRequest
        @return: CreateFullNatEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_full_nat_entry_with_options(request, runtime)

    async def create_full_nat_entry_async(
        self,
        request: vpc_20160428_models.CreateFullNatEntryRequest,
    ) -> vpc_20160428_models.CreateFullNatEntryResponse:
        """
        @summary Adds a FULLNAT entry to the FULLNAT table.
        
        @description    **CreateFullNatEntry** is an asynchronous operation. After you send a request to call this operation, the system returns a FULLNAT entry and the FULLNAT entry is being added in the backend. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
        If the FULLNAT entry is in the **Creating** state, the system is adding the FULLNAT entry. You can only query the status of the FULLNAT entry, but cannot perform other operations.
        If the FULLNAT entry is in the **Available** state, the FULLNAT entry is added.
        You cannot repeatedly call the **CreateFullNatEntry** operation for the same VPN gateway within the specified period of time.
        
        @param request: CreateFullNatEntryRequest
        @return: CreateFullNatEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_full_nat_entry_with_options_async(request, runtime)

    def create_global_acceleration_instance_with_options(
        self,
        request: vpc_20160428_models.CreateGlobalAccelerationInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateGlobalAccelerationInstanceResponse:
        """
        @deprecated OpenAPI CreateGlobalAccelerationInstance is deprecated
        
        @summary Creates a Global Accelerator (GA) instance.
        
        @description ## Usage notes
        You can call this operation to create only pay-as-you-go GA instances.
        
        @param request: CreateGlobalAccelerationInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateGlobalAccelerationInstanceResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.bandwidth_type):
            query['BandwidthType'] = request.bandwidth_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.service_location):
            query['ServiceLocation'] = request.service_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateGlobalAccelerationInstance',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateGlobalAccelerationInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_global_acceleration_instance_with_options_async(
        self,
        request: vpc_20160428_models.CreateGlobalAccelerationInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateGlobalAccelerationInstanceResponse:
        """
        @deprecated OpenAPI CreateGlobalAccelerationInstance is deprecated
        
        @summary Creates a Global Accelerator (GA) instance.
        
        @description ## Usage notes
        You can call this operation to create only pay-as-you-go GA instances.
        
        @param request: CreateGlobalAccelerationInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateGlobalAccelerationInstanceResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.bandwidth_type):
            query['BandwidthType'] = request.bandwidth_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.service_location):
            query['ServiceLocation'] = request.service_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateGlobalAccelerationInstance',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateGlobalAccelerationInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_global_acceleration_instance(
        self,
        request: vpc_20160428_models.CreateGlobalAccelerationInstanceRequest,
    ) -> vpc_20160428_models.CreateGlobalAccelerationInstanceResponse:
        """
        @deprecated OpenAPI CreateGlobalAccelerationInstance is deprecated
        
        @summary Creates a Global Accelerator (GA) instance.
        
        @description ## Usage notes
        You can call this operation to create only pay-as-you-go GA instances.
        
        @param request: CreateGlobalAccelerationInstanceRequest
        @return: CreateGlobalAccelerationInstanceResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.create_global_acceleration_instance_with_options(request, runtime)

    async def create_global_acceleration_instance_async(
        self,
        request: vpc_20160428_models.CreateGlobalAccelerationInstanceRequest,
    ) -> vpc_20160428_models.CreateGlobalAccelerationInstanceResponse:
        """
        @deprecated OpenAPI CreateGlobalAccelerationInstance is deprecated
        
        @summary Creates a Global Accelerator (GA) instance.
        
        @description ## Usage notes
        You can call this operation to create only pay-as-you-go GA instances.
        
        @param request: CreateGlobalAccelerationInstanceRequest
        @return: CreateGlobalAccelerationInstanceResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_global_acceleration_instance_with_options_async(request, runtime)

    def create_ha_vip_with_options(
        self,
        request: vpc_20160428_models.CreateHaVipRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateHaVipResponse:
        """
        @summary Creates a high-availability virtual IP address (HAVIP).
        
        @description *CreateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of the task:
        If the HAVIP is in the **Creating** state, the HAVIP is being created.
        If the HAVIP is in the **Available** state, the HAVIP is created.
        
        @param request: CreateHaVipRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateHaVipResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ip_address):
            query['IpAddress'] = request.ip_address
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateHaVip',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateHaVipResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_ha_vip_with_options_async(
        self,
        request: vpc_20160428_models.CreateHaVipRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateHaVipResponse:
        """
        @summary Creates a high-availability virtual IP address (HAVIP).
        
        @description *CreateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of the task:
        If the HAVIP is in the **Creating** state, the HAVIP is being created.
        If the HAVIP is in the **Available** state, the HAVIP is created.
        
        @param request: CreateHaVipRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateHaVipResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ip_address):
            query['IpAddress'] = request.ip_address
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateHaVip',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateHaVipResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_ha_vip(
        self,
        request: vpc_20160428_models.CreateHaVipRequest,
    ) -> vpc_20160428_models.CreateHaVipResponse:
        """
        @summary Creates a high-availability virtual IP address (HAVIP).
        
        @description *CreateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of the task:
        If the HAVIP is in the **Creating** state, the HAVIP is being created.
        If the HAVIP is in the **Available** state, the HAVIP is created.
        
        @param request: CreateHaVipRequest
        @return: CreateHaVipResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_ha_vip_with_options(request, runtime)

    async def create_ha_vip_async(
        self,
        request: vpc_20160428_models.CreateHaVipRequest,
    ) -> vpc_20160428_models.CreateHaVipResponse:
        """
        @summary Creates a high-availability virtual IP address (HAVIP).
        
        @description *CreateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of the task:
        If the HAVIP is in the **Creating** state, the HAVIP is being created.
        If the HAVIP is in the **Available** state, the HAVIP is created.
        
        @param request: CreateHaVipRequest
        @return: CreateHaVipResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_ha_vip_with_options_async(request, runtime)

    def create_high_reliable_physical_connection_with_options(
        self,
        request: vpc_20160428_models.CreateHighReliablePhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateHighReliablePhysicalConnectionResponse:
        """
        @summary 
        
        @param request: CreateHighReliablePhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateHighReliablePhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.accept_language):
            query['AcceptLanguage'] = request.accept_language
        if not UtilClient.is_unset(request.ap_list):
            query['ApList'] = request.ap_list
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.device_advanced_capacity):
            query['DeviceAdvancedCapacity'] = request.device_advanced_capacity
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.high_reliable_type):
            query['HighReliableType'] = request.high_reliable_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port_type):
            query['PortType'] = request.port_type
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateHighReliablePhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateHighReliablePhysicalConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_high_reliable_physical_connection_with_options_async(
        self,
        request: vpc_20160428_models.CreateHighReliablePhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateHighReliablePhysicalConnectionResponse:
        """
        @summary 
        
        @param request: CreateHighReliablePhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateHighReliablePhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.accept_language):
            query['AcceptLanguage'] = request.accept_language
        if not UtilClient.is_unset(request.ap_list):
            query['ApList'] = request.ap_list
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.device_advanced_capacity):
            query['DeviceAdvancedCapacity'] = request.device_advanced_capacity
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.high_reliable_type):
            query['HighReliableType'] = request.high_reliable_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port_type):
            query['PortType'] = request.port_type
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateHighReliablePhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateHighReliablePhysicalConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_high_reliable_physical_connection(
        self,
        request: vpc_20160428_models.CreateHighReliablePhysicalConnectionRequest,
    ) -> vpc_20160428_models.CreateHighReliablePhysicalConnectionResponse:
        """
        @summary 
        
        @param request: CreateHighReliablePhysicalConnectionRequest
        @return: CreateHighReliablePhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_high_reliable_physical_connection_with_options(request, runtime)

    async def create_high_reliable_physical_connection_async(
        self,
        request: vpc_20160428_models.CreateHighReliablePhysicalConnectionRequest,
    ) -> vpc_20160428_models.CreateHighReliablePhysicalConnectionResponse:
        """
        @summary 
        
        @param request: CreateHighReliablePhysicalConnectionRequest
        @return: CreateHighReliablePhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_high_reliable_physical_connection_with_options_async(request, runtime)

    def create_ipv_6translator_with_options(
        self,
        request: vpc_20160428_models.CreateIPv6TranslatorRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateIPv6TranslatorResponse:
        """
        @deprecated OpenAPI CreateIPv6Translator is deprecated
        
        @summary Creates an IPv6 Translation Service instance.
        
        @param request: CreateIPv6TranslatorRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIPv6TranslatorResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.duration):
            query['Duration'] = request.duration
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pay_type):
            query['PayType'] = request.pay_type
        if not UtilClient.is_unset(request.pricing_cycle):
            query['PricingCycle'] = request.pricing_cycle
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.spec):
            query['Spec'] = request.spec
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateIPv6Translator',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateIPv6TranslatorResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_ipv_6translator_with_options_async(
        self,
        request: vpc_20160428_models.CreateIPv6TranslatorRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateIPv6TranslatorResponse:
        """
        @deprecated OpenAPI CreateIPv6Translator is deprecated
        
        @summary Creates an IPv6 Translation Service instance.
        
        @param request: CreateIPv6TranslatorRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIPv6TranslatorResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.duration):
            query['Duration'] = request.duration
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pay_type):
            query['PayType'] = request.pay_type
        if not UtilClient.is_unset(request.pricing_cycle):
            query['PricingCycle'] = request.pricing_cycle
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.spec):
            query['Spec'] = request.spec
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateIPv6Translator',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateIPv6TranslatorResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_ipv_6translator(
        self,
        request: vpc_20160428_models.CreateIPv6TranslatorRequest,
    ) -> vpc_20160428_models.CreateIPv6TranslatorResponse:
        """
        @deprecated OpenAPI CreateIPv6Translator is deprecated
        
        @summary Creates an IPv6 Translation Service instance.
        
        @param request: CreateIPv6TranslatorRequest
        @return: CreateIPv6TranslatorResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.create_ipv_6translator_with_options(request, runtime)

    async def create_ipv_6translator_async(
        self,
        request: vpc_20160428_models.CreateIPv6TranslatorRequest,
    ) -> vpc_20160428_models.CreateIPv6TranslatorResponse:
        """
        @deprecated OpenAPI CreateIPv6Translator is deprecated
        
        @summary Creates an IPv6 Translation Service instance.
        
        @param request: CreateIPv6TranslatorRequest
        @return: CreateIPv6TranslatorResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_ipv_6translator_with_options_async(request, runtime)

    def create_ipv_6translator_acl_list_with_options(
        self,
        request: vpc_20160428_models.CreateIPv6TranslatorAclListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateIPv6TranslatorAclListResponse:
        """
        @deprecated OpenAPI CreateIPv6TranslatorAclList is deprecated
        
        @summary Creates an access control list (ACL).
        
        @param request: CreateIPv6TranslatorAclListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIPv6TranslatorAclListResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_name):
            query['AclName'] = request.acl_name
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateIPv6TranslatorAclList',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateIPv6TranslatorAclListResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_ipv_6translator_acl_list_with_options_async(
        self,
        request: vpc_20160428_models.CreateIPv6TranslatorAclListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateIPv6TranslatorAclListResponse:
        """
        @deprecated OpenAPI CreateIPv6TranslatorAclList is deprecated
        
        @summary Creates an access control list (ACL).
        
        @param request: CreateIPv6TranslatorAclListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIPv6TranslatorAclListResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_name):
            query['AclName'] = request.acl_name
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateIPv6TranslatorAclList',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateIPv6TranslatorAclListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_ipv_6translator_acl_list(
        self,
        request: vpc_20160428_models.CreateIPv6TranslatorAclListRequest,
    ) -> vpc_20160428_models.CreateIPv6TranslatorAclListResponse:
        """
        @deprecated OpenAPI CreateIPv6TranslatorAclList is deprecated
        
        @summary Creates an access control list (ACL).
        
        @param request: CreateIPv6TranslatorAclListRequest
        @return: CreateIPv6TranslatorAclListResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.create_ipv_6translator_acl_list_with_options(request, runtime)

    async def create_ipv_6translator_acl_list_async(
        self,
        request: vpc_20160428_models.CreateIPv6TranslatorAclListRequest,
    ) -> vpc_20160428_models.CreateIPv6TranslatorAclListResponse:
        """
        @deprecated OpenAPI CreateIPv6TranslatorAclList is deprecated
        
        @summary Creates an access control list (ACL).
        
        @param request: CreateIPv6TranslatorAclListRequest
        @return: CreateIPv6TranslatorAclListResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_ipv_6translator_acl_list_with_options_async(request, runtime)

    def create_ipv_6translator_entry_with_options(
        self,
        request: vpc_20160428_models.CreateIPv6TranslatorEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateIPv6TranslatorEntryResponse:
        """
        @deprecated OpenAPI CreateIPv6TranslatorEntry is deprecated
        
        @summary Adds an IPv6 mapping entry to an IPv6 Translation Service instance.
        
        @param request: CreateIPv6TranslatorEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIPv6TranslatorEntryResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_id):
            query['AclId'] = request.acl_id
        if not UtilClient.is_unset(request.acl_status):
            query['AclStatus'] = request.acl_status
        if not UtilClient.is_unset(request.acl_type):
            query['AclType'] = request.acl_type
        if not UtilClient.is_unset(request.allocate_ipv_6port):
            query['AllocateIpv6Port'] = request.allocate_ipv_6port
        if not UtilClient.is_unset(request.backend_ipv_4addr):
            query['BackendIpv4Addr'] = request.backend_ipv_4addr
        if not UtilClient.is_unset(request.backend_ipv_4port):
            query['BackendIpv4Port'] = request.backend_ipv_4port
        if not UtilClient.is_unset(request.entry_bandwidth):
            query['EntryBandwidth'] = request.entry_bandwidth
        if not UtilClient.is_unset(request.entry_description):
            query['EntryDescription'] = request.entry_description
        if not UtilClient.is_unset(request.entry_name):
            query['EntryName'] = request.entry_name
        if not UtilClient.is_unset(request.ipv_6translator_id):
            query['Ipv6TranslatorId'] = request.ipv_6translator_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.trans_protocol):
            query['TransProtocol'] = request.trans_protocol
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateIPv6TranslatorEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateIPv6TranslatorEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_ipv_6translator_entry_with_options_async(
        self,
        request: vpc_20160428_models.CreateIPv6TranslatorEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateIPv6TranslatorEntryResponse:
        """
        @deprecated OpenAPI CreateIPv6TranslatorEntry is deprecated
        
        @summary Adds an IPv6 mapping entry to an IPv6 Translation Service instance.
        
        @param request: CreateIPv6TranslatorEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIPv6TranslatorEntryResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_id):
            query['AclId'] = request.acl_id
        if not UtilClient.is_unset(request.acl_status):
            query['AclStatus'] = request.acl_status
        if not UtilClient.is_unset(request.acl_type):
            query['AclType'] = request.acl_type
        if not UtilClient.is_unset(request.allocate_ipv_6port):
            query['AllocateIpv6Port'] = request.allocate_ipv_6port
        if not UtilClient.is_unset(request.backend_ipv_4addr):
            query['BackendIpv4Addr'] = request.backend_ipv_4addr
        if not UtilClient.is_unset(request.backend_ipv_4port):
            query['BackendIpv4Port'] = request.backend_ipv_4port
        if not UtilClient.is_unset(request.entry_bandwidth):
            query['EntryBandwidth'] = request.entry_bandwidth
        if not UtilClient.is_unset(request.entry_description):
            query['EntryDescription'] = request.entry_description
        if not UtilClient.is_unset(request.entry_name):
            query['EntryName'] = request.entry_name
        if not UtilClient.is_unset(request.ipv_6translator_id):
            query['Ipv6TranslatorId'] = request.ipv_6translator_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.trans_protocol):
            query['TransProtocol'] = request.trans_protocol
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateIPv6TranslatorEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateIPv6TranslatorEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_ipv_6translator_entry(
        self,
        request: vpc_20160428_models.CreateIPv6TranslatorEntryRequest,
    ) -> vpc_20160428_models.CreateIPv6TranslatorEntryResponse:
        """
        @deprecated OpenAPI CreateIPv6TranslatorEntry is deprecated
        
        @summary Adds an IPv6 mapping entry to an IPv6 Translation Service instance.
        
        @param request: CreateIPv6TranslatorEntryRequest
        @return: CreateIPv6TranslatorEntryResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.create_ipv_6translator_entry_with_options(request, runtime)

    async def create_ipv_6translator_entry_async(
        self,
        request: vpc_20160428_models.CreateIPv6TranslatorEntryRequest,
    ) -> vpc_20160428_models.CreateIPv6TranslatorEntryResponse:
        """
        @deprecated OpenAPI CreateIPv6TranslatorEntry is deprecated
        
        @summary Adds an IPv6 mapping entry to an IPv6 Translation Service instance.
        
        @param request: CreateIPv6TranslatorEntryRequest
        @return: CreateIPv6TranslatorEntryResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_ipv_6translator_entry_with_options_async(request, runtime)

    def create_ipsec_server_with_options(
        self,
        request: vpc_20160428_models.CreateIpsecServerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateIpsecServerResponse:
        """
        @summary Creates an IPsec server.
        
        @description    Before you create an IPsec server, you must create a VPN gateway and enable the SSL-VPN feature for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
        Before you create an IPsec server, make sure that no IPsec-VPN connection exists on the VPN gateway. For more information, see [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
        **CreateIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
        If the VPN gateway is in the **updating** state, the IPsec server is being created.
        If the VPN gateway is in the **active** state, the IPsec server is created.
        You cannot repeatedly call **CreateIpsecServer** within the specified period of time.
        
        @param request: CreateIpsecServerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIpsecServerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_ip_pool):
            query['ClientIpPool'] = request.client_ip_pool
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.effect_immediately):
            query['EffectImmediately'] = request.effect_immediately
        if not UtilClient.is_unset(request.ike_config):
            query['IkeConfig'] = request.ike_config
        if not UtilClient.is_unset(request.ip_sec_server_name):
            query['IpSecServerName'] = request.ip_sec_server_name
        if not UtilClient.is_unset(request.ipsec_config):
            query['IpsecConfig'] = request.ipsec_config
        if not UtilClient.is_unset(request.local_subnet):
            query['LocalSubnet'] = request.local_subnet
        if not UtilClient.is_unset(request.psk):
            query['Psk'] = request.psk
        if not UtilClient.is_unset(request.psk_enabled):
            query['PskEnabled'] = request.psk_enabled
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateIpsecServer',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateIpsecServerResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_ipsec_server_with_options_async(
        self,
        request: vpc_20160428_models.CreateIpsecServerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateIpsecServerResponse:
        """
        @summary Creates an IPsec server.
        
        @description    Before you create an IPsec server, you must create a VPN gateway and enable the SSL-VPN feature for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
        Before you create an IPsec server, make sure that no IPsec-VPN connection exists on the VPN gateway. For more information, see [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
        **CreateIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
        If the VPN gateway is in the **updating** state, the IPsec server is being created.
        If the VPN gateway is in the **active** state, the IPsec server is created.
        You cannot repeatedly call **CreateIpsecServer** within the specified period of time.
        
        @param request: CreateIpsecServerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIpsecServerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_ip_pool):
            query['ClientIpPool'] = request.client_ip_pool
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.effect_immediately):
            query['EffectImmediately'] = request.effect_immediately
        if not UtilClient.is_unset(request.ike_config):
            query['IkeConfig'] = request.ike_config
        if not UtilClient.is_unset(request.ip_sec_server_name):
            query['IpSecServerName'] = request.ip_sec_server_name
        if not UtilClient.is_unset(request.ipsec_config):
            query['IpsecConfig'] = request.ipsec_config
        if not UtilClient.is_unset(request.local_subnet):
            query['LocalSubnet'] = request.local_subnet
        if not UtilClient.is_unset(request.psk):
            query['Psk'] = request.psk
        if not UtilClient.is_unset(request.psk_enabled):
            query['PskEnabled'] = request.psk_enabled
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateIpsecServer',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateIpsecServerResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_ipsec_server(
        self,
        request: vpc_20160428_models.CreateIpsecServerRequest,
    ) -> vpc_20160428_models.CreateIpsecServerResponse:
        """
        @summary Creates an IPsec server.
        
        @description    Before you create an IPsec server, you must create a VPN gateway and enable the SSL-VPN feature for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
        Before you create an IPsec server, make sure that no IPsec-VPN connection exists on the VPN gateway. For more information, see [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
        **CreateIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
        If the VPN gateway is in the **updating** state, the IPsec server is being created.
        If the VPN gateway is in the **active** state, the IPsec server is created.
        You cannot repeatedly call **CreateIpsecServer** within the specified period of time.
        
        @param request: CreateIpsecServerRequest
        @return: CreateIpsecServerResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_ipsec_server_with_options(request, runtime)

    async def create_ipsec_server_async(
        self,
        request: vpc_20160428_models.CreateIpsecServerRequest,
    ) -> vpc_20160428_models.CreateIpsecServerResponse:
        """
        @summary Creates an IPsec server.
        
        @description    Before you create an IPsec server, you must create a VPN gateway and enable the SSL-VPN feature for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
        Before you create an IPsec server, make sure that no IPsec-VPN connection exists on the VPN gateway. For more information, see [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
        **CreateIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
        If the VPN gateway is in the **updating** state, the IPsec server is being created.
        If the VPN gateway is in the **active** state, the IPsec server is created.
        You cannot repeatedly call **CreateIpsecServer** within the specified period of time.
        
        @param request: CreateIpsecServerRequest
        @return: CreateIpsecServerResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_ipsec_server_with_options_async(request, runtime)

    def create_ipv_4gateway_with_options(
        self,
        request: vpc_20160428_models.CreateIpv4GatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateIpv4GatewayResponse:
        """
        @summary IPv4
        
        @description    **CreateIpv4Gateway** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway:
        If the IPv4 gateway is in the **Creating** state, the IPv4 gateway is being created.
        If the IPv4 gateway is in the **Created** state, the IPv4 gateway is created.
        You cannot repeatedly call the **CreateIpv4Gateway** operation to create IPv4 gateways in a virtual private cloud (VPC) within the specified period of time.
        
        @param request: CreateIpv4GatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIpv4GatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.ipv_4gateway_description):
            query['Ipv4GatewayDescription'] = request.ipv_4gateway_description
        if not UtilClient.is_unset(request.ipv_4gateway_name):
            query['Ipv4GatewayName'] = request.ipv_4gateway_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateIpv4Gateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateIpv4GatewayResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_ipv_4gateway_with_options_async(
        self,
        request: vpc_20160428_models.CreateIpv4GatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateIpv4GatewayResponse:
        """
        @summary IPv4
        
        @description    **CreateIpv4Gateway** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway:
        If the IPv4 gateway is in the **Creating** state, the IPv4 gateway is being created.
        If the IPv4 gateway is in the **Created** state, the IPv4 gateway is created.
        You cannot repeatedly call the **CreateIpv4Gateway** operation to create IPv4 gateways in a virtual private cloud (VPC) within the specified period of time.
        
        @param request: CreateIpv4GatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIpv4GatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.ipv_4gateway_description):
            query['Ipv4GatewayDescription'] = request.ipv_4gateway_description
        if not UtilClient.is_unset(request.ipv_4gateway_name):
            query['Ipv4GatewayName'] = request.ipv_4gateway_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateIpv4Gateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateIpv4GatewayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_ipv_4gateway(
        self,
        request: vpc_20160428_models.CreateIpv4GatewayRequest,
    ) -> vpc_20160428_models.CreateIpv4GatewayResponse:
        """
        @summary IPv4
        
        @description    **CreateIpv4Gateway** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway:
        If the IPv4 gateway is in the **Creating** state, the IPv4 gateway is being created.
        If the IPv4 gateway is in the **Created** state, the IPv4 gateway is created.
        You cannot repeatedly call the **CreateIpv4Gateway** operation to create IPv4 gateways in a virtual private cloud (VPC) within the specified period of time.
        
        @param request: CreateIpv4GatewayRequest
        @return: CreateIpv4GatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_ipv_4gateway_with_options(request, runtime)

    async def create_ipv_4gateway_async(
        self,
        request: vpc_20160428_models.CreateIpv4GatewayRequest,
    ) -> vpc_20160428_models.CreateIpv4GatewayResponse:
        """
        @summary IPv4
        
        @description    **CreateIpv4Gateway** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway:
        If the IPv4 gateway is in the **Creating** state, the IPv4 gateway is being created.
        If the IPv4 gateway is in the **Created** state, the IPv4 gateway is created.
        You cannot repeatedly call the **CreateIpv4Gateway** operation to create IPv4 gateways in a virtual private cloud (VPC) within the specified period of time.
        
        @param request: CreateIpv4GatewayRequest
        @return: CreateIpv4GatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_ipv_4gateway_with_options_async(request, runtime)

    def create_ipv_6egress_only_rule_with_options(
        self,
        request: vpc_20160428_models.CreateIpv6EgressOnlyRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateIpv6EgressOnlyRuleResponse:
        """
        @summary You can call CreateIpv6EgressOnlyRule to create egress-only rules to enable ECS instances in VPCs that have IPv6 enabled to access IPv6 clients. However, IPv6 clients cannot access the ECS instances over the Internet.
        
        @description    **CreateIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and creates the rule in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
        If the egress-only rule is in the **Creating** state, the egress-only rule is being created.
        If the egress-only rule is in the **Created** state, the egress-only rule is created.
        You cannot repeatedly call the **CreateIpv6EgressOnlyRule** operation to add egress-only rules for an IPv6 address within the specified period of time.
        
        @param request: CreateIpv6EgressOnlyRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIpv6EgressOnlyRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.ipv_6gateway_id):
            query['Ipv6GatewayId'] = request.ipv_6gateway_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateIpv6EgressOnlyRule',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateIpv6EgressOnlyRuleResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_ipv_6egress_only_rule_with_options_async(
        self,
        request: vpc_20160428_models.CreateIpv6EgressOnlyRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateIpv6EgressOnlyRuleResponse:
        """
        @summary You can call CreateIpv6EgressOnlyRule to create egress-only rules to enable ECS instances in VPCs that have IPv6 enabled to access IPv6 clients. However, IPv6 clients cannot access the ECS instances over the Internet.
        
        @description    **CreateIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and creates the rule in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
        If the egress-only rule is in the **Creating** state, the egress-only rule is being created.
        If the egress-only rule is in the **Created** state, the egress-only rule is created.
        You cannot repeatedly call the **CreateIpv6EgressOnlyRule** operation to add egress-only rules for an IPv6 address within the specified period of time.
        
        @param request: CreateIpv6EgressOnlyRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIpv6EgressOnlyRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.ipv_6gateway_id):
            query['Ipv6GatewayId'] = request.ipv_6gateway_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateIpv6EgressOnlyRule',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateIpv6EgressOnlyRuleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_ipv_6egress_only_rule(
        self,
        request: vpc_20160428_models.CreateIpv6EgressOnlyRuleRequest,
    ) -> vpc_20160428_models.CreateIpv6EgressOnlyRuleResponse:
        """
        @summary You can call CreateIpv6EgressOnlyRule to create egress-only rules to enable ECS instances in VPCs that have IPv6 enabled to access IPv6 clients. However, IPv6 clients cannot access the ECS instances over the Internet.
        
        @description    **CreateIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and creates the rule in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
        If the egress-only rule is in the **Creating** state, the egress-only rule is being created.
        If the egress-only rule is in the **Created** state, the egress-only rule is created.
        You cannot repeatedly call the **CreateIpv6EgressOnlyRule** operation to add egress-only rules for an IPv6 address within the specified period of time.
        
        @param request: CreateIpv6EgressOnlyRuleRequest
        @return: CreateIpv6EgressOnlyRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_ipv_6egress_only_rule_with_options(request, runtime)

    async def create_ipv_6egress_only_rule_async(
        self,
        request: vpc_20160428_models.CreateIpv6EgressOnlyRuleRequest,
    ) -> vpc_20160428_models.CreateIpv6EgressOnlyRuleResponse:
        """
        @summary You can call CreateIpv6EgressOnlyRule to create egress-only rules to enable ECS instances in VPCs that have IPv6 enabled to access IPv6 clients. However, IPv6 clients cannot access the ECS instances over the Internet.
        
        @description    **CreateIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and creates the rule in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
        If the egress-only rule is in the **Creating** state, the egress-only rule is being created.
        If the egress-only rule is in the **Created** state, the egress-only rule is created.
        You cannot repeatedly call the **CreateIpv6EgressOnlyRule** operation to add egress-only rules for an IPv6 address within the specified period of time.
        
        @param request: CreateIpv6EgressOnlyRuleRequest
        @return: CreateIpv6EgressOnlyRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_ipv_6egress_only_rule_with_options_async(request, runtime)

    def create_ipv_6gateway_with_options(
        self,
        request: vpc_20160428_models.CreateIpv6GatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateIpv6GatewayResponse:
        """
        @summary IPv6 gateways are used to control the IPv6 traffic of virtual private clouds (VPCs). You can call the CreateIpv6Gateway operation to create IPv6 gateways.
        
        @description    **CreateIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task.
        If the IPv6 gateway is in the **Creating** state, the IPv6 gateway is being created.
        If the IPv6 gateway is in the **Created** state, the IPv6 gateway is created.
        You cannot repeatedly call the **CreateIpv6Gateway** operation within a specific time period.
        
        @param request: CreateIpv6GatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIpv6GatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateIpv6Gateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateIpv6GatewayResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_ipv_6gateway_with_options_async(
        self,
        request: vpc_20160428_models.CreateIpv6GatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateIpv6GatewayResponse:
        """
        @summary IPv6 gateways are used to control the IPv6 traffic of virtual private clouds (VPCs). You can call the CreateIpv6Gateway operation to create IPv6 gateways.
        
        @description    **CreateIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task.
        If the IPv6 gateway is in the **Creating** state, the IPv6 gateway is being created.
        If the IPv6 gateway is in the **Created** state, the IPv6 gateway is created.
        You cannot repeatedly call the **CreateIpv6Gateway** operation within a specific time period.
        
        @param request: CreateIpv6GatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIpv6GatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateIpv6Gateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateIpv6GatewayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_ipv_6gateway(
        self,
        request: vpc_20160428_models.CreateIpv6GatewayRequest,
    ) -> vpc_20160428_models.CreateIpv6GatewayResponse:
        """
        @summary IPv6 gateways are used to control the IPv6 traffic of virtual private clouds (VPCs). You can call the CreateIpv6Gateway operation to create IPv6 gateways.
        
        @description    **CreateIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task.
        If the IPv6 gateway is in the **Creating** state, the IPv6 gateway is being created.
        If the IPv6 gateway is in the **Created** state, the IPv6 gateway is created.
        You cannot repeatedly call the **CreateIpv6Gateway** operation within a specific time period.
        
        @param request: CreateIpv6GatewayRequest
        @return: CreateIpv6GatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_ipv_6gateway_with_options(request, runtime)

    async def create_ipv_6gateway_async(
        self,
        request: vpc_20160428_models.CreateIpv6GatewayRequest,
    ) -> vpc_20160428_models.CreateIpv6GatewayResponse:
        """
        @summary IPv6 gateways are used to control the IPv6 traffic of virtual private clouds (VPCs). You can call the CreateIpv6Gateway operation to create IPv6 gateways.
        
        @description    **CreateIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task.
        If the IPv6 gateway is in the **Creating** state, the IPv6 gateway is being created.
        If the IPv6 gateway is in the **Created** state, the IPv6 gateway is created.
        You cannot repeatedly call the **CreateIpv6Gateway** operation within a specific time period.
        
        @param request: CreateIpv6GatewayRequest
        @return: CreateIpv6GatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_ipv_6gateway_with_options_async(request, runtime)

    def create_nat_gateway_with_options(
        self,
        request: vpc_20160428_models.CreateNatGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateNatGatewayResponse:
        """
        @summary Creates an enhanced Internet NAT gateway or a Virtual Private Cloud (VPC) NAT gateway.
        
        @description ## [](#)
        Before you call this operation, take note of the following items:
        The first time you create a NAT gateway, the system automatically creates the service-linked role AliyunServiceRoleForNatgw. Then, the system attaches the permission policy AliyunServiceRolePolicyForNatgw to the role. This allows the NAT gateway to access other resources on Alibaba Cloud. For more information, see [Service-linked roles](https://help.aliyun.com/document_detail/174251.html).
        After you create an enhanced Internet NAT gateway, a route entry is automatically added to the route table of the VPC. The destination CIDR block of the route entry is 0.0.0.0/0 and the next hop is the NAT gateway. This ensures that traffic is routed to the NAT gateway.
        **CreateNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) operation to query the status of the task.
        If a NAT gateway is in the **Creating** state, the NAT gateway is being created. In this case, you can query the NAT gateway but cannot perform other operations.
        If a NAT gateway is in the **Available** state, the NAT gateway is created.
        It takes 1 to 3 minutes to create a NAT gateway.
        You cannot repeatedly call the **CreateNatGateway** operation within a specific period of time.
        
        @param request: CreateNatGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateNatGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.duration):
            query['Duration'] = request.duration
        if not UtilClient.is_unset(request.eip_bind_mode):
            query['EipBindMode'] = request.eip_bind_mode
        if not UtilClient.is_unset(request.icmp_reply_enabled):
            query['IcmpReplyEnabled'] = request.icmp_reply_enabled
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.nat_type):
            query['NatType'] = request.nat_type
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pricing_cycle):
            query['PricingCycle'] = request.pricing_cycle
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_protection_enabled):
            query['SecurityProtectionEnabled'] = request.security_protection_enabled
        if not UtilClient.is_unset(request.spec):
            query['Spec'] = request.spec
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateNatGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateNatGatewayResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_nat_gateway_with_options_async(
        self,
        request: vpc_20160428_models.CreateNatGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateNatGatewayResponse:
        """
        @summary Creates an enhanced Internet NAT gateway or a Virtual Private Cloud (VPC) NAT gateway.
        
        @description ## [](#)
        Before you call this operation, take note of the following items:
        The first time you create a NAT gateway, the system automatically creates the service-linked role AliyunServiceRoleForNatgw. Then, the system attaches the permission policy AliyunServiceRolePolicyForNatgw to the role. This allows the NAT gateway to access other resources on Alibaba Cloud. For more information, see [Service-linked roles](https://help.aliyun.com/document_detail/174251.html).
        After you create an enhanced Internet NAT gateway, a route entry is automatically added to the route table of the VPC. The destination CIDR block of the route entry is 0.0.0.0/0 and the next hop is the NAT gateway. This ensures that traffic is routed to the NAT gateway.
        **CreateNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) operation to query the status of the task.
        If a NAT gateway is in the **Creating** state, the NAT gateway is being created. In this case, you can query the NAT gateway but cannot perform other operations.
        If a NAT gateway is in the **Available** state, the NAT gateway is created.
        It takes 1 to 3 minutes to create a NAT gateway.
        You cannot repeatedly call the **CreateNatGateway** operation within a specific period of time.
        
        @param request: CreateNatGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateNatGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.duration):
            query['Duration'] = request.duration
        if not UtilClient.is_unset(request.eip_bind_mode):
            query['EipBindMode'] = request.eip_bind_mode
        if not UtilClient.is_unset(request.icmp_reply_enabled):
            query['IcmpReplyEnabled'] = request.icmp_reply_enabled
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.nat_type):
            query['NatType'] = request.nat_type
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pricing_cycle):
            query['PricingCycle'] = request.pricing_cycle
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_protection_enabled):
            query['SecurityProtectionEnabled'] = request.security_protection_enabled
        if not UtilClient.is_unset(request.spec):
            query['Spec'] = request.spec
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateNatGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateNatGatewayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_nat_gateway(
        self,
        request: vpc_20160428_models.CreateNatGatewayRequest,
    ) -> vpc_20160428_models.CreateNatGatewayResponse:
        """
        @summary Creates an enhanced Internet NAT gateway or a Virtual Private Cloud (VPC) NAT gateway.
        
        @description ## [](#)
        Before you call this operation, take note of the following items:
        The first time you create a NAT gateway, the system automatically creates the service-linked role AliyunServiceRoleForNatgw. Then, the system attaches the permission policy AliyunServiceRolePolicyForNatgw to the role. This allows the NAT gateway to access other resources on Alibaba Cloud. For more information, see [Service-linked roles](https://help.aliyun.com/document_detail/174251.html).
        After you create an enhanced Internet NAT gateway, a route entry is automatically added to the route table of the VPC. The destination CIDR block of the route entry is 0.0.0.0/0 and the next hop is the NAT gateway. This ensures that traffic is routed to the NAT gateway.
        **CreateNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) operation to query the status of the task.
        If a NAT gateway is in the **Creating** state, the NAT gateway is being created. In this case, you can query the NAT gateway but cannot perform other operations.
        If a NAT gateway is in the **Available** state, the NAT gateway is created.
        It takes 1 to 3 minutes to create a NAT gateway.
        You cannot repeatedly call the **CreateNatGateway** operation within a specific period of time.
        
        @param request: CreateNatGatewayRequest
        @return: CreateNatGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_nat_gateway_with_options(request, runtime)

    async def create_nat_gateway_async(
        self,
        request: vpc_20160428_models.CreateNatGatewayRequest,
    ) -> vpc_20160428_models.CreateNatGatewayResponse:
        """
        @summary Creates an enhanced Internet NAT gateway or a Virtual Private Cloud (VPC) NAT gateway.
        
        @description ## [](#)
        Before you call this operation, take note of the following items:
        The first time you create a NAT gateway, the system automatically creates the service-linked role AliyunServiceRoleForNatgw. Then, the system attaches the permission policy AliyunServiceRolePolicyForNatgw to the role. This allows the NAT gateway to access other resources on Alibaba Cloud. For more information, see [Service-linked roles](https://help.aliyun.com/document_detail/174251.html).
        After you create an enhanced Internet NAT gateway, a route entry is automatically added to the route table of the VPC. The destination CIDR block of the route entry is 0.0.0.0/0 and the next hop is the NAT gateway. This ensures that traffic is routed to the NAT gateway.
        **CreateNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) operation to query the status of the task.
        If a NAT gateway is in the **Creating** state, the NAT gateway is being created. In this case, you can query the NAT gateway but cannot perform other operations.
        If a NAT gateway is in the **Available** state, the NAT gateway is created.
        It takes 1 to 3 minutes to create a NAT gateway.
        You cannot repeatedly call the **CreateNatGateway** operation within a specific period of time.
        
        @param request: CreateNatGatewayRequest
        @return: CreateNatGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_nat_gateway_with_options_async(request, runtime)

    def create_nat_ip_with_options(
        self,
        request: vpc_20160428_models.CreateNatIpRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateNatIpResponse:
        """
        @summary Creates a NAT IP address.
        
        @description ## [](#)
        *CreateNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/287000.html) operation to query the status of the task.
        If a NAT IP address is in the **Creating** state, the NAT IP address is being created. In this case, you can only query the NAT IP address and cannot perform other operations.
        If a NAT IP address is in the **Available** state, the NAT IP address is created.
        You cannot repeatedly call the *CreateNatIp** operation to create a NAT IP address within a specific period of time.
        
        @param request: CreateNatIpRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateNatIpResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.nat_ip):
            query['NatIp'] = request.nat_ip
        if not UtilClient.is_unset(request.nat_ip_cidr):
            query['NatIpCidr'] = request.nat_ip_cidr
        if not UtilClient.is_unset(request.nat_ip_description):
            query['NatIpDescription'] = request.nat_ip_description
        if not UtilClient.is_unset(request.nat_ip_name):
            query['NatIpName'] = request.nat_ip_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateNatIp',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateNatIpResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_nat_ip_with_options_async(
        self,
        request: vpc_20160428_models.CreateNatIpRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateNatIpResponse:
        """
        @summary Creates a NAT IP address.
        
        @description ## [](#)
        *CreateNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/287000.html) operation to query the status of the task.
        If a NAT IP address is in the **Creating** state, the NAT IP address is being created. In this case, you can only query the NAT IP address and cannot perform other operations.
        If a NAT IP address is in the **Available** state, the NAT IP address is created.
        You cannot repeatedly call the *CreateNatIp** operation to create a NAT IP address within a specific period of time.
        
        @param request: CreateNatIpRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateNatIpResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.nat_ip):
            query['NatIp'] = request.nat_ip
        if not UtilClient.is_unset(request.nat_ip_cidr):
            query['NatIpCidr'] = request.nat_ip_cidr
        if not UtilClient.is_unset(request.nat_ip_description):
            query['NatIpDescription'] = request.nat_ip_description
        if not UtilClient.is_unset(request.nat_ip_name):
            query['NatIpName'] = request.nat_ip_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateNatIp',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateNatIpResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_nat_ip(
        self,
        request: vpc_20160428_models.CreateNatIpRequest,
    ) -> vpc_20160428_models.CreateNatIpResponse:
        """
        @summary Creates a NAT IP address.
        
        @description ## [](#)
        *CreateNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/287000.html) operation to query the status of the task.
        If a NAT IP address is in the **Creating** state, the NAT IP address is being created. In this case, you can only query the NAT IP address and cannot perform other operations.
        If a NAT IP address is in the **Available** state, the NAT IP address is created.
        You cannot repeatedly call the *CreateNatIp** operation to create a NAT IP address within a specific period of time.
        
        @param request: CreateNatIpRequest
        @return: CreateNatIpResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_nat_ip_with_options(request, runtime)

    async def create_nat_ip_async(
        self,
        request: vpc_20160428_models.CreateNatIpRequest,
    ) -> vpc_20160428_models.CreateNatIpResponse:
        """
        @summary Creates a NAT IP address.
        
        @description ## [](#)
        *CreateNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/287000.html) operation to query the status of the task.
        If a NAT IP address is in the **Creating** state, the NAT IP address is being created. In this case, you can only query the NAT IP address and cannot perform other operations.
        If a NAT IP address is in the **Available** state, the NAT IP address is created.
        You cannot repeatedly call the *CreateNatIp** operation to create a NAT IP address within a specific period of time.
        
        @param request: CreateNatIpRequest
        @return: CreateNatIpResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_nat_ip_with_options_async(request, runtime)

    def create_nat_ip_cidr_with_options(
        self,
        request: vpc_20160428_models.CreateNatIpCidrRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateNatIpCidrResponse:
        """
        @summary Creates a NAT CIDR block.
        
        @description ## [](#)Description
        You cannot repeatedly call the *CreateNatIpCidr** operation to create a NAT CIDR block within the specified period of time.
        
        @param request: CreateNatIpCidrRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateNatIpCidrResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.nat_ip_cidr):
            query['NatIpCidr'] = request.nat_ip_cidr
        if not UtilClient.is_unset(request.nat_ip_cidr_description):
            query['NatIpCidrDescription'] = request.nat_ip_cidr_description
        if not UtilClient.is_unset(request.nat_ip_cidr_name):
            query['NatIpCidrName'] = request.nat_ip_cidr_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateNatIpCidr',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateNatIpCidrResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_nat_ip_cidr_with_options_async(
        self,
        request: vpc_20160428_models.CreateNatIpCidrRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateNatIpCidrResponse:
        """
        @summary Creates a NAT CIDR block.
        
        @description ## [](#)Description
        You cannot repeatedly call the *CreateNatIpCidr** operation to create a NAT CIDR block within the specified period of time.
        
        @param request: CreateNatIpCidrRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateNatIpCidrResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.nat_ip_cidr):
            query['NatIpCidr'] = request.nat_ip_cidr
        if not UtilClient.is_unset(request.nat_ip_cidr_description):
            query['NatIpCidrDescription'] = request.nat_ip_cidr_description
        if not UtilClient.is_unset(request.nat_ip_cidr_name):
            query['NatIpCidrName'] = request.nat_ip_cidr_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateNatIpCidr',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateNatIpCidrResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_nat_ip_cidr(
        self,
        request: vpc_20160428_models.CreateNatIpCidrRequest,
    ) -> vpc_20160428_models.CreateNatIpCidrResponse:
        """
        @summary Creates a NAT CIDR block.
        
        @description ## [](#)Description
        You cannot repeatedly call the *CreateNatIpCidr** operation to create a NAT CIDR block within the specified period of time.
        
        @param request: CreateNatIpCidrRequest
        @return: CreateNatIpCidrResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_nat_ip_cidr_with_options(request, runtime)

    async def create_nat_ip_cidr_async(
        self,
        request: vpc_20160428_models.CreateNatIpCidrRequest,
    ) -> vpc_20160428_models.CreateNatIpCidrResponse:
        """
        @summary Creates a NAT CIDR block.
        
        @description ## [](#)Description
        You cannot repeatedly call the *CreateNatIpCidr** operation to create a NAT CIDR block within the specified period of time.
        
        @param request: CreateNatIpCidrRequest
        @return: CreateNatIpCidrResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_nat_ip_cidr_with_options_async(request, runtime)

    def create_network_acl_with_options(
        self,
        request: vpc_20160428_models.CreateNetworkAclRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateNetworkAclResponse:
        """
        @summary Creates a network ACL.
        
        @param request: CreateNetworkAclRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateNetworkAclResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.network_acl_name):
            query['NetworkAclName'] = request.network_acl_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateNetworkAcl',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateNetworkAclResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_network_acl_with_options_async(
        self,
        request: vpc_20160428_models.CreateNetworkAclRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateNetworkAclResponse:
        """
        @summary Creates a network ACL.
        
        @param request: CreateNetworkAclRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateNetworkAclResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.network_acl_name):
            query['NetworkAclName'] = request.network_acl_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateNetworkAcl',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateNetworkAclResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_network_acl(
        self,
        request: vpc_20160428_models.CreateNetworkAclRequest,
    ) -> vpc_20160428_models.CreateNetworkAclResponse:
        """
        @summary Creates a network ACL.
        
        @param request: CreateNetworkAclRequest
        @return: CreateNetworkAclResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_network_acl_with_options(request, runtime)

    async def create_network_acl_async(
        self,
        request: vpc_20160428_models.CreateNetworkAclRequest,
    ) -> vpc_20160428_models.CreateNetworkAclResponse:
        """
        @summary Creates a network ACL.
        
        @param request: CreateNetworkAclRequest
        @return: CreateNetworkAclResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_network_acl_with_options_async(request, runtime)

    def create_physical_connection_with_options(
        self,
        request: vpc_20160428_models.CreatePhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreatePhysicalConnectionResponse:
        """
        @summary Applies for an Express Connect circuit.
        
        @description You can apply for a dedicated Express Connect circuit for yourself or create a hosted connection for a tenant. After your application is approved, the Express Connect circuit changes to the *Initial** state. You can contact the connectivity provider to start construction.
        When you call this operation, take note of the following limits:
        If your Alibaba Cloud account has more than five Express Connect circuits that are not in the **Enabled** state, you cannot apply for another Express Connect circuit.
        If your Alibaba Cloud account has an Express Connect circuit with overdue payments, you cannot apply for another Express Connect circuit.
        
        @param request: CreatePhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.access_point_id):
            query['AccessPointId'] = request.access_point_id
        if not UtilClient.is_unset(request.circuit_code):
            query['CircuitCode'] = request.circuit_code
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.device_advanced_capacity):
            query['DeviceAdvancedCapacity'] = request.device_advanced_capacity
        if not UtilClient.is_unset(request.line_operator):
            query['LineOperator'] = request.line_operator
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_location):
            query['PeerLocation'] = request.peer_location
        if not UtilClient.is_unset(request.port_type):
            query['PortType'] = request.port_type
        if not UtilClient.is_unset(request.redundant_physical_connection_id):
            query['RedundantPhysicalConnectionId'] = request.redundant_physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.bandwidth):
            query['bandwidth'] = request.bandwidth
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreatePhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreatePhysicalConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_physical_connection_with_options_async(
        self,
        request: vpc_20160428_models.CreatePhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreatePhysicalConnectionResponse:
        """
        @summary Applies for an Express Connect circuit.
        
        @description You can apply for a dedicated Express Connect circuit for yourself or create a hosted connection for a tenant. After your application is approved, the Express Connect circuit changes to the *Initial** state. You can contact the connectivity provider to start construction.
        When you call this operation, take note of the following limits:
        If your Alibaba Cloud account has more than five Express Connect circuits that are not in the **Enabled** state, you cannot apply for another Express Connect circuit.
        If your Alibaba Cloud account has an Express Connect circuit with overdue payments, you cannot apply for another Express Connect circuit.
        
        @param request: CreatePhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.access_point_id):
            query['AccessPointId'] = request.access_point_id
        if not UtilClient.is_unset(request.circuit_code):
            query['CircuitCode'] = request.circuit_code
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.device_advanced_capacity):
            query['DeviceAdvancedCapacity'] = request.device_advanced_capacity
        if not UtilClient.is_unset(request.line_operator):
            query['LineOperator'] = request.line_operator
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_location):
            query['PeerLocation'] = request.peer_location
        if not UtilClient.is_unset(request.port_type):
            query['PortType'] = request.port_type
        if not UtilClient.is_unset(request.redundant_physical_connection_id):
            query['RedundantPhysicalConnectionId'] = request.redundant_physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.bandwidth):
            query['bandwidth'] = request.bandwidth
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreatePhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreatePhysicalConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_physical_connection(
        self,
        request: vpc_20160428_models.CreatePhysicalConnectionRequest,
    ) -> vpc_20160428_models.CreatePhysicalConnectionResponse:
        """
        @summary Applies for an Express Connect circuit.
        
        @description You can apply for a dedicated Express Connect circuit for yourself or create a hosted connection for a tenant. After your application is approved, the Express Connect circuit changes to the *Initial** state. You can contact the connectivity provider to start construction.
        When you call this operation, take note of the following limits:
        If your Alibaba Cloud account has more than five Express Connect circuits that are not in the **Enabled** state, you cannot apply for another Express Connect circuit.
        If your Alibaba Cloud account has an Express Connect circuit with overdue payments, you cannot apply for another Express Connect circuit.
        
        @param request: CreatePhysicalConnectionRequest
        @return: CreatePhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_physical_connection_with_options(request, runtime)

    async def create_physical_connection_async(
        self,
        request: vpc_20160428_models.CreatePhysicalConnectionRequest,
    ) -> vpc_20160428_models.CreatePhysicalConnectionResponse:
        """
        @summary Applies for an Express Connect circuit.
        
        @description You can apply for a dedicated Express Connect circuit for yourself or create a hosted connection for a tenant. After your application is approved, the Express Connect circuit changes to the *Initial** state. You can contact the connectivity provider to start construction.
        When you call this operation, take note of the following limits:
        If your Alibaba Cloud account has more than five Express Connect circuits that are not in the **Enabled** state, you cannot apply for another Express Connect circuit.
        If your Alibaba Cloud account has an Express Connect circuit with overdue payments, you cannot apply for another Express Connect circuit.
        
        @param request: CreatePhysicalConnectionRequest
        @return: CreatePhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_physical_connection_with_options_async(request, runtime)

    def create_physical_connection_occupancy_order_with_options(
        self,
        request: vpc_20160428_models.CreatePhysicalConnectionOccupancyOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreatePhysicalConnectionOccupancyOrderResponse:
        """
        @summary Creates an order for resource usage fees.
        
        @description >  You can call this operation only when the Express Connect circuit is in the *Complete** state.
        
        @param request: CreatePhysicalConnectionOccupancyOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePhysicalConnectionOccupancyOrderResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.pricing_cycle):
            query['PricingCycle'] = request.pricing_cycle
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreatePhysicalConnectionOccupancyOrder',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreatePhysicalConnectionOccupancyOrderResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_physical_connection_occupancy_order_with_options_async(
        self,
        request: vpc_20160428_models.CreatePhysicalConnectionOccupancyOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreatePhysicalConnectionOccupancyOrderResponse:
        """
        @summary Creates an order for resource usage fees.
        
        @description >  You can call this operation only when the Express Connect circuit is in the *Complete** state.
        
        @param request: CreatePhysicalConnectionOccupancyOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePhysicalConnectionOccupancyOrderResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.pricing_cycle):
            query['PricingCycle'] = request.pricing_cycle
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreatePhysicalConnectionOccupancyOrder',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreatePhysicalConnectionOccupancyOrderResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_physical_connection_occupancy_order(
        self,
        request: vpc_20160428_models.CreatePhysicalConnectionOccupancyOrderRequest,
    ) -> vpc_20160428_models.CreatePhysicalConnectionOccupancyOrderResponse:
        """
        @summary Creates an order for resource usage fees.
        
        @description >  You can call this operation only when the Express Connect circuit is in the *Complete** state.
        
        @param request: CreatePhysicalConnectionOccupancyOrderRequest
        @return: CreatePhysicalConnectionOccupancyOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_physical_connection_occupancy_order_with_options(request, runtime)

    async def create_physical_connection_occupancy_order_async(
        self,
        request: vpc_20160428_models.CreatePhysicalConnectionOccupancyOrderRequest,
    ) -> vpc_20160428_models.CreatePhysicalConnectionOccupancyOrderResponse:
        """
        @summary Creates an order for resource usage fees.
        
        @description >  You can call this operation only when the Express Connect circuit is in the *Complete** state.
        
        @param request: CreatePhysicalConnectionOccupancyOrderRequest
        @return: CreatePhysicalConnectionOccupancyOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_physical_connection_occupancy_order_with_options_async(request, runtime)

    def create_physical_connection_setup_order_with_options(
        self,
        request: vpc_20160428_models.CreatePhysicalConnectionSetupOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreatePhysicalConnectionSetupOrderResponse:
        """
        @summary 
        
        @param request: CreatePhysicalConnectionSetupOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePhysicalConnectionSetupOrderResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.access_point_id):
            query['AccessPointId'] = request.access_point_id
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.line_operator):
            query['LineOperator'] = request.line_operator
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port_type):
            query['PortType'] = request.port_type
        if not UtilClient.is_unset(request.redundant_physical_connection_id):
            query['RedundantPhysicalConnectionId'] = request.redundant_physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreatePhysicalConnectionSetupOrder',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreatePhysicalConnectionSetupOrderResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_physical_connection_setup_order_with_options_async(
        self,
        request: vpc_20160428_models.CreatePhysicalConnectionSetupOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreatePhysicalConnectionSetupOrderResponse:
        """
        @summary 
        
        @param request: CreatePhysicalConnectionSetupOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePhysicalConnectionSetupOrderResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.access_point_id):
            query['AccessPointId'] = request.access_point_id
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.line_operator):
            query['LineOperator'] = request.line_operator
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port_type):
            query['PortType'] = request.port_type
        if not UtilClient.is_unset(request.redundant_physical_connection_id):
            query['RedundantPhysicalConnectionId'] = request.redundant_physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreatePhysicalConnectionSetupOrder',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreatePhysicalConnectionSetupOrderResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_physical_connection_setup_order(
        self,
        request: vpc_20160428_models.CreatePhysicalConnectionSetupOrderRequest,
    ) -> vpc_20160428_models.CreatePhysicalConnectionSetupOrderResponse:
        """
        @summary 
        
        @param request: CreatePhysicalConnectionSetupOrderRequest
        @return: CreatePhysicalConnectionSetupOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_physical_connection_setup_order_with_options(request, runtime)

    async def create_physical_connection_setup_order_async(
        self,
        request: vpc_20160428_models.CreatePhysicalConnectionSetupOrderRequest,
    ) -> vpc_20160428_models.CreatePhysicalConnectionSetupOrderResponse:
        """
        @summary 
        
        @param request: CreatePhysicalConnectionSetupOrderRequest
        @return: CreatePhysicalConnectionSetupOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_physical_connection_setup_order_with_options_async(request, runtime)

    def create_public_ip_address_pool_with_options(
        self,
        request: vpc_20160428_models.CreatePublicIpAddressPoolRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreatePublicIpAddressPoolResponse:
        """
        @summary Creates an IP address pool.
        
        @description By default, the IP address pool feature is unavailable. You can apply for the privilege to use the *IP address pool feature** in the Quota Center console. For more information, see the "Request a quota increase in the Quota Center console" section in the [Manage EIP quotas](https://help.aliyun.com/document_detail/108213.html) topic.
        
        @param request: CreatePublicIpAddressPoolRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePublicIpAddressPoolResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.biz_type):
            query['BizType'] = request.biz_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.isp):
            query['Isp'] = request.isp
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_protection_types):
            query['SecurityProtectionTypes'] = request.security_protection_types
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zones):
            query['Zones'] = request.zones
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreatePublicIpAddressPool',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreatePublicIpAddressPoolResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_public_ip_address_pool_with_options_async(
        self,
        request: vpc_20160428_models.CreatePublicIpAddressPoolRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreatePublicIpAddressPoolResponse:
        """
        @summary Creates an IP address pool.
        
        @description By default, the IP address pool feature is unavailable. You can apply for the privilege to use the *IP address pool feature** in the Quota Center console. For more information, see the "Request a quota increase in the Quota Center console" section in the [Manage EIP quotas](https://help.aliyun.com/document_detail/108213.html) topic.
        
        @param request: CreatePublicIpAddressPoolRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePublicIpAddressPoolResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.biz_type):
            query['BizType'] = request.biz_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.isp):
            query['Isp'] = request.isp
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_protection_types):
            query['SecurityProtectionTypes'] = request.security_protection_types
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.zones):
            query['Zones'] = request.zones
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreatePublicIpAddressPool',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreatePublicIpAddressPoolResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_public_ip_address_pool(
        self,
        request: vpc_20160428_models.CreatePublicIpAddressPoolRequest,
    ) -> vpc_20160428_models.CreatePublicIpAddressPoolResponse:
        """
        @summary Creates an IP address pool.
        
        @description By default, the IP address pool feature is unavailable. You can apply for the privilege to use the *IP address pool feature** in the Quota Center console. For more information, see the "Request a quota increase in the Quota Center console" section in the [Manage EIP quotas](https://help.aliyun.com/document_detail/108213.html) topic.
        
        @param request: CreatePublicIpAddressPoolRequest
        @return: CreatePublicIpAddressPoolResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_public_ip_address_pool_with_options(request, runtime)

    async def create_public_ip_address_pool_async(
        self,
        request: vpc_20160428_models.CreatePublicIpAddressPoolRequest,
    ) -> vpc_20160428_models.CreatePublicIpAddressPoolResponse:
        """
        @summary Creates an IP address pool.
        
        @description By default, the IP address pool feature is unavailable. You can apply for the privilege to use the *IP address pool feature** in the Quota Center console. For more information, see the "Request a quota increase in the Quota Center console" section in the [Manage EIP quotas](https://help.aliyun.com/document_detail/108213.html) topic.
        
        @param request: CreatePublicIpAddressPoolRequest
        @return: CreatePublicIpAddressPoolResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_public_ip_address_pool_with_options_async(request, runtime)

    def create_route_entries_with_options(
        self,
        request: vpc_20160428_models.CreateRouteEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateRouteEntriesResponse:
        """
        @summary Adds custom route entries to the route table of a vRouter in a virtual private cloud (VPC).
        
        @description ## [](#)References
        **CreateRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
        If the route entry is in the **Creating** state, the route entry is being created.
        If the route entry is in the **Created** state, the route entry is created.
        You cannot repeatedly call the **CreateRouteEntries** operation to create the same route entry within the specified period of time.
        *When you call this operation to add custom route entries to the route table of a vRouter, take note of the following items:**\
        A route table can contain up to 200 custom route entries.
        The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be the same as or overlap with the CIDR block of a vSwitch in the VPC.
        The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or its subnets.
        The destination CIDR blocks (**DstCidrBlock**) of route entries in the same route table must be unique.
        If you do not include the mask length when you specify the destination CIDR block (**DstCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
        Multiple custom route entries can point to the same next hop (**NextHop**).
        The next hop (**NextHop**) of a custom route entry must belong to the same VPC as the route table.
        
        @param request: CreateRouteEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRouteEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_entries):
            query['RouteEntries'] = request.route_entries
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateRouteEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateRouteEntriesResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_route_entries_with_options_async(
        self,
        request: vpc_20160428_models.CreateRouteEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateRouteEntriesResponse:
        """
        @summary Adds custom route entries to the route table of a vRouter in a virtual private cloud (VPC).
        
        @description ## [](#)References
        **CreateRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
        If the route entry is in the **Creating** state, the route entry is being created.
        If the route entry is in the **Created** state, the route entry is created.
        You cannot repeatedly call the **CreateRouteEntries** operation to create the same route entry within the specified period of time.
        *When you call this operation to add custom route entries to the route table of a vRouter, take note of the following items:**\
        A route table can contain up to 200 custom route entries.
        The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be the same as or overlap with the CIDR block of a vSwitch in the VPC.
        The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or its subnets.
        The destination CIDR blocks (**DstCidrBlock**) of route entries in the same route table must be unique.
        If you do not include the mask length when you specify the destination CIDR block (**DstCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
        Multiple custom route entries can point to the same next hop (**NextHop**).
        The next hop (**NextHop**) of a custom route entry must belong to the same VPC as the route table.
        
        @param request: CreateRouteEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRouteEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_entries):
            query['RouteEntries'] = request.route_entries
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateRouteEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateRouteEntriesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_route_entries(
        self,
        request: vpc_20160428_models.CreateRouteEntriesRequest,
    ) -> vpc_20160428_models.CreateRouteEntriesResponse:
        """
        @summary Adds custom route entries to the route table of a vRouter in a virtual private cloud (VPC).
        
        @description ## [](#)References
        **CreateRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
        If the route entry is in the **Creating** state, the route entry is being created.
        If the route entry is in the **Created** state, the route entry is created.
        You cannot repeatedly call the **CreateRouteEntries** operation to create the same route entry within the specified period of time.
        *When you call this operation to add custom route entries to the route table of a vRouter, take note of the following items:**\
        A route table can contain up to 200 custom route entries.
        The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be the same as or overlap with the CIDR block of a vSwitch in the VPC.
        The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or its subnets.
        The destination CIDR blocks (**DstCidrBlock**) of route entries in the same route table must be unique.
        If you do not include the mask length when you specify the destination CIDR block (**DstCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
        Multiple custom route entries can point to the same next hop (**NextHop**).
        The next hop (**NextHop**) of a custom route entry must belong to the same VPC as the route table.
        
        @param request: CreateRouteEntriesRequest
        @return: CreateRouteEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_route_entries_with_options(request, runtime)

    async def create_route_entries_async(
        self,
        request: vpc_20160428_models.CreateRouteEntriesRequest,
    ) -> vpc_20160428_models.CreateRouteEntriesResponse:
        """
        @summary Adds custom route entries to the route table of a vRouter in a virtual private cloud (VPC).
        
        @description ## [](#)References
        **CreateRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
        If the route entry is in the **Creating** state, the route entry is being created.
        If the route entry is in the **Created** state, the route entry is created.
        You cannot repeatedly call the **CreateRouteEntries** operation to create the same route entry within the specified period of time.
        *When you call this operation to add custom route entries to the route table of a vRouter, take note of the following items:**\
        A route table can contain up to 200 custom route entries.
        The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be the same as or overlap with the CIDR block of a vSwitch in the VPC.
        The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or its subnets.
        The destination CIDR blocks (**DstCidrBlock**) of route entries in the same route table must be unique.
        If you do not include the mask length when you specify the destination CIDR block (**DstCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
        Multiple custom route entries can point to the same next hop (**NextHop**).
        The next hop (**NextHop**) of a custom route entry must belong to the same VPC as the route table.
        
        @param request: CreateRouteEntriesRequest
        @return: CreateRouteEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_route_entries_with_options_async(request, runtime)

    def create_route_entry_with_options(
        self,
        request: vpc_20160428_models.CreateRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateRouteEntryResponse:
        """
        @summary Creates a custom route entry in the route table of a VRouter or virtual border router (VBR).
        
        @description    **CreateRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task:
        If a route is in the **Creating** state, the route is being added.
        If a route is in the **Created** state, the route is added.
        You cannot repeatedly call **CreateRouteEntry** within a specific period of time.
        *When you call this operation to add a custom route entry to the route table of a vRouter, take note of the following limits:**\
        >  When you add a route entry from a prefix list, the quota usage is calculated by adding the number of existing route entries and the maximum number of route entries of the prefix list.
        A route table can contain up to 200 custom route entries.
        The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be the same as or be a subset of the CIDR block of a vSwitch in the virtual private cloud (VPC). The destination CIDR block can contain the CIDR block of a vSwitch.
        The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
        The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
        If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
        Multiple custom route entries can point to the same next hop (**NextHopId**).
        The next hop (**NextHopId**) of a custom route entry must in the same VPC as the route table.
        Equal-cost multi-path (ECMP) routing can be configured by specifying the **NextHopList** parameter.
        When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you must not specify **NextHopList**.
        When you add route entries for ECMP routing, you must specify **DestinationCidrBlock** and **NextHopList**, and you must not specify **NextHopType** or **NextHopId**.
        *When you call this operation to add a custom route entry to the route table of a VBR, take note of the following limits:**\
        A route table can contain up to 200 custom route entries.
        **NextHopList** is not supported.
        The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
        The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
        If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
        Multiple custom route entries can point to the same next hop (**NextHopId**).
        The next hop (**NextHopId**) of a custom route entry must be a router interface associated with the VBR.
        You can add route entries only when the VBR is in the **Active** state, and the Express Connect circuit associated with the VBR is in the **Enabled** state and is not locked due to overdue payments.
        Only non-ECMP route entries are supported. When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you cannot specify **NextHopList**.
        
        @param request: CreateRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRouteEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.destination_cidr_block):
            query['DestinationCidrBlock'] = request.destination_cidr_block
        if not UtilClient.is_unset(request.next_hop_id):
            query['NextHopId'] = request.next_hop_id
        if not UtilClient.is_unset(request.next_hop_list):
            query['NextHopList'] = request.next_hop_list
        if not UtilClient.is_unset(request.next_hop_type):
            query['NextHopType'] = request.next_hop_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_entry_name):
            query['RouteEntryName'] = request.route_entry_name
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateRouteEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateRouteEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_route_entry_with_options_async(
        self,
        request: vpc_20160428_models.CreateRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateRouteEntryResponse:
        """
        @summary Creates a custom route entry in the route table of a VRouter or virtual border router (VBR).
        
        @description    **CreateRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task:
        If a route is in the **Creating** state, the route is being added.
        If a route is in the **Created** state, the route is added.
        You cannot repeatedly call **CreateRouteEntry** within a specific period of time.
        *When you call this operation to add a custom route entry to the route table of a vRouter, take note of the following limits:**\
        >  When you add a route entry from a prefix list, the quota usage is calculated by adding the number of existing route entries and the maximum number of route entries of the prefix list.
        A route table can contain up to 200 custom route entries.
        The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be the same as or be a subset of the CIDR block of a vSwitch in the virtual private cloud (VPC). The destination CIDR block can contain the CIDR block of a vSwitch.
        The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
        The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
        If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
        Multiple custom route entries can point to the same next hop (**NextHopId**).
        The next hop (**NextHopId**) of a custom route entry must in the same VPC as the route table.
        Equal-cost multi-path (ECMP) routing can be configured by specifying the **NextHopList** parameter.
        When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you must not specify **NextHopList**.
        When you add route entries for ECMP routing, you must specify **DestinationCidrBlock** and **NextHopList**, and you must not specify **NextHopType** or **NextHopId**.
        *When you call this operation to add a custom route entry to the route table of a VBR, take note of the following limits:**\
        A route table can contain up to 200 custom route entries.
        **NextHopList** is not supported.
        The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
        The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
        If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
        Multiple custom route entries can point to the same next hop (**NextHopId**).
        The next hop (**NextHopId**) of a custom route entry must be a router interface associated with the VBR.
        You can add route entries only when the VBR is in the **Active** state, and the Express Connect circuit associated with the VBR is in the **Enabled** state and is not locked due to overdue payments.
        Only non-ECMP route entries are supported. When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you cannot specify **NextHopList**.
        
        @param request: CreateRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRouteEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.destination_cidr_block):
            query['DestinationCidrBlock'] = request.destination_cidr_block
        if not UtilClient.is_unset(request.next_hop_id):
            query['NextHopId'] = request.next_hop_id
        if not UtilClient.is_unset(request.next_hop_list):
            query['NextHopList'] = request.next_hop_list
        if not UtilClient.is_unset(request.next_hop_type):
            query['NextHopType'] = request.next_hop_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_entry_name):
            query['RouteEntryName'] = request.route_entry_name
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateRouteEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateRouteEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_route_entry(
        self,
        request: vpc_20160428_models.CreateRouteEntryRequest,
    ) -> vpc_20160428_models.CreateRouteEntryResponse:
        """
        @summary Creates a custom route entry in the route table of a VRouter or virtual border router (VBR).
        
        @description    **CreateRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task:
        If a route is in the **Creating** state, the route is being added.
        If a route is in the **Created** state, the route is added.
        You cannot repeatedly call **CreateRouteEntry** within a specific period of time.
        *When you call this operation to add a custom route entry to the route table of a vRouter, take note of the following limits:**\
        >  When you add a route entry from a prefix list, the quota usage is calculated by adding the number of existing route entries and the maximum number of route entries of the prefix list.
        A route table can contain up to 200 custom route entries.
        The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be the same as or be a subset of the CIDR block of a vSwitch in the virtual private cloud (VPC). The destination CIDR block can contain the CIDR block of a vSwitch.
        The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
        The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
        If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
        Multiple custom route entries can point to the same next hop (**NextHopId**).
        The next hop (**NextHopId**) of a custom route entry must in the same VPC as the route table.
        Equal-cost multi-path (ECMP) routing can be configured by specifying the **NextHopList** parameter.
        When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you must not specify **NextHopList**.
        When you add route entries for ECMP routing, you must specify **DestinationCidrBlock** and **NextHopList**, and you must not specify **NextHopType** or **NextHopId**.
        *When you call this operation to add a custom route entry to the route table of a VBR, take note of the following limits:**\
        A route table can contain up to 200 custom route entries.
        **NextHopList** is not supported.
        The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
        The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
        If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
        Multiple custom route entries can point to the same next hop (**NextHopId**).
        The next hop (**NextHopId**) of a custom route entry must be a router interface associated with the VBR.
        You can add route entries only when the VBR is in the **Active** state, and the Express Connect circuit associated with the VBR is in the **Enabled** state and is not locked due to overdue payments.
        Only non-ECMP route entries are supported. When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you cannot specify **NextHopList**.
        
        @param request: CreateRouteEntryRequest
        @return: CreateRouteEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_route_entry_with_options(request, runtime)

    async def create_route_entry_async(
        self,
        request: vpc_20160428_models.CreateRouteEntryRequest,
    ) -> vpc_20160428_models.CreateRouteEntryResponse:
        """
        @summary Creates a custom route entry in the route table of a VRouter or virtual border router (VBR).
        
        @description    **CreateRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task:
        If a route is in the **Creating** state, the route is being added.
        If a route is in the **Created** state, the route is added.
        You cannot repeatedly call **CreateRouteEntry** within a specific period of time.
        *When you call this operation to add a custom route entry to the route table of a vRouter, take note of the following limits:**\
        >  When you add a route entry from a prefix list, the quota usage is calculated by adding the number of existing route entries and the maximum number of route entries of the prefix list.
        A route table can contain up to 200 custom route entries.
        The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be the same as or be a subset of the CIDR block of a vSwitch in the virtual private cloud (VPC). The destination CIDR block can contain the CIDR block of a vSwitch.
        The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
        The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
        If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
        Multiple custom route entries can point to the same next hop (**NextHopId**).
        The next hop (**NextHopId**) of a custom route entry must in the same VPC as the route table.
        Equal-cost multi-path (ECMP) routing can be configured by specifying the **NextHopList** parameter.
        When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you must not specify **NextHopList**.
        When you add route entries for ECMP routing, you must specify **DestinationCidrBlock** and **NextHopList**, and you must not specify **NextHopType** or **NextHopId**.
        *When you call this operation to add a custom route entry to the route table of a VBR, take note of the following limits:**\
        A route table can contain up to 200 custom route entries.
        **NextHopList** is not supported.
        The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
        The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
        If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
        Multiple custom route entries can point to the same next hop (**NextHopId**).
        The next hop (**NextHopId**) of a custom route entry must be a router interface associated with the VBR.
        You can add route entries only when the VBR is in the **Active** state, and the Express Connect circuit associated with the VBR is in the **Enabled** state and is not locked due to overdue payments.
        Only non-ECMP route entries are supported. When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you cannot specify **NextHopList**.
        
        @param request: CreateRouteEntryRequest
        @return: CreateRouteEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_route_entry_with_options_async(request, runtime)

    def create_route_table_with_options(
        self,
        request: vpc_20160428_models.CreateRouteTableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateRouteTableResponse:
        """
        @summary Creates a custom route table.
        
        @description    **CreateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the operation in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
        If the custom route table is in the **Creating** state, the custom route table is being created.
        If the custom route table is in the **Created** state, the custom route table is created.
        You cannot repeatedly call the **CreateRouteTable** operation within the specified period of time.
        
        @param request: CreateRouteTableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRouteTableResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.associate_type):
            query['AssociateType'] = request.associate_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_name):
            query['RouteTableName'] = request.route_table_name
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateRouteTable',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateRouteTableResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_route_table_with_options_async(
        self,
        request: vpc_20160428_models.CreateRouteTableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateRouteTableResponse:
        """
        @summary Creates a custom route table.
        
        @description    **CreateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the operation in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
        If the custom route table is in the **Creating** state, the custom route table is being created.
        If the custom route table is in the **Created** state, the custom route table is created.
        You cannot repeatedly call the **CreateRouteTable** operation within the specified period of time.
        
        @param request: CreateRouteTableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRouteTableResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.associate_type):
            query['AssociateType'] = request.associate_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_name):
            query['RouteTableName'] = request.route_table_name
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateRouteTable',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateRouteTableResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_route_table(
        self,
        request: vpc_20160428_models.CreateRouteTableRequest,
    ) -> vpc_20160428_models.CreateRouteTableResponse:
        """
        @summary Creates a custom route table.
        
        @description    **CreateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the operation in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
        If the custom route table is in the **Creating** state, the custom route table is being created.
        If the custom route table is in the **Created** state, the custom route table is created.
        You cannot repeatedly call the **CreateRouteTable** operation within the specified period of time.
        
        @param request: CreateRouteTableRequest
        @return: CreateRouteTableResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_route_table_with_options(request, runtime)

    async def create_route_table_async(
        self,
        request: vpc_20160428_models.CreateRouteTableRequest,
    ) -> vpc_20160428_models.CreateRouteTableResponse:
        """
        @summary Creates a custom route table.
        
        @description    **CreateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the operation in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
        If the custom route table is in the **Creating** state, the custom route table is being created.
        If the custom route table is in the **Created** state, the custom route table is created.
        You cannot repeatedly call the **CreateRouteTable** operation within the specified period of time.
        
        @param request: CreateRouteTableRequest
        @return: CreateRouteTableResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_route_table_with_options_async(request, runtime)

    def create_router_interface_with_options(
        self,
        request: vpc_20160428_models.CreateRouterInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateRouterInterfaceResponse:
        """
        @summary Creates a router interface.
        
        @description When you call this operation, take note of the following limits:
        You can create only one pair of interfaces to be connected between two routers.
        You can create a maximum of five router interfaces for a router.
        If your Alibaba Cloud account has a router interface with overdue payments, you cannot create new router interfaces.
        Each destination CIDR block of route entries in the same route table must be unique.
        A virtual border router (VBR) can serve only as a requester. The VBR must be in the Activated state.
        You can call this operation to create subscription and pay-as-you-go router interfaces.
        
        @param request: CreateRouterInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRouterInterfaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.access_point_id):
            query['AccessPointId'] = request.access_point_id
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.fast_link_mode):
            query['FastLinkMode'] = request.fast_link_mode
        if not UtilClient.is_unset(request.health_check_source_ip):
            query['HealthCheckSourceIp'] = request.health_check_source_ip
        if not UtilClient.is_unset(request.health_check_target_ip):
            query['HealthCheckTargetIp'] = request.health_check_target_ip
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.opposite_access_point_id):
            query['OppositeAccessPointId'] = request.opposite_access_point_id
        if not UtilClient.is_unset(request.opposite_interface_id):
            query['OppositeInterfaceId'] = request.opposite_interface_id
        if not UtilClient.is_unset(request.opposite_interface_owner_id):
            query['OppositeInterfaceOwnerId'] = request.opposite_interface_owner_id
        if not UtilClient.is_unset(request.opposite_region_id):
            query['OppositeRegionId'] = request.opposite_region_id
        if not UtilClient.is_unset(request.opposite_router_id):
            query['OppositeRouterId'] = request.opposite_router_id
        if not UtilClient.is_unset(request.opposite_router_type):
            query['OppositeRouterType'] = request.opposite_router_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.pricing_cycle):
            query['PricingCycle'] = request.pricing_cycle
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.role):
            query['Role'] = request.role
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        if not UtilClient.is_unset(request.router_type):
            query['RouterType'] = request.router_type
        if not UtilClient.is_unset(request.spec):
            query['Spec'] = request.spec
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateRouterInterface',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateRouterInterfaceResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_router_interface_with_options_async(
        self,
        request: vpc_20160428_models.CreateRouterInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateRouterInterfaceResponse:
        """
        @summary Creates a router interface.
        
        @description When you call this operation, take note of the following limits:
        You can create only one pair of interfaces to be connected between two routers.
        You can create a maximum of five router interfaces for a router.
        If your Alibaba Cloud account has a router interface with overdue payments, you cannot create new router interfaces.
        Each destination CIDR block of route entries in the same route table must be unique.
        A virtual border router (VBR) can serve only as a requester. The VBR must be in the Activated state.
        You can call this operation to create subscription and pay-as-you-go router interfaces.
        
        @param request: CreateRouterInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRouterInterfaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.access_point_id):
            query['AccessPointId'] = request.access_point_id
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.auto_renew):
            query['AutoRenew'] = request.auto_renew
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.fast_link_mode):
            query['FastLinkMode'] = request.fast_link_mode
        if not UtilClient.is_unset(request.health_check_source_ip):
            query['HealthCheckSourceIp'] = request.health_check_source_ip
        if not UtilClient.is_unset(request.health_check_target_ip):
            query['HealthCheckTargetIp'] = request.health_check_target_ip
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.opposite_access_point_id):
            query['OppositeAccessPointId'] = request.opposite_access_point_id
        if not UtilClient.is_unset(request.opposite_interface_id):
            query['OppositeInterfaceId'] = request.opposite_interface_id
        if not UtilClient.is_unset(request.opposite_interface_owner_id):
            query['OppositeInterfaceOwnerId'] = request.opposite_interface_owner_id
        if not UtilClient.is_unset(request.opposite_region_id):
            query['OppositeRegionId'] = request.opposite_region_id
        if not UtilClient.is_unset(request.opposite_router_id):
            query['OppositeRouterId'] = request.opposite_router_id
        if not UtilClient.is_unset(request.opposite_router_type):
            query['OppositeRouterType'] = request.opposite_router_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.pricing_cycle):
            query['PricingCycle'] = request.pricing_cycle
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.role):
            query['Role'] = request.role
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        if not UtilClient.is_unset(request.router_type):
            query['RouterType'] = request.router_type
        if not UtilClient.is_unset(request.spec):
            query['Spec'] = request.spec
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateRouterInterface',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateRouterInterfaceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_router_interface(
        self,
        request: vpc_20160428_models.CreateRouterInterfaceRequest,
    ) -> vpc_20160428_models.CreateRouterInterfaceResponse:
        """
        @summary Creates a router interface.
        
        @description When you call this operation, take note of the following limits:
        You can create only one pair of interfaces to be connected between two routers.
        You can create a maximum of five router interfaces for a router.
        If your Alibaba Cloud account has a router interface with overdue payments, you cannot create new router interfaces.
        Each destination CIDR block of route entries in the same route table must be unique.
        A virtual border router (VBR) can serve only as a requester. The VBR must be in the Activated state.
        You can call this operation to create subscription and pay-as-you-go router interfaces.
        
        @param request: CreateRouterInterfaceRequest
        @return: CreateRouterInterfaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_router_interface_with_options(request, runtime)

    async def create_router_interface_async(
        self,
        request: vpc_20160428_models.CreateRouterInterfaceRequest,
    ) -> vpc_20160428_models.CreateRouterInterfaceResponse:
        """
        @summary Creates a router interface.
        
        @description When you call this operation, take note of the following limits:
        You can create only one pair of interfaces to be connected between two routers.
        You can create a maximum of five router interfaces for a router.
        If your Alibaba Cloud account has a router interface with overdue payments, you cannot create new router interfaces.
        Each destination CIDR block of route entries in the same route table must be unique.
        A virtual border router (VBR) can serve only as a requester. The VBR must be in the Activated state.
        You can call this operation to create subscription and pay-as-you-go router interfaces.
        
        @param request: CreateRouterInterfaceRequest
        @return: CreateRouterInterfaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_router_interface_with_options_async(request, runtime)

    def create_snat_entry_with_options(
        self,
        request: vpc_20160428_models.CreateSnatEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateSnatEntryResponse:
        """
        @summary Adds an SNAT entry to an SNAT table.
        
        @description You can call this operation to add SNAT entries to Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways. In this topic, a *NAT** gateway refers to both gateway types.
        Before you call this operation, take note of the following limits:
        **CreateSnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
        If the SNAT entry is in the **Pending** state, the system is adding the SNAT entry. You can only query the status of the SNAT entry, and cannot perform other operations.
        If the SNAT entry is in the **Available** state, the SNAT entry is added.
        You cannot repeatedly call the **CreateSnatEntry** operation to add an SNAT entry to an SNAT table within the specified period of time.
        The vSwitch and Elastic Compute Service (ECS) instance specified in an SNAT entry must be created in the VPC where the NAT gateway is deployed.
        Each vSwitch or ECS instance can be specified in only one SNAT entry.
        If a high-availability virtual IP address (HAVIP) exists in a vSwitch, you cannot create SNAT entries.
        
        @param request: CreateSnatEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateSnatEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.eip_affinity):
            query['EipAffinity'] = request.eip_affinity
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snat_entry_name):
            query['SnatEntryName'] = request.snat_entry_name
        if not UtilClient.is_unset(request.snat_ip):
            query['SnatIp'] = request.snat_ip
        if not UtilClient.is_unset(request.snat_table_id):
            query['SnatTableId'] = request.snat_table_id
        if not UtilClient.is_unset(request.source_cidr):
            query['SourceCIDR'] = request.source_cidr
        if not UtilClient.is_unset(request.source_vswitch_id):
            query['SourceVSwitchId'] = request.source_vswitch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateSnatEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateSnatEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_snat_entry_with_options_async(
        self,
        request: vpc_20160428_models.CreateSnatEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateSnatEntryResponse:
        """
        @summary Adds an SNAT entry to an SNAT table.
        
        @description You can call this operation to add SNAT entries to Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways. In this topic, a *NAT** gateway refers to both gateway types.
        Before you call this operation, take note of the following limits:
        **CreateSnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
        If the SNAT entry is in the **Pending** state, the system is adding the SNAT entry. You can only query the status of the SNAT entry, and cannot perform other operations.
        If the SNAT entry is in the **Available** state, the SNAT entry is added.
        You cannot repeatedly call the **CreateSnatEntry** operation to add an SNAT entry to an SNAT table within the specified period of time.
        The vSwitch and Elastic Compute Service (ECS) instance specified in an SNAT entry must be created in the VPC where the NAT gateway is deployed.
        Each vSwitch or ECS instance can be specified in only one SNAT entry.
        If a high-availability virtual IP address (HAVIP) exists in a vSwitch, you cannot create SNAT entries.
        
        @param request: CreateSnatEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateSnatEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.eip_affinity):
            query['EipAffinity'] = request.eip_affinity
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snat_entry_name):
            query['SnatEntryName'] = request.snat_entry_name
        if not UtilClient.is_unset(request.snat_ip):
            query['SnatIp'] = request.snat_ip
        if not UtilClient.is_unset(request.snat_table_id):
            query['SnatTableId'] = request.snat_table_id
        if not UtilClient.is_unset(request.source_cidr):
            query['SourceCIDR'] = request.source_cidr
        if not UtilClient.is_unset(request.source_vswitch_id):
            query['SourceVSwitchId'] = request.source_vswitch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateSnatEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateSnatEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_snat_entry(
        self,
        request: vpc_20160428_models.CreateSnatEntryRequest,
    ) -> vpc_20160428_models.CreateSnatEntryResponse:
        """
        @summary Adds an SNAT entry to an SNAT table.
        
        @description You can call this operation to add SNAT entries to Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways. In this topic, a *NAT** gateway refers to both gateway types.
        Before you call this operation, take note of the following limits:
        **CreateSnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
        If the SNAT entry is in the **Pending** state, the system is adding the SNAT entry. You can only query the status of the SNAT entry, and cannot perform other operations.
        If the SNAT entry is in the **Available** state, the SNAT entry is added.
        You cannot repeatedly call the **CreateSnatEntry** operation to add an SNAT entry to an SNAT table within the specified period of time.
        The vSwitch and Elastic Compute Service (ECS) instance specified in an SNAT entry must be created in the VPC where the NAT gateway is deployed.
        Each vSwitch or ECS instance can be specified in only one SNAT entry.
        If a high-availability virtual IP address (HAVIP) exists in a vSwitch, you cannot create SNAT entries.
        
        @param request: CreateSnatEntryRequest
        @return: CreateSnatEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_snat_entry_with_options(request, runtime)

    async def create_snat_entry_async(
        self,
        request: vpc_20160428_models.CreateSnatEntryRequest,
    ) -> vpc_20160428_models.CreateSnatEntryResponse:
        """
        @summary Adds an SNAT entry to an SNAT table.
        
        @description You can call this operation to add SNAT entries to Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways. In this topic, a *NAT** gateway refers to both gateway types.
        Before you call this operation, take note of the following limits:
        **CreateSnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
        If the SNAT entry is in the **Pending** state, the system is adding the SNAT entry. You can only query the status of the SNAT entry, and cannot perform other operations.
        If the SNAT entry is in the **Available** state, the SNAT entry is added.
        You cannot repeatedly call the **CreateSnatEntry** operation to add an SNAT entry to an SNAT table within the specified period of time.
        The vSwitch and Elastic Compute Service (ECS) instance specified in an SNAT entry must be created in the VPC where the NAT gateway is deployed.
        Each vSwitch or ECS instance can be specified in only one SNAT entry.
        If a high-availability virtual IP address (HAVIP) exists in a vSwitch, you cannot create SNAT entries.
        
        @param request: CreateSnatEntryRequest
        @return: CreateSnatEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_snat_entry_with_options_async(request, runtime)

    def create_ssl_vpn_client_cert_with_options(
        self,
        request: vpc_20160428_models.CreateSslVpnClientCertRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateSslVpnClientCertResponse:
        """
        @summary SSL-VPN
        
        @param request: CreateSslVpnClientCertRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateSslVpnClientCertResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.ssl_vpn_server_id):
            query['SslVpnServerId'] = request.ssl_vpn_server_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateSslVpnClientCert',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateSslVpnClientCertResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_ssl_vpn_client_cert_with_options_async(
        self,
        request: vpc_20160428_models.CreateSslVpnClientCertRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateSslVpnClientCertResponse:
        """
        @summary SSL-VPN
        
        @param request: CreateSslVpnClientCertRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateSslVpnClientCertResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.ssl_vpn_server_id):
            query['SslVpnServerId'] = request.ssl_vpn_server_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateSslVpnClientCert',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateSslVpnClientCertResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_ssl_vpn_client_cert(
        self,
        request: vpc_20160428_models.CreateSslVpnClientCertRequest,
    ) -> vpc_20160428_models.CreateSslVpnClientCertResponse:
        """
        @summary SSL-VPN
        
        @param request: CreateSslVpnClientCertRequest
        @return: CreateSslVpnClientCertResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_ssl_vpn_client_cert_with_options(request, runtime)

    async def create_ssl_vpn_client_cert_async(
        self,
        request: vpc_20160428_models.CreateSslVpnClientCertRequest,
    ) -> vpc_20160428_models.CreateSslVpnClientCertResponse:
        """
        @summary SSL-VPN
        
        @param request: CreateSslVpnClientCertRequest
        @return: CreateSslVpnClientCertResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_ssl_vpn_client_cert_with_options_async(request, runtime)

    def create_ssl_vpn_server_with_options(
        self,
        request: vpc_20160428_models.CreateSslVpnServerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateSslVpnServerResponse:
        """
        @summary Creates an SSL server.
        
        @description    **CreateSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the task.
        If the VPN gateway is in the **updating** state, the SSL server is being created.
        If the VPN gateway is in the **active** state, the SSL server is created.
        You cannot call the **CreateSslVpnServer** operation to create multiple SSL servers at a time for the same VPN gateway.
        ### [](#)Prerequisites
        A VPN gateway is created, and the SSL-VPN feature is enabled for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2526913.html).
        
        @param request: CreateSslVpnServerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateSslVpnServerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cipher):
            query['Cipher'] = request.cipher
        if not UtilClient.is_unset(request.client_ip_pool):
            query['ClientIpPool'] = request.client_ip_pool
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.compress):
            query['Compress'] = request.compress
        if not UtilClient.is_unset(request.enable_multi_factor_auth):
            query['EnableMultiFactorAuth'] = request.enable_multi_factor_auth
        if not UtilClient.is_unset(request.idaa_sapplication_id):
            query['IDaaSApplicationId'] = request.idaa_sapplication_id
        if not UtilClient.is_unset(request.idaa_sinstance_id):
            query['IDaaSInstanceId'] = request.idaa_sinstance_id
        if not UtilClient.is_unset(request.idaa_sregion_id):
            query['IDaaSRegionId'] = request.idaa_sregion_id
        if not UtilClient.is_unset(request.local_subnet):
            query['LocalSubnet'] = request.local_subnet
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port):
            query['Port'] = request.port
        if not UtilClient.is_unset(request.proto):
            query['Proto'] = request.proto
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateSslVpnServer',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateSslVpnServerResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_ssl_vpn_server_with_options_async(
        self,
        request: vpc_20160428_models.CreateSslVpnServerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateSslVpnServerResponse:
        """
        @summary Creates an SSL server.
        
        @description    **CreateSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the task.
        If the VPN gateway is in the **updating** state, the SSL server is being created.
        If the VPN gateway is in the **active** state, the SSL server is created.
        You cannot call the **CreateSslVpnServer** operation to create multiple SSL servers at a time for the same VPN gateway.
        ### [](#)Prerequisites
        A VPN gateway is created, and the SSL-VPN feature is enabled for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2526913.html).
        
        @param request: CreateSslVpnServerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateSslVpnServerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cipher):
            query['Cipher'] = request.cipher
        if not UtilClient.is_unset(request.client_ip_pool):
            query['ClientIpPool'] = request.client_ip_pool
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.compress):
            query['Compress'] = request.compress
        if not UtilClient.is_unset(request.enable_multi_factor_auth):
            query['EnableMultiFactorAuth'] = request.enable_multi_factor_auth
        if not UtilClient.is_unset(request.idaa_sapplication_id):
            query['IDaaSApplicationId'] = request.idaa_sapplication_id
        if not UtilClient.is_unset(request.idaa_sinstance_id):
            query['IDaaSInstanceId'] = request.idaa_sinstance_id
        if not UtilClient.is_unset(request.idaa_sregion_id):
            query['IDaaSRegionId'] = request.idaa_sregion_id
        if not UtilClient.is_unset(request.local_subnet):
            query['LocalSubnet'] = request.local_subnet
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port):
            query['Port'] = request.port
        if not UtilClient.is_unset(request.proto):
            query['Proto'] = request.proto
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateSslVpnServer',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateSslVpnServerResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_ssl_vpn_server(
        self,
        request: vpc_20160428_models.CreateSslVpnServerRequest,
    ) -> vpc_20160428_models.CreateSslVpnServerResponse:
        """
        @summary Creates an SSL server.
        
        @description    **CreateSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the task.
        If the VPN gateway is in the **updating** state, the SSL server is being created.
        If the VPN gateway is in the **active** state, the SSL server is created.
        You cannot call the **CreateSslVpnServer** operation to create multiple SSL servers at a time for the same VPN gateway.
        ### [](#)Prerequisites
        A VPN gateway is created, and the SSL-VPN feature is enabled for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2526913.html).
        
        @param request: CreateSslVpnServerRequest
        @return: CreateSslVpnServerResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_ssl_vpn_server_with_options(request, runtime)

    async def create_ssl_vpn_server_async(
        self,
        request: vpc_20160428_models.CreateSslVpnServerRequest,
    ) -> vpc_20160428_models.CreateSslVpnServerResponse:
        """
        @summary Creates an SSL server.
        
        @description    **CreateSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the task.
        If the VPN gateway is in the **updating** state, the SSL server is being created.
        If the VPN gateway is in the **active** state, the SSL server is created.
        You cannot call the **CreateSslVpnServer** operation to create multiple SSL servers at a time for the same VPN gateway.
        ### [](#)Prerequisites
        A VPN gateway is created, and the SSL-VPN feature is enabled for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2526913.html).
        
        @param request: CreateSslVpnServerRequest
        @return: CreateSslVpnServerResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_ssl_vpn_server_with_options_async(request, runtime)

    def create_traffic_mirror_filter_with_options(
        self,
        request: vpc_20160428_models.CreateTrafficMirrorFilterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateTrafficMirrorFilterResponse:
        """
        @summary Creates a filter for traffic mirroring.
        
        @description *CreateTrafficMirrorFilter** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of the task.
        If the filter is in the **Creating** state, the filter is being created.
        If the filter is in the **Created** state, the filter is created.
        
        @param request: CreateTrafficMirrorFilterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateTrafficMirrorFilterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.egress_rules):
            query['EgressRules'] = request.egress_rules
        if not UtilClient.is_unset(request.ingress_rules):
            query['IngressRules'] = request.ingress_rules
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.traffic_mirror_filter_description):
            query['TrafficMirrorFilterDescription'] = request.traffic_mirror_filter_description
        if not UtilClient.is_unset(request.traffic_mirror_filter_name):
            query['TrafficMirrorFilterName'] = request.traffic_mirror_filter_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateTrafficMirrorFilter',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateTrafficMirrorFilterResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_traffic_mirror_filter_with_options_async(
        self,
        request: vpc_20160428_models.CreateTrafficMirrorFilterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateTrafficMirrorFilterResponse:
        """
        @summary Creates a filter for traffic mirroring.
        
        @description *CreateTrafficMirrorFilter** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of the task.
        If the filter is in the **Creating** state, the filter is being created.
        If the filter is in the **Created** state, the filter is created.
        
        @param request: CreateTrafficMirrorFilterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateTrafficMirrorFilterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.egress_rules):
            query['EgressRules'] = request.egress_rules
        if not UtilClient.is_unset(request.ingress_rules):
            query['IngressRules'] = request.ingress_rules
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.traffic_mirror_filter_description):
            query['TrafficMirrorFilterDescription'] = request.traffic_mirror_filter_description
        if not UtilClient.is_unset(request.traffic_mirror_filter_name):
            query['TrafficMirrorFilterName'] = request.traffic_mirror_filter_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateTrafficMirrorFilter',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateTrafficMirrorFilterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_traffic_mirror_filter(
        self,
        request: vpc_20160428_models.CreateTrafficMirrorFilterRequest,
    ) -> vpc_20160428_models.CreateTrafficMirrorFilterResponse:
        """
        @summary Creates a filter for traffic mirroring.
        
        @description *CreateTrafficMirrorFilter** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of the task.
        If the filter is in the **Creating** state, the filter is being created.
        If the filter is in the **Created** state, the filter is created.
        
        @param request: CreateTrafficMirrorFilterRequest
        @return: CreateTrafficMirrorFilterResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_traffic_mirror_filter_with_options(request, runtime)

    async def create_traffic_mirror_filter_async(
        self,
        request: vpc_20160428_models.CreateTrafficMirrorFilterRequest,
    ) -> vpc_20160428_models.CreateTrafficMirrorFilterResponse:
        """
        @summary Creates a filter for traffic mirroring.
        
        @description *CreateTrafficMirrorFilter** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of the task.
        If the filter is in the **Creating** state, the filter is being created.
        If the filter is in the **Created** state, the filter is created.
        
        @param request: CreateTrafficMirrorFilterRequest
        @return: CreateTrafficMirrorFilterResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_traffic_mirror_filter_with_options_async(request, runtime)

    def create_traffic_mirror_filter_rules_with_options(
        self,
        request: vpc_20160428_models.CreateTrafficMirrorFilterRulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateTrafficMirrorFilterRulesResponse:
        """
        @summary Creates an inbound or outbound rule for traffic mirroring.
        
        @description    **CreateTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
        If the inbound or outbound rule is in the **Creating** state, the rule is being created.
        If the inbound or outbound rule is in the **Created** state, the rule is created.
        You cannot call **CreateTrafficMirrorFilterRules** within the specified period of time.
        
        @param request: CreateTrafficMirrorFilterRulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateTrafficMirrorFilterRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.egress_rules):
            query['EgressRules'] = request.egress_rules
        if not UtilClient.is_unset(request.ingress_rules):
            query['IngressRules'] = request.ingress_rules
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.traffic_mirror_filter_id):
            query['TrafficMirrorFilterId'] = request.traffic_mirror_filter_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateTrafficMirrorFilterRules',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateTrafficMirrorFilterRulesResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_traffic_mirror_filter_rules_with_options_async(
        self,
        request: vpc_20160428_models.CreateTrafficMirrorFilterRulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateTrafficMirrorFilterRulesResponse:
        """
        @summary Creates an inbound or outbound rule for traffic mirroring.
        
        @description    **CreateTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
        If the inbound or outbound rule is in the **Creating** state, the rule is being created.
        If the inbound or outbound rule is in the **Created** state, the rule is created.
        You cannot call **CreateTrafficMirrorFilterRules** within the specified period of time.
        
        @param request: CreateTrafficMirrorFilterRulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateTrafficMirrorFilterRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.egress_rules):
            query['EgressRules'] = request.egress_rules
        if not UtilClient.is_unset(request.ingress_rules):
            query['IngressRules'] = request.ingress_rules
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.traffic_mirror_filter_id):
            query['TrafficMirrorFilterId'] = request.traffic_mirror_filter_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateTrafficMirrorFilterRules',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateTrafficMirrorFilterRulesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_traffic_mirror_filter_rules(
        self,
        request: vpc_20160428_models.CreateTrafficMirrorFilterRulesRequest,
    ) -> vpc_20160428_models.CreateTrafficMirrorFilterRulesResponse:
        """
        @summary Creates an inbound or outbound rule for traffic mirroring.
        
        @description    **CreateTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
        If the inbound or outbound rule is in the **Creating** state, the rule is being created.
        If the inbound or outbound rule is in the **Created** state, the rule is created.
        You cannot call **CreateTrafficMirrorFilterRules** within the specified period of time.
        
        @param request: CreateTrafficMirrorFilterRulesRequest
        @return: CreateTrafficMirrorFilterRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_traffic_mirror_filter_rules_with_options(request, runtime)

    async def create_traffic_mirror_filter_rules_async(
        self,
        request: vpc_20160428_models.CreateTrafficMirrorFilterRulesRequest,
    ) -> vpc_20160428_models.CreateTrafficMirrorFilterRulesResponse:
        """
        @summary Creates an inbound or outbound rule for traffic mirroring.
        
        @description    **CreateTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
        If the inbound or outbound rule is in the **Creating** state, the rule is being created.
        If the inbound or outbound rule is in the **Created** state, the rule is created.
        You cannot call **CreateTrafficMirrorFilterRules** within the specified period of time.
        
        @param request: CreateTrafficMirrorFilterRulesRequest
        @return: CreateTrafficMirrorFilterRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_traffic_mirror_filter_rules_with_options_async(request, runtime)

    def create_traffic_mirror_session_with_options(
        self,
        request: vpc_20160428_models.CreateTrafficMirrorSessionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateTrafficMirrorSessionResponse:
        """
        @summary Creates a traffic mirror session.
        
        @description *CreateTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) to query the status of the task.
        If the traffic mirror session is in the **Creating** state, it is being created.
        If the traffic mirror session is in the **Created** state, it is created.
        
        @param request: CreateTrafficMirrorSessionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateTrafficMirrorSessionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.enabled):
            query['Enabled'] = request.enabled
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.packet_length):
            query['PacketLength'] = request.packet_length
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.traffic_mirror_filter_id):
            query['TrafficMirrorFilterId'] = request.traffic_mirror_filter_id
        if not UtilClient.is_unset(request.traffic_mirror_session_description):
            query['TrafficMirrorSessionDescription'] = request.traffic_mirror_session_description
        if not UtilClient.is_unset(request.traffic_mirror_session_name):
            query['TrafficMirrorSessionName'] = request.traffic_mirror_session_name
        if not UtilClient.is_unset(request.traffic_mirror_source_ids):
            query['TrafficMirrorSourceIds'] = request.traffic_mirror_source_ids
        if not UtilClient.is_unset(request.traffic_mirror_target_id):
            query['TrafficMirrorTargetId'] = request.traffic_mirror_target_id
        if not UtilClient.is_unset(request.traffic_mirror_target_type):
            query['TrafficMirrorTargetType'] = request.traffic_mirror_target_type
        if not UtilClient.is_unset(request.virtual_network_id):
            query['VirtualNetworkId'] = request.virtual_network_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateTrafficMirrorSession',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateTrafficMirrorSessionResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_traffic_mirror_session_with_options_async(
        self,
        request: vpc_20160428_models.CreateTrafficMirrorSessionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateTrafficMirrorSessionResponse:
        """
        @summary Creates a traffic mirror session.
        
        @description *CreateTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) to query the status of the task.
        If the traffic mirror session is in the **Creating** state, it is being created.
        If the traffic mirror session is in the **Created** state, it is created.
        
        @param request: CreateTrafficMirrorSessionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateTrafficMirrorSessionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.enabled):
            query['Enabled'] = request.enabled
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.packet_length):
            query['PacketLength'] = request.packet_length
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.traffic_mirror_filter_id):
            query['TrafficMirrorFilterId'] = request.traffic_mirror_filter_id
        if not UtilClient.is_unset(request.traffic_mirror_session_description):
            query['TrafficMirrorSessionDescription'] = request.traffic_mirror_session_description
        if not UtilClient.is_unset(request.traffic_mirror_session_name):
            query['TrafficMirrorSessionName'] = request.traffic_mirror_session_name
        if not UtilClient.is_unset(request.traffic_mirror_source_ids):
            query['TrafficMirrorSourceIds'] = request.traffic_mirror_source_ids
        if not UtilClient.is_unset(request.traffic_mirror_target_id):
            query['TrafficMirrorTargetId'] = request.traffic_mirror_target_id
        if not UtilClient.is_unset(request.traffic_mirror_target_type):
            query['TrafficMirrorTargetType'] = request.traffic_mirror_target_type
        if not UtilClient.is_unset(request.virtual_network_id):
            query['VirtualNetworkId'] = request.virtual_network_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateTrafficMirrorSession',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateTrafficMirrorSessionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_traffic_mirror_session(
        self,
        request: vpc_20160428_models.CreateTrafficMirrorSessionRequest,
    ) -> vpc_20160428_models.CreateTrafficMirrorSessionResponse:
        """
        @summary Creates a traffic mirror session.
        
        @description *CreateTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) to query the status of the task.
        If the traffic mirror session is in the **Creating** state, it is being created.
        If the traffic mirror session is in the **Created** state, it is created.
        
        @param request: CreateTrafficMirrorSessionRequest
        @return: CreateTrafficMirrorSessionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_traffic_mirror_session_with_options(request, runtime)

    async def create_traffic_mirror_session_async(
        self,
        request: vpc_20160428_models.CreateTrafficMirrorSessionRequest,
    ) -> vpc_20160428_models.CreateTrafficMirrorSessionResponse:
        """
        @summary Creates a traffic mirror session.
        
        @description *CreateTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) to query the status of the task.
        If the traffic mirror session is in the **Creating** state, it is being created.
        If the traffic mirror session is in the **Created** state, it is created.
        
        @param request: CreateTrafficMirrorSessionRequest
        @return: CreateTrafficMirrorSessionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_traffic_mirror_session_with_options_async(request, runtime)

    def create_vswitch_with_options(
        self,
        request: vpc_20160428_models.CreateVSwitchRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVSwitchResponse:
        """
        @summary 
        
        @description When you call this operation, take note of the following limits:
        You can create at most 150 vSwitches in a virtual private cloud (VPC).
        The first IP address and last three IP addresses of each vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
        The number of instances in a vSwitch cannot exceed the remaining capacity of the VPC. The remaining capacity is the difference between 15,000 and the current number of instances.
        Each instance can belong to only one vSwitch.
        vSwitches do not support multicast or broadcast.
        After you create a vSwitch, you cannot modify its CIDR block.
        **CreateVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) to query the status of the task.
        If the vSwitch is in the **Pending** state, the vSwitch is being configured.
        If the vSwitch is in the **Available** state, the vSwitch is available.
        You cannot repeatedly call the **CreateVSwitch** operation to create a vSwitch in a VPC within the specified period of time.
        
        @param request: CreateVSwitchRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVSwitchResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cidr_block):
            query['CidrBlock'] = request.cidr_block
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ipv_6cidr_block):
            query['Ipv6CidrBlock'] = request.ipv_6cidr_block
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.v_switch_name):
            query['VSwitchName'] = request.v_switch_name
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.vpc_ipv_6cidr_block):
            query['VpcIpv6CidrBlock'] = request.vpc_ipv_6cidr_block
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVSwitch',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVSwitchResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_vswitch_with_options_async(
        self,
        request: vpc_20160428_models.CreateVSwitchRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVSwitchResponse:
        """
        @summary 
        
        @description When you call this operation, take note of the following limits:
        You can create at most 150 vSwitches in a virtual private cloud (VPC).
        The first IP address and last three IP addresses of each vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
        The number of instances in a vSwitch cannot exceed the remaining capacity of the VPC. The remaining capacity is the difference between 15,000 and the current number of instances.
        Each instance can belong to only one vSwitch.
        vSwitches do not support multicast or broadcast.
        After you create a vSwitch, you cannot modify its CIDR block.
        **CreateVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) to query the status of the task.
        If the vSwitch is in the **Pending** state, the vSwitch is being configured.
        If the vSwitch is in the **Available** state, the vSwitch is available.
        You cannot repeatedly call the **CreateVSwitch** operation to create a vSwitch in a VPC within the specified period of time.
        
        @param request: CreateVSwitchRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVSwitchResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cidr_block):
            query['CidrBlock'] = request.cidr_block
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ipv_6cidr_block):
            query['Ipv6CidrBlock'] = request.ipv_6cidr_block
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.v_switch_name):
            query['VSwitchName'] = request.v_switch_name
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.vpc_ipv_6cidr_block):
            query['VpcIpv6CidrBlock'] = request.vpc_ipv_6cidr_block
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVSwitch',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVSwitchResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_vswitch(
        self,
        request: vpc_20160428_models.CreateVSwitchRequest,
    ) -> vpc_20160428_models.CreateVSwitchResponse:
        """
        @summary 
        
        @description When you call this operation, take note of the following limits:
        You can create at most 150 vSwitches in a virtual private cloud (VPC).
        The first IP address and last three IP addresses of each vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
        The number of instances in a vSwitch cannot exceed the remaining capacity of the VPC. The remaining capacity is the difference between 15,000 and the current number of instances.
        Each instance can belong to only one vSwitch.
        vSwitches do not support multicast or broadcast.
        After you create a vSwitch, you cannot modify its CIDR block.
        **CreateVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) to query the status of the task.
        If the vSwitch is in the **Pending** state, the vSwitch is being configured.
        If the vSwitch is in the **Available** state, the vSwitch is available.
        You cannot repeatedly call the **CreateVSwitch** operation to create a vSwitch in a VPC within the specified period of time.
        
        @param request: CreateVSwitchRequest
        @return: CreateVSwitchResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_vswitch_with_options(request, runtime)

    async def create_vswitch_async(
        self,
        request: vpc_20160428_models.CreateVSwitchRequest,
    ) -> vpc_20160428_models.CreateVSwitchResponse:
        """
        @summary 
        
        @description When you call this operation, take note of the following limits:
        You can create at most 150 vSwitches in a virtual private cloud (VPC).
        The first IP address and last three IP addresses of each vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
        The number of instances in a vSwitch cannot exceed the remaining capacity of the VPC. The remaining capacity is the difference between 15,000 and the current number of instances.
        Each instance can belong to only one vSwitch.
        vSwitches do not support multicast or broadcast.
        After you create a vSwitch, you cannot modify its CIDR block.
        **CreateVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) to query the status of the task.
        If the vSwitch is in the **Pending** state, the vSwitch is being configured.
        If the vSwitch is in the **Available** state, the vSwitch is available.
        You cannot repeatedly call the **CreateVSwitch** operation to create a vSwitch in a VPC within the specified period of time.
        
        @param request: CreateVSwitchRequest
        @return: CreateVSwitchResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_vswitch_with_options_async(request, runtime)

    def create_vswitch_cidr_reservation_with_options(
        self,
        request: vpc_20160428_models.CreateVSwitchCidrReservationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVSwitchCidrReservationResponse:
        """
        @summary Creates a reserved CIDR block for a vSwitch.
        
        @description ## [](#)Description
        Take note of the following items:
        You can create at most 10 reserved IPv4 CIDR blocks and 10 reserved IPv6 CIDR blocks for each vSwitch in a virtual private cloud (VPC).
        After you create a reserved CIDR block for a vSwitch, the CIDR block cannot contain the IP address of the subnet gateway of the VPC to which the vSwitch belongs.
        **CreateVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
        If the vSwitch is in the **Assigning** state, the reserved CIDR block is being created.
        If the vSwitch is in the **Assigned** state, the reserved CIDR block is created.
        When you create a reserved IPv4 CIDR block for a vSwitch, the first IP address and the last three IP addresses of the vSwitch are reserved by the system. The four IP addresses will not be allocated.
        When you create a reserved IPv6 CIDR block for a vSwitch, the first IP address and the last nine IP addresses of the vSwitch are reserved by the system. The 10 IP addresses will not be allocated. For example, if you create a reserved IPv4 CIDR block for a vSwitch whose CIDR block is 192.168.1.0/24, the reserved CIDR block cannot contain the following IP addresses: 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255.
        
        @param request: CreateVSwitchCidrReservationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVSwitchCidrReservationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.ip_version):
            query['IpVersion'] = request.ip_version
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_cidr):
            query['VSwitchCidrReservationCidr'] = request.v_switch_cidr_reservation_cidr
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_description):
            query['VSwitchCidrReservationDescription'] = request.v_switch_cidr_reservation_description
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_mask):
            query['VSwitchCidrReservationMask'] = request.v_switch_cidr_reservation_mask
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_name):
            query['VSwitchCidrReservationName'] = request.v_switch_cidr_reservation_name
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_type):
            query['VSwitchCidrReservationType'] = request.v_switch_cidr_reservation_type
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVSwitchCidrReservation',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVSwitchCidrReservationResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_vswitch_cidr_reservation_with_options_async(
        self,
        request: vpc_20160428_models.CreateVSwitchCidrReservationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVSwitchCidrReservationResponse:
        """
        @summary Creates a reserved CIDR block for a vSwitch.
        
        @description ## [](#)Description
        Take note of the following items:
        You can create at most 10 reserved IPv4 CIDR blocks and 10 reserved IPv6 CIDR blocks for each vSwitch in a virtual private cloud (VPC).
        After you create a reserved CIDR block for a vSwitch, the CIDR block cannot contain the IP address of the subnet gateway of the VPC to which the vSwitch belongs.
        **CreateVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
        If the vSwitch is in the **Assigning** state, the reserved CIDR block is being created.
        If the vSwitch is in the **Assigned** state, the reserved CIDR block is created.
        When you create a reserved IPv4 CIDR block for a vSwitch, the first IP address and the last three IP addresses of the vSwitch are reserved by the system. The four IP addresses will not be allocated.
        When you create a reserved IPv6 CIDR block for a vSwitch, the first IP address and the last nine IP addresses of the vSwitch are reserved by the system. The 10 IP addresses will not be allocated. For example, if you create a reserved IPv4 CIDR block for a vSwitch whose CIDR block is 192.168.1.0/24, the reserved CIDR block cannot contain the following IP addresses: 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255.
        
        @param request: CreateVSwitchCidrReservationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVSwitchCidrReservationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.ip_version):
            query['IpVersion'] = request.ip_version
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_cidr):
            query['VSwitchCidrReservationCidr'] = request.v_switch_cidr_reservation_cidr
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_description):
            query['VSwitchCidrReservationDescription'] = request.v_switch_cidr_reservation_description
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_mask):
            query['VSwitchCidrReservationMask'] = request.v_switch_cidr_reservation_mask
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_name):
            query['VSwitchCidrReservationName'] = request.v_switch_cidr_reservation_name
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_type):
            query['VSwitchCidrReservationType'] = request.v_switch_cidr_reservation_type
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVSwitchCidrReservation',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVSwitchCidrReservationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_vswitch_cidr_reservation(
        self,
        request: vpc_20160428_models.CreateVSwitchCidrReservationRequest,
    ) -> vpc_20160428_models.CreateVSwitchCidrReservationResponse:
        """
        @summary Creates a reserved CIDR block for a vSwitch.
        
        @description ## [](#)Description
        Take note of the following items:
        You can create at most 10 reserved IPv4 CIDR blocks and 10 reserved IPv6 CIDR blocks for each vSwitch in a virtual private cloud (VPC).
        After you create a reserved CIDR block for a vSwitch, the CIDR block cannot contain the IP address of the subnet gateway of the VPC to which the vSwitch belongs.
        **CreateVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
        If the vSwitch is in the **Assigning** state, the reserved CIDR block is being created.
        If the vSwitch is in the **Assigned** state, the reserved CIDR block is created.
        When you create a reserved IPv4 CIDR block for a vSwitch, the first IP address and the last three IP addresses of the vSwitch are reserved by the system. The four IP addresses will not be allocated.
        When you create a reserved IPv6 CIDR block for a vSwitch, the first IP address and the last nine IP addresses of the vSwitch are reserved by the system. The 10 IP addresses will not be allocated. For example, if you create a reserved IPv4 CIDR block for a vSwitch whose CIDR block is 192.168.1.0/24, the reserved CIDR block cannot contain the following IP addresses: 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255.
        
        @param request: CreateVSwitchCidrReservationRequest
        @return: CreateVSwitchCidrReservationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_vswitch_cidr_reservation_with_options(request, runtime)

    async def create_vswitch_cidr_reservation_async(
        self,
        request: vpc_20160428_models.CreateVSwitchCidrReservationRequest,
    ) -> vpc_20160428_models.CreateVSwitchCidrReservationResponse:
        """
        @summary Creates a reserved CIDR block for a vSwitch.
        
        @description ## [](#)Description
        Take note of the following items:
        You can create at most 10 reserved IPv4 CIDR blocks and 10 reserved IPv6 CIDR blocks for each vSwitch in a virtual private cloud (VPC).
        After you create a reserved CIDR block for a vSwitch, the CIDR block cannot contain the IP address of the subnet gateway of the VPC to which the vSwitch belongs.
        **CreateVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
        If the vSwitch is in the **Assigning** state, the reserved CIDR block is being created.
        If the vSwitch is in the **Assigned** state, the reserved CIDR block is created.
        When you create a reserved IPv4 CIDR block for a vSwitch, the first IP address and the last three IP addresses of the vSwitch are reserved by the system. The four IP addresses will not be allocated.
        When you create a reserved IPv6 CIDR block for a vSwitch, the first IP address and the last nine IP addresses of the vSwitch are reserved by the system. The 10 IP addresses will not be allocated. For example, if you create a reserved IPv4 CIDR block for a vSwitch whose CIDR block is 192.168.1.0/24, the reserved CIDR block cannot contain the following IP addresses: 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255.
        
        @param request: CreateVSwitchCidrReservationRequest
        @return: CreateVSwitchCidrReservationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_vswitch_cidr_reservation_with_options_async(request, runtime)

    def create_vbr_ha_with_options(
        self,
        request: vpc_20160428_models.CreateVbrHaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVbrHaResponse:
        """
        @summary Creates a virtual border router (VBR) failover group.
        
        @param request: CreateVbrHaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVbrHaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_vbr_id):
            query['PeerVbrId'] = request.peer_vbr_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVbrHa',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVbrHaResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_vbr_ha_with_options_async(
        self,
        request: vpc_20160428_models.CreateVbrHaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVbrHaResponse:
        """
        @summary Creates a virtual border router (VBR) failover group.
        
        @param request: CreateVbrHaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVbrHaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_vbr_id):
            query['PeerVbrId'] = request.peer_vbr_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVbrHa',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVbrHaResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_vbr_ha(
        self,
        request: vpc_20160428_models.CreateVbrHaRequest,
    ) -> vpc_20160428_models.CreateVbrHaResponse:
        """
        @summary Creates a virtual border router (VBR) failover group.
        
        @param request: CreateVbrHaRequest
        @return: CreateVbrHaResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_vbr_ha_with_options(request, runtime)

    async def create_vbr_ha_async(
        self,
        request: vpc_20160428_models.CreateVbrHaRequest,
    ) -> vpc_20160428_models.CreateVbrHaResponse:
        """
        @summary Creates a virtual border router (VBR) failover group.
        
        @param request: CreateVbrHaRequest
        @return: CreateVbrHaResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_vbr_ha_with_options_async(request, runtime)

    def create_vco_route_entry_with_options(
        self,
        request: vpc_20160428_models.CreateVcoRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVcoRouteEntryResponse:
        """
        @summary Adds a destination-based route for an IPsec-VPN connection.
        
        @description    The IPsec-VPN connection must be associated with a transit router. For more information, see [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468249.html).
        You cannot create a destination-based route whose destination CIDR block is 0.0.0.0/0.
        Do not add a destination-based route whose destination CIDR block is 100.64.0.0/10, or a CIDR block that contains 100.64.0.0/10 or belongs to 100.64.0.0/10. Such a route will make the console fail to display the status of the IPsec-VPN connection or cause IPsec negotiation failures.
        **CreateVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) to query the status of the task.
        If the IPsec-VPN connection is in the **updating** state, the destination-based route is being created.
        If the IPsec-VPN connection is in the **attached** state, the destination-based route is created.
        You cannot repeatedly call **CreateVcoRouteEntry** within the specified period of time.
        
        @param request: CreateVcoRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVcoRouteEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.overlay_mode):
            query['OverlayMode'] = request.overlay_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVcoRouteEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVcoRouteEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_vco_route_entry_with_options_async(
        self,
        request: vpc_20160428_models.CreateVcoRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVcoRouteEntryResponse:
        """
        @summary Adds a destination-based route for an IPsec-VPN connection.
        
        @description    The IPsec-VPN connection must be associated with a transit router. For more information, see [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468249.html).
        You cannot create a destination-based route whose destination CIDR block is 0.0.0.0/0.
        Do not add a destination-based route whose destination CIDR block is 100.64.0.0/10, or a CIDR block that contains 100.64.0.0/10 or belongs to 100.64.0.0/10. Such a route will make the console fail to display the status of the IPsec-VPN connection or cause IPsec negotiation failures.
        **CreateVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) to query the status of the task.
        If the IPsec-VPN connection is in the **updating** state, the destination-based route is being created.
        If the IPsec-VPN connection is in the **attached** state, the destination-based route is created.
        You cannot repeatedly call **CreateVcoRouteEntry** within the specified period of time.
        
        @param request: CreateVcoRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVcoRouteEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.overlay_mode):
            query['OverlayMode'] = request.overlay_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVcoRouteEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVcoRouteEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_vco_route_entry(
        self,
        request: vpc_20160428_models.CreateVcoRouteEntryRequest,
    ) -> vpc_20160428_models.CreateVcoRouteEntryResponse:
        """
        @summary Adds a destination-based route for an IPsec-VPN connection.
        
        @description    The IPsec-VPN connection must be associated with a transit router. For more information, see [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468249.html).
        You cannot create a destination-based route whose destination CIDR block is 0.0.0.0/0.
        Do not add a destination-based route whose destination CIDR block is 100.64.0.0/10, or a CIDR block that contains 100.64.0.0/10 or belongs to 100.64.0.0/10. Such a route will make the console fail to display the status of the IPsec-VPN connection or cause IPsec negotiation failures.
        **CreateVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) to query the status of the task.
        If the IPsec-VPN connection is in the **updating** state, the destination-based route is being created.
        If the IPsec-VPN connection is in the **attached** state, the destination-based route is created.
        You cannot repeatedly call **CreateVcoRouteEntry** within the specified period of time.
        
        @param request: CreateVcoRouteEntryRequest
        @return: CreateVcoRouteEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_vco_route_entry_with_options(request, runtime)

    async def create_vco_route_entry_async(
        self,
        request: vpc_20160428_models.CreateVcoRouteEntryRequest,
    ) -> vpc_20160428_models.CreateVcoRouteEntryResponse:
        """
        @summary Adds a destination-based route for an IPsec-VPN connection.
        
        @description    The IPsec-VPN connection must be associated with a transit router. For more information, see [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468249.html).
        You cannot create a destination-based route whose destination CIDR block is 0.0.0.0/0.
        Do not add a destination-based route whose destination CIDR block is 100.64.0.0/10, or a CIDR block that contains 100.64.0.0/10 or belongs to 100.64.0.0/10. Such a route will make the console fail to display the status of the IPsec-VPN connection or cause IPsec negotiation failures.
        **CreateVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) to query the status of the task.
        If the IPsec-VPN connection is in the **updating** state, the destination-based route is being created.
        If the IPsec-VPN connection is in the **attached** state, the destination-based route is created.
        You cannot repeatedly call **CreateVcoRouteEntry** within the specified period of time.
        
        @param request: CreateVcoRouteEntryRequest
        @return: CreateVcoRouteEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_vco_route_entry_with_options_async(request, runtime)

    def create_virtual_border_router_with_options(
        self,
        request: vpc_20160428_models.CreateVirtualBorderRouterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVirtualBorderRouterResponse:
        """
        @summary Creates a virtual border router (VBR).
        
        @description After you create a VBR, the VBR is in the *active** state.
        
        @param request: CreateVirtualBorderRouterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVirtualBorderRouterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.circuit_code):
            query['CircuitCode'] = request.circuit_code
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.enable_ipv_6):
            query['EnableIpv6'] = request.enable_ipv_6
        if not UtilClient.is_unset(request.local_gateway_ip):
            query['LocalGatewayIp'] = request.local_gateway_ip
        if not UtilClient.is_unset(request.local_ipv_6gateway_ip):
            query['LocalIpv6GatewayIp'] = request.local_ipv_6gateway_ip
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_gateway_ip):
            query['PeerGatewayIp'] = request.peer_gateway_ip
        if not UtilClient.is_unset(request.peer_ipv_6gateway_ip):
            query['PeerIpv6GatewayIp'] = request.peer_ipv_6gateway_ip
        if not UtilClient.is_unset(request.peering_ipv_6subnet_mask):
            query['PeeringIpv6SubnetMask'] = request.peering_ipv_6subnet_mask
        if not UtilClient.is_unset(request.peering_subnet_mask):
            query['PeeringSubnetMask'] = request.peering_subnet_mask
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.vbr_owner_id):
            query['VbrOwnerId'] = request.vbr_owner_id
        if not UtilClient.is_unset(request.vlan_id):
            query['VlanId'] = request.vlan_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVirtualBorderRouter',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVirtualBorderRouterResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_virtual_border_router_with_options_async(
        self,
        request: vpc_20160428_models.CreateVirtualBorderRouterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVirtualBorderRouterResponse:
        """
        @summary Creates a virtual border router (VBR).
        
        @description After you create a VBR, the VBR is in the *active** state.
        
        @param request: CreateVirtualBorderRouterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVirtualBorderRouterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.circuit_code):
            query['CircuitCode'] = request.circuit_code
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.enable_ipv_6):
            query['EnableIpv6'] = request.enable_ipv_6
        if not UtilClient.is_unset(request.local_gateway_ip):
            query['LocalGatewayIp'] = request.local_gateway_ip
        if not UtilClient.is_unset(request.local_ipv_6gateway_ip):
            query['LocalIpv6GatewayIp'] = request.local_ipv_6gateway_ip
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_gateway_ip):
            query['PeerGatewayIp'] = request.peer_gateway_ip
        if not UtilClient.is_unset(request.peer_ipv_6gateway_ip):
            query['PeerIpv6GatewayIp'] = request.peer_ipv_6gateway_ip
        if not UtilClient.is_unset(request.peering_ipv_6subnet_mask):
            query['PeeringIpv6SubnetMask'] = request.peering_ipv_6subnet_mask
        if not UtilClient.is_unset(request.peering_subnet_mask):
            query['PeeringSubnetMask'] = request.peering_subnet_mask
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.vbr_owner_id):
            query['VbrOwnerId'] = request.vbr_owner_id
        if not UtilClient.is_unset(request.vlan_id):
            query['VlanId'] = request.vlan_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVirtualBorderRouter',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVirtualBorderRouterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_virtual_border_router(
        self,
        request: vpc_20160428_models.CreateVirtualBorderRouterRequest,
    ) -> vpc_20160428_models.CreateVirtualBorderRouterResponse:
        """
        @summary Creates a virtual border router (VBR).
        
        @description After you create a VBR, the VBR is in the *active** state.
        
        @param request: CreateVirtualBorderRouterRequest
        @return: CreateVirtualBorderRouterResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_virtual_border_router_with_options(request, runtime)

    async def create_virtual_border_router_async(
        self,
        request: vpc_20160428_models.CreateVirtualBorderRouterRequest,
    ) -> vpc_20160428_models.CreateVirtualBorderRouterResponse:
        """
        @summary Creates a virtual border router (VBR).
        
        @description After you create a VBR, the VBR is in the *active** state.
        
        @param request: CreateVirtualBorderRouterRequest
        @return: CreateVirtualBorderRouterResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_virtual_border_router_with_options_async(request, runtime)

    def create_virtual_physical_connection_with_options(
        self,
        request: vpc_20160428_models.CreateVirtualPhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVirtualPhysicalConnectionResponse:
        """
        @summary Creates a hosted connection over Express Connect circuit.
        
        @description # [](#)Description
        Before you call this operation, we recommend that you learn about the workflow for creating a hosted connection and the environment requirements. For more information, see [Overview of hosted connections](https://help.aliyun.com/document_detail/146571.html) and [Operations performed by Express Connect partners](https://help.aliyun.com/document_detail/155987.html).
        
        @param request: CreateVirtualPhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVirtualPhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.order_mode):
            query['OrderMode'] = request.order_mode
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.spec):
            query['Spec'] = request.spec
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.token):
            query['Token'] = request.token
        if not UtilClient.is_unset(request.vlan_id):
            query['VlanId'] = request.vlan_id
        if not UtilClient.is_unset(request.vpconn_ali_uid):
            query['VpconnAliUid'] = request.vpconn_ali_uid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVirtualPhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVirtualPhysicalConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_virtual_physical_connection_with_options_async(
        self,
        request: vpc_20160428_models.CreateVirtualPhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVirtualPhysicalConnectionResponse:
        """
        @summary Creates a hosted connection over Express Connect circuit.
        
        @description # [](#)Description
        Before you call this operation, we recommend that you learn about the workflow for creating a hosted connection and the environment requirements. For more information, see [Overview of hosted connections](https://help.aliyun.com/document_detail/146571.html) and [Operations performed by Express Connect partners](https://help.aliyun.com/document_detail/155987.html).
        
        @param request: CreateVirtualPhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVirtualPhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.order_mode):
            query['OrderMode'] = request.order_mode
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.spec):
            query['Spec'] = request.spec
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.token):
            query['Token'] = request.token
        if not UtilClient.is_unset(request.vlan_id):
            query['VlanId'] = request.vlan_id
        if not UtilClient.is_unset(request.vpconn_ali_uid):
            query['VpconnAliUid'] = request.vpconn_ali_uid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVirtualPhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVirtualPhysicalConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_virtual_physical_connection(
        self,
        request: vpc_20160428_models.CreateVirtualPhysicalConnectionRequest,
    ) -> vpc_20160428_models.CreateVirtualPhysicalConnectionResponse:
        """
        @summary Creates a hosted connection over Express Connect circuit.
        
        @description # [](#)Description
        Before you call this operation, we recommend that you learn about the workflow for creating a hosted connection and the environment requirements. For more information, see [Overview of hosted connections](https://help.aliyun.com/document_detail/146571.html) and [Operations performed by Express Connect partners](https://help.aliyun.com/document_detail/155987.html).
        
        @param request: CreateVirtualPhysicalConnectionRequest
        @return: CreateVirtualPhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_virtual_physical_connection_with_options(request, runtime)

    async def create_virtual_physical_connection_async(
        self,
        request: vpc_20160428_models.CreateVirtualPhysicalConnectionRequest,
    ) -> vpc_20160428_models.CreateVirtualPhysicalConnectionResponse:
        """
        @summary Creates a hosted connection over Express Connect circuit.
        
        @description # [](#)Description
        Before you call this operation, we recommend that you learn about the workflow for creating a hosted connection and the environment requirements. For more information, see [Overview of hosted connections](https://help.aliyun.com/document_detail/146571.html) and [Operations performed by Express Connect partners](https://help.aliyun.com/document_detail/155987.html).
        
        @param request: CreateVirtualPhysicalConnectionRequest
        @return: CreateVirtualPhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_virtual_physical_connection_with_options_async(request, runtime)

    def create_vpc_with_options(
        self,
        request: vpc_20160428_models.CreateVpcRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVpcResponse:
        """
        @summary Creates a virtual private cloud (VPC).
        
        @description When you call this operation, take note of the following items:
        You can specify only one CIDR block for each VPC.
        After you create a VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to the VPC.
        In each VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
        After you create a VPC, a vRouter and a route table are automatically created.
        At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if both 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
        **CreateVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
        If the VPC is in the **Creating** state, the VPC is being created.
        If the VPC is in the **Created** state, the VPC is created.
        You cannot repeatedly call the **DeleteRouteEntry** operation to create default VPCs within a specific time period. However, you can repeatedly call this operation to create custom VPCs within a specific time period.
        
        @param request: CreateVpcRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVpcResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cidr_block):
            query['CidrBlock'] = request.cidr_block
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.enable_ipv_6):
            query['EnableIpv6'] = request.enable_ipv_6
        if not UtilClient.is_unset(request.ipv_4cidr_mask):
            query['Ipv4CidrMask'] = request.ipv_4cidr_mask
        if not UtilClient.is_unset(request.ipv_4ipam_pool_id):
            query['Ipv4IpamPoolId'] = request.ipv_4ipam_pool_id
        if not UtilClient.is_unset(request.ipv_6cidr_block):
            query['Ipv6CidrBlock'] = request.ipv_6cidr_block
        if not UtilClient.is_unset(request.ipv_6isp):
            query['Ipv6Isp'] = request.ipv_6isp
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        if not UtilClient.is_unset(request.vpc_name):
            query['VpcName'] = request.vpc_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVpc',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVpcResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_vpc_with_options_async(
        self,
        request: vpc_20160428_models.CreateVpcRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVpcResponse:
        """
        @summary Creates a virtual private cloud (VPC).
        
        @description When you call this operation, take note of the following items:
        You can specify only one CIDR block for each VPC.
        After you create a VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to the VPC.
        In each VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
        After you create a VPC, a vRouter and a route table are automatically created.
        At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if both 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
        **CreateVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
        If the VPC is in the **Creating** state, the VPC is being created.
        If the VPC is in the **Created** state, the VPC is created.
        You cannot repeatedly call the **DeleteRouteEntry** operation to create default VPCs within a specific time period. However, you can repeatedly call this operation to create custom VPCs within a specific time period.
        
        @param request: CreateVpcRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVpcResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cidr_block):
            query['CidrBlock'] = request.cidr_block
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.enable_ipv_6):
            query['EnableIpv6'] = request.enable_ipv_6
        if not UtilClient.is_unset(request.ipv_4cidr_mask):
            query['Ipv4CidrMask'] = request.ipv_4cidr_mask
        if not UtilClient.is_unset(request.ipv_4ipam_pool_id):
            query['Ipv4IpamPoolId'] = request.ipv_4ipam_pool_id
        if not UtilClient.is_unset(request.ipv_6cidr_block):
            query['Ipv6CidrBlock'] = request.ipv_6cidr_block
        if not UtilClient.is_unset(request.ipv_6isp):
            query['Ipv6Isp'] = request.ipv_6isp
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.user_cidr):
            query['UserCidr'] = request.user_cidr
        if not UtilClient.is_unset(request.vpc_name):
            query['VpcName'] = request.vpc_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVpc',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVpcResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_vpc(
        self,
        request: vpc_20160428_models.CreateVpcRequest,
    ) -> vpc_20160428_models.CreateVpcResponse:
        """
        @summary Creates a virtual private cloud (VPC).
        
        @description When you call this operation, take note of the following items:
        You can specify only one CIDR block for each VPC.
        After you create a VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to the VPC.
        In each VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
        After you create a VPC, a vRouter and a route table are automatically created.
        At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if both 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
        **CreateVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
        If the VPC is in the **Creating** state, the VPC is being created.
        If the VPC is in the **Created** state, the VPC is created.
        You cannot repeatedly call the **DeleteRouteEntry** operation to create default VPCs within a specific time period. However, you can repeatedly call this operation to create custom VPCs within a specific time period.
        
        @param request: CreateVpcRequest
        @return: CreateVpcResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_vpc_with_options(request, runtime)

    async def create_vpc_async(
        self,
        request: vpc_20160428_models.CreateVpcRequest,
    ) -> vpc_20160428_models.CreateVpcResponse:
        """
        @summary Creates a virtual private cloud (VPC).
        
        @description When you call this operation, take note of the following items:
        You can specify only one CIDR block for each VPC.
        After you create a VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to the VPC.
        In each VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
        After you create a VPC, a vRouter and a route table are automatically created.
        At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if both 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
        **CreateVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
        If the VPC is in the **Creating** state, the VPC is being created.
        If the VPC is in the **Created** state, the VPC is created.
        You cannot repeatedly call the **DeleteRouteEntry** operation to create default VPCs within a specific time period. However, you can repeatedly call this operation to create custom VPCs within a specific time period.
        
        @param request: CreateVpcRequest
        @return: CreateVpcResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_vpc_with_options_async(request, runtime)

    def create_vpc_gateway_endpoint_with_options(
        self,
        request: vpc_20160428_models.CreateVpcGatewayEndpointRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVpcGatewayEndpointResponse:
        """
        @summary Creates a gateway endpoint.
        
        @description    **CreateVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns an **EndpointId** and runs the task in the background. You can call the [ListVpcGatewayEndpoints](https://help.aliyun.com/document_detail/448682.html) operation to query the status of the task.
        If the gateway endpoint is in the **Creating** state, the gateway endpoint is being created.
        If the gateway endpoint is in the **Created** state, the gateway endpoint is created.
        You cannot repeatedly call the **CreateVpcGatewayEndpoint** operation for the same endpoint service within the specified period of time.
        
        @param request: CreateVpcGatewayEndpointRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVpcGatewayEndpointResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.endpoint_description):
            query['EndpointDescription'] = request.endpoint_description
        if not UtilClient.is_unset(request.endpoint_name):
            query['EndpointName'] = request.endpoint_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.policy_document):
            query['PolicyDocument'] = request.policy_document
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.service_name):
            query['ServiceName'] = request.service_name
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVpcGatewayEndpoint',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVpcGatewayEndpointResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_vpc_gateway_endpoint_with_options_async(
        self,
        request: vpc_20160428_models.CreateVpcGatewayEndpointRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVpcGatewayEndpointResponse:
        """
        @summary Creates a gateway endpoint.
        
        @description    **CreateVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns an **EndpointId** and runs the task in the background. You can call the [ListVpcGatewayEndpoints](https://help.aliyun.com/document_detail/448682.html) operation to query the status of the task.
        If the gateway endpoint is in the **Creating** state, the gateway endpoint is being created.
        If the gateway endpoint is in the **Created** state, the gateway endpoint is created.
        You cannot repeatedly call the **CreateVpcGatewayEndpoint** operation for the same endpoint service within the specified period of time.
        
        @param request: CreateVpcGatewayEndpointRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVpcGatewayEndpointResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.endpoint_description):
            query['EndpointDescription'] = request.endpoint_description
        if not UtilClient.is_unset(request.endpoint_name):
            query['EndpointName'] = request.endpoint_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.policy_document):
            query['PolicyDocument'] = request.policy_document
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.service_name):
            query['ServiceName'] = request.service_name
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVpcGatewayEndpoint',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVpcGatewayEndpointResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_vpc_gateway_endpoint(
        self,
        request: vpc_20160428_models.CreateVpcGatewayEndpointRequest,
    ) -> vpc_20160428_models.CreateVpcGatewayEndpointResponse:
        """
        @summary Creates a gateway endpoint.
        
        @description    **CreateVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns an **EndpointId** and runs the task in the background. You can call the [ListVpcGatewayEndpoints](https://help.aliyun.com/document_detail/448682.html) operation to query the status of the task.
        If the gateway endpoint is in the **Creating** state, the gateway endpoint is being created.
        If the gateway endpoint is in the **Created** state, the gateway endpoint is created.
        You cannot repeatedly call the **CreateVpcGatewayEndpoint** operation for the same endpoint service within the specified period of time.
        
        @param request: CreateVpcGatewayEndpointRequest
        @return: CreateVpcGatewayEndpointResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_vpc_gateway_endpoint_with_options(request, runtime)

    async def create_vpc_gateway_endpoint_async(
        self,
        request: vpc_20160428_models.CreateVpcGatewayEndpointRequest,
    ) -> vpc_20160428_models.CreateVpcGatewayEndpointResponse:
        """
        @summary Creates a gateway endpoint.
        
        @description    **CreateVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns an **EndpointId** and runs the task in the background. You can call the [ListVpcGatewayEndpoints](https://help.aliyun.com/document_detail/448682.html) operation to query the status of the task.
        If the gateway endpoint is in the **Creating** state, the gateway endpoint is being created.
        If the gateway endpoint is in the **Created** state, the gateway endpoint is created.
        You cannot repeatedly call the **CreateVpcGatewayEndpoint** operation for the same endpoint service within the specified period of time.
        
        @param request: CreateVpcGatewayEndpointRequest
        @return: CreateVpcGatewayEndpointResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_vpc_gateway_endpoint_with_options_async(request, runtime)

    def create_vpc_prefix_list_with_options(
        self,
        request: vpc_20160428_models.CreateVpcPrefixListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVpcPrefixListResponse:
        """
        @summary Creates a prefix list.
        
        @description You cannot repeatedly call the *CreateVpcPrefixList** operation within the specified period of time.
        
        @param request: CreateVpcPrefixListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVpcPrefixListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.ip_version):
            query['IpVersion'] = request.ip_version
        if not UtilClient.is_unset(request.max_entries):
            query['MaxEntries'] = request.max_entries
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_description):
            query['PrefixListDescription'] = request.prefix_list_description
        if not UtilClient.is_unset(request.prefix_list_entries):
            query['PrefixListEntries'] = request.prefix_list_entries
        if not UtilClient.is_unset(request.prefix_list_name):
            query['PrefixListName'] = request.prefix_list_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVpcPrefixList',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVpcPrefixListResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_vpc_prefix_list_with_options_async(
        self,
        request: vpc_20160428_models.CreateVpcPrefixListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVpcPrefixListResponse:
        """
        @summary Creates a prefix list.
        
        @description You cannot repeatedly call the *CreateVpcPrefixList** operation within the specified period of time.
        
        @param request: CreateVpcPrefixListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVpcPrefixListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.ip_version):
            query['IpVersion'] = request.ip_version
        if not UtilClient.is_unset(request.max_entries):
            query['MaxEntries'] = request.max_entries
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_description):
            query['PrefixListDescription'] = request.prefix_list_description
        if not UtilClient.is_unset(request.prefix_list_entries):
            query['PrefixListEntries'] = request.prefix_list_entries
        if not UtilClient.is_unset(request.prefix_list_name):
            query['PrefixListName'] = request.prefix_list_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVpcPrefixList',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVpcPrefixListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_vpc_prefix_list(
        self,
        request: vpc_20160428_models.CreateVpcPrefixListRequest,
    ) -> vpc_20160428_models.CreateVpcPrefixListResponse:
        """
        @summary Creates a prefix list.
        
        @description You cannot repeatedly call the *CreateVpcPrefixList** operation within the specified period of time.
        
        @param request: CreateVpcPrefixListRequest
        @return: CreateVpcPrefixListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_vpc_prefix_list_with_options(request, runtime)

    async def create_vpc_prefix_list_async(
        self,
        request: vpc_20160428_models.CreateVpcPrefixListRequest,
    ) -> vpc_20160428_models.CreateVpcPrefixListResponse:
        """
        @summary Creates a prefix list.
        
        @description You cannot repeatedly call the *CreateVpcPrefixList** operation within the specified period of time.
        
        @param request: CreateVpcPrefixListRequest
        @return: CreateVpcPrefixListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_vpc_prefix_list_with_options_async(request, runtime)

    def create_vpconn_from_vbr_with_options(
        self,
        request: vpc_20160428_models.CreateVpconnFromVbrRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVpconnFromVbrResponse:
        """
        @summary Adds a shared port to a hosted connection.
        
        @description If an Express Connect partner has created a virtual border router (VBR) for a tenant before, the Express Connect partner can push the Express Connect circuit that is associated with the VBR to the tenant account by adding a shared port for the tenant account. The service of the tenant is not interrupted in this process.
        Preparations:
        Before the Express Connect partner performs the operation, the Express Connect partner must notify the tenant and request the tenant to enable outbound data transfer billing. For more information, see [Enable outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html).
        What to do next:
        1.  After the Express Connect partner performs the operation, a shared port is added for the tenant account. The tenant must call the [ConfirmPhysicalConnection](https://help.aliyun.com/document_detail/324198.html) operation to accept the shared port.
        2.  Then, the Express Connect partner must call the [AttachVbrToVpconn](https://help.aliyun.com/document_detail/324191.html) operation to associate the VBR with the newly added shared port that belongs to the tenant account.
        
        @param request: CreateVpconnFromVbrRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVpconnFromVbrResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.order_mode):
            query['OrderMode'] = request.order_mode
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.token):
            query['Token'] = request.token
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVpconnFromVbr',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVpconnFromVbrResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_vpconn_from_vbr_with_options_async(
        self,
        request: vpc_20160428_models.CreateVpconnFromVbrRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVpconnFromVbrResponse:
        """
        @summary Adds a shared port to a hosted connection.
        
        @description If an Express Connect partner has created a virtual border router (VBR) for a tenant before, the Express Connect partner can push the Express Connect circuit that is associated with the VBR to the tenant account by adding a shared port for the tenant account. The service of the tenant is not interrupted in this process.
        Preparations:
        Before the Express Connect partner performs the operation, the Express Connect partner must notify the tenant and request the tenant to enable outbound data transfer billing. For more information, see [Enable outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html).
        What to do next:
        1.  After the Express Connect partner performs the operation, a shared port is added for the tenant account. The tenant must call the [ConfirmPhysicalConnection](https://help.aliyun.com/document_detail/324198.html) operation to accept the shared port.
        2.  Then, the Express Connect partner must call the [AttachVbrToVpconn](https://help.aliyun.com/document_detail/324191.html) operation to associate the VBR with the newly added shared port that belongs to the tenant account.
        
        @param request: CreateVpconnFromVbrRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVpconnFromVbrResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.order_mode):
            query['OrderMode'] = request.order_mode
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.token):
            query['Token'] = request.token
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVpconnFromVbr',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVpconnFromVbrResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_vpconn_from_vbr(
        self,
        request: vpc_20160428_models.CreateVpconnFromVbrRequest,
    ) -> vpc_20160428_models.CreateVpconnFromVbrResponse:
        """
        @summary Adds a shared port to a hosted connection.
        
        @description If an Express Connect partner has created a virtual border router (VBR) for a tenant before, the Express Connect partner can push the Express Connect circuit that is associated with the VBR to the tenant account by adding a shared port for the tenant account. The service of the tenant is not interrupted in this process.
        Preparations:
        Before the Express Connect partner performs the operation, the Express Connect partner must notify the tenant and request the tenant to enable outbound data transfer billing. For more information, see [Enable outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html).
        What to do next:
        1.  After the Express Connect partner performs the operation, a shared port is added for the tenant account. The tenant must call the [ConfirmPhysicalConnection](https://help.aliyun.com/document_detail/324198.html) operation to accept the shared port.
        2.  Then, the Express Connect partner must call the [AttachVbrToVpconn](https://help.aliyun.com/document_detail/324191.html) operation to associate the VBR with the newly added shared port that belongs to the tenant account.
        
        @param request: CreateVpconnFromVbrRequest
        @return: CreateVpconnFromVbrResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_vpconn_from_vbr_with_options(request, runtime)

    async def create_vpconn_from_vbr_async(
        self,
        request: vpc_20160428_models.CreateVpconnFromVbrRequest,
    ) -> vpc_20160428_models.CreateVpconnFromVbrResponse:
        """
        @summary Adds a shared port to a hosted connection.
        
        @description If an Express Connect partner has created a virtual border router (VBR) for a tenant before, the Express Connect partner can push the Express Connect circuit that is associated with the VBR to the tenant account by adding a shared port for the tenant account. The service of the tenant is not interrupted in this process.
        Preparations:
        Before the Express Connect partner performs the operation, the Express Connect partner must notify the tenant and request the tenant to enable outbound data transfer billing. For more information, see [Enable outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html).
        What to do next:
        1.  After the Express Connect partner performs the operation, a shared port is added for the tenant account. The tenant must call the [ConfirmPhysicalConnection](https://help.aliyun.com/document_detail/324198.html) operation to accept the shared port.
        2.  Then, the Express Connect partner must call the [AttachVbrToVpconn](https://help.aliyun.com/document_detail/324191.html) operation to associate the VBR with the newly added shared port that belongs to the tenant account.
        
        @param request: CreateVpconnFromVbrRequest
        @return: CreateVpconnFromVbrResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_vpconn_from_vbr_with_options_async(request, runtime)

    def create_vpn_attachment_with_options(
        self,
        request: vpc_20160428_models.CreateVpnAttachmentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVpnAttachmentResponse:
        """
        @summary Creates an IPsec-VPN connection. After you create the IPsec-VPN connection, you can associate the IPsec-VPN connection with a transit router.
        
        @description By default, an IPsec-VPN connection created by calling the `CreateVpnAttachment` operation is not associated with a resource. You can associate an IPsec-VPN connection with a transit router by calling the [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/443993.html) operation.
        ### [](#)Prerequisites
        Before you create an IPsec-VPN connection, make sure that you created a customer gateway in the region where you want to create the IPsec-VPN connection. For more information, see [CreateCustomerGateway](https://help.aliyun.com/document_detail/120368.html).
        If you want to add BGP configurations to an IPsec-VPN connection, make sure that an autonomous system number (ASN) is assigned to the customer gateway.
        
        @param request: CreateVpnAttachmentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVpnAttachmentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_config_route):
            query['AutoConfigRoute'] = request.auto_config_route
        if not UtilClient.is_unset(request.bgp_config):
            query['BgpConfig'] = request.bgp_config
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.customer_gateway_id):
            query['CustomerGatewayId'] = request.customer_gateway_id
        if not UtilClient.is_unset(request.effect_immediately):
            query['EffectImmediately'] = request.effect_immediately
        if not UtilClient.is_unset(request.enable_dpd):
            query['EnableDpd'] = request.enable_dpd
        if not UtilClient.is_unset(request.enable_nat_traversal):
            query['EnableNatTraversal'] = request.enable_nat_traversal
        if not UtilClient.is_unset(request.health_check_config):
            query['HealthCheckConfig'] = request.health_check_config
        if not UtilClient.is_unset(request.ike_config):
            query['IkeConfig'] = request.ike_config
        if not UtilClient.is_unset(request.ipsec_config):
            query['IpsecConfig'] = request.ipsec_config
        if not UtilClient.is_unset(request.local_subnet):
            query['LocalSubnet'] = request.local_subnet
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remote_ca_cert):
            query['RemoteCaCert'] = request.remote_ca_cert
        if not UtilClient.is_unset(request.remote_subnet):
            query['RemoteSubnet'] = request.remote_subnet
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVpnAttachment',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVpnAttachmentResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_vpn_attachment_with_options_async(
        self,
        request: vpc_20160428_models.CreateVpnAttachmentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVpnAttachmentResponse:
        """
        @summary Creates an IPsec-VPN connection. After you create the IPsec-VPN connection, you can associate the IPsec-VPN connection with a transit router.
        
        @description By default, an IPsec-VPN connection created by calling the `CreateVpnAttachment` operation is not associated with a resource. You can associate an IPsec-VPN connection with a transit router by calling the [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/443993.html) operation.
        ### [](#)Prerequisites
        Before you create an IPsec-VPN connection, make sure that you created a customer gateway in the region where you want to create the IPsec-VPN connection. For more information, see [CreateCustomerGateway](https://help.aliyun.com/document_detail/120368.html).
        If you want to add BGP configurations to an IPsec-VPN connection, make sure that an autonomous system number (ASN) is assigned to the customer gateway.
        
        @param request: CreateVpnAttachmentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVpnAttachmentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_config_route):
            query['AutoConfigRoute'] = request.auto_config_route
        if not UtilClient.is_unset(request.bgp_config):
            query['BgpConfig'] = request.bgp_config
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.customer_gateway_id):
            query['CustomerGatewayId'] = request.customer_gateway_id
        if not UtilClient.is_unset(request.effect_immediately):
            query['EffectImmediately'] = request.effect_immediately
        if not UtilClient.is_unset(request.enable_dpd):
            query['EnableDpd'] = request.enable_dpd
        if not UtilClient.is_unset(request.enable_nat_traversal):
            query['EnableNatTraversal'] = request.enable_nat_traversal
        if not UtilClient.is_unset(request.health_check_config):
            query['HealthCheckConfig'] = request.health_check_config
        if not UtilClient.is_unset(request.ike_config):
            query['IkeConfig'] = request.ike_config
        if not UtilClient.is_unset(request.ipsec_config):
            query['IpsecConfig'] = request.ipsec_config
        if not UtilClient.is_unset(request.local_subnet):
            query['LocalSubnet'] = request.local_subnet
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remote_ca_cert):
            query['RemoteCaCert'] = request.remote_ca_cert
        if not UtilClient.is_unset(request.remote_subnet):
            query['RemoteSubnet'] = request.remote_subnet
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVpnAttachment',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVpnAttachmentResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_vpn_attachment(
        self,
        request: vpc_20160428_models.CreateVpnAttachmentRequest,
    ) -> vpc_20160428_models.CreateVpnAttachmentResponse:
        """
        @summary Creates an IPsec-VPN connection. After you create the IPsec-VPN connection, you can associate the IPsec-VPN connection with a transit router.
        
        @description By default, an IPsec-VPN connection created by calling the `CreateVpnAttachment` operation is not associated with a resource. You can associate an IPsec-VPN connection with a transit router by calling the [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/443993.html) operation.
        ### [](#)Prerequisites
        Before you create an IPsec-VPN connection, make sure that you created a customer gateway in the region where you want to create the IPsec-VPN connection. For more information, see [CreateCustomerGateway](https://help.aliyun.com/document_detail/120368.html).
        If you want to add BGP configurations to an IPsec-VPN connection, make sure that an autonomous system number (ASN) is assigned to the customer gateway.
        
        @param request: CreateVpnAttachmentRequest
        @return: CreateVpnAttachmentResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_vpn_attachment_with_options(request, runtime)

    async def create_vpn_attachment_async(
        self,
        request: vpc_20160428_models.CreateVpnAttachmentRequest,
    ) -> vpc_20160428_models.CreateVpnAttachmentResponse:
        """
        @summary Creates an IPsec-VPN connection. After you create the IPsec-VPN connection, you can associate the IPsec-VPN connection with a transit router.
        
        @description By default, an IPsec-VPN connection created by calling the `CreateVpnAttachment` operation is not associated with a resource. You can associate an IPsec-VPN connection with a transit router by calling the [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/443993.html) operation.
        ### [](#)Prerequisites
        Before you create an IPsec-VPN connection, make sure that you created a customer gateway in the region where you want to create the IPsec-VPN connection. For more information, see [CreateCustomerGateway](https://help.aliyun.com/document_detail/120368.html).
        If you want to add BGP configurations to an IPsec-VPN connection, make sure that an autonomous system number (ASN) is assigned to the customer gateway.
        
        @param request: CreateVpnAttachmentRequest
        @return: CreateVpnAttachmentResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_vpn_attachment_with_options_async(request, runtime)

    def create_vpn_connection_with_options(
        self,
        request: vpc_20160428_models.CreateVpnConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVpnConnectionResponse:
        """
        @summary Creates an IPsec-VPN connection.
        
        @description    If the VPN gateway supports the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
        *ClientToken**, **Name**, **EffectImmediately**, **AutoConfigRoute**, **Tags** array, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
        For more information about the regions and zones that support the dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
        If the VPN gateway supports only the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
        *ClientToken**, **CustomerGatewayId**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **RemoteCaCertificate**, and **Tags** array.
        **CreateVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If the VPN gateway is in the **updating** state, the IPsec-VPN connection is being created.
        If the VPN gateway is in the **active** state, the IPsec-VPN connection is created.
        You cannot call **CreateVpnConnection** to create multiple IPsec-VPN connections associated with a VPN gateway at the same time.
        
        @param request: CreateVpnConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVpnConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_config_route):
            query['AutoConfigRoute'] = request.auto_config_route
        if not UtilClient.is_unset(request.bgp_config):
            query['BgpConfig'] = request.bgp_config
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.customer_gateway_id):
            query['CustomerGatewayId'] = request.customer_gateway_id
        if not UtilClient.is_unset(request.effect_immediately):
            query['EffectImmediately'] = request.effect_immediately
        if not UtilClient.is_unset(request.enable_dpd):
            query['EnableDpd'] = request.enable_dpd
        if not UtilClient.is_unset(request.enable_nat_traversal):
            query['EnableNatTraversal'] = request.enable_nat_traversal
        if not UtilClient.is_unset(request.enable_tunnels_bgp):
            query['EnableTunnelsBgp'] = request.enable_tunnels_bgp
        if not UtilClient.is_unset(request.health_check_config):
            query['HealthCheckConfig'] = request.health_check_config
        if not UtilClient.is_unset(request.ike_config):
            query['IkeConfig'] = request.ike_config
        if not UtilClient.is_unset(request.ipsec_config):
            query['IpsecConfig'] = request.ipsec_config
        if not UtilClient.is_unset(request.local_subnet):
            query['LocalSubnet'] = request.local_subnet
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remote_ca_certificate):
            query['RemoteCaCertificate'] = request.remote_ca_certificate
        if not UtilClient.is_unset(request.remote_subnet):
            query['RemoteSubnet'] = request.remote_subnet
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        body = {}
        body_flat = {}
        if not UtilClient.is_unset(request.tunnel_options_specification):
            body_flat['TunnelOptionsSpecification'] = request.tunnel_options_specification
        body = TeaCore.merge(body,
            OpenApiUtilClient.query(body_flat))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateVpnConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVpnConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_vpn_connection_with_options_async(
        self,
        request: vpc_20160428_models.CreateVpnConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVpnConnectionResponse:
        """
        @summary Creates an IPsec-VPN connection.
        
        @description    If the VPN gateway supports the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
        *ClientToken**, **Name**, **EffectImmediately**, **AutoConfigRoute**, **Tags** array, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
        For more information about the regions and zones that support the dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
        If the VPN gateway supports only the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
        *ClientToken**, **CustomerGatewayId**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **RemoteCaCertificate**, and **Tags** array.
        **CreateVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If the VPN gateway is in the **updating** state, the IPsec-VPN connection is being created.
        If the VPN gateway is in the **active** state, the IPsec-VPN connection is created.
        You cannot call **CreateVpnConnection** to create multiple IPsec-VPN connections associated with a VPN gateway at the same time.
        
        @param request: CreateVpnConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVpnConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_config_route):
            query['AutoConfigRoute'] = request.auto_config_route
        if not UtilClient.is_unset(request.bgp_config):
            query['BgpConfig'] = request.bgp_config
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.customer_gateway_id):
            query['CustomerGatewayId'] = request.customer_gateway_id
        if not UtilClient.is_unset(request.effect_immediately):
            query['EffectImmediately'] = request.effect_immediately
        if not UtilClient.is_unset(request.enable_dpd):
            query['EnableDpd'] = request.enable_dpd
        if not UtilClient.is_unset(request.enable_nat_traversal):
            query['EnableNatTraversal'] = request.enable_nat_traversal
        if not UtilClient.is_unset(request.enable_tunnels_bgp):
            query['EnableTunnelsBgp'] = request.enable_tunnels_bgp
        if not UtilClient.is_unset(request.health_check_config):
            query['HealthCheckConfig'] = request.health_check_config
        if not UtilClient.is_unset(request.ike_config):
            query['IkeConfig'] = request.ike_config
        if not UtilClient.is_unset(request.ipsec_config):
            query['IpsecConfig'] = request.ipsec_config
        if not UtilClient.is_unset(request.local_subnet):
            query['LocalSubnet'] = request.local_subnet
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remote_ca_certificate):
            query['RemoteCaCertificate'] = request.remote_ca_certificate
        if not UtilClient.is_unset(request.remote_subnet):
            query['RemoteSubnet'] = request.remote_subnet
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        body = {}
        body_flat = {}
        if not UtilClient.is_unset(request.tunnel_options_specification):
            body_flat['TunnelOptionsSpecification'] = request.tunnel_options_specification
        body = TeaCore.merge(body,
            OpenApiUtilClient.query(body_flat))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateVpnConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVpnConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_vpn_connection(
        self,
        request: vpc_20160428_models.CreateVpnConnectionRequest,
    ) -> vpc_20160428_models.CreateVpnConnectionResponse:
        """
        @summary Creates an IPsec-VPN connection.
        
        @description    If the VPN gateway supports the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
        *ClientToken**, **Name**, **EffectImmediately**, **AutoConfigRoute**, **Tags** array, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
        For more information about the regions and zones that support the dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
        If the VPN gateway supports only the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
        *ClientToken**, **CustomerGatewayId**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **RemoteCaCertificate**, and **Tags** array.
        **CreateVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If the VPN gateway is in the **updating** state, the IPsec-VPN connection is being created.
        If the VPN gateway is in the **active** state, the IPsec-VPN connection is created.
        You cannot call **CreateVpnConnection** to create multiple IPsec-VPN connections associated with a VPN gateway at the same time.
        
        @param request: CreateVpnConnectionRequest
        @return: CreateVpnConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_vpn_connection_with_options(request, runtime)

    async def create_vpn_connection_async(
        self,
        request: vpc_20160428_models.CreateVpnConnectionRequest,
    ) -> vpc_20160428_models.CreateVpnConnectionResponse:
        """
        @summary Creates an IPsec-VPN connection.
        
        @description    If the VPN gateway supports the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
        *ClientToken**, **Name**, **EffectImmediately**, **AutoConfigRoute**, **Tags** array, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
        For more information about the regions and zones that support the dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
        If the VPN gateway supports only the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
        *ClientToken**, **CustomerGatewayId**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **RemoteCaCertificate**, and **Tags** array.
        **CreateVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If the VPN gateway is in the **updating** state, the IPsec-VPN connection is being created.
        If the VPN gateway is in the **active** state, the IPsec-VPN connection is created.
        You cannot call **CreateVpnConnection** to create multiple IPsec-VPN connections associated with a VPN gateway at the same time.
        
        @param request: CreateVpnConnectionRequest
        @return: CreateVpnConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_vpn_connection_with_options_async(request, runtime)

    def create_vpn_gateway_with_options(
        self,
        request: vpc_20160428_models.CreateVpnGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVpnGatewayResponse:
        """
        @summary Creates a VPN gateway.
        
        @description    Before you create a VPN gateway, we recommend that you know more about the limits of VPN gateways. For more information, see the [Limits](https://help.aliyun.com/document_detail/65290.html) section in the "Create and manage a VPN gateway" topic.
        VPN gateways in some regions support only IPsec-VPN connections in dual-tunnel mode. If you call `CreateVpnGateway` in these regions, you must specify **VSwitchId** and **DisasterRecoveryVSwitchId** in addition to the required parameters. For more information about the regions and zones that support the IPsec-VPN connections in dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
        **CreateVpnGateway** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the endpoint service is being created in the backend. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
        If the VPN gateway is in the **provisioning** state, the VPN gateway is being created.
        If the VPN gateway is in the **active** state, the VPN gateway is created.
        
        @param request: CreateVpnGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVpnGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.disaster_recovery_vswitch_id):
            query['DisasterRecoveryVSwitchId'] = request.disaster_recovery_vswitch_id
        if not UtilClient.is_unset(request.enable_ipsec):
            query['EnableIpsec'] = request.enable_ipsec
        if not UtilClient.is_unset(request.enable_ssl):
            query['EnableSsl'] = request.enable_ssl
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.ssl_connections):
            query['SslConnections'] = request.ssl_connections
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.vpn_type):
            query['VpnType'] = request.vpn_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVpnGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVpnGatewayResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_vpn_gateway_with_options_async(
        self,
        request: vpc_20160428_models.CreateVpnGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVpnGatewayResponse:
        """
        @summary Creates a VPN gateway.
        
        @description    Before you create a VPN gateway, we recommend that you know more about the limits of VPN gateways. For more information, see the [Limits](https://help.aliyun.com/document_detail/65290.html) section in the "Create and manage a VPN gateway" topic.
        VPN gateways in some regions support only IPsec-VPN connections in dual-tunnel mode. If you call `CreateVpnGateway` in these regions, you must specify **VSwitchId** and **DisasterRecoveryVSwitchId** in addition to the required parameters. For more information about the regions and zones that support the IPsec-VPN connections in dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
        **CreateVpnGateway** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the endpoint service is being created in the backend. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
        If the VPN gateway is in the **provisioning** state, the VPN gateway is being created.
        If the VPN gateway is in the **active** state, the VPN gateway is created.
        
        @param request: CreateVpnGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVpnGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.disaster_recovery_vswitch_id):
            query['DisasterRecoveryVSwitchId'] = request.disaster_recovery_vswitch_id
        if not UtilClient.is_unset(request.enable_ipsec):
            query['EnableIpsec'] = request.enable_ipsec
        if not UtilClient.is_unset(request.enable_ssl):
            query['EnableSsl'] = request.enable_ssl
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.ssl_connections):
            query['SslConnections'] = request.ssl_connections
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.vpn_type):
            query['VpnType'] = request.vpn_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVpnGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVpnGatewayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_vpn_gateway(
        self,
        request: vpc_20160428_models.CreateVpnGatewayRequest,
    ) -> vpc_20160428_models.CreateVpnGatewayResponse:
        """
        @summary Creates a VPN gateway.
        
        @description    Before you create a VPN gateway, we recommend that you know more about the limits of VPN gateways. For more information, see the [Limits](https://help.aliyun.com/document_detail/65290.html) section in the "Create and manage a VPN gateway" topic.
        VPN gateways in some regions support only IPsec-VPN connections in dual-tunnel mode. If you call `CreateVpnGateway` in these regions, you must specify **VSwitchId** and **DisasterRecoveryVSwitchId** in addition to the required parameters. For more information about the regions and zones that support the IPsec-VPN connections in dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
        **CreateVpnGateway** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the endpoint service is being created in the backend. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
        If the VPN gateway is in the **provisioning** state, the VPN gateway is being created.
        If the VPN gateway is in the **active** state, the VPN gateway is created.
        
        @param request: CreateVpnGatewayRequest
        @return: CreateVpnGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_vpn_gateway_with_options(request, runtime)

    async def create_vpn_gateway_async(
        self,
        request: vpc_20160428_models.CreateVpnGatewayRequest,
    ) -> vpc_20160428_models.CreateVpnGatewayResponse:
        """
        @summary Creates a VPN gateway.
        
        @description    Before you create a VPN gateway, we recommend that you know more about the limits of VPN gateways. For more information, see the [Limits](https://help.aliyun.com/document_detail/65290.html) section in the "Create and manage a VPN gateway" topic.
        VPN gateways in some regions support only IPsec-VPN connections in dual-tunnel mode. If you call `CreateVpnGateway` in these regions, you must specify **VSwitchId** and **DisasterRecoveryVSwitchId** in addition to the required parameters. For more information about the regions and zones that support the IPsec-VPN connections in dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
        **CreateVpnGateway** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the endpoint service is being created in the backend. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
        If the VPN gateway is in the **provisioning** state, the VPN gateway is being created.
        If the VPN gateway is in the **active** state, the VPN gateway is created.
        
        @param request: CreateVpnGatewayRequest
        @return: CreateVpnGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_vpn_gateway_with_options_async(request, runtime)

    def create_vpn_pbr_route_entry_with_options(
        self,
        request: vpc_20160428_models.CreateVpnPbrRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVpnPbrRouteEntryResponse:
        """
        @summary Creates a policy-based route for a VPN gateway.
        
        @description    Before you call this operation, make sure that you are familiar with the match rules of and limits on policy-based routes. For more information, see [Manage policy-based routes](https://help.aliyun.com/document_detail/110777.html).
        Before you create a policy-based route, make sure that an IPsec-VPN connection is created. For more information, see [CreateVpnConnection](https://help.aliyun.com/document_detail/120391.html).
        **CreateVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the VPN gateway.
        If the VPN gateway is in the **updating** state, the policy-based route is being created.
        If the VPN gateway is in the **active** state, the policy-based route is created.
        You cannot call the **CreateVpnPbrRouteEntry** operation to create multiple policy-based routes for a VPN gateway at a time.
        
        @param request: CreateVpnPbrRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVpnPbrRouteEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.overlay_mode):
            query['OverlayMode'] = request.overlay_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.publish_vpc):
            query['PublishVpc'] = request.publish_vpc
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.route_source):
            query['RouteSource'] = request.route_source
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVpnPbrRouteEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVpnPbrRouteEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_vpn_pbr_route_entry_with_options_async(
        self,
        request: vpc_20160428_models.CreateVpnPbrRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVpnPbrRouteEntryResponse:
        """
        @summary Creates a policy-based route for a VPN gateway.
        
        @description    Before you call this operation, make sure that you are familiar with the match rules of and limits on policy-based routes. For more information, see [Manage policy-based routes](https://help.aliyun.com/document_detail/110777.html).
        Before you create a policy-based route, make sure that an IPsec-VPN connection is created. For more information, see [CreateVpnConnection](https://help.aliyun.com/document_detail/120391.html).
        **CreateVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the VPN gateway.
        If the VPN gateway is in the **updating** state, the policy-based route is being created.
        If the VPN gateway is in the **active** state, the policy-based route is created.
        You cannot call the **CreateVpnPbrRouteEntry** operation to create multiple policy-based routes for a VPN gateway at a time.
        
        @param request: CreateVpnPbrRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVpnPbrRouteEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.overlay_mode):
            query['OverlayMode'] = request.overlay_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.publish_vpc):
            query['PublishVpc'] = request.publish_vpc
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.route_source):
            query['RouteSource'] = request.route_source
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVpnPbrRouteEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVpnPbrRouteEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_vpn_pbr_route_entry(
        self,
        request: vpc_20160428_models.CreateVpnPbrRouteEntryRequest,
    ) -> vpc_20160428_models.CreateVpnPbrRouteEntryResponse:
        """
        @summary Creates a policy-based route for a VPN gateway.
        
        @description    Before you call this operation, make sure that you are familiar with the match rules of and limits on policy-based routes. For more information, see [Manage policy-based routes](https://help.aliyun.com/document_detail/110777.html).
        Before you create a policy-based route, make sure that an IPsec-VPN connection is created. For more information, see [CreateVpnConnection](https://help.aliyun.com/document_detail/120391.html).
        **CreateVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the VPN gateway.
        If the VPN gateway is in the **updating** state, the policy-based route is being created.
        If the VPN gateway is in the **active** state, the policy-based route is created.
        You cannot call the **CreateVpnPbrRouteEntry** operation to create multiple policy-based routes for a VPN gateway at a time.
        
        @param request: CreateVpnPbrRouteEntryRequest
        @return: CreateVpnPbrRouteEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_vpn_pbr_route_entry_with_options(request, runtime)

    async def create_vpn_pbr_route_entry_async(
        self,
        request: vpc_20160428_models.CreateVpnPbrRouteEntryRequest,
    ) -> vpc_20160428_models.CreateVpnPbrRouteEntryResponse:
        """
        @summary Creates a policy-based route for a VPN gateway.
        
        @description    Before you call this operation, make sure that you are familiar with the match rules of and limits on policy-based routes. For more information, see [Manage policy-based routes](https://help.aliyun.com/document_detail/110777.html).
        Before you create a policy-based route, make sure that an IPsec-VPN connection is created. For more information, see [CreateVpnConnection](https://help.aliyun.com/document_detail/120391.html).
        **CreateVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the VPN gateway.
        If the VPN gateway is in the **updating** state, the policy-based route is being created.
        If the VPN gateway is in the **active** state, the policy-based route is created.
        You cannot call the **CreateVpnPbrRouteEntry** operation to create multiple policy-based routes for a VPN gateway at a time.
        
        @param request: CreateVpnPbrRouteEntryRequest
        @return: CreateVpnPbrRouteEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_vpn_pbr_route_entry_with_options_async(request, runtime)

    def create_vpn_route_entry_with_options(
        self,
        request: vpc_20160428_models.CreateVpnRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVpnRouteEntryResponse:
        """
        @summary Creates a destination-based route entry for a VPN gateway.
        
        @description    **CreateVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the destination-based route entry is being created.
        If a VPN gateway is in the **active** state, the destination-based route entry has been created.
        You cannot repeatedly call **CreateVpnRouteEntry** to create a destination-based route entry for a VPN gateway within the specified period of time.
        
        @param request: CreateVpnRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVpnRouteEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.overlay_mode):
            query['OverlayMode'] = request.overlay_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.publish_vpc):
            query['PublishVpc'] = request.publish_vpc
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVpnRouteEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVpnRouteEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_vpn_route_entry_with_options_async(
        self,
        request: vpc_20160428_models.CreateVpnRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.CreateVpnRouteEntryResponse:
        """
        @summary Creates a destination-based route entry for a VPN gateway.
        
        @description    **CreateVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the destination-based route entry is being created.
        If a VPN gateway is in the **active** state, the destination-based route entry has been created.
        You cannot repeatedly call **CreateVpnRouteEntry** to create a destination-based route entry for a VPN gateway within the specified period of time.
        
        @param request: CreateVpnRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVpnRouteEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.overlay_mode):
            query['OverlayMode'] = request.overlay_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.publish_vpc):
            query['PublishVpc'] = request.publish_vpc
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVpnRouteEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.CreateVpnRouteEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_vpn_route_entry(
        self,
        request: vpc_20160428_models.CreateVpnRouteEntryRequest,
    ) -> vpc_20160428_models.CreateVpnRouteEntryResponse:
        """
        @summary Creates a destination-based route entry for a VPN gateway.
        
        @description    **CreateVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the destination-based route entry is being created.
        If a VPN gateway is in the **active** state, the destination-based route entry has been created.
        You cannot repeatedly call **CreateVpnRouteEntry** to create a destination-based route entry for a VPN gateway within the specified period of time.
        
        @param request: CreateVpnRouteEntryRequest
        @return: CreateVpnRouteEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_vpn_route_entry_with_options(request, runtime)

    async def create_vpn_route_entry_async(
        self,
        request: vpc_20160428_models.CreateVpnRouteEntryRequest,
    ) -> vpc_20160428_models.CreateVpnRouteEntryResponse:
        """
        @summary Creates a destination-based route entry for a VPN gateway.
        
        @description    **CreateVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the destination-based route entry is being created.
        If a VPN gateway is in the **active** state, the destination-based route entry has been created.
        You cannot repeatedly call **CreateVpnRouteEntry** to create a destination-based route entry for a VPN gateway within the specified period of time.
        
        @param request: CreateVpnRouteEntryRequest
        @return: CreateVpnRouteEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_vpn_route_entry_with_options_async(request, runtime)

    def deactivate_router_interface_with_options(
        self,
        request: vpc_20160428_models.DeactivateRouterInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeactivateRouterInterfaceResponse:
        """
        @summary 
        
        @param request: DeactivateRouterInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeactivateRouterInterfaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeactivateRouterInterface',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeactivateRouterInterfaceResponse(),
            self.call_api(params, req, runtime)
        )

    async def deactivate_router_interface_with_options_async(
        self,
        request: vpc_20160428_models.DeactivateRouterInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeactivateRouterInterfaceResponse:
        """
        @summary 
        
        @param request: DeactivateRouterInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeactivateRouterInterfaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeactivateRouterInterface',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeactivateRouterInterfaceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def deactivate_router_interface(
        self,
        request: vpc_20160428_models.DeactivateRouterInterfaceRequest,
    ) -> vpc_20160428_models.DeactivateRouterInterfaceResponse:
        """
        @summary 
        
        @param request: DeactivateRouterInterfaceRequest
        @return: DeactivateRouterInterfaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.deactivate_router_interface_with_options(request, runtime)

    async def deactivate_router_interface_async(
        self,
        request: vpc_20160428_models.DeactivateRouterInterfaceRequest,
    ) -> vpc_20160428_models.DeactivateRouterInterfaceResponse:
        """
        @summary 
        
        @param request: DeactivateRouterInterfaceRequest
        @return: DeactivateRouterInterfaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.deactivate_router_interface_with_options_async(request, runtime)

    def deactive_flow_log_with_options(
        self,
        request: vpc_20160428_models.DeactiveFlowLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeactiveFlowLogResponse:
        """
        @summary Disables a flow log. After a flow log is disabled, the system no longer captures the traffic information about a resource.
        
        @description    The **DeactiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
        If the flow log is in the **Deactivating** state, the flow log is being disabled.
        If the flow log is in the **Inactive** state, the flow log is disabled.
        You cannot repeatedly call the **DeactiveFlowLog** operation to disable a flow log within the specified period of time.
        
        @param request: DeactiveFlowLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeactiveFlowLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.flow_log_id):
            query['FlowLogId'] = request.flow_log_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeactiveFlowLog',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeactiveFlowLogResponse(),
            self.call_api(params, req, runtime)
        )

    async def deactive_flow_log_with_options_async(
        self,
        request: vpc_20160428_models.DeactiveFlowLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeactiveFlowLogResponse:
        """
        @summary Disables a flow log. After a flow log is disabled, the system no longer captures the traffic information about a resource.
        
        @description    The **DeactiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
        If the flow log is in the **Deactivating** state, the flow log is being disabled.
        If the flow log is in the **Inactive** state, the flow log is disabled.
        You cannot repeatedly call the **DeactiveFlowLog** operation to disable a flow log within the specified period of time.
        
        @param request: DeactiveFlowLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeactiveFlowLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.flow_log_id):
            query['FlowLogId'] = request.flow_log_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeactiveFlowLog',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeactiveFlowLogResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def deactive_flow_log(
        self,
        request: vpc_20160428_models.DeactiveFlowLogRequest,
    ) -> vpc_20160428_models.DeactiveFlowLogResponse:
        """
        @summary Disables a flow log. After a flow log is disabled, the system no longer captures the traffic information about a resource.
        
        @description    The **DeactiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
        If the flow log is in the **Deactivating** state, the flow log is being disabled.
        If the flow log is in the **Inactive** state, the flow log is disabled.
        You cannot repeatedly call the **DeactiveFlowLog** operation to disable a flow log within the specified period of time.
        
        @param request: DeactiveFlowLogRequest
        @return: DeactiveFlowLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.deactive_flow_log_with_options(request, runtime)

    async def deactive_flow_log_async(
        self,
        request: vpc_20160428_models.DeactiveFlowLogRequest,
    ) -> vpc_20160428_models.DeactiveFlowLogResponse:
        """
        @summary Disables a flow log. After a flow log is disabled, the system no longer captures the traffic information about a resource.
        
        @description    The **DeactiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
        If the flow log is in the **Deactivating** state, the flow log is being disabled.
        If the flow log is in the **Inactive** state, the flow log is disabled.
        You cannot repeatedly call the **DeactiveFlowLog** operation to disable a flow log within the specified period of time.
        
        @param request: DeactiveFlowLogRequest
        @return: DeactiveFlowLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.deactive_flow_log_with_options_async(request, runtime)

    def delete_bgp_group_with_options(
        self,
        request: vpc_20160428_models.DeleteBgpGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteBgpGroupResponse:
        """
        @summary Deletes a Border Gateway Protocol (BGP) group.
        
        @param request: DeleteBgpGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteBgpGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bgp_group_id):
            query['BgpGroupId'] = request.bgp_group_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteBgpGroup',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteBgpGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_bgp_group_with_options_async(
        self,
        request: vpc_20160428_models.DeleteBgpGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteBgpGroupResponse:
        """
        @summary Deletes a Border Gateway Protocol (BGP) group.
        
        @param request: DeleteBgpGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteBgpGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bgp_group_id):
            query['BgpGroupId'] = request.bgp_group_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteBgpGroup',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteBgpGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_bgp_group(
        self,
        request: vpc_20160428_models.DeleteBgpGroupRequest,
    ) -> vpc_20160428_models.DeleteBgpGroupResponse:
        """
        @summary Deletes a Border Gateway Protocol (BGP) group.
        
        @param request: DeleteBgpGroupRequest
        @return: DeleteBgpGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_bgp_group_with_options(request, runtime)

    async def delete_bgp_group_async(
        self,
        request: vpc_20160428_models.DeleteBgpGroupRequest,
    ) -> vpc_20160428_models.DeleteBgpGroupResponse:
        """
        @summary Deletes a Border Gateway Protocol (BGP) group.
        
        @param request: DeleteBgpGroupRequest
        @return: DeleteBgpGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_bgp_group_with_options_async(request, runtime)

    def delete_bgp_network_with_options(
        self,
        request: vpc_20160428_models.DeleteBgpNetworkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteBgpNetworkResponse:
        """
        @summary Deletes an advertised Border Gateway Protocol (BGP) network.
        
        @param request: DeleteBgpNetworkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteBgpNetworkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dst_cidr_block):
            query['DstCidrBlock'] = request.dst_cidr_block
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteBgpNetwork',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteBgpNetworkResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_bgp_network_with_options_async(
        self,
        request: vpc_20160428_models.DeleteBgpNetworkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteBgpNetworkResponse:
        """
        @summary Deletes an advertised Border Gateway Protocol (BGP) network.
        
        @param request: DeleteBgpNetworkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteBgpNetworkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dst_cidr_block):
            query['DstCidrBlock'] = request.dst_cidr_block
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteBgpNetwork',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteBgpNetworkResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_bgp_network(
        self,
        request: vpc_20160428_models.DeleteBgpNetworkRequest,
    ) -> vpc_20160428_models.DeleteBgpNetworkResponse:
        """
        @summary Deletes an advertised Border Gateway Protocol (BGP) network.
        
        @param request: DeleteBgpNetworkRequest
        @return: DeleteBgpNetworkResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_bgp_network_with_options(request, runtime)

    async def delete_bgp_network_async(
        self,
        request: vpc_20160428_models.DeleteBgpNetworkRequest,
    ) -> vpc_20160428_models.DeleteBgpNetworkResponse:
        """
        @summary Deletes an advertised Border Gateway Protocol (BGP) network.
        
        @param request: DeleteBgpNetworkRequest
        @return: DeleteBgpNetworkResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_bgp_network_with_options_async(request, runtime)

    def delete_bgp_peer_with_options(
        self,
        request: vpc_20160428_models.DeleteBgpPeerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteBgpPeerResponse:
        """
        @summary Deletes a Border Gateway Protocol (BGP) peer.
        
        @param request: DeleteBgpPeerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteBgpPeerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bgp_peer_id):
            query['BgpPeerId'] = request.bgp_peer_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteBgpPeer',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteBgpPeerResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_bgp_peer_with_options_async(
        self,
        request: vpc_20160428_models.DeleteBgpPeerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteBgpPeerResponse:
        """
        @summary Deletes a Border Gateway Protocol (BGP) peer.
        
        @param request: DeleteBgpPeerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteBgpPeerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bgp_peer_id):
            query['BgpPeerId'] = request.bgp_peer_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteBgpPeer',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteBgpPeerResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_bgp_peer(
        self,
        request: vpc_20160428_models.DeleteBgpPeerRequest,
    ) -> vpc_20160428_models.DeleteBgpPeerResponse:
        """
        @summary Deletes a Border Gateway Protocol (BGP) peer.
        
        @param request: DeleteBgpPeerRequest
        @return: DeleteBgpPeerResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_bgp_peer_with_options(request, runtime)

    async def delete_bgp_peer_async(
        self,
        request: vpc_20160428_models.DeleteBgpPeerRequest,
    ) -> vpc_20160428_models.DeleteBgpPeerResponse:
        """
        @summary Deletes a Border Gateway Protocol (BGP) peer.
        
        @param request: DeleteBgpPeerRequest
        @return: DeleteBgpPeerResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_bgp_peer_with_options_async(request, runtime)

    def delete_common_bandwidth_package_with_options(
        self,
        request: vpc_20160428_models.DeleteCommonBandwidthPackageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteCommonBandwidthPackageResponse:
        """
        @summary Deletes an Internet Shared Bandwidth instance.
        
        @description You cannot repeatedly call the *DeleteCommonBandwidthPackage** operation to delete an Internet Shared Bandwidth instance within the specified period of time.
        
        @param request: DeleteCommonBandwidthPackageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCommonBandwidthPackageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCommonBandwidthPackage',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteCommonBandwidthPackageResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_common_bandwidth_package_with_options_async(
        self,
        request: vpc_20160428_models.DeleteCommonBandwidthPackageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteCommonBandwidthPackageResponse:
        """
        @summary Deletes an Internet Shared Bandwidth instance.
        
        @description You cannot repeatedly call the *DeleteCommonBandwidthPackage** operation to delete an Internet Shared Bandwidth instance within the specified period of time.
        
        @param request: DeleteCommonBandwidthPackageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCommonBandwidthPackageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCommonBandwidthPackage',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteCommonBandwidthPackageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_common_bandwidth_package(
        self,
        request: vpc_20160428_models.DeleteCommonBandwidthPackageRequest,
    ) -> vpc_20160428_models.DeleteCommonBandwidthPackageResponse:
        """
        @summary Deletes an Internet Shared Bandwidth instance.
        
        @description You cannot repeatedly call the *DeleteCommonBandwidthPackage** operation to delete an Internet Shared Bandwidth instance within the specified period of time.
        
        @param request: DeleteCommonBandwidthPackageRequest
        @return: DeleteCommonBandwidthPackageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_common_bandwidth_package_with_options(request, runtime)

    async def delete_common_bandwidth_package_async(
        self,
        request: vpc_20160428_models.DeleteCommonBandwidthPackageRequest,
    ) -> vpc_20160428_models.DeleteCommonBandwidthPackageResponse:
        """
        @summary Deletes an Internet Shared Bandwidth instance.
        
        @description You cannot repeatedly call the *DeleteCommonBandwidthPackage** operation to delete an Internet Shared Bandwidth instance within the specified period of time.
        
        @param request: DeleteCommonBandwidthPackageRequest
        @return: DeleteCommonBandwidthPackageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_common_bandwidth_package_with_options_async(request, runtime)

    def delete_customer_gateway_with_options(
        self,
        request: vpc_20160428_models.DeleteCustomerGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteCustomerGatewayResponse:
        """
        @summary Deletes a customer gateway.
        
        @description Before you delete a customer gateway, make sure that no IPsec-VPN connection is associated with the customer gateway. For more information about how to delete an IPsec-VPN connection, see [DeleteVpnAttachment](https://help.aliyun.com/document_detail/2526938.html) or [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
        
        @param request: DeleteCustomerGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCustomerGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.customer_gateway_id):
            query['CustomerGatewayId'] = request.customer_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCustomerGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteCustomerGatewayResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_customer_gateway_with_options_async(
        self,
        request: vpc_20160428_models.DeleteCustomerGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteCustomerGatewayResponse:
        """
        @summary Deletes a customer gateway.
        
        @description Before you delete a customer gateway, make sure that no IPsec-VPN connection is associated with the customer gateway. For more information about how to delete an IPsec-VPN connection, see [DeleteVpnAttachment](https://help.aliyun.com/document_detail/2526938.html) or [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
        
        @param request: DeleteCustomerGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCustomerGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.customer_gateway_id):
            query['CustomerGatewayId'] = request.customer_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCustomerGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteCustomerGatewayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_customer_gateway(
        self,
        request: vpc_20160428_models.DeleteCustomerGatewayRequest,
    ) -> vpc_20160428_models.DeleteCustomerGatewayResponse:
        """
        @summary Deletes a customer gateway.
        
        @description Before you delete a customer gateway, make sure that no IPsec-VPN connection is associated with the customer gateway. For more information about how to delete an IPsec-VPN connection, see [DeleteVpnAttachment](https://help.aliyun.com/document_detail/2526938.html) or [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
        
        @param request: DeleteCustomerGatewayRequest
        @return: DeleteCustomerGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_customer_gateway_with_options(request, runtime)

    async def delete_customer_gateway_async(
        self,
        request: vpc_20160428_models.DeleteCustomerGatewayRequest,
    ) -> vpc_20160428_models.DeleteCustomerGatewayResponse:
        """
        @summary Deletes a customer gateway.
        
        @description Before you delete a customer gateway, make sure that no IPsec-VPN connection is associated with the customer gateway. For more information about how to delete an IPsec-VPN connection, see [DeleteVpnAttachment](https://help.aliyun.com/document_detail/2526938.html) or [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
        
        @param request: DeleteCustomerGatewayRequest
        @return: DeleteCustomerGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_customer_gateway_with_options_async(request, runtime)

    def delete_dhcp_options_set_with_options(
        self,
        request: vpc_20160428_models.DeleteDhcpOptionsSetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteDhcpOptionsSetResponse:
        """
        @summary Deletes a DHCP options set.
        
        @description ## [](#)Description
        **DeleteDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/189208.html) operation to query the status of the task.
        If the DHCP options set is in the **Deleting** state, the DHCP options set is being deleted.
        If you cannot query the DHCP options set, the DHCP options set is deleted.
        You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a DHCP options set within the specified period of time.
        
        @param request: DeleteDhcpOptionsSetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDhcpOptionsSetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dhcp_options_set_id):
            query['DhcpOptionsSetId'] = request.dhcp_options_set_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDhcpOptionsSet',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteDhcpOptionsSetResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_dhcp_options_set_with_options_async(
        self,
        request: vpc_20160428_models.DeleteDhcpOptionsSetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteDhcpOptionsSetResponse:
        """
        @summary Deletes a DHCP options set.
        
        @description ## [](#)Description
        **DeleteDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/189208.html) operation to query the status of the task.
        If the DHCP options set is in the **Deleting** state, the DHCP options set is being deleted.
        If you cannot query the DHCP options set, the DHCP options set is deleted.
        You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a DHCP options set within the specified period of time.
        
        @param request: DeleteDhcpOptionsSetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDhcpOptionsSetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dhcp_options_set_id):
            query['DhcpOptionsSetId'] = request.dhcp_options_set_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDhcpOptionsSet',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteDhcpOptionsSetResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_dhcp_options_set(
        self,
        request: vpc_20160428_models.DeleteDhcpOptionsSetRequest,
    ) -> vpc_20160428_models.DeleteDhcpOptionsSetResponse:
        """
        @summary Deletes a DHCP options set.
        
        @description ## [](#)Description
        **DeleteDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/189208.html) operation to query the status of the task.
        If the DHCP options set is in the **Deleting** state, the DHCP options set is being deleted.
        If you cannot query the DHCP options set, the DHCP options set is deleted.
        You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a DHCP options set within the specified period of time.
        
        @param request: DeleteDhcpOptionsSetRequest
        @return: DeleteDhcpOptionsSetResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_dhcp_options_set_with_options(request, runtime)

    async def delete_dhcp_options_set_async(
        self,
        request: vpc_20160428_models.DeleteDhcpOptionsSetRequest,
    ) -> vpc_20160428_models.DeleteDhcpOptionsSetResponse:
        """
        @summary Deletes a DHCP options set.
        
        @description ## [](#)Description
        **DeleteDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/189208.html) operation to query the status of the task.
        If the DHCP options set is in the **Deleting** state, the DHCP options set is being deleted.
        If you cannot query the DHCP options set, the DHCP options set is deleted.
        You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a DHCP options set within the specified period of time.
        
        @param request: DeleteDhcpOptionsSetRequest
        @return: DeleteDhcpOptionsSetResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_dhcp_options_set_with_options_async(request, runtime)

    def delete_express_connect_traffic_qos_with_options(
        self,
        request: vpc_20160428_models.DeleteExpressConnectTrafficQosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteExpressConnectTrafficQosResponse:
        """
        @summary Qos
        
        @param request: DeleteExpressConnectTrafficQosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteExpressConnectTrafficQosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.qos_id):
            query['QosId'] = request.qos_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteExpressConnectTrafficQos',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteExpressConnectTrafficQosResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_express_connect_traffic_qos_with_options_async(
        self,
        request: vpc_20160428_models.DeleteExpressConnectTrafficQosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteExpressConnectTrafficQosResponse:
        """
        @summary Qos
        
        @param request: DeleteExpressConnectTrafficQosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteExpressConnectTrafficQosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.qos_id):
            query['QosId'] = request.qos_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteExpressConnectTrafficQos',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteExpressConnectTrafficQosResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_express_connect_traffic_qos(
        self,
        request: vpc_20160428_models.DeleteExpressConnectTrafficQosRequest,
    ) -> vpc_20160428_models.DeleteExpressConnectTrafficQosResponse:
        """
        @summary Qos
        
        @param request: DeleteExpressConnectTrafficQosRequest
        @return: DeleteExpressConnectTrafficQosResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_express_connect_traffic_qos_with_options(request, runtime)

    async def delete_express_connect_traffic_qos_async(
        self,
        request: vpc_20160428_models.DeleteExpressConnectTrafficQosRequest,
    ) -> vpc_20160428_models.DeleteExpressConnectTrafficQosResponse:
        """
        @summary Qos
        
        @param request: DeleteExpressConnectTrafficQosRequest
        @return: DeleteExpressConnectTrafficQosResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_express_connect_traffic_qos_with_options_async(request, runtime)

    def delete_express_connect_traffic_qos_queue_with_options(
        self,
        request: vpc_20160428_models.DeleteExpressConnectTrafficQosQueueRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteExpressConnectTrafficQosQueueResponse:
        """
        @summary Qos
        
        @param request: DeleteExpressConnectTrafficQosQueueRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteExpressConnectTrafficQosQueueResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.qos_id):
            query['QosId'] = request.qos_id
        if not UtilClient.is_unset(request.queue_id):
            query['QueueId'] = request.queue_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteExpressConnectTrafficQosQueue',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteExpressConnectTrafficQosQueueResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_express_connect_traffic_qos_queue_with_options_async(
        self,
        request: vpc_20160428_models.DeleteExpressConnectTrafficQosQueueRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteExpressConnectTrafficQosQueueResponse:
        """
        @summary Qos
        
        @param request: DeleteExpressConnectTrafficQosQueueRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteExpressConnectTrafficQosQueueResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.qos_id):
            query['QosId'] = request.qos_id
        if not UtilClient.is_unset(request.queue_id):
            query['QueueId'] = request.queue_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteExpressConnectTrafficQosQueue',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteExpressConnectTrafficQosQueueResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_express_connect_traffic_qos_queue(
        self,
        request: vpc_20160428_models.DeleteExpressConnectTrafficQosQueueRequest,
    ) -> vpc_20160428_models.DeleteExpressConnectTrafficQosQueueResponse:
        """
        @summary Qos
        
        @param request: DeleteExpressConnectTrafficQosQueueRequest
        @return: DeleteExpressConnectTrafficQosQueueResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_express_connect_traffic_qos_queue_with_options(request, runtime)

    async def delete_express_connect_traffic_qos_queue_async(
        self,
        request: vpc_20160428_models.DeleteExpressConnectTrafficQosQueueRequest,
    ) -> vpc_20160428_models.DeleteExpressConnectTrafficQosQueueResponse:
        """
        @summary Qos
        
        @param request: DeleteExpressConnectTrafficQosQueueRequest
        @return: DeleteExpressConnectTrafficQosQueueResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_express_connect_traffic_qos_queue_with_options_async(request, runtime)

    def delete_express_connect_traffic_qos_rule_with_options(
        self,
        request: vpc_20160428_models.DeleteExpressConnectTrafficQosRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteExpressConnectTrafficQosRuleResponse:
        """
        @summary Qos
        
        @param request: DeleteExpressConnectTrafficQosRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteExpressConnectTrafficQosRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.qos_id):
            query['QosId'] = request.qos_id
        if not UtilClient.is_unset(request.queue_id):
            query['QueueId'] = request.queue_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.rule_id):
            query['RuleId'] = request.rule_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteExpressConnectTrafficQosRule',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteExpressConnectTrafficQosRuleResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_express_connect_traffic_qos_rule_with_options_async(
        self,
        request: vpc_20160428_models.DeleteExpressConnectTrafficQosRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteExpressConnectTrafficQosRuleResponse:
        """
        @summary Qos
        
        @param request: DeleteExpressConnectTrafficQosRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteExpressConnectTrafficQosRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.qos_id):
            query['QosId'] = request.qos_id
        if not UtilClient.is_unset(request.queue_id):
            query['QueueId'] = request.queue_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.rule_id):
            query['RuleId'] = request.rule_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteExpressConnectTrafficQosRule',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteExpressConnectTrafficQosRuleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_express_connect_traffic_qos_rule(
        self,
        request: vpc_20160428_models.DeleteExpressConnectTrafficQosRuleRequest,
    ) -> vpc_20160428_models.DeleteExpressConnectTrafficQosRuleResponse:
        """
        @summary Qos
        
        @param request: DeleteExpressConnectTrafficQosRuleRequest
        @return: DeleteExpressConnectTrafficQosRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_express_connect_traffic_qos_rule_with_options(request, runtime)

    async def delete_express_connect_traffic_qos_rule_async(
        self,
        request: vpc_20160428_models.DeleteExpressConnectTrafficQosRuleRequest,
    ) -> vpc_20160428_models.DeleteExpressConnectTrafficQosRuleResponse:
        """
        @summary Qos
        
        @param request: DeleteExpressConnectTrafficQosRuleRequest
        @return: DeleteExpressConnectTrafficQosRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_express_connect_traffic_qos_rule_with_options_async(request, runtime)

    def delete_failover_test_job_with_options(
        self,
        request: vpc_20160428_models.DeleteFailoverTestJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteFailoverTestJobResponse:
        """
        @summary 
        
        @param request: DeleteFailoverTestJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteFailoverTestJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteFailoverTestJob',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteFailoverTestJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_failover_test_job_with_options_async(
        self,
        request: vpc_20160428_models.DeleteFailoverTestJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteFailoverTestJobResponse:
        """
        @summary 
        
        @param request: DeleteFailoverTestJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteFailoverTestJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteFailoverTestJob',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteFailoverTestJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_failover_test_job(
        self,
        request: vpc_20160428_models.DeleteFailoverTestJobRequest,
    ) -> vpc_20160428_models.DeleteFailoverTestJobResponse:
        """
        @summary 
        
        @param request: DeleteFailoverTestJobRequest
        @return: DeleteFailoverTestJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_failover_test_job_with_options(request, runtime)

    async def delete_failover_test_job_async(
        self,
        request: vpc_20160428_models.DeleteFailoverTestJobRequest,
    ) -> vpc_20160428_models.DeleteFailoverTestJobResponse:
        """
        @summary 
        
        @param request: DeleteFailoverTestJobRequest
        @return: DeleteFailoverTestJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_failover_test_job_with_options_async(request, runtime)

    def delete_flow_log_with_options(
        self,
        request: vpc_20160428_models.DeleteFlowLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteFlowLogResponse:
        """
        @summary Deletes a flow log.
        
        @description    The **DeleteFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
        If the flow log is in the **Deleting** state, the flow log is being deleted.
        If you cannot query the flow log, the flow log is deleted.
        You cannot repeatedly call the **DeleteFlowLog** operation to delete a flow log within the specified period of time.
        
        @param request: DeleteFlowLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteFlowLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.flow_log_id):
            query['FlowLogId'] = request.flow_log_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteFlowLog',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteFlowLogResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_flow_log_with_options_async(
        self,
        request: vpc_20160428_models.DeleteFlowLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteFlowLogResponse:
        """
        @summary Deletes a flow log.
        
        @description    The **DeleteFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
        If the flow log is in the **Deleting** state, the flow log is being deleted.
        If you cannot query the flow log, the flow log is deleted.
        You cannot repeatedly call the **DeleteFlowLog** operation to delete a flow log within the specified period of time.
        
        @param request: DeleteFlowLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteFlowLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.flow_log_id):
            query['FlowLogId'] = request.flow_log_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteFlowLog',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteFlowLogResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_flow_log(
        self,
        request: vpc_20160428_models.DeleteFlowLogRequest,
    ) -> vpc_20160428_models.DeleteFlowLogResponse:
        """
        @summary Deletes a flow log.
        
        @description    The **DeleteFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
        If the flow log is in the **Deleting** state, the flow log is being deleted.
        If you cannot query the flow log, the flow log is deleted.
        You cannot repeatedly call the **DeleteFlowLog** operation to delete a flow log within the specified period of time.
        
        @param request: DeleteFlowLogRequest
        @return: DeleteFlowLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_flow_log_with_options(request, runtime)

    async def delete_flow_log_async(
        self,
        request: vpc_20160428_models.DeleteFlowLogRequest,
    ) -> vpc_20160428_models.DeleteFlowLogResponse:
        """
        @summary Deletes a flow log.
        
        @description    The **DeleteFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
        If the flow log is in the **Deleting** state, the flow log is being deleted.
        If you cannot query the flow log, the flow log is deleted.
        You cannot repeatedly call the **DeleteFlowLog** operation to delete a flow log within the specified period of time.
        
        @param request: DeleteFlowLogRequest
        @return: DeleteFlowLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_flow_log_with_options_async(request, runtime)

    def delete_forward_entry_with_options(
        self,
        request: vpc_20160428_models.DeleteForwardEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteForwardEntryResponse:
        """
        @summary Deletes a DNAT entry.
        
        @description ## [](#)Description
        **DeleteForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
        If the DNAT entry is in the **Deleting** state, the system is deleting the DNAT entry. In this case, you can only query the status of the DNAT entry, but cannot perform other operations.
        If the DNAT entry cannot be found, it is deleted.
        >  If a DNAT table has DNAT entries in the *Pending** state, you cannot delete the DNAT entries.
        You cannot repeatedly call the **DeleteForwardEntry** operation to delete a DNAT entry within the specified period of time.
        
        @param request: DeleteForwardEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteForwardEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.forward_entry_id):
            query['ForwardEntryId'] = request.forward_entry_id
        if not UtilClient.is_unset(request.forward_table_id):
            query['ForwardTableId'] = request.forward_table_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteForwardEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteForwardEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_forward_entry_with_options_async(
        self,
        request: vpc_20160428_models.DeleteForwardEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteForwardEntryResponse:
        """
        @summary Deletes a DNAT entry.
        
        @description ## [](#)Description
        **DeleteForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
        If the DNAT entry is in the **Deleting** state, the system is deleting the DNAT entry. In this case, you can only query the status of the DNAT entry, but cannot perform other operations.
        If the DNAT entry cannot be found, it is deleted.
        >  If a DNAT table has DNAT entries in the *Pending** state, you cannot delete the DNAT entries.
        You cannot repeatedly call the **DeleteForwardEntry** operation to delete a DNAT entry within the specified period of time.
        
        @param request: DeleteForwardEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteForwardEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.forward_entry_id):
            query['ForwardEntryId'] = request.forward_entry_id
        if not UtilClient.is_unset(request.forward_table_id):
            query['ForwardTableId'] = request.forward_table_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteForwardEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteForwardEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_forward_entry(
        self,
        request: vpc_20160428_models.DeleteForwardEntryRequest,
    ) -> vpc_20160428_models.DeleteForwardEntryResponse:
        """
        @summary Deletes a DNAT entry.
        
        @description ## [](#)Description
        **DeleteForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
        If the DNAT entry is in the **Deleting** state, the system is deleting the DNAT entry. In this case, you can only query the status of the DNAT entry, but cannot perform other operations.
        If the DNAT entry cannot be found, it is deleted.
        >  If a DNAT table has DNAT entries in the *Pending** state, you cannot delete the DNAT entries.
        You cannot repeatedly call the **DeleteForwardEntry** operation to delete a DNAT entry within the specified period of time.
        
        @param request: DeleteForwardEntryRequest
        @return: DeleteForwardEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_forward_entry_with_options(request, runtime)

    async def delete_forward_entry_async(
        self,
        request: vpc_20160428_models.DeleteForwardEntryRequest,
    ) -> vpc_20160428_models.DeleteForwardEntryResponse:
        """
        @summary Deletes a DNAT entry.
        
        @description ## [](#)Description
        **DeleteForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
        If the DNAT entry is in the **Deleting** state, the system is deleting the DNAT entry. In this case, you can only query the status of the DNAT entry, but cannot perform other operations.
        If the DNAT entry cannot be found, it is deleted.
        >  If a DNAT table has DNAT entries in the *Pending** state, you cannot delete the DNAT entries.
        You cannot repeatedly call the **DeleteForwardEntry** operation to delete a DNAT entry within the specified period of time.
        
        @param request: DeleteForwardEntryRequest
        @return: DeleteForwardEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_forward_entry_with_options_async(request, runtime)

    def delete_full_nat_entry_with_options(
        self,
        request: vpc_20160428_models.DeleteFullNatEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteFullNatEntryResponse:
        """
        @summary Deletes a FULLNAT entry.
        
        @description ## [](#)Description
        *DeleteFullNatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
        If the FULLNAT entry is in the **Deleting** state, the system is deleting the FULLNAT entry. In this case, you can query the status of the FULLNAT entry, but cannot perform other operations.
        If the FULLNAT entry cannot be found, the FULLNAT entry is deleted.
        You cannot repeatedly call the *DeleteFullNatEntry** operation to delete a FULLNAT entry within the specified period of time.
        
        @param request: DeleteFullNatEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteFullNatEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.full_nat_entry_id):
            query['FullNatEntryId'] = request.full_nat_entry_id
        if not UtilClient.is_unset(request.full_nat_table_id):
            query['FullNatTableId'] = request.full_nat_table_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteFullNatEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteFullNatEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_full_nat_entry_with_options_async(
        self,
        request: vpc_20160428_models.DeleteFullNatEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteFullNatEntryResponse:
        """
        @summary Deletes a FULLNAT entry.
        
        @description ## [](#)Description
        *DeleteFullNatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
        If the FULLNAT entry is in the **Deleting** state, the system is deleting the FULLNAT entry. In this case, you can query the status of the FULLNAT entry, but cannot perform other operations.
        If the FULLNAT entry cannot be found, the FULLNAT entry is deleted.
        You cannot repeatedly call the *DeleteFullNatEntry** operation to delete a FULLNAT entry within the specified period of time.
        
        @param request: DeleteFullNatEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteFullNatEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.full_nat_entry_id):
            query['FullNatEntryId'] = request.full_nat_entry_id
        if not UtilClient.is_unset(request.full_nat_table_id):
            query['FullNatTableId'] = request.full_nat_table_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteFullNatEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteFullNatEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_full_nat_entry(
        self,
        request: vpc_20160428_models.DeleteFullNatEntryRequest,
    ) -> vpc_20160428_models.DeleteFullNatEntryResponse:
        """
        @summary Deletes a FULLNAT entry.
        
        @description ## [](#)Description
        *DeleteFullNatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
        If the FULLNAT entry is in the **Deleting** state, the system is deleting the FULLNAT entry. In this case, you can query the status of the FULLNAT entry, but cannot perform other operations.
        If the FULLNAT entry cannot be found, the FULLNAT entry is deleted.
        You cannot repeatedly call the *DeleteFullNatEntry** operation to delete a FULLNAT entry within the specified period of time.
        
        @param request: DeleteFullNatEntryRequest
        @return: DeleteFullNatEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_full_nat_entry_with_options(request, runtime)

    async def delete_full_nat_entry_async(
        self,
        request: vpc_20160428_models.DeleteFullNatEntryRequest,
    ) -> vpc_20160428_models.DeleteFullNatEntryResponse:
        """
        @summary Deletes a FULLNAT entry.
        
        @description ## [](#)Description
        *DeleteFullNatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
        If the FULLNAT entry is in the **Deleting** state, the system is deleting the FULLNAT entry. In this case, you can query the status of the FULLNAT entry, but cannot perform other operations.
        If the FULLNAT entry cannot be found, the FULLNAT entry is deleted.
        You cannot repeatedly call the *DeleteFullNatEntry** operation to delete a FULLNAT entry within the specified period of time.
        
        @param request: DeleteFullNatEntryRequest
        @return: DeleteFullNatEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_full_nat_entry_with_options_async(request, runtime)

    def delete_global_acceleration_instance_with_options(
        self,
        request: vpc_20160428_models.DeleteGlobalAccelerationInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteGlobalAccelerationInstanceResponse:
        """
        @summary Deletes a Global Accelerator (GA) instance.
        
        @description When you call this operation, take note of the following items:
        You can delete only pay-as-you-go instances.
        Before you can delete a dedicated instance, disassociate the backend server from the instance first.
        Before you can delete a shared instance, disassociate the elastic IP address (EIP) from the instance first.
        
        @param request: DeleteGlobalAccelerationInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteGlobalAccelerationInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.global_acceleration_instance_id):
            query['GlobalAccelerationInstanceId'] = request.global_acceleration_instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteGlobalAccelerationInstance',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteGlobalAccelerationInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_global_acceleration_instance_with_options_async(
        self,
        request: vpc_20160428_models.DeleteGlobalAccelerationInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteGlobalAccelerationInstanceResponse:
        """
        @summary Deletes a Global Accelerator (GA) instance.
        
        @description When you call this operation, take note of the following items:
        You can delete only pay-as-you-go instances.
        Before you can delete a dedicated instance, disassociate the backend server from the instance first.
        Before you can delete a shared instance, disassociate the elastic IP address (EIP) from the instance first.
        
        @param request: DeleteGlobalAccelerationInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteGlobalAccelerationInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.global_acceleration_instance_id):
            query['GlobalAccelerationInstanceId'] = request.global_acceleration_instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteGlobalAccelerationInstance',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteGlobalAccelerationInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_global_acceleration_instance(
        self,
        request: vpc_20160428_models.DeleteGlobalAccelerationInstanceRequest,
    ) -> vpc_20160428_models.DeleteGlobalAccelerationInstanceResponse:
        """
        @summary Deletes a Global Accelerator (GA) instance.
        
        @description When you call this operation, take note of the following items:
        You can delete only pay-as-you-go instances.
        Before you can delete a dedicated instance, disassociate the backend server from the instance first.
        Before you can delete a shared instance, disassociate the elastic IP address (EIP) from the instance first.
        
        @param request: DeleteGlobalAccelerationInstanceRequest
        @return: DeleteGlobalAccelerationInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_global_acceleration_instance_with_options(request, runtime)

    async def delete_global_acceleration_instance_async(
        self,
        request: vpc_20160428_models.DeleteGlobalAccelerationInstanceRequest,
    ) -> vpc_20160428_models.DeleteGlobalAccelerationInstanceResponse:
        """
        @summary Deletes a Global Accelerator (GA) instance.
        
        @description When you call this operation, take note of the following items:
        You can delete only pay-as-you-go instances.
        Before you can delete a dedicated instance, disassociate the backend server from the instance first.
        Before you can delete a shared instance, disassociate the elastic IP address (EIP) from the instance first.
        
        @param request: DeleteGlobalAccelerationInstanceRequest
        @return: DeleteGlobalAccelerationInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_global_acceleration_instance_with_options_async(request, runtime)

    def delete_ha_vip_with_options(
        self,
        request: vpc_20160428_models.DeleteHaVipRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteHaVipResponse:
        """
        @summary Deletes a high-availability virtual IP address (HAVIP).
        
        @description When you call this operation, take note of the following rules:
        You can delete only HAVIPs that are in the Available state.
        Make sure that no route points to the HAVIP that you want to delete.
        Make sure that no elastic IP address (EIP) is associated with the HAVIP that you want to delete.
        The **DeleteHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HAVIP:
        If the HAVIP is in the **Deleting** state, the HAVIP is being deleted.
        If you cannot query the HAVIP, the HAVIP is deleted.
        You cannot repeatedly call the **DeleteHaVip** operation to delete an HAVIP within the specified period of time.
        
        @param request: DeleteHaVipRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteHaVipResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ha_vip_id):
            query['HaVipId'] = request.ha_vip_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteHaVip',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteHaVipResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_ha_vip_with_options_async(
        self,
        request: vpc_20160428_models.DeleteHaVipRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteHaVipResponse:
        """
        @summary Deletes a high-availability virtual IP address (HAVIP).
        
        @description When you call this operation, take note of the following rules:
        You can delete only HAVIPs that are in the Available state.
        Make sure that no route points to the HAVIP that you want to delete.
        Make sure that no elastic IP address (EIP) is associated with the HAVIP that you want to delete.
        The **DeleteHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HAVIP:
        If the HAVIP is in the **Deleting** state, the HAVIP is being deleted.
        If you cannot query the HAVIP, the HAVIP is deleted.
        You cannot repeatedly call the **DeleteHaVip** operation to delete an HAVIP within the specified period of time.
        
        @param request: DeleteHaVipRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteHaVipResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ha_vip_id):
            query['HaVipId'] = request.ha_vip_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteHaVip',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteHaVipResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_ha_vip(
        self,
        request: vpc_20160428_models.DeleteHaVipRequest,
    ) -> vpc_20160428_models.DeleteHaVipResponse:
        """
        @summary Deletes a high-availability virtual IP address (HAVIP).
        
        @description When you call this operation, take note of the following rules:
        You can delete only HAVIPs that are in the Available state.
        Make sure that no route points to the HAVIP that you want to delete.
        Make sure that no elastic IP address (EIP) is associated with the HAVIP that you want to delete.
        The **DeleteHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HAVIP:
        If the HAVIP is in the **Deleting** state, the HAVIP is being deleted.
        If you cannot query the HAVIP, the HAVIP is deleted.
        You cannot repeatedly call the **DeleteHaVip** operation to delete an HAVIP within the specified period of time.
        
        @param request: DeleteHaVipRequest
        @return: DeleteHaVipResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_ha_vip_with_options(request, runtime)

    async def delete_ha_vip_async(
        self,
        request: vpc_20160428_models.DeleteHaVipRequest,
    ) -> vpc_20160428_models.DeleteHaVipResponse:
        """
        @summary Deletes a high-availability virtual IP address (HAVIP).
        
        @description When you call this operation, take note of the following rules:
        You can delete only HAVIPs that are in the Available state.
        Make sure that no route points to the HAVIP that you want to delete.
        Make sure that no elastic IP address (EIP) is associated with the HAVIP that you want to delete.
        The **DeleteHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HAVIP:
        If the HAVIP is in the **Deleting** state, the HAVIP is being deleted.
        If you cannot query the HAVIP, the HAVIP is deleted.
        You cannot repeatedly call the **DeleteHaVip** operation to delete an HAVIP within the specified period of time.
        
        @param request: DeleteHaVipRequest
        @return: DeleteHaVipResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_ha_vip_with_options_async(request, runtime)

    def delete_ipv_6translator_with_options(
        self,
        request: vpc_20160428_models.DeleteIPv6TranslatorRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteIPv6TranslatorResponse:
        """
        @summary Deletes an IPv6 Translation Service instance.
        
        @param request: DeleteIPv6TranslatorRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIPv6TranslatorResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ipv_6translator_id):
            query['Ipv6TranslatorId'] = request.ipv_6translator_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIPv6Translator',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteIPv6TranslatorResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_ipv_6translator_with_options_async(
        self,
        request: vpc_20160428_models.DeleteIPv6TranslatorRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteIPv6TranslatorResponse:
        """
        @summary Deletes an IPv6 Translation Service instance.
        
        @param request: DeleteIPv6TranslatorRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIPv6TranslatorResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ipv_6translator_id):
            query['Ipv6TranslatorId'] = request.ipv_6translator_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIPv6Translator',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteIPv6TranslatorResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_ipv_6translator(
        self,
        request: vpc_20160428_models.DeleteIPv6TranslatorRequest,
    ) -> vpc_20160428_models.DeleteIPv6TranslatorResponse:
        """
        @summary Deletes an IPv6 Translation Service instance.
        
        @param request: DeleteIPv6TranslatorRequest
        @return: DeleteIPv6TranslatorResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_ipv_6translator_with_options(request, runtime)

    async def delete_ipv_6translator_async(
        self,
        request: vpc_20160428_models.DeleteIPv6TranslatorRequest,
    ) -> vpc_20160428_models.DeleteIPv6TranslatorResponse:
        """
        @summary Deletes an IPv6 Translation Service instance.
        
        @param request: DeleteIPv6TranslatorRequest
        @return: DeleteIPv6TranslatorResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_ipv_6translator_with_options_async(request, runtime)

    def delete_ipv_6translator_acl_list_with_options(
        self,
        request: vpc_20160428_models.DeleteIPv6TranslatorAclListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteIPv6TranslatorAclListResponse:
        """
        @deprecated OpenAPI DeleteIPv6TranslatorAclList is deprecated
        
        @summary Deletes an access control list (ACL). You can delete an ACL only when the ACL is not associated with IPv6 translation mappings.
        
        @param request: DeleteIPv6TranslatorAclListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIPv6TranslatorAclListResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_id):
            query['AclId'] = request.acl_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIPv6TranslatorAclList',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteIPv6TranslatorAclListResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_ipv_6translator_acl_list_with_options_async(
        self,
        request: vpc_20160428_models.DeleteIPv6TranslatorAclListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteIPv6TranslatorAclListResponse:
        """
        @deprecated OpenAPI DeleteIPv6TranslatorAclList is deprecated
        
        @summary Deletes an access control list (ACL). You can delete an ACL only when the ACL is not associated with IPv6 translation mappings.
        
        @param request: DeleteIPv6TranslatorAclListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIPv6TranslatorAclListResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_id):
            query['AclId'] = request.acl_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIPv6TranslatorAclList',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteIPv6TranslatorAclListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_ipv_6translator_acl_list(
        self,
        request: vpc_20160428_models.DeleteIPv6TranslatorAclListRequest,
    ) -> vpc_20160428_models.DeleteIPv6TranslatorAclListResponse:
        """
        @deprecated OpenAPI DeleteIPv6TranslatorAclList is deprecated
        
        @summary Deletes an access control list (ACL). You can delete an ACL only when the ACL is not associated with IPv6 translation mappings.
        
        @param request: DeleteIPv6TranslatorAclListRequest
        @return: DeleteIPv6TranslatorAclListResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_ipv_6translator_acl_list_with_options(request, runtime)

    async def delete_ipv_6translator_acl_list_async(
        self,
        request: vpc_20160428_models.DeleteIPv6TranslatorAclListRequest,
    ) -> vpc_20160428_models.DeleteIPv6TranslatorAclListResponse:
        """
        @deprecated OpenAPI DeleteIPv6TranslatorAclList is deprecated
        
        @summary Deletes an access control list (ACL). You can delete an ACL only when the ACL is not associated with IPv6 translation mappings.
        
        @param request: DeleteIPv6TranslatorAclListRequest
        @return: DeleteIPv6TranslatorAclListResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_ipv_6translator_acl_list_with_options_async(request, runtime)

    def delete_ipv_6translator_entry_with_options(
        self,
        request: vpc_20160428_models.DeleteIPv6TranslatorEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteIPv6TranslatorEntryResponse:
        """
        @deprecated OpenAPI DeleteIPv6TranslatorEntry is deprecated
        
        @summary Deletes an IPv6 mapping entry.
        
        @param request: DeleteIPv6TranslatorEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIPv6TranslatorEntryResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ipv_6translator_entry_id):
            query['Ipv6TranslatorEntryId'] = request.ipv_6translator_entry_id
        if not UtilClient.is_unset(request.ipv_6translator_id):
            query['Ipv6TranslatorId'] = request.ipv_6translator_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIPv6TranslatorEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteIPv6TranslatorEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_ipv_6translator_entry_with_options_async(
        self,
        request: vpc_20160428_models.DeleteIPv6TranslatorEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteIPv6TranslatorEntryResponse:
        """
        @deprecated OpenAPI DeleteIPv6TranslatorEntry is deprecated
        
        @summary Deletes an IPv6 mapping entry.
        
        @param request: DeleteIPv6TranslatorEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIPv6TranslatorEntryResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ipv_6translator_entry_id):
            query['Ipv6TranslatorEntryId'] = request.ipv_6translator_entry_id
        if not UtilClient.is_unset(request.ipv_6translator_id):
            query['Ipv6TranslatorId'] = request.ipv_6translator_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIPv6TranslatorEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteIPv6TranslatorEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_ipv_6translator_entry(
        self,
        request: vpc_20160428_models.DeleteIPv6TranslatorEntryRequest,
    ) -> vpc_20160428_models.DeleteIPv6TranslatorEntryResponse:
        """
        @deprecated OpenAPI DeleteIPv6TranslatorEntry is deprecated
        
        @summary Deletes an IPv6 mapping entry.
        
        @param request: DeleteIPv6TranslatorEntryRequest
        @return: DeleteIPv6TranslatorEntryResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_ipv_6translator_entry_with_options(request, runtime)

    async def delete_ipv_6translator_entry_async(
        self,
        request: vpc_20160428_models.DeleteIPv6TranslatorEntryRequest,
    ) -> vpc_20160428_models.DeleteIPv6TranslatorEntryResponse:
        """
        @deprecated OpenAPI DeleteIPv6TranslatorEntry is deprecated
        
        @summary Deletes an IPv6 mapping entry.
        
        @param request: DeleteIPv6TranslatorEntryRequest
        @return: DeleteIPv6TranslatorEntryResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_ipv_6translator_entry_with_options_async(request, runtime)

    def delete_ipsec_server_with_options(
        self,
        request: vpc_20160428_models.DeleteIpsecServerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteIpsecServerResponse:
        """
        @summary Deletes an IPsec server.
        
        @description    **DeleteIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the IPsec server is being deleted.
        If a VPN gateway is in the **active** state, the IPsec server is deleted.
        You cannot repeatedly call **DeleteIpsecServer** to delete an IPsec server from a VPN gateway within the specified period of time.
        
        @param request: DeleteIpsecServerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIpsecServerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.ipsec_server_id):
            query['IpsecServerId'] = request.ipsec_server_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIpsecServer',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteIpsecServerResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_ipsec_server_with_options_async(
        self,
        request: vpc_20160428_models.DeleteIpsecServerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteIpsecServerResponse:
        """
        @summary Deletes an IPsec server.
        
        @description    **DeleteIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the IPsec server is being deleted.
        If a VPN gateway is in the **active** state, the IPsec server is deleted.
        You cannot repeatedly call **DeleteIpsecServer** to delete an IPsec server from a VPN gateway within the specified period of time.
        
        @param request: DeleteIpsecServerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIpsecServerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.ipsec_server_id):
            query['IpsecServerId'] = request.ipsec_server_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIpsecServer',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteIpsecServerResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_ipsec_server(
        self,
        request: vpc_20160428_models.DeleteIpsecServerRequest,
    ) -> vpc_20160428_models.DeleteIpsecServerResponse:
        """
        @summary Deletes an IPsec server.
        
        @description    **DeleteIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the IPsec server is being deleted.
        If a VPN gateway is in the **active** state, the IPsec server is deleted.
        You cannot repeatedly call **DeleteIpsecServer** to delete an IPsec server from a VPN gateway within the specified period of time.
        
        @param request: DeleteIpsecServerRequest
        @return: DeleteIpsecServerResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_ipsec_server_with_options(request, runtime)

    async def delete_ipsec_server_async(
        self,
        request: vpc_20160428_models.DeleteIpsecServerRequest,
    ) -> vpc_20160428_models.DeleteIpsecServerResponse:
        """
        @summary Deletes an IPsec server.
        
        @description    **DeleteIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the IPsec server is being deleted.
        If a VPN gateway is in the **active** state, the IPsec server is deleted.
        You cannot repeatedly call **DeleteIpsecServer** to delete an IPsec server from a VPN gateway within the specified period of time.
        
        @param request: DeleteIpsecServerRequest
        @return: DeleteIpsecServerResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_ipsec_server_with_options_async(request, runtime)

    def delete_ipv_4gateway_with_options(
        self,
        request: vpc_20160428_models.DeleteIpv4GatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteIpv4GatewayResponse:
        """
        @summary Deletes an IPv4 gateway.
        
        @description ### [](#)Description
        Before you delete an IPv4 gateway, make sure that no route tables are associated with the IPv4 gateway.
        **DeleteIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of the task.
        If the IPv4 gateway is in the **Deleting** state, the IPv4 gateway is being deleted.
        If the IPv4 gateway cannot be queried, the IPv4 gateway is deleted.
        After you call the **DeleteIpv4Gateway** operation to delete an IPv4 gateway, you cannot call the operation again to delete the IPv4 gateway until the deletion task is complete.
        
        @param request: DeleteIpv4GatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIpv4GatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.internet_mode):
            query['InternetMode'] = request.internet_mode
        if not UtilClient.is_unset(request.ipv_4gateway_id):
            query['Ipv4GatewayId'] = request.ipv_4gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIpv4Gateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteIpv4GatewayResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_ipv_4gateway_with_options_async(
        self,
        request: vpc_20160428_models.DeleteIpv4GatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteIpv4GatewayResponse:
        """
        @summary Deletes an IPv4 gateway.
        
        @description ### [](#)Description
        Before you delete an IPv4 gateway, make sure that no route tables are associated with the IPv4 gateway.
        **DeleteIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of the task.
        If the IPv4 gateway is in the **Deleting** state, the IPv4 gateway is being deleted.
        If the IPv4 gateway cannot be queried, the IPv4 gateway is deleted.
        After you call the **DeleteIpv4Gateway** operation to delete an IPv4 gateway, you cannot call the operation again to delete the IPv4 gateway until the deletion task is complete.
        
        @param request: DeleteIpv4GatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIpv4GatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.internet_mode):
            query['InternetMode'] = request.internet_mode
        if not UtilClient.is_unset(request.ipv_4gateway_id):
            query['Ipv4GatewayId'] = request.ipv_4gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIpv4Gateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteIpv4GatewayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_ipv_4gateway(
        self,
        request: vpc_20160428_models.DeleteIpv4GatewayRequest,
    ) -> vpc_20160428_models.DeleteIpv4GatewayResponse:
        """
        @summary Deletes an IPv4 gateway.
        
        @description ### [](#)Description
        Before you delete an IPv4 gateway, make sure that no route tables are associated with the IPv4 gateway.
        **DeleteIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of the task.
        If the IPv4 gateway is in the **Deleting** state, the IPv4 gateway is being deleted.
        If the IPv4 gateway cannot be queried, the IPv4 gateway is deleted.
        After you call the **DeleteIpv4Gateway** operation to delete an IPv4 gateway, you cannot call the operation again to delete the IPv4 gateway until the deletion task is complete.
        
        @param request: DeleteIpv4GatewayRequest
        @return: DeleteIpv4GatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_ipv_4gateway_with_options(request, runtime)

    async def delete_ipv_4gateway_async(
        self,
        request: vpc_20160428_models.DeleteIpv4GatewayRequest,
    ) -> vpc_20160428_models.DeleteIpv4GatewayResponse:
        """
        @summary Deletes an IPv4 gateway.
        
        @description ### [](#)Description
        Before you delete an IPv4 gateway, make sure that no route tables are associated with the IPv4 gateway.
        **DeleteIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of the task.
        If the IPv4 gateway is in the **Deleting** state, the IPv4 gateway is being deleted.
        If the IPv4 gateway cannot be queried, the IPv4 gateway is deleted.
        After you call the **DeleteIpv4Gateway** operation to delete an IPv4 gateway, you cannot call the operation again to delete the IPv4 gateway until the deletion task is complete.
        
        @param request: DeleteIpv4GatewayRequest
        @return: DeleteIpv4GatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_ipv_4gateway_with_options_async(request, runtime)

    def delete_ipv_6egress_only_rule_with_options(
        self,
        request: vpc_20160428_models.DeleteIpv6EgressOnlyRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteIpv6EgressOnlyRuleResponse:
        """
        @summary Deletes an egress-only rule.
        
        @description    **DeleteIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
        If the egress-only rule is in the **Deleting** state, the egress-only rule is being deleted.
        If you cannot query the egress-only rule, the egress-only rule is deleted.
        You cannot call the **DeleteIpv6EgressOnlyRule** within the specified period of time.
        
        @param request: DeleteIpv6EgressOnlyRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIpv6EgressOnlyRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ipv_6egress_only_rule_id):
            query['Ipv6EgressOnlyRuleId'] = request.ipv_6egress_only_rule_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIpv6EgressOnlyRule',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteIpv6EgressOnlyRuleResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_ipv_6egress_only_rule_with_options_async(
        self,
        request: vpc_20160428_models.DeleteIpv6EgressOnlyRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteIpv6EgressOnlyRuleResponse:
        """
        @summary Deletes an egress-only rule.
        
        @description    **DeleteIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
        If the egress-only rule is in the **Deleting** state, the egress-only rule is being deleted.
        If you cannot query the egress-only rule, the egress-only rule is deleted.
        You cannot call the **DeleteIpv6EgressOnlyRule** within the specified period of time.
        
        @param request: DeleteIpv6EgressOnlyRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIpv6EgressOnlyRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ipv_6egress_only_rule_id):
            query['Ipv6EgressOnlyRuleId'] = request.ipv_6egress_only_rule_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIpv6EgressOnlyRule',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteIpv6EgressOnlyRuleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_ipv_6egress_only_rule(
        self,
        request: vpc_20160428_models.DeleteIpv6EgressOnlyRuleRequest,
    ) -> vpc_20160428_models.DeleteIpv6EgressOnlyRuleResponse:
        """
        @summary Deletes an egress-only rule.
        
        @description    **DeleteIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
        If the egress-only rule is in the **Deleting** state, the egress-only rule is being deleted.
        If you cannot query the egress-only rule, the egress-only rule is deleted.
        You cannot call the **DeleteIpv6EgressOnlyRule** within the specified period of time.
        
        @param request: DeleteIpv6EgressOnlyRuleRequest
        @return: DeleteIpv6EgressOnlyRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_ipv_6egress_only_rule_with_options(request, runtime)

    async def delete_ipv_6egress_only_rule_async(
        self,
        request: vpc_20160428_models.DeleteIpv6EgressOnlyRuleRequest,
    ) -> vpc_20160428_models.DeleteIpv6EgressOnlyRuleResponse:
        """
        @summary Deletes an egress-only rule.
        
        @description    **DeleteIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
        If the egress-only rule is in the **Deleting** state, the egress-only rule is being deleted.
        If you cannot query the egress-only rule, the egress-only rule is deleted.
        You cannot call the **DeleteIpv6EgressOnlyRule** within the specified period of time.
        
        @param request: DeleteIpv6EgressOnlyRuleRequest
        @return: DeleteIpv6EgressOnlyRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_ipv_6egress_only_rule_with_options_async(request, runtime)

    def delete_ipv_6gateway_with_options(
        self,
        request: vpc_20160428_models.DeleteIpv6GatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteIpv6GatewayResponse:
        """
        @summary Deletes an IPv6 gateway.
        
        @description Before you delete an IPv6 gateway, you must delete the egress-only rules of the IPv6 gateway. For more information, see [DeleteIpv6EgressOnlyRule](https://help.aliyun.com/document_detail/102201.html).
        **DeleteIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task:
        If the IPv6 gateway is in the **Deleting** state, the IPv6 gateway is being deleted.
        If you cannot query the IPv6 gateway, the IPv6 gateway is deleted.
        You cannot repeatedly call the **DeleteIpv6Gateway** operation to delete an IPv6 gateway within the specified period of time.
        
        @param request: DeleteIpv6GatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIpv6GatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipv_6gateway_id):
            query['Ipv6GatewayId'] = request.ipv_6gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIpv6Gateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteIpv6GatewayResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_ipv_6gateway_with_options_async(
        self,
        request: vpc_20160428_models.DeleteIpv6GatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteIpv6GatewayResponse:
        """
        @summary Deletes an IPv6 gateway.
        
        @description Before you delete an IPv6 gateway, you must delete the egress-only rules of the IPv6 gateway. For more information, see [DeleteIpv6EgressOnlyRule](https://help.aliyun.com/document_detail/102201.html).
        **DeleteIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task:
        If the IPv6 gateway is in the **Deleting** state, the IPv6 gateway is being deleted.
        If you cannot query the IPv6 gateway, the IPv6 gateway is deleted.
        You cannot repeatedly call the **DeleteIpv6Gateway** operation to delete an IPv6 gateway within the specified period of time.
        
        @param request: DeleteIpv6GatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIpv6GatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipv_6gateway_id):
            query['Ipv6GatewayId'] = request.ipv_6gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIpv6Gateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteIpv6GatewayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_ipv_6gateway(
        self,
        request: vpc_20160428_models.DeleteIpv6GatewayRequest,
    ) -> vpc_20160428_models.DeleteIpv6GatewayResponse:
        """
        @summary Deletes an IPv6 gateway.
        
        @description Before you delete an IPv6 gateway, you must delete the egress-only rules of the IPv6 gateway. For more information, see [DeleteIpv6EgressOnlyRule](https://help.aliyun.com/document_detail/102201.html).
        **DeleteIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task:
        If the IPv6 gateway is in the **Deleting** state, the IPv6 gateway is being deleted.
        If you cannot query the IPv6 gateway, the IPv6 gateway is deleted.
        You cannot repeatedly call the **DeleteIpv6Gateway** operation to delete an IPv6 gateway within the specified period of time.
        
        @param request: DeleteIpv6GatewayRequest
        @return: DeleteIpv6GatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_ipv_6gateway_with_options(request, runtime)

    async def delete_ipv_6gateway_async(
        self,
        request: vpc_20160428_models.DeleteIpv6GatewayRequest,
    ) -> vpc_20160428_models.DeleteIpv6GatewayResponse:
        """
        @summary Deletes an IPv6 gateway.
        
        @description Before you delete an IPv6 gateway, you must delete the egress-only rules of the IPv6 gateway. For more information, see [DeleteIpv6EgressOnlyRule](https://help.aliyun.com/document_detail/102201.html).
        **DeleteIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task:
        If the IPv6 gateway is in the **Deleting** state, the IPv6 gateway is being deleted.
        If you cannot query the IPv6 gateway, the IPv6 gateway is deleted.
        You cannot repeatedly call the **DeleteIpv6Gateway** operation to delete an IPv6 gateway within the specified period of time.
        
        @param request: DeleteIpv6GatewayRequest
        @return: DeleteIpv6GatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_ipv_6gateway_with_options_async(request, runtime)

    def delete_ipv_6internet_bandwidth_with_options(
        self,
        request: vpc_20160428_models.DeleteIpv6InternetBandwidthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteIpv6InternetBandwidthResponse:
        """
        @summary Deletes Internet bandwidth.
        
        @description You cannot call the *DeleteIpv6InternetBandwidth** operation within the specified period of time.
        
        @param request: DeleteIpv6InternetBandwidthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIpv6InternetBandwidthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipv_6address_id):
            query['Ipv6AddressId'] = request.ipv_6address_id
        if not UtilClient.is_unset(request.ipv_6internet_bandwidth_id):
            query['Ipv6InternetBandwidthId'] = request.ipv_6internet_bandwidth_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIpv6InternetBandwidth',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteIpv6InternetBandwidthResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_ipv_6internet_bandwidth_with_options_async(
        self,
        request: vpc_20160428_models.DeleteIpv6InternetBandwidthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteIpv6InternetBandwidthResponse:
        """
        @summary Deletes Internet bandwidth.
        
        @description You cannot call the *DeleteIpv6InternetBandwidth** operation within the specified period of time.
        
        @param request: DeleteIpv6InternetBandwidthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIpv6InternetBandwidthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipv_6address_id):
            query['Ipv6AddressId'] = request.ipv_6address_id
        if not UtilClient.is_unset(request.ipv_6internet_bandwidth_id):
            query['Ipv6InternetBandwidthId'] = request.ipv_6internet_bandwidth_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIpv6InternetBandwidth',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteIpv6InternetBandwidthResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_ipv_6internet_bandwidth(
        self,
        request: vpc_20160428_models.DeleteIpv6InternetBandwidthRequest,
    ) -> vpc_20160428_models.DeleteIpv6InternetBandwidthResponse:
        """
        @summary Deletes Internet bandwidth.
        
        @description You cannot call the *DeleteIpv6InternetBandwidth** operation within the specified period of time.
        
        @param request: DeleteIpv6InternetBandwidthRequest
        @return: DeleteIpv6InternetBandwidthResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_ipv_6internet_bandwidth_with_options(request, runtime)

    async def delete_ipv_6internet_bandwidth_async(
        self,
        request: vpc_20160428_models.DeleteIpv6InternetBandwidthRequest,
    ) -> vpc_20160428_models.DeleteIpv6InternetBandwidthResponse:
        """
        @summary Deletes Internet bandwidth.
        
        @description You cannot call the *DeleteIpv6InternetBandwidth** operation within the specified period of time.
        
        @param request: DeleteIpv6InternetBandwidthRequest
        @return: DeleteIpv6InternetBandwidthResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_ipv_6internet_bandwidth_with_options_async(request, runtime)

    def delete_nat_gateway_with_options(
        self,
        request: vpc_20160428_models.DeleteNatGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteNatGatewayResponse:
        """
        @summary Deletes a specified Internet NAT gateway.
        
        @description ## [](#)Description
        **DeleteNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) to query the status of the task.
        If a NAT gateway is in the **Deleting** state, the NAT gateway is being deleted. In this case, you can query the NAT gateway but you cannot perform other operations.
        If the NAT gateway cannot be found, the NAT gateway is deleted.
        After you delete a NAT gateway, you cannot restore the NAT gateway. Proceed with caution.
        You cannot repeatedly call the **DeleteNatGateway** operation to delete a NAT gateway within the specified period of time.
        
        @param request: DeleteNatGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteNatGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteNatGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteNatGatewayResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_nat_gateway_with_options_async(
        self,
        request: vpc_20160428_models.DeleteNatGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteNatGatewayResponse:
        """
        @summary Deletes a specified Internet NAT gateway.
        
        @description ## [](#)Description
        **DeleteNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) to query the status of the task.
        If a NAT gateway is in the **Deleting** state, the NAT gateway is being deleted. In this case, you can query the NAT gateway but you cannot perform other operations.
        If the NAT gateway cannot be found, the NAT gateway is deleted.
        After you delete a NAT gateway, you cannot restore the NAT gateway. Proceed with caution.
        You cannot repeatedly call the **DeleteNatGateway** operation to delete a NAT gateway within the specified period of time.
        
        @param request: DeleteNatGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteNatGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteNatGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteNatGatewayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_nat_gateway(
        self,
        request: vpc_20160428_models.DeleteNatGatewayRequest,
    ) -> vpc_20160428_models.DeleteNatGatewayResponse:
        """
        @summary Deletes a specified Internet NAT gateway.
        
        @description ## [](#)Description
        **DeleteNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) to query the status of the task.
        If a NAT gateway is in the **Deleting** state, the NAT gateway is being deleted. In this case, you can query the NAT gateway but you cannot perform other operations.
        If the NAT gateway cannot be found, the NAT gateway is deleted.
        After you delete a NAT gateway, you cannot restore the NAT gateway. Proceed with caution.
        You cannot repeatedly call the **DeleteNatGateway** operation to delete a NAT gateway within the specified period of time.
        
        @param request: DeleteNatGatewayRequest
        @return: DeleteNatGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_nat_gateway_with_options(request, runtime)

    async def delete_nat_gateway_async(
        self,
        request: vpc_20160428_models.DeleteNatGatewayRequest,
    ) -> vpc_20160428_models.DeleteNatGatewayResponse:
        """
        @summary Deletes a specified Internet NAT gateway.
        
        @description ## [](#)Description
        **DeleteNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) to query the status of the task.
        If a NAT gateway is in the **Deleting** state, the NAT gateway is being deleted. In this case, you can query the NAT gateway but you cannot perform other operations.
        If the NAT gateway cannot be found, the NAT gateway is deleted.
        After you delete a NAT gateway, you cannot restore the NAT gateway. Proceed with caution.
        You cannot repeatedly call the **DeleteNatGateway** operation to delete a NAT gateway within the specified period of time.
        
        @param request: DeleteNatGatewayRequest
        @return: DeleteNatGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_nat_gateway_with_options_async(request, runtime)

    def delete_nat_ip_with_options(
        self,
        request: vpc_20160428_models.DeleteNatIpRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteNatIpResponse:
        """
        @summary Deletes a NAT IP address.
        
        @description ## [](#)Description
        **DeleteNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/281979.html) operation to query the status of the task.
        If the NAT IP address is in the **Deleting** state, the NAT IP address is being deleted. In this case, you can only query the NAT IP address but cannot perform other operations.
        If the NAT IP address cannot be found, it is deleted.
        You cannot repeatedly call the **DeleteNatIp** operation to delete a NAT IP address within the specified period of time.
        
        @param request: DeleteNatIpRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteNatIpResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.nat_ip_id):
            query['NatIpId'] = request.nat_ip_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteNatIp',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteNatIpResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_nat_ip_with_options_async(
        self,
        request: vpc_20160428_models.DeleteNatIpRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteNatIpResponse:
        """
        @summary Deletes a NAT IP address.
        
        @description ## [](#)Description
        **DeleteNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/281979.html) operation to query the status of the task.
        If the NAT IP address is in the **Deleting** state, the NAT IP address is being deleted. In this case, you can only query the NAT IP address but cannot perform other operations.
        If the NAT IP address cannot be found, it is deleted.
        You cannot repeatedly call the **DeleteNatIp** operation to delete a NAT IP address within the specified period of time.
        
        @param request: DeleteNatIpRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteNatIpResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.nat_ip_id):
            query['NatIpId'] = request.nat_ip_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteNatIp',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteNatIpResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_nat_ip(
        self,
        request: vpc_20160428_models.DeleteNatIpRequest,
    ) -> vpc_20160428_models.DeleteNatIpResponse:
        """
        @summary Deletes a NAT IP address.
        
        @description ## [](#)Description
        **DeleteNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/281979.html) operation to query the status of the task.
        If the NAT IP address is in the **Deleting** state, the NAT IP address is being deleted. In this case, you can only query the NAT IP address but cannot perform other operations.
        If the NAT IP address cannot be found, it is deleted.
        You cannot repeatedly call the **DeleteNatIp** operation to delete a NAT IP address within the specified period of time.
        
        @param request: DeleteNatIpRequest
        @return: DeleteNatIpResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_nat_ip_with_options(request, runtime)

    async def delete_nat_ip_async(
        self,
        request: vpc_20160428_models.DeleteNatIpRequest,
    ) -> vpc_20160428_models.DeleteNatIpResponse:
        """
        @summary Deletes a NAT IP address.
        
        @description ## [](#)Description
        **DeleteNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/281979.html) operation to query the status of the task.
        If the NAT IP address is in the **Deleting** state, the NAT IP address is being deleted. In this case, you can only query the NAT IP address but cannot perform other operations.
        If the NAT IP address cannot be found, it is deleted.
        You cannot repeatedly call the **DeleteNatIp** operation to delete a NAT IP address within the specified period of time.
        
        @param request: DeleteNatIpRequest
        @return: DeleteNatIpResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_nat_ip_with_options_async(request, runtime)

    def delete_nat_ip_cidr_with_options(
        self,
        request: vpc_20160428_models.DeleteNatIpCidrRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteNatIpCidrResponse:
        """
        @summary Deletes a NAT CIDR block.
        
        @description ## [](#)Description
        You cannot repeatedly call the *DeleteNatIpCidr** operation to delete a NAT CIDR block within the specified period of time.
        
        @param request: DeleteNatIpCidrRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteNatIpCidrResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.nat_ip_cidr):
            query['NatIpCidr'] = request.nat_ip_cidr
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteNatIpCidr',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteNatIpCidrResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_nat_ip_cidr_with_options_async(
        self,
        request: vpc_20160428_models.DeleteNatIpCidrRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteNatIpCidrResponse:
        """
        @summary Deletes a NAT CIDR block.
        
        @description ## [](#)Description
        You cannot repeatedly call the *DeleteNatIpCidr** operation to delete a NAT CIDR block within the specified period of time.
        
        @param request: DeleteNatIpCidrRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteNatIpCidrResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.nat_ip_cidr):
            query['NatIpCidr'] = request.nat_ip_cidr
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteNatIpCidr',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteNatIpCidrResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_nat_ip_cidr(
        self,
        request: vpc_20160428_models.DeleteNatIpCidrRequest,
    ) -> vpc_20160428_models.DeleteNatIpCidrResponse:
        """
        @summary Deletes a NAT CIDR block.
        
        @description ## [](#)Description
        You cannot repeatedly call the *DeleteNatIpCidr** operation to delete a NAT CIDR block within the specified period of time.
        
        @param request: DeleteNatIpCidrRequest
        @return: DeleteNatIpCidrResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_nat_ip_cidr_with_options(request, runtime)

    async def delete_nat_ip_cidr_async(
        self,
        request: vpc_20160428_models.DeleteNatIpCidrRequest,
    ) -> vpc_20160428_models.DeleteNatIpCidrResponse:
        """
        @summary Deletes a NAT CIDR block.
        
        @description ## [](#)Description
        You cannot repeatedly call the *DeleteNatIpCidr** operation to delete a NAT CIDR block within the specified period of time.
        
        @param request: DeleteNatIpCidrRequest
        @return: DeleteNatIpCidrResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_nat_ip_cidr_with_options_async(request, runtime)

    def delete_network_acl_with_options(
        self,
        request: vpc_20160428_models.DeleteNetworkAclRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteNetworkAclResponse:
        """
        @summary Deletes a network access control list (ACL).
        
        @description ## [](#)Description
        You cannot repeatedly call the *DeleteNetworkAcl** operation within the specified period of time.
        
        @param request: DeleteNetworkAclRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteNetworkAclResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.network_acl_id):
            query['NetworkAclId'] = request.network_acl_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteNetworkAcl',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteNetworkAclResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_network_acl_with_options_async(
        self,
        request: vpc_20160428_models.DeleteNetworkAclRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteNetworkAclResponse:
        """
        @summary Deletes a network access control list (ACL).
        
        @description ## [](#)Description
        You cannot repeatedly call the *DeleteNetworkAcl** operation within the specified period of time.
        
        @param request: DeleteNetworkAclRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteNetworkAclResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.network_acl_id):
            query['NetworkAclId'] = request.network_acl_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteNetworkAcl',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteNetworkAclResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_network_acl(
        self,
        request: vpc_20160428_models.DeleteNetworkAclRequest,
    ) -> vpc_20160428_models.DeleteNetworkAclResponse:
        """
        @summary Deletes a network access control list (ACL).
        
        @description ## [](#)Description
        You cannot repeatedly call the *DeleteNetworkAcl** operation within the specified period of time.
        
        @param request: DeleteNetworkAclRequest
        @return: DeleteNetworkAclResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_network_acl_with_options(request, runtime)

    async def delete_network_acl_async(
        self,
        request: vpc_20160428_models.DeleteNetworkAclRequest,
    ) -> vpc_20160428_models.DeleteNetworkAclResponse:
        """
        @summary Deletes a network access control list (ACL).
        
        @description ## [](#)Description
        You cannot repeatedly call the *DeleteNetworkAcl** operation within the specified period of time.
        
        @param request: DeleteNetworkAclRequest
        @return: DeleteNetworkAclResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_network_acl_with_options_async(request, runtime)

    def delete_physical_connection_with_options(
        self,
        request: vpc_20160428_models.DeletePhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeletePhysicalConnectionResponse:
        """
        @summary Deletes a connection over an Express Connect circuit.
        
        @description You can only delete a connection over an Express Connect circuit that is in the *Rejected**, **Canceled**, **AllocationFailed**, or **Terminated** state.
        
        @param request: DeletePhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeletePhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeletePhysicalConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_physical_connection_with_options_async(
        self,
        request: vpc_20160428_models.DeletePhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeletePhysicalConnectionResponse:
        """
        @summary Deletes a connection over an Express Connect circuit.
        
        @description You can only delete a connection over an Express Connect circuit that is in the *Rejected**, **Canceled**, **AllocationFailed**, or **Terminated** state.
        
        @param request: DeletePhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeletePhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeletePhysicalConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_physical_connection(
        self,
        request: vpc_20160428_models.DeletePhysicalConnectionRequest,
    ) -> vpc_20160428_models.DeletePhysicalConnectionResponse:
        """
        @summary Deletes a connection over an Express Connect circuit.
        
        @description You can only delete a connection over an Express Connect circuit that is in the *Rejected**, **Canceled**, **AllocationFailed**, or **Terminated** state.
        
        @param request: DeletePhysicalConnectionRequest
        @return: DeletePhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_physical_connection_with_options(request, runtime)

    async def delete_physical_connection_async(
        self,
        request: vpc_20160428_models.DeletePhysicalConnectionRequest,
    ) -> vpc_20160428_models.DeletePhysicalConnectionResponse:
        """
        @summary Deletes a connection over an Express Connect circuit.
        
        @description You can only delete a connection over an Express Connect circuit that is in the *Rejected**, **Canceled**, **AllocationFailed**, or **Terminated** state.
        
        @param request: DeletePhysicalConnectionRequest
        @return: DeletePhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_physical_connection_with_options_async(request, runtime)

    def delete_public_ip_address_pool_with_options(
        self,
        request: vpc_20160428_models.DeletePublicIpAddressPoolRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeletePublicIpAddressPoolResponse:
        """
        @summary Deletes an IP address pool.
        
        @description Before you call this operation, take note of the following items:
        Before you delete an IP address pool, make sure that no IP address in the pool is being used.
        **DeletePublicIpAddressPool** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPools](https://help.aliyun.com/document_detail/429433.html) operation to query the status of the task.
        If the IP address pool is in the **Deleting** state, the IP address pool is being deleted. In this state. you can only query the IP address pool and cannot perform other operations.
        If you cannot query the IP address pool, the IP address pool is deleted.
        You cannot repeatedly call the **DeletePublicIpAddressPool** operation to delete an IP address pool within the specified period of time.
        
        @param request: DeletePublicIpAddressPoolRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePublicIpAddressPoolResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.public_ip_address_pool_id):
            query['PublicIpAddressPoolId'] = request.public_ip_address_pool_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeletePublicIpAddressPool',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeletePublicIpAddressPoolResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_public_ip_address_pool_with_options_async(
        self,
        request: vpc_20160428_models.DeletePublicIpAddressPoolRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeletePublicIpAddressPoolResponse:
        """
        @summary Deletes an IP address pool.
        
        @description Before you call this operation, take note of the following items:
        Before you delete an IP address pool, make sure that no IP address in the pool is being used.
        **DeletePublicIpAddressPool** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPools](https://help.aliyun.com/document_detail/429433.html) operation to query the status of the task.
        If the IP address pool is in the **Deleting** state, the IP address pool is being deleted. In this state. you can only query the IP address pool and cannot perform other operations.
        If you cannot query the IP address pool, the IP address pool is deleted.
        You cannot repeatedly call the **DeletePublicIpAddressPool** operation to delete an IP address pool within the specified period of time.
        
        @param request: DeletePublicIpAddressPoolRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePublicIpAddressPoolResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.public_ip_address_pool_id):
            query['PublicIpAddressPoolId'] = request.public_ip_address_pool_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeletePublicIpAddressPool',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeletePublicIpAddressPoolResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_public_ip_address_pool(
        self,
        request: vpc_20160428_models.DeletePublicIpAddressPoolRequest,
    ) -> vpc_20160428_models.DeletePublicIpAddressPoolResponse:
        """
        @summary Deletes an IP address pool.
        
        @description Before you call this operation, take note of the following items:
        Before you delete an IP address pool, make sure that no IP address in the pool is being used.
        **DeletePublicIpAddressPool** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPools](https://help.aliyun.com/document_detail/429433.html) operation to query the status of the task.
        If the IP address pool is in the **Deleting** state, the IP address pool is being deleted. In this state. you can only query the IP address pool and cannot perform other operations.
        If you cannot query the IP address pool, the IP address pool is deleted.
        You cannot repeatedly call the **DeletePublicIpAddressPool** operation to delete an IP address pool within the specified period of time.
        
        @param request: DeletePublicIpAddressPoolRequest
        @return: DeletePublicIpAddressPoolResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_public_ip_address_pool_with_options(request, runtime)

    async def delete_public_ip_address_pool_async(
        self,
        request: vpc_20160428_models.DeletePublicIpAddressPoolRequest,
    ) -> vpc_20160428_models.DeletePublicIpAddressPoolResponse:
        """
        @summary Deletes an IP address pool.
        
        @description Before you call this operation, take note of the following items:
        Before you delete an IP address pool, make sure that no IP address in the pool is being used.
        **DeletePublicIpAddressPool** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPools](https://help.aliyun.com/document_detail/429433.html) operation to query the status of the task.
        If the IP address pool is in the **Deleting** state, the IP address pool is being deleted. In this state. you can only query the IP address pool and cannot perform other operations.
        If you cannot query the IP address pool, the IP address pool is deleted.
        You cannot repeatedly call the **DeletePublicIpAddressPool** operation to delete an IP address pool within the specified period of time.
        
        @param request: DeletePublicIpAddressPoolRequest
        @return: DeletePublicIpAddressPoolResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_public_ip_address_pool_with_options_async(request, runtime)

    def delete_public_ip_address_pool_cidr_block_with_options(
        self,
        request: vpc_20160428_models.DeletePublicIpAddressPoolCidrBlockRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeletePublicIpAddressPoolCidrBlockResponse:
        """
        @summary Deletes a CIDR block from an IP address pool.
        
        @description Before you call this operation, take note of the following items:
        Before you delete a CIDR block, make sure that it is not being used.
        **DeletePublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
        If the CIDR block is in the **Deleting** state, the CIDR block is being deleted. In this state, you can only query the CIDR block and cannot perform other operations.
        If you cannot query the CIDR block, the CIDR block is deleted.
        You cannot repeatedly call the **DeletePublicIpAddressPoolCidrBlock** operation to delete a CIDR block within the specified period of time.
        
        @param request: DeletePublicIpAddressPoolCidrBlockRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePublicIpAddressPoolCidrBlockResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cidr_block):
            query['CidrBlock'] = request.cidr_block
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.public_ip_address_pool_id):
            query['PublicIpAddressPoolId'] = request.public_ip_address_pool_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeletePublicIpAddressPoolCidrBlock',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeletePublicIpAddressPoolCidrBlockResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_public_ip_address_pool_cidr_block_with_options_async(
        self,
        request: vpc_20160428_models.DeletePublicIpAddressPoolCidrBlockRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeletePublicIpAddressPoolCidrBlockResponse:
        """
        @summary Deletes a CIDR block from an IP address pool.
        
        @description Before you call this operation, take note of the following items:
        Before you delete a CIDR block, make sure that it is not being used.
        **DeletePublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
        If the CIDR block is in the **Deleting** state, the CIDR block is being deleted. In this state, you can only query the CIDR block and cannot perform other operations.
        If you cannot query the CIDR block, the CIDR block is deleted.
        You cannot repeatedly call the **DeletePublicIpAddressPoolCidrBlock** operation to delete a CIDR block within the specified period of time.
        
        @param request: DeletePublicIpAddressPoolCidrBlockRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePublicIpAddressPoolCidrBlockResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cidr_block):
            query['CidrBlock'] = request.cidr_block
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.public_ip_address_pool_id):
            query['PublicIpAddressPoolId'] = request.public_ip_address_pool_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeletePublicIpAddressPoolCidrBlock',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeletePublicIpAddressPoolCidrBlockResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_public_ip_address_pool_cidr_block(
        self,
        request: vpc_20160428_models.DeletePublicIpAddressPoolCidrBlockRequest,
    ) -> vpc_20160428_models.DeletePublicIpAddressPoolCidrBlockResponse:
        """
        @summary Deletes a CIDR block from an IP address pool.
        
        @description Before you call this operation, take note of the following items:
        Before you delete a CIDR block, make sure that it is not being used.
        **DeletePublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
        If the CIDR block is in the **Deleting** state, the CIDR block is being deleted. In this state, you can only query the CIDR block and cannot perform other operations.
        If you cannot query the CIDR block, the CIDR block is deleted.
        You cannot repeatedly call the **DeletePublicIpAddressPoolCidrBlock** operation to delete a CIDR block within the specified period of time.
        
        @param request: DeletePublicIpAddressPoolCidrBlockRequest
        @return: DeletePublicIpAddressPoolCidrBlockResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_public_ip_address_pool_cidr_block_with_options(request, runtime)

    async def delete_public_ip_address_pool_cidr_block_async(
        self,
        request: vpc_20160428_models.DeletePublicIpAddressPoolCidrBlockRequest,
    ) -> vpc_20160428_models.DeletePublicIpAddressPoolCidrBlockResponse:
        """
        @summary Deletes a CIDR block from an IP address pool.
        
        @description Before you call this operation, take note of the following items:
        Before you delete a CIDR block, make sure that it is not being used.
        **DeletePublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
        If the CIDR block is in the **Deleting** state, the CIDR block is being deleted. In this state, you can only query the CIDR block and cannot perform other operations.
        If you cannot query the CIDR block, the CIDR block is deleted.
        You cannot repeatedly call the **DeletePublicIpAddressPoolCidrBlock** operation to delete a CIDR block within the specified period of time.
        
        @param request: DeletePublicIpAddressPoolCidrBlockRequest
        @return: DeletePublicIpAddressPoolCidrBlockResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_public_ip_address_pool_cidr_block_with_options_async(request, runtime)

    def delete_route_entries_with_options(
        self,
        request: vpc_20160428_models.DeleteRouteEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteRouteEntriesResponse:
        """
        @summary Deletes multiple custom route entries at a time.
        
        @description When you call this operation, take note of the following items:
        You can delete only routes that are in the **Available** state.
        You cannot delete a route of a virtual private cloud (VPC) in which a vSwitch or another route is being created or deleted.
        **DeleteRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
        If the route is in the **Deleting** state, the route is being deleted.
        If you cannot query the route, the route is deleted.
        You cannot repeatedly call **DeleteRouteEntries** within a specific period of time.
        
        @param request: DeleteRouteEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteRouteEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_entries):
            query['RouteEntries'] = request.route_entries
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteRouteEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteRouteEntriesResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_route_entries_with_options_async(
        self,
        request: vpc_20160428_models.DeleteRouteEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteRouteEntriesResponse:
        """
        @summary Deletes multiple custom route entries at a time.
        
        @description When you call this operation, take note of the following items:
        You can delete only routes that are in the **Available** state.
        You cannot delete a route of a virtual private cloud (VPC) in which a vSwitch or another route is being created or deleted.
        **DeleteRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
        If the route is in the **Deleting** state, the route is being deleted.
        If you cannot query the route, the route is deleted.
        You cannot repeatedly call **DeleteRouteEntries** within a specific period of time.
        
        @param request: DeleteRouteEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteRouteEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_entries):
            query['RouteEntries'] = request.route_entries
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteRouteEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteRouteEntriesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_route_entries(
        self,
        request: vpc_20160428_models.DeleteRouteEntriesRequest,
    ) -> vpc_20160428_models.DeleteRouteEntriesResponse:
        """
        @summary Deletes multiple custom route entries at a time.
        
        @description When you call this operation, take note of the following items:
        You can delete only routes that are in the **Available** state.
        You cannot delete a route of a virtual private cloud (VPC) in which a vSwitch or another route is being created or deleted.
        **DeleteRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
        If the route is in the **Deleting** state, the route is being deleted.
        If you cannot query the route, the route is deleted.
        You cannot repeatedly call **DeleteRouteEntries** within a specific period of time.
        
        @param request: DeleteRouteEntriesRequest
        @return: DeleteRouteEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_route_entries_with_options(request, runtime)

    async def delete_route_entries_async(
        self,
        request: vpc_20160428_models.DeleteRouteEntriesRequest,
    ) -> vpc_20160428_models.DeleteRouteEntriesResponse:
        """
        @summary Deletes multiple custom route entries at a time.
        
        @description When you call this operation, take note of the following items:
        You can delete only routes that are in the **Available** state.
        You cannot delete a route of a virtual private cloud (VPC) in which a vSwitch or another route is being created or deleted.
        **DeleteRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
        If the route is in the **Deleting** state, the route is being deleted.
        If you cannot query the route, the route is deleted.
        You cannot repeatedly call **DeleteRouteEntries** within a specific period of time.
        
        @param request: DeleteRouteEntriesRequest
        @return: DeleteRouteEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_route_entries_with_options_async(request, runtime)

    def delete_route_entry_with_options(
        self,
        request: vpc_20160428_models.DeleteRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteRouteEntryResponse:
        """
        @summary Deletes a route entry from a route table of a VRouter or virtual border router (VBR).
        
        @description When you call this operation, take note of the following items:
        You can delete only routes that are in the **Available** state.
        You cannot delete a route entry of a virtual private cloud (VPC) in which a vSwitch or another route entry is being created or deleted.
        Before you call this operation to delete a route of a VBR route table, call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the **NextHopId** of the route first.
        **DeleteRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
        If the route is in the **Deleting** state, the route is being deleted.
        If you cannot query the route entry, the route entry is deleted.
        You cannot repeatedly call the **DeleteRouteEntry** operation to delete a route from the route table of a vRouter or a VBR within the specified period of time.
        
        @param request: DeleteRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteRouteEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.destination_cidr_block):
            query['DestinationCidrBlock'] = request.destination_cidr_block
        if not UtilClient.is_unset(request.next_hop_id):
            query['NextHopId'] = request.next_hop_id
        if not UtilClient.is_unset(request.next_hop_list):
            query['NextHopList'] = request.next_hop_list
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_entry_id):
            query['RouteEntryId'] = request.route_entry_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteRouteEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteRouteEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_route_entry_with_options_async(
        self,
        request: vpc_20160428_models.DeleteRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteRouteEntryResponse:
        """
        @summary Deletes a route entry from a route table of a VRouter or virtual border router (VBR).
        
        @description When you call this operation, take note of the following items:
        You can delete only routes that are in the **Available** state.
        You cannot delete a route entry of a virtual private cloud (VPC) in which a vSwitch or another route entry is being created or deleted.
        Before you call this operation to delete a route of a VBR route table, call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the **NextHopId** of the route first.
        **DeleteRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
        If the route is in the **Deleting** state, the route is being deleted.
        If you cannot query the route entry, the route entry is deleted.
        You cannot repeatedly call the **DeleteRouteEntry** operation to delete a route from the route table of a vRouter or a VBR within the specified period of time.
        
        @param request: DeleteRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteRouteEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.destination_cidr_block):
            query['DestinationCidrBlock'] = request.destination_cidr_block
        if not UtilClient.is_unset(request.next_hop_id):
            query['NextHopId'] = request.next_hop_id
        if not UtilClient.is_unset(request.next_hop_list):
            query['NextHopList'] = request.next_hop_list
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_entry_id):
            query['RouteEntryId'] = request.route_entry_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteRouteEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteRouteEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_route_entry(
        self,
        request: vpc_20160428_models.DeleteRouteEntryRequest,
    ) -> vpc_20160428_models.DeleteRouteEntryResponse:
        """
        @summary Deletes a route entry from a route table of a VRouter or virtual border router (VBR).
        
        @description When you call this operation, take note of the following items:
        You can delete only routes that are in the **Available** state.
        You cannot delete a route entry of a virtual private cloud (VPC) in which a vSwitch or another route entry is being created or deleted.
        Before you call this operation to delete a route of a VBR route table, call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the **NextHopId** of the route first.
        **DeleteRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
        If the route is in the **Deleting** state, the route is being deleted.
        If you cannot query the route entry, the route entry is deleted.
        You cannot repeatedly call the **DeleteRouteEntry** operation to delete a route from the route table of a vRouter or a VBR within the specified period of time.
        
        @param request: DeleteRouteEntryRequest
        @return: DeleteRouteEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_route_entry_with_options(request, runtime)

    async def delete_route_entry_async(
        self,
        request: vpc_20160428_models.DeleteRouteEntryRequest,
    ) -> vpc_20160428_models.DeleteRouteEntryResponse:
        """
        @summary Deletes a route entry from a route table of a VRouter or virtual border router (VBR).
        
        @description When you call this operation, take note of the following items:
        You can delete only routes that are in the **Available** state.
        You cannot delete a route entry of a virtual private cloud (VPC) in which a vSwitch or another route entry is being created or deleted.
        Before you call this operation to delete a route of a VBR route table, call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the **NextHopId** of the route first.
        **DeleteRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
        If the route is in the **Deleting** state, the route is being deleted.
        If you cannot query the route entry, the route entry is deleted.
        You cannot repeatedly call the **DeleteRouteEntry** operation to delete a route from the route table of a vRouter or a VBR within the specified period of time.
        
        @param request: DeleteRouteEntryRequest
        @return: DeleteRouteEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_route_entry_with_options_async(request, runtime)

    def delete_route_table_with_options(
        self,
        request: vpc_20160428_models.DeleteRouteTableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteRouteTableResponse:
        """
        @summary Deletes a custom route table.
        
        @description ## [](#)Description
        **DeleteRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
        If the custom route table is in the **Deleting** state, the custom route table is being deleted.
        If you cannot query the custom route table, the custom route table is deleted.
        You cannot repeatedly call the **DeleteRouteTable** operation to delete a custom route table within the specified period of time.
        
        @param request: DeleteRouteTableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteRouteTableResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteRouteTable',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteRouteTableResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_route_table_with_options_async(
        self,
        request: vpc_20160428_models.DeleteRouteTableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteRouteTableResponse:
        """
        @summary Deletes a custom route table.
        
        @description ## [](#)Description
        **DeleteRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
        If the custom route table is in the **Deleting** state, the custom route table is being deleted.
        If you cannot query the custom route table, the custom route table is deleted.
        You cannot repeatedly call the **DeleteRouteTable** operation to delete a custom route table within the specified period of time.
        
        @param request: DeleteRouteTableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteRouteTableResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteRouteTable',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteRouteTableResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_route_table(
        self,
        request: vpc_20160428_models.DeleteRouteTableRequest,
    ) -> vpc_20160428_models.DeleteRouteTableResponse:
        """
        @summary Deletes a custom route table.
        
        @description ## [](#)Description
        **DeleteRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
        If the custom route table is in the **Deleting** state, the custom route table is being deleted.
        If you cannot query the custom route table, the custom route table is deleted.
        You cannot repeatedly call the **DeleteRouteTable** operation to delete a custom route table within the specified period of time.
        
        @param request: DeleteRouteTableRequest
        @return: DeleteRouteTableResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_route_table_with_options(request, runtime)

    async def delete_route_table_async(
        self,
        request: vpc_20160428_models.DeleteRouteTableRequest,
    ) -> vpc_20160428_models.DeleteRouteTableResponse:
        """
        @summary Deletes a custom route table.
        
        @description ## [](#)Description
        **DeleteRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
        If the custom route table is in the **Deleting** state, the custom route table is being deleted.
        If you cannot query the custom route table, the custom route table is deleted.
        You cannot repeatedly call the **DeleteRouteTable** operation to delete a custom route table within the specified period of time.
        
        @param request: DeleteRouteTableRequest
        @return: DeleteRouteTableResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_route_table_with_options_async(request, runtime)

    def delete_router_interface_with_options(
        self,
        request: vpc_20160428_models.DeleteRouterInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteRouterInterfaceResponse:
        """
        @summary Deletes a router interface.
        
        @description When you call this operation, take note of the following limits:
        You can delete only a router interface that is in the **Idle** or **Inactive** state.
        Before you delete a router interface, you must delete all custom route entries destined for the router interface.
        
        @param request: DeleteRouterInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteRouterInterfaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteRouterInterface',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteRouterInterfaceResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_router_interface_with_options_async(
        self,
        request: vpc_20160428_models.DeleteRouterInterfaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteRouterInterfaceResponse:
        """
        @summary Deletes a router interface.
        
        @description When you call this operation, take note of the following limits:
        You can delete only a router interface that is in the **Idle** or **Inactive** state.
        Before you delete a router interface, you must delete all custom route entries destined for the router interface.
        
        @param request: DeleteRouterInterfaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteRouterInterfaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteRouterInterface',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteRouterInterfaceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_router_interface(
        self,
        request: vpc_20160428_models.DeleteRouterInterfaceRequest,
    ) -> vpc_20160428_models.DeleteRouterInterfaceResponse:
        """
        @summary Deletes a router interface.
        
        @description When you call this operation, take note of the following limits:
        You can delete only a router interface that is in the **Idle** or **Inactive** state.
        Before you delete a router interface, you must delete all custom route entries destined for the router interface.
        
        @param request: DeleteRouterInterfaceRequest
        @return: DeleteRouterInterfaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_router_interface_with_options(request, runtime)

    async def delete_router_interface_async(
        self,
        request: vpc_20160428_models.DeleteRouterInterfaceRequest,
    ) -> vpc_20160428_models.DeleteRouterInterfaceResponse:
        """
        @summary Deletes a router interface.
        
        @description When you call this operation, take note of the following limits:
        You can delete only a router interface that is in the **Idle** or **Inactive** state.
        Before you delete a router interface, you must delete all custom route entries destined for the router interface.
        
        @param request: DeleteRouterInterfaceRequest
        @return: DeleteRouterInterfaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_router_interface_with_options_async(request, runtime)

    def delete_snat_entry_with_options(
        self,
        request: vpc_20160428_models.DeleteSnatEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteSnatEntryResponse:
        """
        @summary Deletes an SNAT entry.
        
        @description DeleteSnatEntry is an asynchronous operation. After you make a request, the ID of the request is returned but the specified SNAT entry is not deleted. The system deletes the SNAT entry in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of SNAT entries.
        If the SNAT entries are in the **Deleting** state, the system is deleting the SNAT entries. In this case, you can only query the status of the SNAT entries, and cannot perform other operations.
        If no SNAT entry is returned in the response, the SNAT entry is deleted.
        If some SNAT entries are in the *Pending** state, you cannot delete these SNAT entries.
        
        @param request: DeleteSnatEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteSnatEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snat_entry_id):
            query['SnatEntryId'] = request.snat_entry_id
        if not UtilClient.is_unset(request.snat_table_id):
            query['SnatTableId'] = request.snat_table_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteSnatEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteSnatEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_snat_entry_with_options_async(
        self,
        request: vpc_20160428_models.DeleteSnatEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteSnatEntryResponse:
        """
        @summary Deletes an SNAT entry.
        
        @description DeleteSnatEntry is an asynchronous operation. After you make a request, the ID of the request is returned but the specified SNAT entry is not deleted. The system deletes the SNAT entry in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of SNAT entries.
        If the SNAT entries are in the **Deleting** state, the system is deleting the SNAT entries. In this case, you can only query the status of the SNAT entries, and cannot perform other operations.
        If no SNAT entry is returned in the response, the SNAT entry is deleted.
        If some SNAT entries are in the *Pending** state, you cannot delete these SNAT entries.
        
        @param request: DeleteSnatEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteSnatEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snat_entry_id):
            query['SnatEntryId'] = request.snat_entry_id
        if not UtilClient.is_unset(request.snat_table_id):
            query['SnatTableId'] = request.snat_table_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteSnatEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteSnatEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_snat_entry(
        self,
        request: vpc_20160428_models.DeleteSnatEntryRequest,
    ) -> vpc_20160428_models.DeleteSnatEntryResponse:
        """
        @summary Deletes an SNAT entry.
        
        @description DeleteSnatEntry is an asynchronous operation. After you make a request, the ID of the request is returned but the specified SNAT entry is not deleted. The system deletes the SNAT entry in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of SNAT entries.
        If the SNAT entries are in the **Deleting** state, the system is deleting the SNAT entries. In this case, you can only query the status of the SNAT entries, and cannot perform other operations.
        If no SNAT entry is returned in the response, the SNAT entry is deleted.
        If some SNAT entries are in the *Pending** state, you cannot delete these SNAT entries.
        
        @param request: DeleteSnatEntryRequest
        @return: DeleteSnatEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_snat_entry_with_options(request, runtime)

    async def delete_snat_entry_async(
        self,
        request: vpc_20160428_models.DeleteSnatEntryRequest,
    ) -> vpc_20160428_models.DeleteSnatEntryResponse:
        """
        @summary Deletes an SNAT entry.
        
        @description DeleteSnatEntry is an asynchronous operation. After you make a request, the ID of the request is returned but the specified SNAT entry is not deleted. The system deletes the SNAT entry in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of SNAT entries.
        If the SNAT entries are in the **Deleting** state, the system is deleting the SNAT entries. In this case, you can only query the status of the SNAT entries, and cannot perform other operations.
        If no SNAT entry is returned in the response, the SNAT entry is deleted.
        If some SNAT entries are in the *Pending** state, you cannot delete these SNAT entries.
        
        @param request: DeleteSnatEntryRequest
        @return: DeleteSnatEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_snat_entry_with_options_async(request, runtime)

    def delete_ssl_vpn_client_cert_with_options(
        self,
        request: vpc_20160428_models.DeleteSslVpnClientCertRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteSslVpnClientCertResponse:
        """
        @summary Deletes an SSL client certificate.
        
        @description    **DeleteSslVpnClientCert** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If the VPN gateway is in the **updating** state, the SSL client certificate is being deleted.
        If the VPN gateway is in the **active** state, the SSL client certificate is deleted.
        You cannot repeatedly call **DeleteSslVpnClientCert** to delete an SSL client certificate from the same VPN gateway within the specified period of time.
        
        @param request: DeleteSslVpnClientCertRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteSslVpnClientCertResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.ssl_vpn_client_cert_id):
            query['SslVpnClientCertId'] = request.ssl_vpn_client_cert_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteSslVpnClientCert',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteSslVpnClientCertResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_ssl_vpn_client_cert_with_options_async(
        self,
        request: vpc_20160428_models.DeleteSslVpnClientCertRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteSslVpnClientCertResponse:
        """
        @summary Deletes an SSL client certificate.
        
        @description    **DeleteSslVpnClientCert** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If the VPN gateway is in the **updating** state, the SSL client certificate is being deleted.
        If the VPN gateway is in the **active** state, the SSL client certificate is deleted.
        You cannot repeatedly call **DeleteSslVpnClientCert** to delete an SSL client certificate from the same VPN gateway within the specified period of time.
        
        @param request: DeleteSslVpnClientCertRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteSslVpnClientCertResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.ssl_vpn_client_cert_id):
            query['SslVpnClientCertId'] = request.ssl_vpn_client_cert_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteSslVpnClientCert',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteSslVpnClientCertResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_ssl_vpn_client_cert(
        self,
        request: vpc_20160428_models.DeleteSslVpnClientCertRequest,
    ) -> vpc_20160428_models.DeleteSslVpnClientCertResponse:
        """
        @summary Deletes an SSL client certificate.
        
        @description    **DeleteSslVpnClientCert** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If the VPN gateway is in the **updating** state, the SSL client certificate is being deleted.
        If the VPN gateway is in the **active** state, the SSL client certificate is deleted.
        You cannot repeatedly call **DeleteSslVpnClientCert** to delete an SSL client certificate from the same VPN gateway within the specified period of time.
        
        @param request: DeleteSslVpnClientCertRequest
        @return: DeleteSslVpnClientCertResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_ssl_vpn_client_cert_with_options(request, runtime)

    async def delete_ssl_vpn_client_cert_async(
        self,
        request: vpc_20160428_models.DeleteSslVpnClientCertRequest,
    ) -> vpc_20160428_models.DeleteSslVpnClientCertResponse:
        """
        @summary Deletes an SSL client certificate.
        
        @description    **DeleteSslVpnClientCert** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If the VPN gateway is in the **updating** state, the SSL client certificate is being deleted.
        If the VPN gateway is in the **active** state, the SSL client certificate is deleted.
        You cannot repeatedly call **DeleteSslVpnClientCert** to delete an SSL client certificate from the same VPN gateway within the specified period of time.
        
        @param request: DeleteSslVpnClientCertRequest
        @return: DeleteSslVpnClientCertResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_ssl_vpn_client_cert_with_options_async(request, runtime)

    def delete_ssl_vpn_server_with_options(
        self,
        request: vpc_20160428_models.DeleteSslVpnServerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteSslVpnServerResponse:
        """
        @summary Deletes an SSL server.
        
        @description    **DeleteSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
        If the VPN gateway is in the **updating** state, the SSL server is being deleted.
        If the VPN gateway is in the **active** state, the SSL server is deleted.
        You cannot repeatedly call the **DeleteSslVpnServer** operation to delete an SSL server from the same VPN gateway within the specified period of time.
        
        @param request: DeleteSslVpnServerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteSslVpnServerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.ssl_vpn_server_id):
            query['SslVpnServerId'] = request.ssl_vpn_server_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteSslVpnServer',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteSslVpnServerResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_ssl_vpn_server_with_options_async(
        self,
        request: vpc_20160428_models.DeleteSslVpnServerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteSslVpnServerResponse:
        """
        @summary Deletes an SSL server.
        
        @description    **DeleteSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
        If the VPN gateway is in the **updating** state, the SSL server is being deleted.
        If the VPN gateway is in the **active** state, the SSL server is deleted.
        You cannot repeatedly call the **DeleteSslVpnServer** operation to delete an SSL server from the same VPN gateway within the specified period of time.
        
        @param request: DeleteSslVpnServerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteSslVpnServerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.ssl_vpn_server_id):
            query['SslVpnServerId'] = request.ssl_vpn_server_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteSslVpnServer',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteSslVpnServerResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_ssl_vpn_server(
        self,
        request: vpc_20160428_models.DeleteSslVpnServerRequest,
    ) -> vpc_20160428_models.DeleteSslVpnServerResponse:
        """
        @summary Deletes an SSL server.
        
        @description    **DeleteSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
        If the VPN gateway is in the **updating** state, the SSL server is being deleted.
        If the VPN gateway is in the **active** state, the SSL server is deleted.
        You cannot repeatedly call the **DeleteSslVpnServer** operation to delete an SSL server from the same VPN gateway within the specified period of time.
        
        @param request: DeleteSslVpnServerRequest
        @return: DeleteSslVpnServerResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_ssl_vpn_server_with_options(request, runtime)

    async def delete_ssl_vpn_server_async(
        self,
        request: vpc_20160428_models.DeleteSslVpnServerRequest,
    ) -> vpc_20160428_models.DeleteSslVpnServerResponse:
        """
        @summary Deletes an SSL server.
        
        @description    **DeleteSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
        If the VPN gateway is in the **updating** state, the SSL server is being deleted.
        If the VPN gateway is in the **active** state, the SSL server is deleted.
        You cannot repeatedly call the **DeleteSslVpnServer** operation to delete an SSL server from the same VPN gateway within the specified period of time.
        
        @param request: DeleteSslVpnServerRequest
        @return: DeleteSslVpnServerResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_ssl_vpn_server_with_options_async(request, runtime)

    def delete_traffic_mirror_filter_with_options(
        self,
        request: vpc_20160428_models.DeleteTrafficMirrorFilterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteTrafficMirrorFilterResponse:
        """
        @summary Deletes a filter of traffic mirroring.
        
        @description    The **DeleteTrafficMirrorFilter** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of a filter:
        If the filter is in the **Deleting** state, the filter is being deleted.
        If you cannot query the filter, the filter is deleted.
        You cannot repeatedly call the **DeleteTrafficMirrorFilter** operation to delete a filter within the specified period of time.
        
        @param request: DeleteTrafficMirrorFilterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteTrafficMirrorFilterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.traffic_mirror_filter_id):
            query['TrafficMirrorFilterId'] = request.traffic_mirror_filter_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteTrafficMirrorFilter',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteTrafficMirrorFilterResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_traffic_mirror_filter_with_options_async(
        self,
        request: vpc_20160428_models.DeleteTrafficMirrorFilterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteTrafficMirrorFilterResponse:
        """
        @summary Deletes a filter of traffic mirroring.
        
        @description    The **DeleteTrafficMirrorFilter** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of a filter:
        If the filter is in the **Deleting** state, the filter is being deleted.
        If you cannot query the filter, the filter is deleted.
        You cannot repeatedly call the **DeleteTrafficMirrorFilter** operation to delete a filter within the specified period of time.
        
        @param request: DeleteTrafficMirrorFilterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteTrafficMirrorFilterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.traffic_mirror_filter_id):
            query['TrafficMirrorFilterId'] = request.traffic_mirror_filter_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteTrafficMirrorFilter',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteTrafficMirrorFilterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_traffic_mirror_filter(
        self,
        request: vpc_20160428_models.DeleteTrafficMirrorFilterRequest,
    ) -> vpc_20160428_models.DeleteTrafficMirrorFilterResponse:
        """
        @summary Deletes a filter of traffic mirroring.
        
        @description    The **DeleteTrafficMirrorFilter** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of a filter:
        If the filter is in the **Deleting** state, the filter is being deleted.
        If you cannot query the filter, the filter is deleted.
        You cannot repeatedly call the **DeleteTrafficMirrorFilter** operation to delete a filter within the specified period of time.
        
        @param request: DeleteTrafficMirrorFilterRequest
        @return: DeleteTrafficMirrorFilterResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_traffic_mirror_filter_with_options(request, runtime)

    async def delete_traffic_mirror_filter_async(
        self,
        request: vpc_20160428_models.DeleteTrafficMirrorFilterRequest,
    ) -> vpc_20160428_models.DeleteTrafficMirrorFilterResponse:
        """
        @summary Deletes a filter of traffic mirroring.
        
        @description    The **DeleteTrafficMirrorFilter** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of a filter:
        If the filter is in the **Deleting** state, the filter is being deleted.
        If you cannot query the filter, the filter is deleted.
        You cannot repeatedly call the **DeleteTrafficMirrorFilter** operation to delete a filter within the specified period of time.
        
        @param request: DeleteTrafficMirrorFilterRequest
        @return: DeleteTrafficMirrorFilterResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_traffic_mirror_filter_with_options_async(request, runtime)

    def delete_traffic_mirror_filter_rules_with_options(
        self,
        request: vpc_20160428_models.DeleteTrafficMirrorFilterRulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteTrafficMirrorFilterRulesResponse:
        """
        @summary Deletes an inbound or outbound rule of a filter for traffic mirroring.
        
        @description    **DeleteTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
        If the inbound or outbound rule is in the **Deleting** state, the rule is being deleted.
        If you cannot query the rule, the rule is deleted.
        You cannot repeatedly call **DeleteTrafficMirrorFilterRules** within the specified period of time.
        
        @param request: DeleteTrafficMirrorFilterRulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteTrafficMirrorFilterRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.traffic_mirror_filter_id):
            query['TrafficMirrorFilterId'] = request.traffic_mirror_filter_id
        if not UtilClient.is_unset(request.traffic_mirror_filter_rule_ids):
            query['TrafficMirrorFilterRuleIds'] = request.traffic_mirror_filter_rule_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteTrafficMirrorFilterRules',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteTrafficMirrorFilterRulesResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_traffic_mirror_filter_rules_with_options_async(
        self,
        request: vpc_20160428_models.DeleteTrafficMirrorFilterRulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteTrafficMirrorFilterRulesResponse:
        """
        @summary Deletes an inbound or outbound rule of a filter for traffic mirroring.
        
        @description    **DeleteTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
        If the inbound or outbound rule is in the **Deleting** state, the rule is being deleted.
        If you cannot query the rule, the rule is deleted.
        You cannot repeatedly call **DeleteTrafficMirrorFilterRules** within the specified period of time.
        
        @param request: DeleteTrafficMirrorFilterRulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteTrafficMirrorFilterRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.traffic_mirror_filter_id):
            query['TrafficMirrorFilterId'] = request.traffic_mirror_filter_id
        if not UtilClient.is_unset(request.traffic_mirror_filter_rule_ids):
            query['TrafficMirrorFilterRuleIds'] = request.traffic_mirror_filter_rule_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteTrafficMirrorFilterRules',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteTrafficMirrorFilterRulesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_traffic_mirror_filter_rules(
        self,
        request: vpc_20160428_models.DeleteTrafficMirrorFilterRulesRequest,
    ) -> vpc_20160428_models.DeleteTrafficMirrorFilterRulesResponse:
        """
        @summary Deletes an inbound or outbound rule of a filter for traffic mirroring.
        
        @description    **DeleteTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
        If the inbound or outbound rule is in the **Deleting** state, the rule is being deleted.
        If you cannot query the rule, the rule is deleted.
        You cannot repeatedly call **DeleteTrafficMirrorFilterRules** within the specified period of time.
        
        @param request: DeleteTrafficMirrorFilterRulesRequest
        @return: DeleteTrafficMirrorFilterRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_traffic_mirror_filter_rules_with_options(request, runtime)

    async def delete_traffic_mirror_filter_rules_async(
        self,
        request: vpc_20160428_models.DeleteTrafficMirrorFilterRulesRequest,
    ) -> vpc_20160428_models.DeleteTrafficMirrorFilterRulesResponse:
        """
        @summary Deletes an inbound or outbound rule of a filter for traffic mirroring.
        
        @description    **DeleteTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
        If the inbound or outbound rule is in the **Deleting** state, the rule is being deleted.
        If you cannot query the rule, the rule is deleted.
        You cannot repeatedly call **DeleteTrafficMirrorFilterRules** within the specified period of time.
        
        @param request: DeleteTrafficMirrorFilterRulesRequest
        @return: DeleteTrafficMirrorFilterRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_traffic_mirror_filter_rules_with_options_async(request, runtime)

    def delete_traffic_mirror_session_with_options(
        self,
        request: vpc_20160428_models.DeleteTrafficMirrorSessionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteTrafficMirrorSessionResponse:
        """
        @summary Deletes a traffic mirror session.
        
        @description    **DeleteTrafficMirrorSession** is an asynchronous operation. After you send the request, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of a traffic mirror session.
        If the traffic mirror session is in the **Deleting** state, the traffic mirror session is being deleted.
        If you cannot query the traffic mirror session, the traffic mirror session is deleted.
        You cannot repeatedly call the **DeleteTrafficMirrorSession** operation to delete a traffic mirror session within the specified period of time.
        
        @param request: DeleteTrafficMirrorSessionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteTrafficMirrorSessionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.traffic_mirror_session_id):
            query['TrafficMirrorSessionId'] = request.traffic_mirror_session_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteTrafficMirrorSession',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteTrafficMirrorSessionResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_traffic_mirror_session_with_options_async(
        self,
        request: vpc_20160428_models.DeleteTrafficMirrorSessionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteTrafficMirrorSessionResponse:
        """
        @summary Deletes a traffic mirror session.
        
        @description    **DeleteTrafficMirrorSession** is an asynchronous operation. After you send the request, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of a traffic mirror session.
        If the traffic mirror session is in the **Deleting** state, the traffic mirror session is being deleted.
        If you cannot query the traffic mirror session, the traffic mirror session is deleted.
        You cannot repeatedly call the **DeleteTrafficMirrorSession** operation to delete a traffic mirror session within the specified period of time.
        
        @param request: DeleteTrafficMirrorSessionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteTrafficMirrorSessionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.traffic_mirror_session_id):
            query['TrafficMirrorSessionId'] = request.traffic_mirror_session_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteTrafficMirrorSession',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteTrafficMirrorSessionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_traffic_mirror_session(
        self,
        request: vpc_20160428_models.DeleteTrafficMirrorSessionRequest,
    ) -> vpc_20160428_models.DeleteTrafficMirrorSessionResponse:
        """
        @summary Deletes a traffic mirror session.
        
        @description    **DeleteTrafficMirrorSession** is an asynchronous operation. After you send the request, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of a traffic mirror session.
        If the traffic mirror session is in the **Deleting** state, the traffic mirror session is being deleted.
        If you cannot query the traffic mirror session, the traffic mirror session is deleted.
        You cannot repeatedly call the **DeleteTrafficMirrorSession** operation to delete a traffic mirror session within the specified period of time.
        
        @param request: DeleteTrafficMirrorSessionRequest
        @return: DeleteTrafficMirrorSessionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_traffic_mirror_session_with_options(request, runtime)

    async def delete_traffic_mirror_session_async(
        self,
        request: vpc_20160428_models.DeleteTrafficMirrorSessionRequest,
    ) -> vpc_20160428_models.DeleteTrafficMirrorSessionResponse:
        """
        @summary Deletes a traffic mirror session.
        
        @description    **DeleteTrafficMirrorSession** is an asynchronous operation. After you send the request, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of a traffic mirror session.
        If the traffic mirror session is in the **Deleting** state, the traffic mirror session is being deleted.
        If you cannot query the traffic mirror session, the traffic mirror session is deleted.
        You cannot repeatedly call the **DeleteTrafficMirrorSession** operation to delete a traffic mirror session within the specified period of time.
        
        @param request: DeleteTrafficMirrorSessionRequest
        @return: DeleteTrafficMirrorSessionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_traffic_mirror_session_with_options_async(request, runtime)

    def delete_vswitch_with_options(
        self,
        request: vpc_20160428_models.DeleteVSwitchRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVSwitchResponse:
        """
        @summary Deletes a vSwitch.
        
        @description When you call this operation, take note of the following limits:
        Before you delete a vSwitch, you must first release or remove all virtual private cloud (VPC) resources, including vSwitches, instances, router interfaces, and high-availability virtual IP addresses (HAVIPs).
        You can delete only vSwitches that are in the **Available** state.
        You cannot delete a vSwitch from a VPC where a vSwitch or a route is being created or deleted.
        **DeleteVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
        If the vSwitch is in the **Pending** state, the vSwitch is being deleted.
        If you cannot query the vSwitch, the vSwitch is deleted.
        You cannot repeatedly call the **DeleteVSwitch** operation to delete a vSwitch within the specified period of time.
        
        @param request: DeleteVSwitchRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVSwitchResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVSwitch',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVSwitchResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_vswitch_with_options_async(
        self,
        request: vpc_20160428_models.DeleteVSwitchRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVSwitchResponse:
        """
        @summary Deletes a vSwitch.
        
        @description When you call this operation, take note of the following limits:
        Before you delete a vSwitch, you must first release or remove all virtual private cloud (VPC) resources, including vSwitches, instances, router interfaces, and high-availability virtual IP addresses (HAVIPs).
        You can delete only vSwitches that are in the **Available** state.
        You cannot delete a vSwitch from a VPC where a vSwitch or a route is being created or deleted.
        **DeleteVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
        If the vSwitch is in the **Pending** state, the vSwitch is being deleted.
        If you cannot query the vSwitch, the vSwitch is deleted.
        You cannot repeatedly call the **DeleteVSwitch** operation to delete a vSwitch within the specified period of time.
        
        @param request: DeleteVSwitchRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVSwitchResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVSwitch',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVSwitchResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_vswitch(
        self,
        request: vpc_20160428_models.DeleteVSwitchRequest,
    ) -> vpc_20160428_models.DeleteVSwitchResponse:
        """
        @summary Deletes a vSwitch.
        
        @description When you call this operation, take note of the following limits:
        Before you delete a vSwitch, you must first release or remove all virtual private cloud (VPC) resources, including vSwitches, instances, router interfaces, and high-availability virtual IP addresses (HAVIPs).
        You can delete only vSwitches that are in the **Available** state.
        You cannot delete a vSwitch from a VPC where a vSwitch or a route is being created or deleted.
        **DeleteVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
        If the vSwitch is in the **Pending** state, the vSwitch is being deleted.
        If you cannot query the vSwitch, the vSwitch is deleted.
        You cannot repeatedly call the **DeleteVSwitch** operation to delete a vSwitch within the specified period of time.
        
        @param request: DeleteVSwitchRequest
        @return: DeleteVSwitchResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_vswitch_with_options(request, runtime)

    async def delete_vswitch_async(
        self,
        request: vpc_20160428_models.DeleteVSwitchRequest,
    ) -> vpc_20160428_models.DeleteVSwitchResponse:
        """
        @summary Deletes a vSwitch.
        
        @description When you call this operation, take note of the following limits:
        Before you delete a vSwitch, you must first release or remove all virtual private cloud (VPC) resources, including vSwitches, instances, router interfaces, and high-availability virtual IP addresses (HAVIPs).
        You can delete only vSwitches that are in the **Available** state.
        You cannot delete a vSwitch from a VPC where a vSwitch or a route is being created or deleted.
        **DeleteVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
        If the vSwitch is in the **Pending** state, the vSwitch is being deleted.
        If you cannot query the vSwitch, the vSwitch is deleted.
        You cannot repeatedly call the **DeleteVSwitch** operation to delete a vSwitch within the specified period of time.
        
        @param request: DeleteVSwitchRequest
        @return: DeleteVSwitchResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_vswitch_with_options_async(request, runtime)

    def delete_vswitch_cidr_reservation_with_options(
        self,
        request: vpc_20160428_models.DeleteVSwitchCidrReservationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVSwitchCidrReservationResponse:
        """
        @summary Deletes a reserved CIDR block of a vSwitch.
        
        @description ## [](#)Description
        Before you call this operation, make sure that the IP address allocated to an elastic network interface (ENI) from the reserved CIDR block is deleted. If the IP address of the ENI is not deleted, call [UnassignPrivateIpAddresses](https://help.aliyun.com/document_detail/85919.html) or [UnassignIpv6Addresses](https://help.aliyun.com/document_detail/98611.html) to delete the IPv4 or IPv6 address.
        **DeleteVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
        If the reserved CIDR block is in the **Releasing** state, it is being released.
        If the reserved CIDR block is in the **Released** state, it is released.
        
        @param request: DeleteVSwitchCidrReservationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVSwitchCidrReservationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_id):
            query['VSwitchCidrReservationId'] = request.v_switch_cidr_reservation_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVSwitchCidrReservation',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVSwitchCidrReservationResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_vswitch_cidr_reservation_with_options_async(
        self,
        request: vpc_20160428_models.DeleteVSwitchCidrReservationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVSwitchCidrReservationResponse:
        """
        @summary Deletes a reserved CIDR block of a vSwitch.
        
        @description ## [](#)Description
        Before you call this operation, make sure that the IP address allocated to an elastic network interface (ENI) from the reserved CIDR block is deleted. If the IP address of the ENI is not deleted, call [UnassignPrivateIpAddresses](https://help.aliyun.com/document_detail/85919.html) or [UnassignIpv6Addresses](https://help.aliyun.com/document_detail/98611.html) to delete the IPv4 or IPv6 address.
        **DeleteVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
        If the reserved CIDR block is in the **Releasing** state, it is being released.
        If the reserved CIDR block is in the **Released** state, it is released.
        
        @param request: DeleteVSwitchCidrReservationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVSwitchCidrReservationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_id):
            query['VSwitchCidrReservationId'] = request.v_switch_cidr_reservation_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVSwitchCidrReservation',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVSwitchCidrReservationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_vswitch_cidr_reservation(
        self,
        request: vpc_20160428_models.DeleteVSwitchCidrReservationRequest,
    ) -> vpc_20160428_models.DeleteVSwitchCidrReservationResponse:
        """
        @summary Deletes a reserved CIDR block of a vSwitch.
        
        @description ## [](#)Description
        Before you call this operation, make sure that the IP address allocated to an elastic network interface (ENI) from the reserved CIDR block is deleted. If the IP address of the ENI is not deleted, call [UnassignPrivateIpAddresses](https://help.aliyun.com/document_detail/85919.html) or [UnassignIpv6Addresses](https://help.aliyun.com/document_detail/98611.html) to delete the IPv4 or IPv6 address.
        **DeleteVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
        If the reserved CIDR block is in the **Releasing** state, it is being released.
        If the reserved CIDR block is in the **Released** state, it is released.
        
        @param request: DeleteVSwitchCidrReservationRequest
        @return: DeleteVSwitchCidrReservationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_vswitch_cidr_reservation_with_options(request, runtime)

    async def delete_vswitch_cidr_reservation_async(
        self,
        request: vpc_20160428_models.DeleteVSwitchCidrReservationRequest,
    ) -> vpc_20160428_models.DeleteVSwitchCidrReservationResponse:
        """
        @summary Deletes a reserved CIDR block of a vSwitch.
        
        @description ## [](#)Description
        Before you call this operation, make sure that the IP address allocated to an elastic network interface (ENI) from the reserved CIDR block is deleted. If the IP address of the ENI is not deleted, call [UnassignPrivateIpAddresses](https://help.aliyun.com/document_detail/85919.html) or [UnassignIpv6Addresses](https://help.aliyun.com/document_detail/98611.html) to delete the IPv4 or IPv6 address.
        **DeleteVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
        If the reserved CIDR block is in the **Releasing** state, it is being released.
        If the reserved CIDR block is in the **Released** state, it is released.
        
        @param request: DeleteVSwitchCidrReservationRequest
        @return: DeleteVSwitchCidrReservationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_vswitch_cidr_reservation_with_options_async(request, runtime)

    def delete_vbr_ha_with_options(
        self,
        request: vpc_20160428_models.DeleteVbrHaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVbrHaResponse:
        """
        @summary Deletes a virtual border router (VBR) failover group.
        
        @param request: DeleteVbrHaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVbrHaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVbrHa',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVbrHaResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_vbr_ha_with_options_async(
        self,
        request: vpc_20160428_models.DeleteVbrHaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVbrHaResponse:
        """
        @summary Deletes a virtual border router (VBR) failover group.
        
        @param request: DeleteVbrHaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVbrHaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVbrHa',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVbrHaResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_vbr_ha(
        self,
        request: vpc_20160428_models.DeleteVbrHaRequest,
    ) -> vpc_20160428_models.DeleteVbrHaResponse:
        """
        @summary Deletes a virtual border router (VBR) failover group.
        
        @param request: DeleteVbrHaRequest
        @return: DeleteVbrHaResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_vbr_ha_with_options(request, runtime)

    async def delete_vbr_ha_async(
        self,
        request: vpc_20160428_models.DeleteVbrHaRequest,
    ) -> vpc_20160428_models.DeleteVbrHaResponse:
        """
        @summary Deletes a virtual border router (VBR) failover group.
        
        @param request: DeleteVbrHaRequest
        @return: DeleteVbrHaResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_vbr_ha_with_options_async(request, runtime)

    def delete_vco_route_entry_with_options(
        self,
        request: vpc_20160428_models.DeleteVcoRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVcoRouteEntryResponse:
        """
        @summary Deletes a destination-based route from an IPsec-VPN connection.
        
        @description    **DeleteVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task.
        If the IPsec-VPN connection is in the **updating** state, the route is being deleted.
        If the IPsec-VPN connection is in the **attached** state, the route is deleted.
        You cannot repeatedly call the **DeleteVcoRouteEntry** operation within a specific time period.
        
        @param request: DeleteVcoRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVcoRouteEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.overlay_mode):
            query['OverlayMode'] = request.overlay_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVcoRouteEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVcoRouteEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_vco_route_entry_with_options_async(
        self,
        request: vpc_20160428_models.DeleteVcoRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVcoRouteEntryResponse:
        """
        @summary Deletes a destination-based route from an IPsec-VPN connection.
        
        @description    **DeleteVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task.
        If the IPsec-VPN connection is in the **updating** state, the route is being deleted.
        If the IPsec-VPN connection is in the **attached** state, the route is deleted.
        You cannot repeatedly call the **DeleteVcoRouteEntry** operation within a specific time period.
        
        @param request: DeleteVcoRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVcoRouteEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.overlay_mode):
            query['OverlayMode'] = request.overlay_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVcoRouteEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVcoRouteEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_vco_route_entry(
        self,
        request: vpc_20160428_models.DeleteVcoRouteEntryRequest,
    ) -> vpc_20160428_models.DeleteVcoRouteEntryResponse:
        """
        @summary Deletes a destination-based route from an IPsec-VPN connection.
        
        @description    **DeleteVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task.
        If the IPsec-VPN connection is in the **updating** state, the route is being deleted.
        If the IPsec-VPN connection is in the **attached** state, the route is deleted.
        You cannot repeatedly call the **DeleteVcoRouteEntry** operation within a specific time period.
        
        @param request: DeleteVcoRouteEntryRequest
        @return: DeleteVcoRouteEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_vco_route_entry_with_options(request, runtime)

    async def delete_vco_route_entry_async(
        self,
        request: vpc_20160428_models.DeleteVcoRouteEntryRequest,
    ) -> vpc_20160428_models.DeleteVcoRouteEntryResponse:
        """
        @summary Deletes a destination-based route from an IPsec-VPN connection.
        
        @description    **DeleteVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task.
        If the IPsec-VPN connection is in the **updating** state, the route is being deleted.
        If the IPsec-VPN connection is in the **attached** state, the route is deleted.
        You cannot repeatedly call the **DeleteVcoRouteEntry** operation within a specific time period.
        
        @param request: DeleteVcoRouteEntryRequest
        @return: DeleteVcoRouteEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_vco_route_entry_with_options_async(request, runtime)

    def delete_virtual_border_router_with_options(
        self,
        request: vpc_20160428_models.DeleteVirtualBorderRouterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVirtualBorderRouterResponse:
        """
        @summary Deletes a virtual border router (VBR).
        
        @description Before you call this operation, take note of the following limits:
        Before you delete a VBR, you must delete all router interfaces of the VBR.
        You can delete only a VBR in the **unconfirmed**, **active**, or **terminated** state.
        The owner of an Express Connect circuit can delete a VBR that belongs to another account only if the VBR is in the **unconfirmed** state.
        
        @param request: DeleteVirtualBorderRouterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVirtualBorderRouterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVirtualBorderRouter',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVirtualBorderRouterResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_virtual_border_router_with_options_async(
        self,
        request: vpc_20160428_models.DeleteVirtualBorderRouterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVirtualBorderRouterResponse:
        """
        @summary Deletes a virtual border router (VBR).
        
        @description Before you call this operation, take note of the following limits:
        Before you delete a VBR, you must delete all router interfaces of the VBR.
        You can delete only a VBR in the **unconfirmed**, **active**, or **terminated** state.
        The owner of an Express Connect circuit can delete a VBR that belongs to another account only if the VBR is in the **unconfirmed** state.
        
        @param request: DeleteVirtualBorderRouterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVirtualBorderRouterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVirtualBorderRouter',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVirtualBorderRouterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_virtual_border_router(
        self,
        request: vpc_20160428_models.DeleteVirtualBorderRouterRequest,
    ) -> vpc_20160428_models.DeleteVirtualBorderRouterResponse:
        """
        @summary Deletes a virtual border router (VBR).
        
        @description Before you call this operation, take note of the following limits:
        Before you delete a VBR, you must delete all router interfaces of the VBR.
        You can delete only a VBR in the **unconfirmed**, **active**, or **terminated** state.
        The owner of an Express Connect circuit can delete a VBR that belongs to another account only if the VBR is in the **unconfirmed** state.
        
        @param request: DeleteVirtualBorderRouterRequest
        @return: DeleteVirtualBorderRouterResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_virtual_border_router_with_options(request, runtime)

    async def delete_virtual_border_router_async(
        self,
        request: vpc_20160428_models.DeleteVirtualBorderRouterRequest,
    ) -> vpc_20160428_models.DeleteVirtualBorderRouterResponse:
        """
        @summary Deletes a virtual border router (VBR).
        
        @description Before you call this operation, take note of the following limits:
        Before you delete a VBR, you must delete all router interfaces of the VBR.
        You can delete only a VBR in the **unconfirmed**, **active**, or **terminated** state.
        The owner of an Express Connect circuit can delete a VBR that belongs to another account only if the VBR is in the **unconfirmed** state.
        
        @param request: DeleteVirtualBorderRouterRequest
        @return: DeleteVirtualBorderRouterResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_virtual_border_router_with_options_async(request, runtime)

    def delete_vpc_with_options(
        self,
        request: vpc_20160428_models.DeleteVpcRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVpcResponse:
        """
        @summary Deletes a virtual private cloud (VPC).
        
        @description When you call this operation, take note of the following limits:
        Before you delete a VPC, make sure that all resources deployed in the VPC are released or removed, such as vSwitches, instances, and high-availability virtual IP addresses (HAVIPs).
        You can delete only a VPC that is in the **Available** state.
        The **DeleteVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a VPC:
        If the VPC is in the **Deleting** state, the VPC is being deleted.
        If you cannot query the VPC, the VPC is deleted.
        You cannot repeatedly call the **DeleteVpc** operation to delete a VPC within the specified period of time.
        
        @param request: DeleteVpcRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVpcResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.force_delete):
            query['ForceDelete'] = request.force_delete
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVpc',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVpcResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_vpc_with_options_async(
        self,
        request: vpc_20160428_models.DeleteVpcRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVpcResponse:
        """
        @summary Deletes a virtual private cloud (VPC).
        
        @description When you call this operation, take note of the following limits:
        Before you delete a VPC, make sure that all resources deployed in the VPC are released or removed, such as vSwitches, instances, and high-availability virtual IP addresses (HAVIPs).
        You can delete only a VPC that is in the **Available** state.
        The **DeleteVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a VPC:
        If the VPC is in the **Deleting** state, the VPC is being deleted.
        If you cannot query the VPC, the VPC is deleted.
        You cannot repeatedly call the **DeleteVpc** operation to delete a VPC within the specified period of time.
        
        @param request: DeleteVpcRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVpcResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.force_delete):
            query['ForceDelete'] = request.force_delete
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVpc',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVpcResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_vpc(
        self,
        request: vpc_20160428_models.DeleteVpcRequest,
    ) -> vpc_20160428_models.DeleteVpcResponse:
        """
        @summary Deletes a virtual private cloud (VPC).
        
        @description When you call this operation, take note of the following limits:
        Before you delete a VPC, make sure that all resources deployed in the VPC are released or removed, such as vSwitches, instances, and high-availability virtual IP addresses (HAVIPs).
        You can delete only a VPC that is in the **Available** state.
        The **DeleteVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a VPC:
        If the VPC is in the **Deleting** state, the VPC is being deleted.
        If you cannot query the VPC, the VPC is deleted.
        You cannot repeatedly call the **DeleteVpc** operation to delete a VPC within the specified period of time.
        
        @param request: DeleteVpcRequest
        @return: DeleteVpcResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_vpc_with_options(request, runtime)

    async def delete_vpc_async(
        self,
        request: vpc_20160428_models.DeleteVpcRequest,
    ) -> vpc_20160428_models.DeleteVpcResponse:
        """
        @summary Deletes a virtual private cloud (VPC).
        
        @description When you call this operation, take note of the following limits:
        Before you delete a VPC, make sure that all resources deployed in the VPC are released or removed, such as vSwitches, instances, and high-availability virtual IP addresses (HAVIPs).
        You can delete only a VPC that is in the **Available** state.
        The **DeleteVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a VPC:
        If the VPC is in the **Deleting** state, the VPC is being deleted.
        If you cannot query the VPC, the VPC is deleted.
        You cannot repeatedly call the **DeleteVpc** operation to delete a VPC within the specified period of time.
        
        @param request: DeleteVpcRequest
        @return: DeleteVpcResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_vpc_with_options_async(request, runtime)

    def delete_vpc_gateway_endpoint_with_options(
        self,
        request: vpc_20160428_models.DeleteVpcGatewayEndpointRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVpcGatewayEndpointResponse:
        """
        @summary Deletes a gateway endpoint.
        
        @param request: DeleteVpcGatewayEndpointRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVpcGatewayEndpointResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.endpoint_id):
            query['EndpointId'] = request.endpoint_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVpcGatewayEndpoint',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVpcGatewayEndpointResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_vpc_gateway_endpoint_with_options_async(
        self,
        request: vpc_20160428_models.DeleteVpcGatewayEndpointRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVpcGatewayEndpointResponse:
        """
        @summary Deletes a gateway endpoint.
        
        @param request: DeleteVpcGatewayEndpointRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVpcGatewayEndpointResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.endpoint_id):
            query['EndpointId'] = request.endpoint_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVpcGatewayEndpoint',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVpcGatewayEndpointResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_vpc_gateway_endpoint(
        self,
        request: vpc_20160428_models.DeleteVpcGatewayEndpointRequest,
    ) -> vpc_20160428_models.DeleteVpcGatewayEndpointResponse:
        """
        @summary Deletes a gateway endpoint.
        
        @param request: DeleteVpcGatewayEndpointRequest
        @return: DeleteVpcGatewayEndpointResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_vpc_gateway_endpoint_with_options(request, runtime)

    async def delete_vpc_gateway_endpoint_async(
        self,
        request: vpc_20160428_models.DeleteVpcGatewayEndpointRequest,
    ) -> vpc_20160428_models.DeleteVpcGatewayEndpointResponse:
        """
        @summary Deletes a gateway endpoint.
        
        @param request: DeleteVpcGatewayEndpointRequest
        @return: DeleteVpcGatewayEndpointResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_vpc_gateway_endpoint_with_options_async(request, runtime)

    def delete_vpc_prefix_list_with_options(
        self,
        request: vpc_20160428_models.DeleteVpcPrefixListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVpcPrefixListResponse:
        """
        @summary Deletes a prefix list.
        
        @description You cannot repeatedly call the *DeleteDhcpOptionsSet** operation to delete a prefix list within the specified period of time.
        
        @param request: DeleteVpcPrefixListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVpcPrefixListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_id):
            query['PrefixListId'] = request.prefix_list_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVpcPrefixList',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVpcPrefixListResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_vpc_prefix_list_with_options_async(
        self,
        request: vpc_20160428_models.DeleteVpcPrefixListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVpcPrefixListResponse:
        """
        @summary Deletes a prefix list.
        
        @description You cannot repeatedly call the *DeleteDhcpOptionsSet** operation to delete a prefix list within the specified period of time.
        
        @param request: DeleteVpcPrefixListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVpcPrefixListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_id):
            query['PrefixListId'] = request.prefix_list_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVpcPrefixList',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVpcPrefixListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_vpc_prefix_list(
        self,
        request: vpc_20160428_models.DeleteVpcPrefixListRequest,
    ) -> vpc_20160428_models.DeleteVpcPrefixListResponse:
        """
        @summary Deletes a prefix list.
        
        @description You cannot repeatedly call the *DeleteDhcpOptionsSet** operation to delete a prefix list within the specified period of time.
        
        @param request: DeleteVpcPrefixListRequest
        @return: DeleteVpcPrefixListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_vpc_prefix_list_with_options(request, runtime)

    async def delete_vpc_prefix_list_async(
        self,
        request: vpc_20160428_models.DeleteVpcPrefixListRequest,
    ) -> vpc_20160428_models.DeleteVpcPrefixListResponse:
        """
        @summary Deletes a prefix list.
        
        @description You cannot repeatedly call the *DeleteDhcpOptionsSet** operation to delete a prefix list within the specified period of time.
        
        @param request: DeleteVpcPrefixListRequest
        @return: DeleteVpcPrefixListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_vpc_prefix_list_with_options_async(request, runtime)

    def delete_vpn_attachment_with_options(
        self,
        request: vpc_20160428_models.DeleteVpnAttachmentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVpnAttachmentResponse:
        """
        @summary Deletes an IPsec-VPN connection.
        
        @description    If an IPsec-VPN connection is associated with a transit router, you must disassociate the transit router from the IPsec-VPN connection before you delete the IPsec-VPN connection. For more information, see [DeleteTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468251.html).
        If an IPsec-VPN connection is not associated with a resource, you can call `DeleteVpnAttachment` to directly delete the IPsec-VPN connection.
        
        @param request: DeleteVpnAttachmentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVpnAttachmentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVpnAttachment',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVpnAttachmentResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_vpn_attachment_with_options_async(
        self,
        request: vpc_20160428_models.DeleteVpnAttachmentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVpnAttachmentResponse:
        """
        @summary Deletes an IPsec-VPN connection.
        
        @description    If an IPsec-VPN connection is associated with a transit router, you must disassociate the transit router from the IPsec-VPN connection before you delete the IPsec-VPN connection. For more information, see [DeleteTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468251.html).
        If an IPsec-VPN connection is not associated with a resource, you can call `DeleteVpnAttachment` to directly delete the IPsec-VPN connection.
        
        @param request: DeleteVpnAttachmentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVpnAttachmentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVpnAttachment',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVpnAttachmentResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_vpn_attachment(
        self,
        request: vpc_20160428_models.DeleteVpnAttachmentRequest,
    ) -> vpc_20160428_models.DeleteVpnAttachmentResponse:
        """
        @summary Deletes an IPsec-VPN connection.
        
        @description    If an IPsec-VPN connection is associated with a transit router, you must disassociate the transit router from the IPsec-VPN connection before you delete the IPsec-VPN connection. For more information, see [DeleteTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468251.html).
        If an IPsec-VPN connection is not associated with a resource, you can call `DeleteVpnAttachment` to directly delete the IPsec-VPN connection.
        
        @param request: DeleteVpnAttachmentRequest
        @return: DeleteVpnAttachmentResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_vpn_attachment_with_options(request, runtime)

    async def delete_vpn_attachment_async(
        self,
        request: vpc_20160428_models.DeleteVpnAttachmentRequest,
    ) -> vpc_20160428_models.DeleteVpnAttachmentResponse:
        """
        @summary Deletes an IPsec-VPN connection.
        
        @description    If an IPsec-VPN connection is associated with a transit router, you must disassociate the transit router from the IPsec-VPN connection before you delete the IPsec-VPN connection. For more information, see [DeleteTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468251.html).
        If an IPsec-VPN connection is not associated with a resource, you can call `DeleteVpnAttachment` to directly delete the IPsec-VPN connection.
        
        @param request: DeleteVpnAttachmentRequest
        @return: DeleteVpnAttachmentResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_vpn_attachment_with_options_async(request, runtime)

    def delete_vpn_connection_with_options(
        self,
        request: vpc_20160428_models.DeleteVpnConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVpnConnectionResponse:
        """
        @summary Deletes an IPsec-VPN connection.
        
        @description    **DeleteVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
        If a VPN gateway is in the **updating** state, the IPsec-VPN connection is being deleted.
        If a VPN gateway is in the **active** state, the IPsec-VPN connection has been deleted.
        You cannot call the **DeleteVpnConnection** operation to delete multiple IPsec-VPN connections for a VPN gateway at a time.
        >  After an IPsec-VPN connection between a data center and Alibaba Cloud is deleted, the connection between the data center and Alibaba Cloud is closed.
        
        @param request: DeleteVpnConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVpnConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVpnConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVpnConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_vpn_connection_with_options_async(
        self,
        request: vpc_20160428_models.DeleteVpnConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVpnConnectionResponse:
        """
        @summary Deletes an IPsec-VPN connection.
        
        @description    **DeleteVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
        If a VPN gateway is in the **updating** state, the IPsec-VPN connection is being deleted.
        If a VPN gateway is in the **active** state, the IPsec-VPN connection has been deleted.
        You cannot call the **DeleteVpnConnection** operation to delete multiple IPsec-VPN connections for a VPN gateway at a time.
        >  After an IPsec-VPN connection between a data center and Alibaba Cloud is deleted, the connection between the data center and Alibaba Cloud is closed.
        
        @param request: DeleteVpnConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVpnConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVpnConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVpnConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_vpn_connection(
        self,
        request: vpc_20160428_models.DeleteVpnConnectionRequest,
    ) -> vpc_20160428_models.DeleteVpnConnectionResponse:
        """
        @summary Deletes an IPsec-VPN connection.
        
        @description    **DeleteVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
        If a VPN gateway is in the **updating** state, the IPsec-VPN connection is being deleted.
        If a VPN gateway is in the **active** state, the IPsec-VPN connection has been deleted.
        You cannot call the **DeleteVpnConnection** operation to delete multiple IPsec-VPN connections for a VPN gateway at a time.
        >  After an IPsec-VPN connection between a data center and Alibaba Cloud is deleted, the connection between the data center and Alibaba Cloud is closed.
        
        @param request: DeleteVpnConnectionRequest
        @return: DeleteVpnConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_vpn_connection_with_options(request, runtime)

    async def delete_vpn_connection_async(
        self,
        request: vpc_20160428_models.DeleteVpnConnectionRequest,
    ) -> vpc_20160428_models.DeleteVpnConnectionResponse:
        """
        @summary Deletes an IPsec-VPN connection.
        
        @description    **DeleteVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
        If a VPN gateway is in the **updating** state, the IPsec-VPN connection is being deleted.
        If a VPN gateway is in the **active** state, the IPsec-VPN connection has been deleted.
        You cannot call the **DeleteVpnConnection** operation to delete multiple IPsec-VPN connections for a VPN gateway at a time.
        >  After an IPsec-VPN connection between a data center and Alibaba Cloud is deleted, the connection between the data center and Alibaba Cloud is closed.
        
        @param request: DeleteVpnConnectionRequest
        @return: DeleteVpnConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_vpn_connection_with_options_async(request, runtime)

    def delete_vpn_gateway_with_options(
        self,
        request: vpc_20160428_models.DeleteVpnGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVpnGatewayResponse:
        """
        @summary Deletes a VPN gateway.
        
        @description >  You cannot delete a VPN gateway associated with existing IPsec-VPN connections.
        
        @param request: DeleteVpnGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVpnGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVpnGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVpnGatewayResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_vpn_gateway_with_options_async(
        self,
        request: vpc_20160428_models.DeleteVpnGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVpnGatewayResponse:
        """
        @summary Deletes a VPN gateway.
        
        @description >  You cannot delete a VPN gateway associated with existing IPsec-VPN connections.
        
        @param request: DeleteVpnGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVpnGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVpnGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVpnGatewayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_vpn_gateway(
        self,
        request: vpc_20160428_models.DeleteVpnGatewayRequest,
    ) -> vpc_20160428_models.DeleteVpnGatewayResponse:
        """
        @summary Deletes a VPN gateway.
        
        @description >  You cannot delete a VPN gateway associated with existing IPsec-VPN connections.
        
        @param request: DeleteVpnGatewayRequest
        @return: DeleteVpnGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_vpn_gateway_with_options(request, runtime)

    async def delete_vpn_gateway_async(
        self,
        request: vpc_20160428_models.DeleteVpnGatewayRequest,
    ) -> vpc_20160428_models.DeleteVpnGatewayResponse:
        """
        @summary Deletes a VPN gateway.
        
        @description >  You cannot delete a VPN gateway associated with existing IPsec-VPN connections.
        
        @param request: DeleteVpnGatewayRequest
        @return: DeleteVpnGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_vpn_gateway_with_options_async(request, runtime)

    def delete_vpn_pbr_route_entry_with_options(
        self,
        request: vpc_20160428_models.DeleteVpnPbrRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVpnPbrRouteEntryResponse:
        """
        @summary Deletes a policy-based route from a VPN gateway.
        
        @description    **DeleteVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the policy-based route is being deleted.
        If a VPN gateway is in the **active** state, the policy-based route has been deleted.
        You cannot repeatedly call **DeleteVpnPbrRouteEntry** to delete a policy-based route within the specified period of time.
        
        @param request: DeleteVpnPbrRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVpnPbrRouteEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.overlay_mode):
            query['OverlayMode'] = request.overlay_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.route_source):
            query['RouteSource'] = request.route_source
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVpnPbrRouteEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVpnPbrRouteEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_vpn_pbr_route_entry_with_options_async(
        self,
        request: vpc_20160428_models.DeleteVpnPbrRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVpnPbrRouteEntryResponse:
        """
        @summary Deletes a policy-based route from a VPN gateway.
        
        @description    **DeleteVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the policy-based route is being deleted.
        If a VPN gateway is in the **active** state, the policy-based route has been deleted.
        You cannot repeatedly call **DeleteVpnPbrRouteEntry** to delete a policy-based route within the specified period of time.
        
        @param request: DeleteVpnPbrRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVpnPbrRouteEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.overlay_mode):
            query['OverlayMode'] = request.overlay_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.route_source):
            query['RouteSource'] = request.route_source
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVpnPbrRouteEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVpnPbrRouteEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_vpn_pbr_route_entry(
        self,
        request: vpc_20160428_models.DeleteVpnPbrRouteEntryRequest,
    ) -> vpc_20160428_models.DeleteVpnPbrRouteEntryResponse:
        """
        @summary Deletes a policy-based route from a VPN gateway.
        
        @description    **DeleteVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the policy-based route is being deleted.
        If a VPN gateway is in the **active** state, the policy-based route has been deleted.
        You cannot repeatedly call **DeleteVpnPbrRouteEntry** to delete a policy-based route within the specified period of time.
        
        @param request: DeleteVpnPbrRouteEntryRequest
        @return: DeleteVpnPbrRouteEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_vpn_pbr_route_entry_with_options(request, runtime)

    async def delete_vpn_pbr_route_entry_async(
        self,
        request: vpc_20160428_models.DeleteVpnPbrRouteEntryRequest,
    ) -> vpc_20160428_models.DeleteVpnPbrRouteEntryResponse:
        """
        @summary Deletes a policy-based route from a VPN gateway.
        
        @description    **DeleteVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the policy-based route is being deleted.
        If a VPN gateway is in the **active** state, the policy-based route has been deleted.
        You cannot repeatedly call **DeleteVpnPbrRouteEntry** to delete a policy-based route within the specified period of time.
        
        @param request: DeleteVpnPbrRouteEntryRequest
        @return: DeleteVpnPbrRouteEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_vpn_pbr_route_entry_with_options_async(request, runtime)

    def delete_vpn_route_entry_with_options(
        self,
        request: vpc_20160428_models.DeleteVpnRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVpnRouteEntryResponse:
        """
        @summary Deletes a destination-based route from a VPN gateway.
        
        @description    **DeleteVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the destination-based route is being deleted.
        If the VPN gateway is in the **active** state, the destination-based route is deleted.
        You cannot repeatedly call **DeleteVpnRouteEntry** to delete a destination-based route from a VPN gateway within the specified period of time.
        
        @param request: DeleteVpnRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVpnRouteEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.overlay_mode):
            query['OverlayMode'] = request.overlay_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVpnRouteEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVpnRouteEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_vpn_route_entry_with_options_async(
        self,
        request: vpc_20160428_models.DeleteVpnRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeleteVpnRouteEntryResponse:
        """
        @summary Deletes a destination-based route from a VPN gateway.
        
        @description    **DeleteVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the destination-based route is being deleted.
        If the VPN gateway is in the **active** state, the destination-based route is deleted.
        You cannot repeatedly call **DeleteVpnRouteEntry** to delete a destination-based route from a VPN gateway within the specified period of time.
        
        @param request: DeleteVpnRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVpnRouteEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.overlay_mode):
            query['OverlayMode'] = request.overlay_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVpnRouteEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeleteVpnRouteEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_vpn_route_entry(
        self,
        request: vpc_20160428_models.DeleteVpnRouteEntryRequest,
    ) -> vpc_20160428_models.DeleteVpnRouteEntryResponse:
        """
        @summary Deletes a destination-based route from a VPN gateway.
        
        @description    **DeleteVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the destination-based route is being deleted.
        If the VPN gateway is in the **active** state, the destination-based route is deleted.
        You cannot repeatedly call **DeleteVpnRouteEntry** to delete a destination-based route from a VPN gateway within the specified period of time.
        
        @param request: DeleteVpnRouteEntryRequest
        @return: DeleteVpnRouteEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_vpn_route_entry_with_options(request, runtime)

    async def delete_vpn_route_entry_async(
        self,
        request: vpc_20160428_models.DeleteVpnRouteEntryRequest,
    ) -> vpc_20160428_models.DeleteVpnRouteEntryResponse:
        """
        @summary Deletes a destination-based route from a VPN gateway.
        
        @description    **DeleteVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the destination-based route is being deleted.
        If the VPN gateway is in the **active** state, the destination-based route is deleted.
        You cannot repeatedly call **DeleteVpnRouteEntry** to delete a destination-based route from a VPN gateway within the specified period of time.
        
        @param request: DeleteVpnRouteEntryRequest
        @return: DeleteVpnRouteEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_vpn_route_entry_with_options_async(request, runtime)

    def deletion_protection_with_options(
        self,
        request: vpc_20160428_models.DeletionProtectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeletionProtectionResponse:
        """
        @summary 
        
        @description After you enable deletion protection for an instance, you cannot delete the instance. You must disable deletion protection before you can delete the instance.
        
        @param request: DeletionProtectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletionProtectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.protection_enable):
            query['ProtectionEnable'] = request.protection_enable
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeletionProtection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeletionProtectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def deletion_protection_with_options_async(
        self,
        request: vpc_20160428_models.DeletionProtectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DeletionProtectionResponse:
        """
        @summary 
        
        @description After you enable deletion protection for an instance, you cannot delete the instance. You must disable deletion protection before you can delete the instance.
        
        @param request: DeletionProtectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletionProtectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.protection_enable):
            query['ProtectionEnable'] = request.protection_enable
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeletionProtection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DeletionProtectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def deletion_protection(
        self,
        request: vpc_20160428_models.DeletionProtectionRequest,
    ) -> vpc_20160428_models.DeletionProtectionResponse:
        """
        @summary 
        
        @description After you enable deletion protection for an instance, you cannot delete the instance. You must disable deletion protection before you can delete the instance.
        
        @param request: DeletionProtectionRequest
        @return: DeletionProtectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.deletion_protection_with_options(request, runtime)

    async def deletion_protection_async(
        self,
        request: vpc_20160428_models.DeletionProtectionRequest,
    ) -> vpc_20160428_models.DeletionProtectionResponse:
        """
        @summary 
        
        @description After you enable deletion protection for an instance, you cannot delete the instance. You must disable deletion protection before you can delete the instance.
        
        @param request: DeletionProtectionRequest
        @return: DeletionProtectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.deletion_protection_with_options_async(request, runtime)

    def describe_95traffic_with_options(
        self,
        request: vpc_20160428_models.Describe95TrafficRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.Describe95TrafficResponse:
        """
        @summary Queries traffic data of a pay-by-enhanced-95th-percentile Internet Shared Bandwidth instance.
        
        @param request: Describe95TrafficRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: Describe95TrafficResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.day):
            query['Day'] = request.day
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='Describe95Traffic',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.Describe95TrafficResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_95traffic_with_options_async(
        self,
        request: vpc_20160428_models.Describe95TrafficRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.Describe95TrafficResponse:
        """
        @summary Queries traffic data of a pay-by-enhanced-95th-percentile Internet Shared Bandwidth instance.
        
        @param request: Describe95TrafficRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: Describe95TrafficResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.day):
            query['Day'] = request.day
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='Describe95Traffic',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.Describe95TrafficResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_95traffic(
        self,
        request: vpc_20160428_models.Describe95TrafficRequest,
    ) -> vpc_20160428_models.Describe95TrafficResponse:
        """
        @summary Queries traffic data of a pay-by-enhanced-95th-percentile Internet Shared Bandwidth instance.
        
        @param request: Describe95TrafficRequest
        @return: Describe95TrafficResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_95traffic_with_options(request, runtime)

    async def describe_95traffic_async(
        self,
        request: vpc_20160428_models.Describe95TrafficRequest,
    ) -> vpc_20160428_models.Describe95TrafficResponse:
        """
        @summary Queries traffic data of a pay-by-enhanced-95th-percentile Internet Shared Bandwidth instance.
        
        @param request: Describe95TrafficRequest
        @return: Describe95TrafficResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_95traffic_with_options_async(request, runtime)

    def describe_access_points_with_options(
        self,
        request: vpc_20160428_models.DescribeAccessPointsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeAccessPointsResponse:
        """
        @summary Queries the access points of Express Connect circuits in a region.
        
        @param request: DescribeAccessPointsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAccessPointsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.accept_language):
            query['AcceptLanguage'] = request.accept_language
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAccessPoints',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeAccessPointsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_access_points_with_options_async(
        self,
        request: vpc_20160428_models.DescribeAccessPointsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeAccessPointsResponse:
        """
        @summary Queries the access points of Express Connect circuits in a region.
        
        @param request: DescribeAccessPointsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAccessPointsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.accept_language):
            query['AcceptLanguage'] = request.accept_language
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAccessPoints',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeAccessPointsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_access_points(
        self,
        request: vpc_20160428_models.DescribeAccessPointsRequest,
    ) -> vpc_20160428_models.DescribeAccessPointsResponse:
        """
        @summary Queries the access points of Express Connect circuits in a region.
        
        @param request: DescribeAccessPointsRequest
        @return: DescribeAccessPointsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_access_points_with_options(request, runtime)

    async def describe_access_points_async(
        self,
        request: vpc_20160428_models.DescribeAccessPointsRequest,
    ) -> vpc_20160428_models.DescribeAccessPointsResponse:
        """
        @summary Queries the access points of Express Connect circuits in a region.
        
        @param request: DescribeAccessPointsRequest
        @return: DescribeAccessPointsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_access_points_with_options_async(request, runtime)

    def describe_bgp_groups_with_options(
        self,
        request: vpc_20160428_models.DescribeBgpGroupsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeBgpGroupsResponse:
        """
        @summary Queries Border Gateway Protocol (BGP) groups in a region.
        
        @param request: DescribeBgpGroupsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeBgpGroupsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bgp_group_id):
            query['BgpGroupId'] = request.bgp_group_id
        if not UtilClient.is_unset(request.is_default):
            query['IsDefault'] = request.is_default
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeBgpGroups',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeBgpGroupsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_bgp_groups_with_options_async(
        self,
        request: vpc_20160428_models.DescribeBgpGroupsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeBgpGroupsResponse:
        """
        @summary Queries Border Gateway Protocol (BGP) groups in a region.
        
        @param request: DescribeBgpGroupsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeBgpGroupsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bgp_group_id):
            query['BgpGroupId'] = request.bgp_group_id
        if not UtilClient.is_unset(request.is_default):
            query['IsDefault'] = request.is_default
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeBgpGroups',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeBgpGroupsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_bgp_groups(
        self,
        request: vpc_20160428_models.DescribeBgpGroupsRequest,
    ) -> vpc_20160428_models.DescribeBgpGroupsResponse:
        """
        @summary Queries Border Gateway Protocol (BGP) groups in a region.
        
        @param request: DescribeBgpGroupsRequest
        @return: DescribeBgpGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_bgp_groups_with_options(request, runtime)

    async def describe_bgp_groups_async(
        self,
        request: vpc_20160428_models.DescribeBgpGroupsRequest,
    ) -> vpc_20160428_models.DescribeBgpGroupsResponse:
        """
        @summary Queries Border Gateway Protocol (BGP) groups in a region.
        
        @param request: DescribeBgpGroupsRequest
        @return: DescribeBgpGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_bgp_groups_with_options_async(request, runtime)

    def describe_bgp_networks_with_options(
        self,
        request: vpc_20160428_models.DescribeBgpNetworksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeBgpNetworksResponse:
        """
        @summary Queries advertised Border Gateway Protocol (BGP) networks.
        
        @param request: DescribeBgpNetworksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeBgpNetworksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeBgpNetworks',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeBgpNetworksResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_bgp_networks_with_options_async(
        self,
        request: vpc_20160428_models.DescribeBgpNetworksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeBgpNetworksResponse:
        """
        @summary Queries advertised Border Gateway Protocol (BGP) networks.
        
        @param request: DescribeBgpNetworksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeBgpNetworksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeBgpNetworks',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeBgpNetworksResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_bgp_networks(
        self,
        request: vpc_20160428_models.DescribeBgpNetworksRequest,
    ) -> vpc_20160428_models.DescribeBgpNetworksResponse:
        """
        @summary Queries advertised Border Gateway Protocol (BGP) networks.
        
        @param request: DescribeBgpNetworksRequest
        @return: DescribeBgpNetworksResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_bgp_networks_with_options(request, runtime)

    async def describe_bgp_networks_async(
        self,
        request: vpc_20160428_models.DescribeBgpNetworksRequest,
    ) -> vpc_20160428_models.DescribeBgpNetworksResponse:
        """
        @summary Queries advertised Border Gateway Protocol (BGP) networks.
        
        @param request: DescribeBgpNetworksRequest
        @return: DescribeBgpNetworksResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_bgp_networks_with_options_async(request, runtime)

    def describe_bgp_peers_with_options(
        self,
        request: vpc_20160428_models.DescribeBgpPeersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeBgpPeersResponse:
        """
        @summary Queries Border Gateway Protocol (BGP) peers in a region.
        
        @param request: DescribeBgpPeersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeBgpPeersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bgp_group_id):
            query['BgpGroupId'] = request.bgp_group_id
        if not UtilClient.is_unset(request.bgp_peer_id):
            query['BgpPeerId'] = request.bgp_peer_id
        if not UtilClient.is_unset(request.is_default):
            query['IsDefault'] = request.is_default
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeBgpPeers',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeBgpPeersResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_bgp_peers_with_options_async(
        self,
        request: vpc_20160428_models.DescribeBgpPeersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeBgpPeersResponse:
        """
        @summary Queries Border Gateway Protocol (BGP) peers in a region.
        
        @param request: DescribeBgpPeersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeBgpPeersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bgp_group_id):
            query['BgpGroupId'] = request.bgp_group_id
        if not UtilClient.is_unset(request.bgp_peer_id):
            query['BgpPeerId'] = request.bgp_peer_id
        if not UtilClient.is_unset(request.is_default):
            query['IsDefault'] = request.is_default
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeBgpPeers',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeBgpPeersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_bgp_peers(
        self,
        request: vpc_20160428_models.DescribeBgpPeersRequest,
    ) -> vpc_20160428_models.DescribeBgpPeersResponse:
        """
        @summary Queries Border Gateway Protocol (BGP) peers in a region.
        
        @param request: DescribeBgpPeersRequest
        @return: DescribeBgpPeersResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_bgp_peers_with_options(request, runtime)

    async def describe_bgp_peers_async(
        self,
        request: vpc_20160428_models.DescribeBgpPeersRequest,
    ) -> vpc_20160428_models.DescribeBgpPeersResponse:
        """
        @summary Queries Border Gateway Protocol (BGP) peers in a region.
        
        @param request: DescribeBgpPeersRequest
        @return: DescribeBgpPeersResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_bgp_peers_with_options_async(request, runtime)

    def describe_common_bandwidth_packages_with_options(
        self,
        request: vpc_20160428_models.DescribeCommonBandwidthPackagesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeCommonBandwidthPackagesResponse:
        """
        @summary Queries a list of Internet Shared Bandwidth instances in a region.
        
        @param request: DescribeCommonBandwidthPackagesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCommonBandwidthPackagesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.include_reservation_data):
            query['IncludeReservationData'] = request.include_reservation_data
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_protection_enabled):
            query['SecurityProtectionEnabled'] = request.security_protection_enabled
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCommonBandwidthPackages',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeCommonBandwidthPackagesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_common_bandwidth_packages_with_options_async(
        self,
        request: vpc_20160428_models.DescribeCommonBandwidthPackagesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeCommonBandwidthPackagesResponse:
        """
        @summary Queries a list of Internet Shared Bandwidth instances in a region.
        
        @param request: DescribeCommonBandwidthPackagesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCommonBandwidthPackagesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.include_reservation_data):
            query['IncludeReservationData'] = request.include_reservation_data
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_protection_enabled):
            query['SecurityProtectionEnabled'] = request.security_protection_enabled
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCommonBandwidthPackages',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeCommonBandwidthPackagesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_common_bandwidth_packages(
        self,
        request: vpc_20160428_models.DescribeCommonBandwidthPackagesRequest,
    ) -> vpc_20160428_models.DescribeCommonBandwidthPackagesResponse:
        """
        @summary Queries a list of Internet Shared Bandwidth instances in a region.
        
        @param request: DescribeCommonBandwidthPackagesRequest
        @return: DescribeCommonBandwidthPackagesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_common_bandwidth_packages_with_options(request, runtime)

    async def describe_common_bandwidth_packages_async(
        self,
        request: vpc_20160428_models.DescribeCommonBandwidthPackagesRequest,
    ) -> vpc_20160428_models.DescribeCommonBandwidthPackagesResponse:
        """
        @summary Queries a list of Internet Shared Bandwidth instances in a region.
        
        @param request: DescribeCommonBandwidthPackagesRequest
        @return: DescribeCommonBandwidthPackagesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_common_bandwidth_packages_with_options_async(request, runtime)

    def describe_customer_gateway_with_options(
        self,
        request: vpc_20160428_models.DescribeCustomerGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeCustomerGatewayResponse:
        """
        @summary Queries details of a customer gateway.
        
        @param request: DescribeCustomerGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCustomerGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.customer_gateway_id):
            query['CustomerGatewayId'] = request.customer_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCustomerGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeCustomerGatewayResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_customer_gateway_with_options_async(
        self,
        request: vpc_20160428_models.DescribeCustomerGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeCustomerGatewayResponse:
        """
        @summary Queries details of a customer gateway.
        
        @param request: DescribeCustomerGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCustomerGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.customer_gateway_id):
            query['CustomerGatewayId'] = request.customer_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCustomerGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeCustomerGatewayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_customer_gateway(
        self,
        request: vpc_20160428_models.DescribeCustomerGatewayRequest,
    ) -> vpc_20160428_models.DescribeCustomerGatewayResponse:
        """
        @summary Queries details of a customer gateway.
        
        @param request: DescribeCustomerGatewayRequest
        @return: DescribeCustomerGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_customer_gateway_with_options(request, runtime)

    async def describe_customer_gateway_async(
        self,
        request: vpc_20160428_models.DescribeCustomerGatewayRequest,
    ) -> vpc_20160428_models.DescribeCustomerGatewayResponse:
        """
        @summary Queries details of a customer gateway.
        
        @param request: DescribeCustomerGatewayRequest
        @return: DescribeCustomerGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_customer_gateway_with_options_async(request, runtime)

    def describe_customer_gateways_with_options(
        self,
        request: vpc_20160428_models.DescribeCustomerGatewaysRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeCustomerGatewaysResponse:
        """
        @summary Queries customer gateways.
        
        @param request: DescribeCustomerGatewaysRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCustomerGatewaysResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.customer_gateway_id):
            query['CustomerGatewayId'] = request.customer_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCustomerGateways',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeCustomerGatewaysResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_customer_gateways_with_options_async(
        self,
        request: vpc_20160428_models.DescribeCustomerGatewaysRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeCustomerGatewaysResponse:
        """
        @summary Queries customer gateways.
        
        @param request: DescribeCustomerGatewaysRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCustomerGatewaysResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.customer_gateway_id):
            query['CustomerGatewayId'] = request.customer_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCustomerGateways',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeCustomerGatewaysResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_customer_gateways(
        self,
        request: vpc_20160428_models.DescribeCustomerGatewaysRequest,
    ) -> vpc_20160428_models.DescribeCustomerGatewaysResponse:
        """
        @summary Queries customer gateways.
        
        @param request: DescribeCustomerGatewaysRequest
        @return: DescribeCustomerGatewaysResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_customer_gateways_with_options(request, runtime)

    async def describe_customer_gateways_async(
        self,
        request: vpc_20160428_models.DescribeCustomerGatewaysRequest,
    ) -> vpc_20160428_models.DescribeCustomerGatewaysResponse:
        """
        @summary Queries customer gateways.
        
        @param request: DescribeCustomerGatewaysRequest
        @return: DescribeCustomerGatewaysResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_customer_gateways_with_options_async(request, runtime)

    def describe_ec_grant_relation_with_options(
        self,
        request: vpc_20160428_models.DescribeEcGrantRelationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeEcGrantRelationResponse:
        """
        @summary Queries whether permissions on a virtual private cloud (VPC) are granted to a virtual border router (VBR).
        
        @param request: DescribeEcGrantRelationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEcGrantRelationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.vbr_region_no):
            query['VbrRegionNo'] = request.vbr_region_no
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEcGrantRelation',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeEcGrantRelationResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_ec_grant_relation_with_options_async(
        self,
        request: vpc_20160428_models.DescribeEcGrantRelationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeEcGrantRelationResponse:
        """
        @summary Queries whether permissions on a virtual private cloud (VPC) are granted to a virtual border router (VBR).
        
        @param request: DescribeEcGrantRelationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEcGrantRelationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.vbr_region_no):
            query['VbrRegionNo'] = request.vbr_region_no
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEcGrantRelation',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeEcGrantRelationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_ec_grant_relation(
        self,
        request: vpc_20160428_models.DescribeEcGrantRelationRequest,
    ) -> vpc_20160428_models.DescribeEcGrantRelationResponse:
        """
        @summary Queries whether permissions on a virtual private cloud (VPC) are granted to a virtual border router (VBR).
        
        @param request: DescribeEcGrantRelationRequest
        @return: DescribeEcGrantRelationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_ec_grant_relation_with_options(request, runtime)

    async def describe_ec_grant_relation_async(
        self,
        request: vpc_20160428_models.DescribeEcGrantRelationRequest,
    ) -> vpc_20160428_models.DescribeEcGrantRelationResponse:
        """
        @summary Queries whether permissions on a virtual private cloud (VPC) are granted to a virtual border router (VBR).
        
        @param request: DescribeEcGrantRelationRequest
        @return: DescribeEcGrantRelationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_ec_grant_relation_with_options_async(request, runtime)

    def describe_eip_addresses_with_options(
        self,
        request: vpc_20160428_models.DescribeEipAddressesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeEipAddressesResponse:
        """
        @summary Queries elastic IP addresses (EIPs) created in a region.
        
        @description You can call this operation to query information about EIPs in a region, including maximum bandwidth, billing methods, and associated instances.
        
        @param request: DescribeEipAddressesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEipAddressesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.associated_instance_id):
            query['AssociatedInstanceId'] = request.associated_instance_id
        if not UtilClient.is_unset(request.associated_instance_type):
            query['AssociatedInstanceType'] = request.associated_instance_type
        if not UtilClient.is_unset(request.charge_type):
            query['ChargeType'] = request.charge_type
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.eip_address):
            query['EipAddress'] = request.eip_address
        if not UtilClient.is_unset(request.eip_name):
            query['EipName'] = request.eip_name
        if not UtilClient.is_unset(request.isp):
            query['ISP'] = request.isp
        if not UtilClient.is_unset(request.include_reservation_data):
            query['IncludeReservationData'] = request.include_reservation_data
        if not UtilClient.is_unset(request.lock_reason):
            query['LockReason'] = request.lock_reason
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.public_ip_address_pool_id):
            query['PublicIpAddressPoolId'] = request.public_ip_address_pool_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_protection_enabled):
            query['SecurityProtectionEnabled'] = request.security_protection_enabled
        if not UtilClient.is_unset(request.segment_instance_id):
            query['SegmentInstanceId'] = request.segment_instance_id
        if not UtilClient.is_unset(request.service_managed):
            query['ServiceManaged'] = request.service_managed
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEipAddresses',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeEipAddressesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_eip_addresses_with_options_async(
        self,
        request: vpc_20160428_models.DescribeEipAddressesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeEipAddressesResponse:
        """
        @summary Queries elastic IP addresses (EIPs) created in a region.
        
        @description You can call this operation to query information about EIPs in a region, including maximum bandwidth, billing methods, and associated instances.
        
        @param request: DescribeEipAddressesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEipAddressesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.associated_instance_id):
            query['AssociatedInstanceId'] = request.associated_instance_id
        if not UtilClient.is_unset(request.associated_instance_type):
            query['AssociatedInstanceType'] = request.associated_instance_type
        if not UtilClient.is_unset(request.charge_type):
            query['ChargeType'] = request.charge_type
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.eip_address):
            query['EipAddress'] = request.eip_address
        if not UtilClient.is_unset(request.eip_name):
            query['EipName'] = request.eip_name
        if not UtilClient.is_unset(request.isp):
            query['ISP'] = request.isp
        if not UtilClient.is_unset(request.include_reservation_data):
            query['IncludeReservationData'] = request.include_reservation_data
        if not UtilClient.is_unset(request.lock_reason):
            query['LockReason'] = request.lock_reason
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.public_ip_address_pool_id):
            query['PublicIpAddressPoolId'] = request.public_ip_address_pool_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_protection_enabled):
            query['SecurityProtectionEnabled'] = request.security_protection_enabled
        if not UtilClient.is_unset(request.segment_instance_id):
            query['SegmentInstanceId'] = request.segment_instance_id
        if not UtilClient.is_unset(request.service_managed):
            query['ServiceManaged'] = request.service_managed
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEipAddresses',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeEipAddressesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_eip_addresses(
        self,
        request: vpc_20160428_models.DescribeEipAddressesRequest,
    ) -> vpc_20160428_models.DescribeEipAddressesResponse:
        """
        @summary Queries elastic IP addresses (EIPs) created in a region.
        
        @description You can call this operation to query information about EIPs in a region, including maximum bandwidth, billing methods, and associated instances.
        
        @param request: DescribeEipAddressesRequest
        @return: DescribeEipAddressesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_eip_addresses_with_options(request, runtime)

    async def describe_eip_addresses_async(
        self,
        request: vpc_20160428_models.DescribeEipAddressesRequest,
    ) -> vpc_20160428_models.DescribeEipAddressesResponse:
        """
        @summary Queries elastic IP addresses (EIPs) created in a region.
        
        @description You can call this operation to query information about EIPs in a region, including maximum bandwidth, billing methods, and associated instances.
        
        @param request: DescribeEipAddressesRequest
        @return: DescribeEipAddressesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_eip_addresses_with_options_async(request, runtime)

    def describe_eip_gateway_info_with_options(
        self,
        request: vpc_20160428_models.DescribeEipGatewayInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeEipGatewayInfoResponse:
        """
        @summary Queries the gateway and subnet mask of an elastic IP address (EIP).
        
        @description You can query only EIPs that are associated with secondary elastic network interfaces (ENIs) in multi-EIP-to-ENI mode.
        
        @param request: DescribeEipGatewayInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEipGatewayInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEipGatewayInfo',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeEipGatewayInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_eip_gateway_info_with_options_async(
        self,
        request: vpc_20160428_models.DescribeEipGatewayInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeEipGatewayInfoResponse:
        """
        @summary Queries the gateway and subnet mask of an elastic IP address (EIP).
        
        @description You can query only EIPs that are associated with secondary elastic network interfaces (ENIs) in multi-EIP-to-ENI mode.
        
        @param request: DescribeEipGatewayInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEipGatewayInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEipGatewayInfo',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeEipGatewayInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_eip_gateway_info(
        self,
        request: vpc_20160428_models.DescribeEipGatewayInfoRequest,
    ) -> vpc_20160428_models.DescribeEipGatewayInfoResponse:
        """
        @summary Queries the gateway and subnet mask of an elastic IP address (EIP).
        
        @description You can query only EIPs that are associated with secondary elastic network interfaces (ENIs) in multi-EIP-to-ENI mode.
        
        @param request: DescribeEipGatewayInfoRequest
        @return: DescribeEipGatewayInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_eip_gateway_info_with_options(request, runtime)

    async def describe_eip_gateway_info_async(
        self,
        request: vpc_20160428_models.DescribeEipGatewayInfoRequest,
    ) -> vpc_20160428_models.DescribeEipGatewayInfoResponse:
        """
        @summary Queries the gateway and subnet mask of an elastic IP address (EIP).
        
        @description You can query only EIPs that are associated with secondary elastic network interfaces (ENIs) in multi-EIP-to-ENI mode.
        
        @param request: DescribeEipGatewayInfoRequest
        @return: DescribeEipGatewayInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_eip_gateway_info_with_options_async(request, runtime)

    def describe_eip_monitor_data_with_options(
        self,
        request: vpc_20160428_models.DescribeEipMonitorDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeEipMonitorDataResponse:
        """
        @summary Queries the monitoring data of an elastic IP address (EIP). You can query monitoring data within the last 30 days, and obtain up to 400 data points in each request.
        
        @description To improve user experience in querying monitoring data, we recommend that you call the DescribeMetricList API operation provided by CloudMonitor to query EIP monitoring data. For more information, see [DescribeMetricList](https://help.aliyun.com/document_detail/51936.html) and [EIP monitoring data](https://help.aliyun.com/document_detail/162874.html).
        
        @param request: DescribeEipMonitorDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEipMonitorDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEipMonitorData',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeEipMonitorDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_eip_monitor_data_with_options_async(
        self,
        request: vpc_20160428_models.DescribeEipMonitorDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeEipMonitorDataResponse:
        """
        @summary Queries the monitoring data of an elastic IP address (EIP). You can query monitoring data within the last 30 days, and obtain up to 400 data points in each request.
        
        @description To improve user experience in querying monitoring data, we recommend that you call the DescribeMetricList API operation provided by CloudMonitor to query EIP monitoring data. For more information, see [DescribeMetricList](https://help.aliyun.com/document_detail/51936.html) and [EIP monitoring data](https://help.aliyun.com/document_detail/162874.html).
        
        @param request: DescribeEipMonitorDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEipMonitorDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEipMonitorData',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeEipMonitorDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_eip_monitor_data(
        self,
        request: vpc_20160428_models.DescribeEipMonitorDataRequest,
    ) -> vpc_20160428_models.DescribeEipMonitorDataResponse:
        """
        @summary Queries the monitoring data of an elastic IP address (EIP). You can query monitoring data within the last 30 days, and obtain up to 400 data points in each request.
        
        @description To improve user experience in querying monitoring data, we recommend that you call the DescribeMetricList API operation provided by CloudMonitor to query EIP monitoring data. For more information, see [DescribeMetricList](https://help.aliyun.com/document_detail/51936.html) and [EIP monitoring data](https://help.aliyun.com/document_detail/162874.html).
        
        @param request: DescribeEipMonitorDataRequest
        @return: DescribeEipMonitorDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_eip_monitor_data_with_options(request, runtime)

    async def describe_eip_monitor_data_async(
        self,
        request: vpc_20160428_models.DescribeEipMonitorDataRequest,
    ) -> vpc_20160428_models.DescribeEipMonitorDataResponse:
        """
        @summary Queries the monitoring data of an elastic IP address (EIP). You can query monitoring data within the last 30 days, and obtain up to 400 data points in each request.
        
        @description To improve user experience in querying monitoring data, we recommend that you call the DescribeMetricList API operation provided by CloudMonitor to query EIP monitoring data. For more information, see [DescribeMetricList](https://help.aliyun.com/document_detail/51936.html) and [EIP monitoring data](https://help.aliyun.com/document_detail/162874.html).
        
        @param request: DescribeEipMonitorDataRequest
        @return: DescribeEipMonitorDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_eip_monitor_data_with_options_async(request, runtime)

    def describe_eip_segment_with_options(
        self,
        request: vpc_20160428_models.DescribeEipSegmentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeEipSegmentResponse:
        """
        @summary Queries contiguous elastic IP address (EIP) groups.
        
        @param request: DescribeEipSegmentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEipSegmentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.segment_instance_id):
            query['SegmentInstanceId'] = request.segment_instance_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEipSegment',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeEipSegmentResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_eip_segment_with_options_async(
        self,
        request: vpc_20160428_models.DescribeEipSegmentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeEipSegmentResponse:
        """
        @summary Queries contiguous elastic IP address (EIP) groups.
        
        @param request: DescribeEipSegmentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEipSegmentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.segment_instance_id):
            query['SegmentInstanceId'] = request.segment_instance_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEipSegment',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeEipSegmentResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_eip_segment(
        self,
        request: vpc_20160428_models.DescribeEipSegmentRequest,
    ) -> vpc_20160428_models.DescribeEipSegmentResponse:
        """
        @summary Queries contiguous elastic IP address (EIP) groups.
        
        @param request: DescribeEipSegmentRequest
        @return: DescribeEipSegmentResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_eip_segment_with_options(request, runtime)

    async def describe_eip_segment_async(
        self,
        request: vpc_20160428_models.DescribeEipSegmentRequest,
    ) -> vpc_20160428_models.DescribeEipSegmentResponse:
        """
        @summary Queries contiguous elastic IP address (EIP) groups.
        
        @param request: DescribeEipSegmentRequest
        @return: DescribeEipSegmentResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_eip_segment_with_options_async(request, runtime)

    def describe_express_connect_traffic_qos_with_options(
        self,
        request: vpc_20160428_models.DescribeExpressConnectTrafficQosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeExpressConnectTrafficQosResponse:
        """
        @summary Qos
        
        @param request: DescribeExpressConnectTrafficQosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeExpressConnectTrafficQosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.qos_id_list):
            query['QosIdList'] = request.qos_id_list
        if not UtilClient.is_unset(request.qos_name_list):
            query['QosNameList'] = request.qos_name_list
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeExpressConnectTrafficQos',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeExpressConnectTrafficQosResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_express_connect_traffic_qos_with_options_async(
        self,
        request: vpc_20160428_models.DescribeExpressConnectTrafficQosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeExpressConnectTrafficQosResponse:
        """
        @summary Qos
        
        @param request: DescribeExpressConnectTrafficQosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeExpressConnectTrafficQosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.qos_id_list):
            query['QosIdList'] = request.qos_id_list
        if not UtilClient.is_unset(request.qos_name_list):
            query['QosNameList'] = request.qos_name_list
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeExpressConnectTrafficQos',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeExpressConnectTrafficQosResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_express_connect_traffic_qos(
        self,
        request: vpc_20160428_models.DescribeExpressConnectTrafficQosRequest,
    ) -> vpc_20160428_models.DescribeExpressConnectTrafficQosResponse:
        """
        @summary Qos
        
        @param request: DescribeExpressConnectTrafficQosRequest
        @return: DescribeExpressConnectTrafficQosResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_express_connect_traffic_qos_with_options(request, runtime)

    async def describe_express_connect_traffic_qos_async(
        self,
        request: vpc_20160428_models.DescribeExpressConnectTrafficQosRequest,
    ) -> vpc_20160428_models.DescribeExpressConnectTrafficQosResponse:
        """
        @summary Qos
        
        @param request: DescribeExpressConnectTrafficQosRequest
        @return: DescribeExpressConnectTrafficQosResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_express_connect_traffic_qos_with_options_async(request, runtime)

    def describe_express_connect_traffic_qos_queue_with_options(
        self,
        request: vpc_20160428_models.DescribeExpressConnectTrafficQosQueueRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeExpressConnectTrafficQosQueueResponse:
        """
        @summary Qos
        
        @param request: DescribeExpressConnectTrafficQosQueueRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeExpressConnectTrafficQosQueueResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.qos_id):
            query['QosId'] = request.qos_id
        if not UtilClient.is_unset(request.queue_id_list):
            query['QueueIdList'] = request.queue_id_list
        if not UtilClient.is_unset(request.queue_name_list):
            query['QueueNameList'] = request.queue_name_list
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeExpressConnectTrafficQosQueue',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeExpressConnectTrafficQosQueueResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_express_connect_traffic_qos_queue_with_options_async(
        self,
        request: vpc_20160428_models.DescribeExpressConnectTrafficQosQueueRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeExpressConnectTrafficQosQueueResponse:
        """
        @summary Qos
        
        @param request: DescribeExpressConnectTrafficQosQueueRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeExpressConnectTrafficQosQueueResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.qos_id):
            query['QosId'] = request.qos_id
        if not UtilClient.is_unset(request.queue_id_list):
            query['QueueIdList'] = request.queue_id_list
        if not UtilClient.is_unset(request.queue_name_list):
            query['QueueNameList'] = request.queue_name_list
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeExpressConnectTrafficQosQueue',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeExpressConnectTrafficQosQueueResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_express_connect_traffic_qos_queue(
        self,
        request: vpc_20160428_models.DescribeExpressConnectTrafficQosQueueRequest,
    ) -> vpc_20160428_models.DescribeExpressConnectTrafficQosQueueResponse:
        """
        @summary Qos
        
        @param request: DescribeExpressConnectTrafficQosQueueRequest
        @return: DescribeExpressConnectTrafficQosQueueResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_express_connect_traffic_qos_queue_with_options(request, runtime)

    async def describe_express_connect_traffic_qos_queue_async(
        self,
        request: vpc_20160428_models.DescribeExpressConnectTrafficQosQueueRequest,
    ) -> vpc_20160428_models.DescribeExpressConnectTrafficQosQueueResponse:
        """
        @summary Qos
        
        @param request: DescribeExpressConnectTrafficQosQueueRequest
        @return: DescribeExpressConnectTrafficQosQueueResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_express_connect_traffic_qos_queue_with_options_async(request, runtime)

    def describe_express_connect_traffic_qos_rule_with_options(
        self,
        request: vpc_20160428_models.DescribeExpressConnectTrafficQosRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeExpressConnectTrafficQosRuleResponse:
        """
        @summary Qos
        
        @param request: DescribeExpressConnectTrafficQosRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeExpressConnectTrafficQosRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.qos_id):
            query['QosId'] = request.qos_id
        if not UtilClient.is_unset(request.queue_id):
            query['QueueId'] = request.queue_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.rule_id_list):
            query['RuleIdList'] = request.rule_id_list
        if not UtilClient.is_unset(request.rule_name_list):
            query['RuleNameList'] = request.rule_name_list
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeExpressConnectTrafficQosRule',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeExpressConnectTrafficQosRuleResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_express_connect_traffic_qos_rule_with_options_async(
        self,
        request: vpc_20160428_models.DescribeExpressConnectTrafficQosRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeExpressConnectTrafficQosRuleResponse:
        """
        @summary Qos
        
        @param request: DescribeExpressConnectTrafficQosRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeExpressConnectTrafficQosRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.qos_id):
            query['QosId'] = request.qos_id
        if not UtilClient.is_unset(request.queue_id):
            query['QueueId'] = request.queue_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.rule_id_list):
            query['RuleIdList'] = request.rule_id_list
        if not UtilClient.is_unset(request.rule_name_list):
            query['RuleNameList'] = request.rule_name_list
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeExpressConnectTrafficQosRule',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeExpressConnectTrafficQosRuleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_express_connect_traffic_qos_rule(
        self,
        request: vpc_20160428_models.DescribeExpressConnectTrafficQosRuleRequest,
    ) -> vpc_20160428_models.DescribeExpressConnectTrafficQosRuleResponse:
        """
        @summary Qos
        
        @param request: DescribeExpressConnectTrafficQosRuleRequest
        @return: DescribeExpressConnectTrafficQosRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_express_connect_traffic_qos_rule_with_options(request, runtime)

    async def describe_express_connect_traffic_qos_rule_async(
        self,
        request: vpc_20160428_models.DescribeExpressConnectTrafficQosRuleRequest,
    ) -> vpc_20160428_models.DescribeExpressConnectTrafficQosRuleResponse:
        """
        @summary Qos
        
        @param request: DescribeExpressConnectTrafficQosRuleRequest
        @return: DescribeExpressConnectTrafficQosRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_express_connect_traffic_qos_rule_with_options_async(request, runtime)

    def describe_failover_test_job_with_options(
        self,
        request: vpc_20160428_models.DescribeFailoverTestJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeFailoverTestJobResponse:
        """
        @summary 
        
        @param request: DescribeFailoverTestJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeFailoverTestJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeFailoverTestJob',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeFailoverTestJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_failover_test_job_with_options_async(
        self,
        request: vpc_20160428_models.DescribeFailoverTestJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeFailoverTestJobResponse:
        """
        @summary 
        
        @param request: DescribeFailoverTestJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeFailoverTestJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeFailoverTestJob',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeFailoverTestJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_failover_test_job(
        self,
        request: vpc_20160428_models.DescribeFailoverTestJobRequest,
    ) -> vpc_20160428_models.DescribeFailoverTestJobResponse:
        """
        @summary 
        
        @param request: DescribeFailoverTestJobRequest
        @return: DescribeFailoverTestJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_failover_test_job_with_options(request, runtime)

    async def describe_failover_test_job_async(
        self,
        request: vpc_20160428_models.DescribeFailoverTestJobRequest,
    ) -> vpc_20160428_models.DescribeFailoverTestJobResponse:
        """
        @summary 
        
        @param request: DescribeFailoverTestJobRequest
        @return: DescribeFailoverTestJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_failover_test_job_with_options_async(request, runtime)

    def describe_failover_test_jobs_with_options(
        self,
        request: vpc_20160428_models.DescribeFailoverTestJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeFailoverTestJobsResponse:
        """
        @summary 
        
        @param request: DescribeFailoverTestJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeFailoverTestJobsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeFailoverTestJobs',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeFailoverTestJobsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_failover_test_jobs_with_options_async(
        self,
        request: vpc_20160428_models.DescribeFailoverTestJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeFailoverTestJobsResponse:
        """
        @summary 
        
        @param request: DescribeFailoverTestJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeFailoverTestJobsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeFailoverTestJobs',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeFailoverTestJobsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_failover_test_jobs(
        self,
        request: vpc_20160428_models.DescribeFailoverTestJobsRequest,
    ) -> vpc_20160428_models.DescribeFailoverTestJobsResponse:
        """
        @summary 
        
        @param request: DescribeFailoverTestJobsRequest
        @return: DescribeFailoverTestJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_failover_test_jobs_with_options(request, runtime)

    async def describe_failover_test_jobs_async(
        self,
        request: vpc_20160428_models.DescribeFailoverTestJobsRequest,
    ) -> vpc_20160428_models.DescribeFailoverTestJobsResponse:
        """
        @summary 
        
        @param request: DescribeFailoverTestJobsRequest
        @return: DescribeFailoverTestJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_failover_test_jobs_with_options_async(request, runtime)

    def describe_flow_logs_with_options(
        self,
        request: vpc_20160428_models.DescribeFlowLogsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeFlowLogsResponse:
        """
        @summary Queries the information about flow logs.
        
        @param request: DescribeFlowLogsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeFlowLogsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.flow_log_id):
            query['FlowLogId'] = request.flow_log_id
        if not UtilClient.is_unset(request.flow_log_name):
            query['FlowLogName'] = request.flow_log_name
        if not UtilClient.is_unset(request.log_store_name):
            query['LogStoreName'] = request.log_store_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.project_name):
            query['ProjectName'] = request.project_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.traffic_type):
            query['TrafficType'] = request.traffic_type
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeFlowLogs',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeFlowLogsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_flow_logs_with_options_async(
        self,
        request: vpc_20160428_models.DescribeFlowLogsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeFlowLogsResponse:
        """
        @summary Queries the information about flow logs.
        
        @param request: DescribeFlowLogsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeFlowLogsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.flow_log_id):
            query['FlowLogId'] = request.flow_log_id
        if not UtilClient.is_unset(request.flow_log_name):
            query['FlowLogName'] = request.flow_log_name
        if not UtilClient.is_unset(request.log_store_name):
            query['LogStoreName'] = request.log_store_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.project_name):
            query['ProjectName'] = request.project_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.traffic_type):
            query['TrafficType'] = request.traffic_type
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeFlowLogs',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeFlowLogsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_flow_logs(
        self,
        request: vpc_20160428_models.DescribeFlowLogsRequest,
    ) -> vpc_20160428_models.DescribeFlowLogsResponse:
        """
        @summary Queries the information about flow logs.
        
        @param request: DescribeFlowLogsRequest
        @return: DescribeFlowLogsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_flow_logs_with_options(request, runtime)

    async def describe_flow_logs_async(
        self,
        request: vpc_20160428_models.DescribeFlowLogsRequest,
    ) -> vpc_20160428_models.DescribeFlowLogsResponse:
        """
        @summary Queries the information about flow logs.
        
        @param request: DescribeFlowLogsRequest
        @return: DescribeFlowLogsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_flow_logs_with_options_async(request, runtime)

    def describe_forward_table_entries_with_options(
        self,
        request: vpc_20160428_models.DescribeForwardTableEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeForwardTableEntriesResponse:
        """
        @summary Queries DNAT entries.
        
        @param request: DescribeForwardTableEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeForwardTableEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.external_ip):
            query['ExternalIp'] = request.external_ip
        if not UtilClient.is_unset(request.external_port):
            query['ExternalPort'] = request.external_port
        if not UtilClient.is_unset(request.forward_entry_id):
            query['ForwardEntryId'] = request.forward_entry_id
        if not UtilClient.is_unset(request.forward_entry_name):
            query['ForwardEntryName'] = request.forward_entry_name
        if not UtilClient.is_unset(request.forward_table_id):
            query['ForwardTableId'] = request.forward_table_id
        if not UtilClient.is_unset(request.internal_ip):
            query['InternalIp'] = request.internal_ip
        if not UtilClient.is_unset(request.internal_port):
            query['InternalPort'] = request.internal_port
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeForwardTableEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeForwardTableEntriesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_forward_table_entries_with_options_async(
        self,
        request: vpc_20160428_models.DescribeForwardTableEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeForwardTableEntriesResponse:
        """
        @summary Queries DNAT entries.
        
        @param request: DescribeForwardTableEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeForwardTableEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.external_ip):
            query['ExternalIp'] = request.external_ip
        if not UtilClient.is_unset(request.external_port):
            query['ExternalPort'] = request.external_port
        if not UtilClient.is_unset(request.forward_entry_id):
            query['ForwardEntryId'] = request.forward_entry_id
        if not UtilClient.is_unset(request.forward_entry_name):
            query['ForwardEntryName'] = request.forward_entry_name
        if not UtilClient.is_unset(request.forward_table_id):
            query['ForwardTableId'] = request.forward_table_id
        if not UtilClient.is_unset(request.internal_ip):
            query['InternalIp'] = request.internal_ip
        if not UtilClient.is_unset(request.internal_port):
            query['InternalPort'] = request.internal_port
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeForwardTableEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeForwardTableEntriesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_forward_table_entries(
        self,
        request: vpc_20160428_models.DescribeForwardTableEntriesRequest,
    ) -> vpc_20160428_models.DescribeForwardTableEntriesResponse:
        """
        @summary Queries DNAT entries.
        
        @param request: DescribeForwardTableEntriesRequest
        @return: DescribeForwardTableEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_forward_table_entries_with_options(request, runtime)

    async def describe_forward_table_entries_async(
        self,
        request: vpc_20160428_models.DescribeForwardTableEntriesRequest,
    ) -> vpc_20160428_models.DescribeForwardTableEntriesResponse:
        """
        @summary Queries DNAT entries.
        
        @param request: DescribeForwardTableEntriesRequest
        @return: DescribeForwardTableEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_forward_table_entries_with_options_async(request, runtime)

    def describe_global_acceleration_instances_with_options(
        self,
        request: vpc_20160428_models.DescribeGlobalAccelerationInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeGlobalAccelerationInstancesResponse:
        """
        @summary Queries Global Accelerator (GA) instances.
        
        @param request: DescribeGlobalAccelerationInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeGlobalAccelerationInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_type):
            query['BandwidthType'] = request.bandwidth_type
        if not UtilClient.is_unset(request.global_acceleration_instance_id):
            query['GlobalAccelerationInstanceId'] = request.global_acceleration_instance_id
        if not UtilClient.is_unset(request.include_reservation_data):
            query['IncludeReservationData'] = request.include_reservation_data
        if not UtilClient.is_unset(request.ip_address):
            query['IpAddress'] = request.ip_address
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.server_id):
            query['ServerId'] = request.server_id
        if not UtilClient.is_unset(request.service_location):
            query['ServiceLocation'] = request.service_location
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeGlobalAccelerationInstances',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeGlobalAccelerationInstancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_global_acceleration_instances_with_options_async(
        self,
        request: vpc_20160428_models.DescribeGlobalAccelerationInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeGlobalAccelerationInstancesResponse:
        """
        @summary Queries Global Accelerator (GA) instances.
        
        @param request: DescribeGlobalAccelerationInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeGlobalAccelerationInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_type):
            query['BandwidthType'] = request.bandwidth_type
        if not UtilClient.is_unset(request.global_acceleration_instance_id):
            query['GlobalAccelerationInstanceId'] = request.global_acceleration_instance_id
        if not UtilClient.is_unset(request.include_reservation_data):
            query['IncludeReservationData'] = request.include_reservation_data
        if not UtilClient.is_unset(request.ip_address):
            query['IpAddress'] = request.ip_address
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.server_id):
            query['ServerId'] = request.server_id
        if not UtilClient.is_unset(request.service_location):
            query['ServiceLocation'] = request.service_location
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeGlobalAccelerationInstances',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeGlobalAccelerationInstancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_global_acceleration_instances(
        self,
        request: vpc_20160428_models.DescribeGlobalAccelerationInstancesRequest,
    ) -> vpc_20160428_models.DescribeGlobalAccelerationInstancesResponse:
        """
        @summary Queries Global Accelerator (GA) instances.
        
        @param request: DescribeGlobalAccelerationInstancesRequest
        @return: DescribeGlobalAccelerationInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_global_acceleration_instances_with_options(request, runtime)

    async def describe_global_acceleration_instances_async(
        self,
        request: vpc_20160428_models.DescribeGlobalAccelerationInstancesRequest,
    ) -> vpc_20160428_models.DescribeGlobalAccelerationInstancesResponse:
        """
        @summary Queries Global Accelerator (GA) instances.
        
        @param request: DescribeGlobalAccelerationInstancesRequest
        @return: DescribeGlobalAccelerationInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_global_acceleration_instances_with_options_async(request, runtime)

    def describe_grant_rules_to_cen_with_options(
        self,
        request: vpc_20160428_models.DescribeGrantRulesToCenRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeGrantRulesToCenResponse:
        """
        @summary VPCVBR
        
        @param request: DescribeGrantRulesToCenRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeGrantRulesToCenResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeGrantRulesToCen',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeGrantRulesToCenResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_grant_rules_to_cen_with_options_async(
        self,
        request: vpc_20160428_models.DescribeGrantRulesToCenRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeGrantRulesToCenResponse:
        """
        @summary VPCVBR
        
        @param request: DescribeGrantRulesToCenRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeGrantRulesToCenResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeGrantRulesToCen',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeGrantRulesToCenResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_grant_rules_to_cen(
        self,
        request: vpc_20160428_models.DescribeGrantRulesToCenRequest,
    ) -> vpc_20160428_models.DescribeGrantRulesToCenResponse:
        """
        @summary VPCVBR
        
        @param request: DescribeGrantRulesToCenRequest
        @return: DescribeGrantRulesToCenResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_grant_rules_to_cen_with_options(request, runtime)

    async def describe_grant_rules_to_cen_async(
        self,
        request: vpc_20160428_models.DescribeGrantRulesToCenRequest,
    ) -> vpc_20160428_models.DescribeGrantRulesToCenResponse:
        """
        @summary VPCVBR
        
        @param request: DescribeGrantRulesToCenRequest
        @return: DescribeGrantRulesToCenResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_grant_rules_to_cen_with_options_async(request, runtime)

    def describe_ha_vips_with_options(
        self,
        request: vpc_20160428_models.DescribeHaVipsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeHaVipsResponse:
        """
        @summary Queries HAVIPs in a region.
        
        @param request: DescribeHaVipsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeHaVipsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeHaVips',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeHaVipsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_ha_vips_with_options_async(
        self,
        request: vpc_20160428_models.DescribeHaVipsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeHaVipsResponse:
        """
        @summary Queries HAVIPs in a region.
        
        @param request: DescribeHaVipsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeHaVipsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeHaVips',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeHaVipsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_ha_vips(
        self,
        request: vpc_20160428_models.DescribeHaVipsRequest,
    ) -> vpc_20160428_models.DescribeHaVipsResponse:
        """
        @summary Queries HAVIPs in a region.
        
        @param request: DescribeHaVipsRequest
        @return: DescribeHaVipsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_ha_vips_with_options(request, runtime)

    async def describe_ha_vips_async(
        self,
        request: vpc_20160428_models.DescribeHaVipsRequest,
    ) -> vpc_20160428_models.DescribeHaVipsResponse:
        """
        @summary Queries HAVIPs in a region.
        
        @param request: DescribeHaVipsRequest
        @return: DescribeHaVipsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_ha_vips_with_options_async(request, runtime)

    def describe_high_definition_monitor_log_attribute_with_options(
        self,
        request: vpc_20160428_models.DescribeHighDefinitionMonitorLogAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeHighDefinitionMonitorLogAttributeResponse:
        """
        @summary Queries configurations about the fine-grained monitoring feature of an elastic IP address (EIP).
        
        @param request: DescribeHighDefinitionMonitorLogAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeHighDefinitionMonitorLogAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeHighDefinitionMonitorLogAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeHighDefinitionMonitorLogAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_high_definition_monitor_log_attribute_with_options_async(
        self,
        request: vpc_20160428_models.DescribeHighDefinitionMonitorLogAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeHighDefinitionMonitorLogAttributeResponse:
        """
        @summary Queries configurations about the fine-grained monitoring feature of an elastic IP address (EIP).
        
        @param request: DescribeHighDefinitionMonitorLogAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeHighDefinitionMonitorLogAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeHighDefinitionMonitorLogAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeHighDefinitionMonitorLogAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_high_definition_monitor_log_attribute(
        self,
        request: vpc_20160428_models.DescribeHighDefinitionMonitorLogAttributeRequest,
    ) -> vpc_20160428_models.DescribeHighDefinitionMonitorLogAttributeResponse:
        """
        @summary Queries configurations about the fine-grained monitoring feature of an elastic IP address (EIP).
        
        @param request: DescribeHighDefinitionMonitorLogAttributeRequest
        @return: DescribeHighDefinitionMonitorLogAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_high_definition_monitor_log_attribute_with_options(request, runtime)

    async def describe_high_definition_monitor_log_attribute_async(
        self,
        request: vpc_20160428_models.DescribeHighDefinitionMonitorLogAttributeRequest,
    ) -> vpc_20160428_models.DescribeHighDefinitionMonitorLogAttributeResponse:
        """
        @summary Queries configurations about the fine-grained monitoring feature of an elastic IP address (EIP).
        
        @param request: DescribeHighDefinitionMonitorLogAttributeRequest
        @return: DescribeHighDefinitionMonitorLogAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_high_definition_monitor_log_attribute_with_options_async(request, runtime)

    def describe_ipv_6translator_acl_list_attributes_with_options(
        self,
        request: vpc_20160428_models.DescribeIPv6TranslatorAclListAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeIPv6TranslatorAclListAttributesResponse:
        """
        @summary Queries the details of an access control list (ACL), including the specified IP addresses and associated IPv6 mapping entries.
        
        @param request: DescribeIPv6TranslatorAclListAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIPv6TranslatorAclListAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_id):
            query['AclId'] = request.acl_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIPv6TranslatorAclListAttributes',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeIPv6TranslatorAclListAttributesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_ipv_6translator_acl_list_attributes_with_options_async(
        self,
        request: vpc_20160428_models.DescribeIPv6TranslatorAclListAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeIPv6TranslatorAclListAttributesResponse:
        """
        @summary Queries the details of an access control list (ACL), including the specified IP addresses and associated IPv6 mapping entries.
        
        @param request: DescribeIPv6TranslatorAclListAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIPv6TranslatorAclListAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_id):
            query['AclId'] = request.acl_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIPv6TranslatorAclListAttributes',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeIPv6TranslatorAclListAttributesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_ipv_6translator_acl_list_attributes(
        self,
        request: vpc_20160428_models.DescribeIPv6TranslatorAclListAttributesRequest,
    ) -> vpc_20160428_models.DescribeIPv6TranslatorAclListAttributesResponse:
        """
        @summary Queries the details of an access control list (ACL), including the specified IP addresses and associated IPv6 mapping entries.
        
        @param request: DescribeIPv6TranslatorAclListAttributesRequest
        @return: DescribeIPv6TranslatorAclListAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_ipv_6translator_acl_list_attributes_with_options(request, runtime)

    async def describe_ipv_6translator_acl_list_attributes_async(
        self,
        request: vpc_20160428_models.DescribeIPv6TranslatorAclListAttributesRequest,
    ) -> vpc_20160428_models.DescribeIPv6TranslatorAclListAttributesResponse:
        """
        @summary Queries the details of an access control list (ACL), including the specified IP addresses and associated IPv6 mapping entries.
        
        @param request: DescribeIPv6TranslatorAclListAttributesRequest
        @return: DescribeIPv6TranslatorAclListAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_ipv_6translator_acl_list_attributes_with_options_async(request, runtime)

    def describe_ipv_6translator_acl_lists_with_options(
        self,
        request: vpc_20160428_models.DescribeIPv6TranslatorAclListsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeIPv6TranslatorAclListsResponse:
        """
        @deprecated OpenAPI DescribeIPv6TranslatorAclLists is deprecated
        
        @summary Queries access control lists (ACLs).
        
        @param request: DescribeIPv6TranslatorAclListsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIPv6TranslatorAclListsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_id):
            query['AclId'] = request.acl_id
        if not UtilClient.is_unset(request.acl_name):
            query['AclName'] = request.acl_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIPv6TranslatorAclLists',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeIPv6TranslatorAclListsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_ipv_6translator_acl_lists_with_options_async(
        self,
        request: vpc_20160428_models.DescribeIPv6TranslatorAclListsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeIPv6TranslatorAclListsResponse:
        """
        @deprecated OpenAPI DescribeIPv6TranslatorAclLists is deprecated
        
        @summary Queries access control lists (ACLs).
        
        @param request: DescribeIPv6TranslatorAclListsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIPv6TranslatorAclListsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_id):
            query['AclId'] = request.acl_id
        if not UtilClient.is_unset(request.acl_name):
            query['AclName'] = request.acl_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIPv6TranslatorAclLists',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeIPv6TranslatorAclListsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_ipv_6translator_acl_lists(
        self,
        request: vpc_20160428_models.DescribeIPv6TranslatorAclListsRequest,
    ) -> vpc_20160428_models.DescribeIPv6TranslatorAclListsResponse:
        """
        @deprecated OpenAPI DescribeIPv6TranslatorAclLists is deprecated
        
        @summary Queries access control lists (ACLs).
        
        @param request: DescribeIPv6TranslatorAclListsRequest
        @return: DescribeIPv6TranslatorAclListsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_ipv_6translator_acl_lists_with_options(request, runtime)

    async def describe_ipv_6translator_acl_lists_async(
        self,
        request: vpc_20160428_models.DescribeIPv6TranslatorAclListsRequest,
    ) -> vpc_20160428_models.DescribeIPv6TranslatorAclListsResponse:
        """
        @deprecated OpenAPI DescribeIPv6TranslatorAclLists is deprecated
        
        @summary Queries access control lists (ACLs).
        
        @param request: DescribeIPv6TranslatorAclListsRequest
        @return: DescribeIPv6TranslatorAclListsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_ipv_6translator_acl_lists_with_options_async(request, runtime)

    def describe_ipv_6translator_entries_with_options(
        self,
        request: vpc_20160428_models.DescribeIPv6TranslatorEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeIPv6TranslatorEntriesResponse:
        """
        @deprecated OpenAPI DescribeIPv6TranslatorEntries is deprecated
        
        @summary Queries IPv6 mapping entries.
        
        @param request: DescribeIPv6TranslatorEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIPv6TranslatorEntriesResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_id):
            query['AclId'] = request.acl_id
        if not UtilClient.is_unset(request.acl_status):
            query['AclStatus'] = request.acl_status
        if not UtilClient.is_unset(request.acl_type):
            query['AclType'] = request.acl_type
        if not UtilClient.is_unset(request.allocate_ipv_6addr):
            query['AllocateIpv6Addr'] = request.allocate_ipv_6addr
        if not UtilClient.is_unset(request.allocate_ipv_6port):
            query['AllocateIpv6Port'] = request.allocate_ipv_6port
        if not UtilClient.is_unset(request.backend_ipv_4addr):
            query['BackendIpv4Addr'] = request.backend_ipv_4addr
        if not UtilClient.is_unset(request.backend_ipv_4port):
            query['BackendIpv4Port'] = request.backend_ipv_4port
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.entry_name):
            query['EntryName'] = request.entry_name
        if not UtilClient.is_unset(request.ipv_6translator_entry_id):
            query['Ipv6TranslatorEntryId'] = request.ipv_6translator_entry_id
        if not UtilClient.is_unset(request.ipv_6translator_id):
            query['Ipv6TranslatorId'] = request.ipv_6translator_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.trans_protocol):
            query['TransProtocol'] = request.trans_protocol
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIPv6TranslatorEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeIPv6TranslatorEntriesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_ipv_6translator_entries_with_options_async(
        self,
        request: vpc_20160428_models.DescribeIPv6TranslatorEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeIPv6TranslatorEntriesResponse:
        """
        @deprecated OpenAPI DescribeIPv6TranslatorEntries is deprecated
        
        @summary Queries IPv6 mapping entries.
        
        @param request: DescribeIPv6TranslatorEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIPv6TranslatorEntriesResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_id):
            query['AclId'] = request.acl_id
        if not UtilClient.is_unset(request.acl_status):
            query['AclStatus'] = request.acl_status
        if not UtilClient.is_unset(request.acl_type):
            query['AclType'] = request.acl_type
        if not UtilClient.is_unset(request.allocate_ipv_6addr):
            query['AllocateIpv6Addr'] = request.allocate_ipv_6addr
        if not UtilClient.is_unset(request.allocate_ipv_6port):
            query['AllocateIpv6Port'] = request.allocate_ipv_6port
        if not UtilClient.is_unset(request.backend_ipv_4addr):
            query['BackendIpv4Addr'] = request.backend_ipv_4addr
        if not UtilClient.is_unset(request.backend_ipv_4port):
            query['BackendIpv4Port'] = request.backend_ipv_4port
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.entry_name):
            query['EntryName'] = request.entry_name
        if not UtilClient.is_unset(request.ipv_6translator_entry_id):
            query['Ipv6TranslatorEntryId'] = request.ipv_6translator_entry_id
        if not UtilClient.is_unset(request.ipv_6translator_id):
            query['Ipv6TranslatorId'] = request.ipv_6translator_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.trans_protocol):
            query['TransProtocol'] = request.trans_protocol
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIPv6TranslatorEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeIPv6TranslatorEntriesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_ipv_6translator_entries(
        self,
        request: vpc_20160428_models.DescribeIPv6TranslatorEntriesRequest,
    ) -> vpc_20160428_models.DescribeIPv6TranslatorEntriesResponse:
        """
        @deprecated OpenAPI DescribeIPv6TranslatorEntries is deprecated
        
        @summary Queries IPv6 mapping entries.
        
        @param request: DescribeIPv6TranslatorEntriesRequest
        @return: DescribeIPv6TranslatorEntriesResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_ipv_6translator_entries_with_options(request, runtime)

    async def describe_ipv_6translator_entries_async(
        self,
        request: vpc_20160428_models.DescribeIPv6TranslatorEntriesRequest,
    ) -> vpc_20160428_models.DescribeIPv6TranslatorEntriesResponse:
        """
        @deprecated OpenAPI DescribeIPv6TranslatorEntries is deprecated
        
        @summary Queries IPv6 mapping entries.
        
        @param request: DescribeIPv6TranslatorEntriesRequest
        @return: DescribeIPv6TranslatorEntriesResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_ipv_6translator_entries_with_options_async(request, runtime)

    def describe_ipv_6translators_with_options(
        self,
        request: vpc_20160428_models.DescribeIPv6TranslatorsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeIPv6TranslatorsResponse:
        """
        @deprecated OpenAPI DescribeIPv6Translators is deprecated
        
        @summary Queries IPv6 Translation Service instances.
        
        @param request: DescribeIPv6TranslatorsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIPv6TranslatorsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocate_ipv_4addr):
            query['AllocateIpv4Addr'] = request.allocate_ipv_4addr
        if not UtilClient.is_unset(request.allocate_ipv_6addr):
            query['AllocateIpv6Addr'] = request.allocate_ipv_6addr
        if not UtilClient.is_unset(request.business_status):
            query['BusinessStatus'] = request.business_status
        if not UtilClient.is_unset(request.ipv_6translator_id):
            query['Ipv6TranslatorId'] = request.ipv_6translator_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.pay_type):
            query['PayType'] = request.pay_type
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.spec):
            query['Spec'] = request.spec
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIPv6Translators',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeIPv6TranslatorsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_ipv_6translators_with_options_async(
        self,
        request: vpc_20160428_models.DescribeIPv6TranslatorsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeIPv6TranslatorsResponse:
        """
        @deprecated OpenAPI DescribeIPv6Translators is deprecated
        
        @summary Queries IPv6 Translation Service instances.
        
        @param request: DescribeIPv6TranslatorsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIPv6TranslatorsResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocate_ipv_4addr):
            query['AllocateIpv4Addr'] = request.allocate_ipv_4addr
        if not UtilClient.is_unset(request.allocate_ipv_6addr):
            query['AllocateIpv6Addr'] = request.allocate_ipv_6addr
        if not UtilClient.is_unset(request.business_status):
            query['BusinessStatus'] = request.business_status
        if not UtilClient.is_unset(request.ipv_6translator_id):
            query['Ipv6TranslatorId'] = request.ipv_6translator_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.pay_type):
            query['PayType'] = request.pay_type
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.spec):
            query['Spec'] = request.spec
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIPv6Translators',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeIPv6TranslatorsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_ipv_6translators(
        self,
        request: vpc_20160428_models.DescribeIPv6TranslatorsRequest,
    ) -> vpc_20160428_models.DescribeIPv6TranslatorsResponse:
        """
        @deprecated OpenAPI DescribeIPv6Translators is deprecated
        
        @summary Queries IPv6 Translation Service instances.
        
        @param request: DescribeIPv6TranslatorsRequest
        @return: DescribeIPv6TranslatorsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_ipv_6translators_with_options(request, runtime)

    async def describe_ipv_6translators_async(
        self,
        request: vpc_20160428_models.DescribeIPv6TranslatorsRequest,
    ) -> vpc_20160428_models.DescribeIPv6TranslatorsResponse:
        """
        @deprecated OpenAPI DescribeIPv6Translators is deprecated
        
        @summary Queries IPv6 Translation Service instances.
        
        @param request: DescribeIPv6TranslatorsRequest
        @return: DescribeIPv6TranslatorsResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_ipv_6translators_with_options_async(request, runtime)

    def describe_ipv_6addresses_with_options(
        self,
        request: vpc_20160428_models.DescribeIpv6AddressesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeIpv6AddressesResponse:
        """
        @summary Queries IPv6 addresses in a region.
        
        @param request: DescribeIpv6AddressesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIpv6AddressesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.address_type):
            query['AddressType'] = request.address_type
        if not UtilClient.is_unset(request.associated_instance_id):
            query['AssociatedInstanceId'] = request.associated_instance_id
        if not UtilClient.is_unset(request.associated_instance_type):
            query['AssociatedInstanceType'] = request.associated_instance_type
        if not UtilClient.is_unset(request.include_reservation_data):
            query['IncludeReservationData'] = request.include_reservation_data
        if not UtilClient.is_unset(request.ipv_6address):
            query['Ipv6Address'] = request.ipv_6address
        if not UtilClient.is_unset(request.ipv_6address_id):
            query['Ipv6AddressId'] = request.ipv_6address_id
        if not UtilClient.is_unset(request.ipv_6internet_bandwidth_id):
            query['Ipv6InternetBandwidthId'] = request.ipv_6internet_bandwidth_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.service_managed):
            query['ServiceManaged'] = request.service_managed
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIpv6Addresses',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeIpv6AddressesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_ipv_6addresses_with_options_async(
        self,
        request: vpc_20160428_models.DescribeIpv6AddressesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeIpv6AddressesResponse:
        """
        @summary Queries IPv6 addresses in a region.
        
        @param request: DescribeIpv6AddressesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIpv6AddressesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.address_type):
            query['AddressType'] = request.address_type
        if not UtilClient.is_unset(request.associated_instance_id):
            query['AssociatedInstanceId'] = request.associated_instance_id
        if not UtilClient.is_unset(request.associated_instance_type):
            query['AssociatedInstanceType'] = request.associated_instance_type
        if not UtilClient.is_unset(request.include_reservation_data):
            query['IncludeReservationData'] = request.include_reservation_data
        if not UtilClient.is_unset(request.ipv_6address):
            query['Ipv6Address'] = request.ipv_6address
        if not UtilClient.is_unset(request.ipv_6address_id):
            query['Ipv6AddressId'] = request.ipv_6address_id
        if not UtilClient.is_unset(request.ipv_6internet_bandwidth_id):
            query['Ipv6InternetBandwidthId'] = request.ipv_6internet_bandwidth_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.service_managed):
            query['ServiceManaged'] = request.service_managed
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIpv6Addresses',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeIpv6AddressesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_ipv_6addresses(
        self,
        request: vpc_20160428_models.DescribeIpv6AddressesRequest,
    ) -> vpc_20160428_models.DescribeIpv6AddressesResponse:
        """
        @summary Queries IPv6 addresses in a region.
        
        @param request: DescribeIpv6AddressesRequest
        @return: DescribeIpv6AddressesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_ipv_6addresses_with_options(request, runtime)

    async def describe_ipv_6addresses_async(
        self,
        request: vpc_20160428_models.DescribeIpv6AddressesRequest,
    ) -> vpc_20160428_models.DescribeIpv6AddressesResponse:
        """
        @summary Queries IPv6 addresses in a region.
        
        @param request: DescribeIpv6AddressesRequest
        @return: DescribeIpv6AddressesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_ipv_6addresses_with_options_async(request, runtime)

    def describe_ipv_6egress_only_rules_with_options(
        self,
        request: vpc_20160428_models.DescribeIpv6EgressOnlyRulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeIpv6EgressOnlyRulesResponse:
        """
        @summary 
        
        @param request: DescribeIpv6EgressOnlyRulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIpv6EgressOnlyRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.ipv_6egress_only_rule_id):
            query['Ipv6EgressOnlyRuleId'] = request.ipv_6egress_only_rule_id
        if not UtilClient.is_unset(request.ipv_6gateway_id):
            query['Ipv6GatewayId'] = request.ipv_6gateway_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIpv6EgressOnlyRules',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeIpv6EgressOnlyRulesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_ipv_6egress_only_rules_with_options_async(
        self,
        request: vpc_20160428_models.DescribeIpv6EgressOnlyRulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeIpv6EgressOnlyRulesResponse:
        """
        @summary 
        
        @param request: DescribeIpv6EgressOnlyRulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIpv6EgressOnlyRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.ipv_6egress_only_rule_id):
            query['Ipv6EgressOnlyRuleId'] = request.ipv_6egress_only_rule_id
        if not UtilClient.is_unset(request.ipv_6gateway_id):
            query['Ipv6GatewayId'] = request.ipv_6gateway_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIpv6EgressOnlyRules',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeIpv6EgressOnlyRulesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_ipv_6egress_only_rules(
        self,
        request: vpc_20160428_models.DescribeIpv6EgressOnlyRulesRequest,
    ) -> vpc_20160428_models.DescribeIpv6EgressOnlyRulesResponse:
        """
        @summary 
        
        @param request: DescribeIpv6EgressOnlyRulesRequest
        @return: DescribeIpv6EgressOnlyRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_ipv_6egress_only_rules_with_options(request, runtime)

    async def describe_ipv_6egress_only_rules_async(
        self,
        request: vpc_20160428_models.DescribeIpv6EgressOnlyRulesRequest,
    ) -> vpc_20160428_models.DescribeIpv6EgressOnlyRulesResponse:
        """
        @summary 
        
        @param request: DescribeIpv6EgressOnlyRulesRequest
        @return: DescribeIpv6EgressOnlyRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_ipv_6egress_only_rules_with_options_async(request, runtime)

    def describe_ipv_6gateway_attribute_with_options(
        self,
        request: vpc_20160428_models.DescribeIpv6GatewayAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeIpv6GatewayAttributeResponse:
        """
        @summary Queries the information about an IPv6 gateway, including the region, virtual private cloud (VPC), status, and billing method.
        
        @param request: DescribeIpv6GatewayAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIpv6GatewayAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipv_6gateway_id):
            query['Ipv6GatewayId'] = request.ipv_6gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIpv6GatewayAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeIpv6GatewayAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_ipv_6gateway_attribute_with_options_async(
        self,
        request: vpc_20160428_models.DescribeIpv6GatewayAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeIpv6GatewayAttributeResponse:
        """
        @summary Queries the information about an IPv6 gateway, including the region, virtual private cloud (VPC), status, and billing method.
        
        @param request: DescribeIpv6GatewayAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIpv6GatewayAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipv_6gateway_id):
            query['Ipv6GatewayId'] = request.ipv_6gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIpv6GatewayAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeIpv6GatewayAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_ipv_6gateway_attribute(
        self,
        request: vpc_20160428_models.DescribeIpv6GatewayAttributeRequest,
    ) -> vpc_20160428_models.DescribeIpv6GatewayAttributeResponse:
        """
        @summary Queries the information about an IPv6 gateway, including the region, virtual private cloud (VPC), status, and billing method.
        
        @param request: DescribeIpv6GatewayAttributeRequest
        @return: DescribeIpv6GatewayAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_ipv_6gateway_attribute_with_options(request, runtime)

    async def describe_ipv_6gateway_attribute_async(
        self,
        request: vpc_20160428_models.DescribeIpv6GatewayAttributeRequest,
    ) -> vpc_20160428_models.DescribeIpv6GatewayAttributeResponse:
        """
        @summary Queries the information about an IPv6 gateway, including the region, virtual private cloud (VPC), status, and billing method.
        
        @param request: DescribeIpv6GatewayAttributeRequest
        @return: DescribeIpv6GatewayAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_ipv_6gateway_attribute_with_options_async(request, runtime)

    def describe_ipv_6gateways_with_options(
        self,
        request: vpc_20160428_models.DescribeIpv6GatewaysRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeIpv6GatewaysResponse:
        """
        @summary Queries IPv6 gateways in a region.
        
        @param request: DescribeIpv6GatewaysRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIpv6GatewaysResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipv_6gateway_id):
            query['Ipv6GatewayId'] = request.ipv_6gateway_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIpv6Gateways',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeIpv6GatewaysResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_ipv_6gateways_with_options_async(
        self,
        request: vpc_20160428_models.DescribeIpv6GatewaysRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeIpv6GatewaysResponse:
        """
        @summary Queries IPv6 gateways in a region.
        
        @param request: DescribeIpv6GatewaysRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIpv6GatewaysResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipv_6gateway_id):
            query['Ipv6GatewayId'] = request.ipv_6gateway_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIpv6Gateways',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeIpv6GatewaysResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_ipv_6gateways(
        self,
        request: vpc_20160428_models.DescribeIpv6GatewaysRequest,
    ) -> vpc_20160428_models.DescribeIpv6GatewaysResponse:
        """
        @summary Queries IPv6 gateways in a region.
        
        @param request: DescribeIpv6GatewaysRequest
        @return: DescribeIpv6GatewaysResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_ipv_6gateways_with_options(request, runtime)

    async def describe_ipv_6gateways_async(
        self,
        request: vpc_20160428_models.DescribeIpv6GatewaysRequest,
    ) -> vpc_20160428_models.DescribeIpv6GatewaysResponse:
        """
        @summary Queries IPv6 gateways in a region.
        
        @param request: DescribeIpv6GatewaysRequest
        @return: DescribeIpv6GatewaysResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_ipv_6gateways_with_options_async(request, runtime)

    def describe_nat_gateways_with_options(
        self,
        request: vpc_20160428_models.DescribeNatGatewaysRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeNatGatewaysResponse:
        """
        @summary Queries NAT gateways that meet specific conditions in a specified region.
        
        @description You can call this operation to query both Virtual Private Cloud (VPC) NAT gateways and Internet NAT gateways. NAT gateways in this topic refer to both VPC NAT gateways and Internet NAT gateways.
        
        @param request: DescribeNatGatewaysRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeNatGatewaysResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.nat_type):
            query['NatType'] = request.nat_type
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.spec):
            query['Spec'] = request.spec
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeNatGateways',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeNatGatewaysResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_nat_gateways_with_options_async(
        self,
        request: vpc_20160428_models.DescribeNatGatewaysRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeNatGatewaysResponse:
        """
        @summary Queries NAT gateways that meet specific conditions in a specified region.
        
        @description You can call this operation to query both Virtual Private Cloud (VPC) NAT gateways and Internet NAT gateways. NAT gateways in this topic refer to both VPC NAT gateways and Internet NAT gateways.
        
        @param request: DescribeNatGatewaysRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeNatGatewaysResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.instance_charge_type):
            query['InstanceChargeType'] = request.instance_charge_type
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.nat_type):
            query['NatType'] = request.nat_type
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.spec):
            query['Spec'] = request.spec
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeNatGateways',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeNatGatewaysResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_nat_gateways(
        self,
        request: vpc_20160428_models.DescribeNatGatewaysRequest,
    ) -> vpc_20160428_models.DescribeNatGatewaysResponse:
        """
        @summary Queries NAT gateways that meet specific conditions in a specified region.
        
        @description You can call this operation to query both Virtual Private Cloud (VPC) NAT gateways and Internet NAT gateways. NAT gateways in this topic refer to both VPC NAT gateways and Internet NAT gateways.
        
        @param request: DescribeNatGatewaysRequest
        @return: DescribeNatGatewaysResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_nat_gateways_with_options(request, runtime)

    async def describe_nat_gateways_async(
        self,
        request: vpc_20160428_models.DescribeNatGatewaysRequest,
    ) -> vpc_20160428_models.DescribeNatGatewaysResponse:
        """
        @summary Queries NAT gateways that meet specific conditions in a specified region.
        
        @description You can call this operation to query both Virtual Private Cloud (VPC) NAT gateways and Internet NAT gateways. NAT gateways in this topic refer to both VPC NAT gateways and Internet NAT gateways.
        
        @param request: DescribeNatGatewaysRequest
        @return: DescribeNatGatewaysResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_nat_gateways_with_options_async(request, runtime)

    def describe_network_acl_attributes_with_options(
        self,
        request: vpc_20160428_models.DescribeNetworkAclAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeNetworkAclAttributesResponse:
        """
        @summary Queries network access control lists (ACLs).
        
        @param request: DescribeNetworkAclAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeNetworkAclAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.network_acl_id):
            query['NetworkAclId'] = request.network_acl_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeNetworkAclAttributes',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeNetworkAclAttributesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_network_acl_attributes_with_options_async(
        self,
        request: vpc_20160428_models.DescribeNetworkAclAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeNetworkAclAttributesResponse:
        """
        @summary Queries network access control lists (ACLs).
        
        @param request: DescribeNetworkAclAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeNetworkAclAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.network_acl_id):
            query['NetworkAclId'] = request.network_acl_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeNetworkAclAttributes',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeNetworkAclAttributesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_network_acl_attributes(
        self,
        request: vpc_20160428_models.DescribeNetworkAclAttributesRequest,
    ) -> vpc_20160428_models.DescribeNetworkAclAttributesResponse:
        """
        @summary Queries network access control lists (ACLs).
        
        @param request: DescribeNetworkAclAttributesRequest
        @return: DescribeNetworkAclAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_network_acl_attributes_with_options(request, runtime)

    async def describe_network_acl_attributes_async(
        self,
        request: vpc_20160428_models.DescribeNetworkAclAttributesRequest,
    ) -> vpc_20160428_models.DescribeNetworkAclAttributesResponse:
        """
        @summary Queries network access control lists (ACLs).
        
        @param request: DescribeNetworkAclAttributesRequest
        @return: DescribeNetworkAclAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_network_acl_attributes_with_options_async(request, runtime)

    def describe_network_acls_with_options(
        self,
        request: vpc_20160428_models.DescribeNetworkAclsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeNetworkAclsResponse:
        """
        @summary Queries network ACLs.
        
        @param request: DescribeNetworkAclsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeNetworkAclsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.network_acl_id):
            query['NetworkAclId'] = request.network_acl_id
        if not UtilClient.is_unset(request.network_acl_name):
            query['NetworkAclName'] = request.network_acl_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeNetworkAcls',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeNetworkAclsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_network_acls_with_options_async(
        self,
        request: vpc_20160428_models.DescribeNetworkAclsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeNetworkAclsResponse:
        """
        @summary Queries network ACLs.
        
        @param request: DescribeNetworkAclsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeNetworkAclsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.network_acl_id):
            query['NetworkAclId'] = request.network_acl_id
        if not UtilClient.is_unset(request.network_acl_name):
            query['NetworkAclName'] = request.network_acl_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeNetworkAcls',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeNetworkAclsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_network_acls(
        self,
        request: vpc_20160428_models.DescribeNetworkAclsRequest,
    ) -> vpc_20160428_models.DescribeNetworkAclsResponse:
        """
        @summary Queries network ACLs.
        
        @param request: DescribeNetworkAclsRequest
        @return: DescribeNetworkAclsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_network_acls_with_options(request, runtime)

    async def describe_network_acls_async(
        self,
        request: vpc_20160428_models.DescribeNetworkAclsRequest,
    ) -> vpc_20160428_models.DescribeNetworkAclsResponse:
        """
        @summary Queries network ACLs.
        
        @param request: DescribeNetworkAclsRequest
        @return: DescribeNetworkAclsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_network_acls_with_options_async(request, runtime)

    def describe_physical_connection_loawith_options(
        self,
        request: vpc_20160428_models.DescribePhysicalConnectionLOARequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribePhysicalConnectionLOAResponse:
        """
        @summary LOA
        
        @param request: DescribePhysicalConnectionLOARequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePhysicalConnectionLOAResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePhysicalConnectionLOA',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribePhysicalConnectionLOAResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_physical_connection_loawith_options_async(
        self,
        request: vpc_20160428_models.DescribePhysicalConnectionLOARequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribePhysicalConnectionLOAResponse:
        """
        @summary LOA
        
        @param request: DescribePhysicalConnectionLOARequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePhysicalConnectionLOAResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePhysicalConnectionLOA',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribePhysicalConnectionLOAResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_physical_connection_loa(
        self,
        request: vpc_20160428_models.DescribePhysicalConnectionLOARequest,
    ) -> vpc_20160428_models.DescribePhysicalConnectionLOAResponse:
        """
        @summary LOA
        
        @param request: DescribePhysicalConnectionLOARequest
        @return: DescribePhysicalConnectionLOAResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_physical_connection_loawith_options(request, runtime)

    async def describe_physical_connection_loa_async(
        self,
        request: vpc_20160428_models.DescribePhysicalConnectionLOARequest,
    ) -> vpc_20160428_models.DescribePhysicalConnectionLOAResponse:
        """
        @summary LOA
        
        @param request: DescribePhysicalConnectionLOARequest
        @return: DescribePhysicalConnectionLOAResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_physical_connection_loawith_options_async(request, runtime)

    def describe_physical_connections_with_options(
        self,
        request: vpc_20160428_models.DescribePhysicalConnectionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribePhysicalConnectionsResponse:
        """
        @summary Queries Express Connect circuits in a region.
        
        @description By default, the system queries information about all Express Connect circuits in the specified region. You can query Express Connect circuits that meet specific conditions by specifying filter conditions provided by the *DescribePhysicalConnections** operation. For more information about the supported filter conditions, see **Key** in the **Request parameters** section.
        
        @param request: DescribePhysicalConnectionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePhysicalConnectionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.include_reservation_data):
            query['IncludeReservationData'] = request.include_reservation_data
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePhysicalConnections',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribePhysicalConnectionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_physical_connections_with_options_async(
        self,
        request: vpc_20160428_models.DescribePhysicalConnectionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribePhysicalConnectionsResponse:
        """
        @summary Queries Express Connect circuits in a region.
        
        @description By default, the system queries information about all Express Connect circuits in the specified region. You can query Express Connect circuits that meet specific conditions by specifying filter conditions provided by the *DescribePhysicalConnections** operation. For more information about the supported filter conditions, see **Key** in the **Request parameters** section.
        
        @param request: DescribePhysicalConnectionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePhysicalConnectionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.include_reservation_data):
            query['IncludeReservationData'] = request.include_reservation_data
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePhysicalConnections',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribePhysicalConnectionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_physical_connections(
        self,
        request: vpc_20160428_models.DescribePhysicalConnectionsRequest,
    ) -> vpc_20160428_models.DescribePhysicalConnectionsResponse:
        """
        @summary Queries Express Connect circuits in a region.
        
        @description By default, the system queries information about all Express Connect circuits in the specified region. You can query Express Connect circuits that meet specific conditions by specifying filter conditions provided by the *DescribePhysicalConnections** operation. For more information about the supported filter conditions, see **Key** in the **Request parameters** section.
        
        @param request: DescribePhysicalConnectionsRequest
        @return: DescribePhysicalConnectionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_physical_connections_with_options(request, runtime)

    async def describe_physical_connections_async(
        self,
        request: vpc_20160428_models.DescribePhysicalConnectionsRequest,
    ) -> vpc_20160428_models.DescribePhysicalConnectionsResponse:
        """
        @summary Queries Express Connect circuits in a region.
        
        @description By default, the system queries information about all Express Connect circuits in the specified region. You can query Express Connect circuits that meet specific conditions by specifying filter conditions provided by the *DescribePhysicalConnections** operation. For more information about the supported filter conditions, see **Key** in the **Request parameters** section.
        
        @param request: DescribePhysicalConnectionsRequest
        @return: DescribePhysicalConnectionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_physical_connections_with_options_async(request, runtime)

    def describe_public_ip_address_with_options(
        self,
        request: vpc_20160428_models.DescribePublicIpAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribePublicIpAddressResponse:
        """
        @summary Queries the public IP address range of a virtual private cloud (VPC) in a region.
        
        @description You cannot query the range of public IP addresses of a classic network by calling the *DescribePublicIpAddress** operation.
        
        @param request: DescribePublicIpAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePublicIpAddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePublicIpAddress',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribePublicIpAddressResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_public_ip_address_with_options_async(
        self,
        request: vpc_20160428_models.DescribePublicIpAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribePublicIpAddressResponse:
        """
        @summary Queries the public IP address range of a virtual private cloud (VPC) in a region.
        
        @description You cannot query the range of public IP addresses of a classic network by calling the *DescribePublicIpAddress** operation.
        
        @param request: DescribePublicIpAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePublicIpAddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePublicIpAddress',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribePublicIpAddressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_public_ip_address(
        self,
        request: vpc_20160428_models.DescribePublicIpAddressRequest,
    ) -> vpc_20160428_models.DescribePublicIpAddressResponse:
        """
        @summary Queries the public IP address range of a virtual private cloud (VPC) in a region.
        
        @description You cannot query the range of public IP addresses of a classic network by calling the *DescribePublicIpAddress** operation.
        
        @param request: DescribePublicIpAddressRequest
        @return: DescribePublicIpAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_public_ip_address_with_options(request, runtime)

    async def describe_public_ip_address_async(
        self,
        request: vpc_20160428_models.DescribePublicIpAddressRequest,
    ) -> vpc_20160428_models.DescribePublicIpAddressResponse:
        """
        @summary Queries the public IP address range of a virtual private cloud (VPC) in a region.
        
        @description You cannot query the range of public IP addresses of a classic network by calling the *DescribePublicIpAddress** operation.
        
        @param request: DescribePublicIpAddressRequest
        @return: DescribePublicIpAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_public_ip_address_with_options_async(request, runtime)

    def describe_regions_with_options(
        self,
        request: vpc_20160428_models.DescribeRegionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeRegionsResponse:
        """
        @summary Queries the most recent region list.
        
        @param request: DescribeRegionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRegionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.accept_language):
            query['AcceptLanguage'] = request.accept_language
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.product_type):
            query['ProductType'] = request.product_type
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRegions',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeRegionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_regions_with_options_async(
        self,
        request: vpc_20160428_models.DescribeRegionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeRegionsResponse:
        """
        @summary Queries the most recent region list.
        
        @param request: DescribeRegionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRegionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.accept_language):
            query['AcceptLanguage'] = request.accept_language
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.product_type):
            query['ProductType'] = request.product_type
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRegions',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeRegionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_regions(
        self,
        request: vpc_20160428_models.DescribeRegionsRequest,
    ) -> vpc_20160428_models.DescribeRegionsResponse:
        """
        @summary Queries the most recent region list.
        
        @param request: DescribeRegionsRequest
        @return: DescribeRegionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_regions_with_options(request, runtime)

    async def describe_regions_async(
        self,
        request: vpc_20160428_models.DescribeRegionsRequest,
    ) -> vpc_20160428_models.DescribeRegionsResponse:
        """
        @summary Queries the most recent region list.
        
        @param request: DescribeRegionsRequest
        @return: DescribeRegionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_regions_with_options_async(request, runtime)

    def describe_route_entry_list_with_options(
        self,
        request: vpc_20160428_models.DescribeRouteEntryListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeRouteEntryListResponse:
        """
        @summary Queries information about route entries in a route table.
        
        @description Before you call the [DeleteRouteEntry](https://help.aliyun.com/document_detail/36013.html) operation to delete a route, you can call this operation to query the next hop of the route that you want to delete.
        
        @param request: DescribeRouteEntryListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRouteEntryListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dest_cidr_block_list):
            query['DestCidrBlockList'] = request.dest_cidr_block_list
        if not UtilClient.is_unset(request.destination_cidr_block):
            query['DestinationCidrBlock'] = request.destination_cidr_block
        if not UtilClient.is_unset(request.ip_version):
            query['IpVersion'] = request.ip_version
        if not UtilClient.is_unset(request.max_result):
            query['MaxResult'] = request.max_result
        if not UtilClient.is_unset(request.next_hop_id):
            query['NextHopId'] = request.next_hop_id
        if not UtilClient.is_unset(request.next_hop_type):
            query['NextHopType'] = request.next_hop_type
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_entry_id):
            query['RouteEntryId'] = request.route_entry_id
        if not UtilClient.is_unset(request.route_entry_name):
            query['RouteEntryName'] = request.route_entry_name
        if not UtilClient.is_unset(request.route_entry_type):
            query['RouteEntryType'] = request.route_entry_type
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        if not UtilClient.is_unset(request.service_type):
            query['ServiceType'] = request.service_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRouteEntryList',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeRouteEntryListResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_route_entry_list_with_options_async(
        self,
        request: vpc_20160428_models.DescribeRouteEntryListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeRouteEntryListResponse:
        """
        @summary Queries information about route entries in a route table.
        
        @description Before you call the [DeleteRouteEntry](https://help.aliyun.com/document_detail/36013.html) operation to delete a route, you can call this operation to query the next hop of the route that you want to delete.
        
        @param request: DescribeRouteEntryListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRouteEntryListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dest_cidr_block_list):
            query['DestCidrBlockList'] = request.dest_cidr_block_list
        if not UtilClient.is_unset(request.destination_cidr_block):
            query['DestinationCidrBlock'] = request.destination_cidr_block
        if not UtilClient.is_unset(request.ip_version):
            query['IpVersion'] = request.ip_version
        if not UtilClient.is_unset(request.max_result):
            query['MaxResult'] = request.max_result
        if not UtilClient.is_unset(request.next_hop_id):
            query['NextHopId'] = request.next_hop_id
        if not UtilClient.is_unset(request.next_hop_type):
            query['NextHopType'] = request.next_hop_type
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_entry_id):
            query['RouteEntryId'] = request.route_entry_id
        if not UtilClient.is_unset(request.route_entry_name):
            query['RouteEntryName'] = request.route_entry_name
        if not UtilClient.is_unset(request.route_entry_type):
            query['RouteEntryType'] = request.route_entry_type
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        if not UtilClient.is_unset(request.service_type):
            query['ServiceType'] = request.service_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRouteEntryList',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeRouteEntryListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_route_entry_list(
        self,
        request: vpc_20160428_models.DescribeRouteEntryListRequest,
    ) -> vpc_20160428_models.DescribeRouteEntryListResponse:
        """
        @summary Queries information about route entries in a route table.
        
        @description Before you call the [DeleteRouteEntry](https://help.aliyun.com/document_detail/36013.html) operation to delete a route, you can call this operation to query the next hop of the route that you want to delete.
        
        @param request: DescribeRouteEntryListRequest
        @return: DescribeRouteEntryListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_route_entry_list_with_options(request, runtime)

    async def describe_route_entry_list_async(
        self,
        request: vpc_20160428_models.DescribeRouteEntryListRequest,
    ) -> vpc_20160428_models.DescribeRouteEntryListResponse:
        """
        @summary Queries information about route entries in a route table.
        
        @description Before you call the [DeleteRouteEntry](https://help.aliyun.com/document_detail/36013.html) operation to delete a route, you can call this operation to query the next hop of the route that you want to delete.
        
        @param request: DescribeRouteEntryListRequest
        @return: DescribeRouteEntryListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_route_entry_list_with_options_async(request, runtime)

    def describe_route_table_list_with_options(
        self,
        request: vpc_20160428_models.DescribeRouteTableListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeRouteTableListResponse:
        """
        @summary Queries route tables.
        
        @param request: DescribeRouteTableListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRouteTableListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        if not UtilClient.is_unset(request.route_table_name):
            query['RouteTableName'] = request.route_table_name
        if not UtilClient.is_unset(request.route_table_type):
            query['RouteTableType'] = request.route_table_type
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        if not UtilClient.is_unset(request.router_type):
            query['RouterType'] = request.router_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRouteTableList',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeRouteTableListResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_route_table_list_with_options_async(
        self,
        request: vpc_20160428_models.DescribeRouteTableListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeRouteTableListResponse:
        """
        @summary Queries route tables.
        
        @param request: DescribeRouteTableListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRouteTableListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        if not UtilClient.is_unset(request.route_table_name):
            query['RouteTableName'] = request.route_table_name
        if not UtilClient.is_unset(request.route_table_type):
            query['RouteTableType'] = request.route_table_type
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        if not UtilClient.is_unset(request.router_type):
            query['RouterType'] = request.router_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRouteTableList',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeRouteTableListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_route_table_list(
        self,
        request: vpc_20160428_models.DescribeRouteTableListRequest,
    ) -> vpc_20160428_models.DescribeRouteTableListResponse:
        """
        @summary Queries route tables.
        
        @param request: DescribeRouteTableListRequest
        @return: DescribeRouteTableListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_route_table_list_with_options(request, runtime)

    async def describe_route_table_list_async(
        self,
        request: vpc_20160428_models.DescribeRouteTableListRequest,
    ) -> vpc_20160428_models.DescribeRouteTableListResponse:
        """
        @summary Queries route tables.
        
        @param request: DescribeRouteTableListRequest
        @return: DescribeRouteTableListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_route_table_list_with_options_async(request, runtime)

    def describe_route_tables_with_options(
        self,
        request: vpc_20160428_models.DescribeRouteTablesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeRouteTablesResponse:
        """
        @deprecated OpenAPI DescribeRouteTables is deprecated, please use Vpc::2016-04-28::DescribeRouteTableList instead.
        
        @summary Queries route tables.
        
        @param request: DescribeRouteTablesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRouteTablesResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        if not UtilClient.is_unset(request.route_table_name):
            query['RouteTableName'] = request.route_table_name
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        if not UtilClient.is_unset(request.router_type):
            query['RouterType'] = request.router_type
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.vrouter_id):
            query['VRouterId'] = request.vrouter_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRouteTables',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeRouteTablesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_route_tables_with_options_async(
        self,
        request: vpc_20160428_models.DescribeRouteTablesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeRouteTablesResponse:
        """
        @deprecated OpenAPI DescribeRouteTables is deprecated, please use Vpc::2016-04-28::DescribeRouteTableList instead.
        
        @summary Queries route tables.
        
        @param request: DescribeRouteTablesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRouteTablesResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        if not UtilClient.is_unset(request.route_table_name):
            query['RouteTableName'] = request.route_table_name
        if not UtilClient.is_unset(request.router_id):
            query['RouterId'] = request.router_id
        if not UtilClient.is_unset(request.router_type):
            query['RouterType'] = request.router_type
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.vrouter_id):
            query['VRouterId'] = request.vrouter_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRouteTables',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeRouteTablesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_route_tables(
        self,
        request: vpc_20160428_models.DescribeRouteTablesRequest,
    ) -> vpc_20160428_models.DescribeRouteTablesResponse:
        """
        @deprecated OpenAPI DescribeRouteTables is deprecated, please use Vpc::2016-04-28::DescribeRouteTableList instead.
        
        @summary Queries route tables.
        
        @param request: DescribeRouteTablesRequest
        @return: DescribeRouteTablesResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_route_tables_with_options(request, runtime)

    async def describe_route_tables_async(
        self,
        request: vpc_20160428_models.DescribeRouteTablesRequest,
    ) -> vpc_20160428_models.DescribeRouteTablesResponse:
        """
        @deprecated OpenAPI DescribeRouteTables is deprecated, please use Vpc::2016-04-28::DescribeRouteTableList instead.
        
        @summary Queries route tables.
        
        @param request: DescribeRouteTablesRequest
        @return: DescribeRouteTablesResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_route_tables_with_options_async(request, runtime)

    def describe_router_interface_attribute_with_options(
        self,
        request: vpc_20160428_models.DescribeRouterInterfaceAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeRouterInterfaceAttributeResponse:
        """
        @summary Queries the configuration of a router interface.
        
        @param request: DescribeRouterInterfaceAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRouterInterfaceAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRouterInterfaceAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeRouterInterfaceAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_router_interface_attribute_with_options_async(
        self,
        request: vpc_20160428_models.DescribeRouterInterfaceAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeRouterInterfaceAttributeResponse:
        """
        @summary Queries the configuration of a router interface.
        
        @param request: DescribeRouterInterfaceAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRouterInterfaceAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRouterInterfaceAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeRouterInterfaceAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_router_interface_attribute(
        self,
        request: vpc_20160428_models.DescribeRouterInterfaceAttributeRequest,
    ) -> vpc_20160428_models.DescribeRouterInterfaceAttributeResponse:
        """
        @summary Queries the configuration of a router interface.
        
        @param request: DescribeRouterInterfaceAttributeRequest
        @return: DescribeRouterInterfaceAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_router_interface_attribute_with_options(request, runtime)

    async def describe_router_interface_attribute_async(
        self,
        request: vpc_20160428_models.DescribeRouterInterfaceAttributeRequest,
    ) -> vpc_20160428_models.DescribeRouterInterfaceAttributeResponse:
        """
        @summary Queries the configuration of a router interface.
        
        @param request: DescribeRouterInterfaceAttributeRequest
        @return: DescribeRouterInterfaceAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_router_interface_attribute_with_options_async(request, runtime)

    def describe_router_interfaces_with_options(
        self,
        request: vpc_20160428_models.DescribeRouterInterfacesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeRouterInterfacesResponse:
        """
        @summary Queries router interfaces in a specified region.
        
        @param request: DescribeRouterInterfacesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRouterInterfacesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.include_reservation_data):
            query['IncludeReservationData'] = request.include_reservation_data
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRouterInterfaces',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeRouterInterfacesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_router_interfaces_with_options_async(
        self,
        request: vpc_20160428_models.DescribeRouterInterfacesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeRouterInterfacesResponse:
        """
        @summary Queries router interfaces in a specified region.
        
        @param request: DescribeRouterInterfacesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRouterInterfacesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.include_reservation_data):
            query['IncludeReservationData'] = request.include_reservation_data
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRouterInterfaces',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeRouterInterfacesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_router_interfaces(
        self,
        request: vpc_20160428_models.DescribeRouterInterfacesRequest,
    ) -> vpc_20160428_models.DescribeRouterInterfacesResponse:
        """
        @summary Queries router interfaces in a specified region.
        
        @param request: DescribeRouterInterfacesRequest
        @return: DescribeRouterInterfacesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_router_interfaces_with_options(request, runtime)

    async def describe_router_interfaces_async(
        self,
        request: vpc_20160428_models.DescribeRouterInterfacesRequest,
    ) -> vpc_20160428_models.DescribeRouterInterfacesResponse:
        """
        @summary Queries router interfaces in a specified region.
        
        @param request: DescribeRouterInterfacesRequest
        @return: DescribeRouterInterfacesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_router_interfaces_with_options_async(request, runtime)

    def describe_server_related_global_acceleration_instances_with_options(
        self,
        request: vpc_20160428_models.DescribeServerRelatedGlobalAccelerationInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeServerRelatedGlobalAccelerationInstancesResponse:
        """
        @summary Queries Global Accelerator (GA) instances that are associated with a backend server.
        
        @description > You can call this operation to query only dedicated-bandwidth GA instances.
        
        @param request: DescribeServerRelatedGlobalAccelerationInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeServerRelatedGlobalAccelerationInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.server_id):
            query['ServerId'] = request.server_id
        if not UtilClient.is_unset(request.server_type):
            query['ServerType'] = request.server_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeServerRelatedGlobalAccelerationInstances',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeServerRelatedGlobalAccelerationInstancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_server_related_global_acceleration_instances_with_options_async(
        self,
        request: vpc_20160428_models.DescribeServerRelatedGlobalAccelerationInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeServerRelatedGlobalAccelerationInstancesResponse:
        """
        @summary Queries Global Accelerator (GA) instances that are associated with a backend server.
        
        @description > You can call this operation to query only dedicated-bandwidth GA instances.
        
        @param request: DescribeServerRelatedGlobalAccelerationInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeServerRelatedGlobalAccelerationInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.server_id):
            query['ServerId'] = request.server_id
        if not UtilClient.is_unset(request.server_type):
            query['ServerType'] = request.server_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeServerRelatedGlobalAccelerationInstances',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeServerRelatedGlobalAccelerationInstancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_server_related_global_acceleration_instances(
        self,
        request: vpc_20160428_models.DescribeServerRelatedGlobalAccelerationInstancesRequest,
    ) -> vpc_20160428_models.DescribeServerRelatedGlobalAccelerationInstancesResponse:
        """
        @summary Queries Global Accelerator (GA) instances that are associated with a backend server.
        
        @description > You can call this operation to query only dedicated-bandwidth GA instances.
        
        @param request: DescribeServerRelatedGlobalAccelerationInstancesRequest
        @return: DescribeServerRelatedGlobalAccelerationInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_server_related_global_acceleration_instances_with_options(request, runtime)

    async def describe_server_related_global_acceleration_instances_async(
        self,
        request: vpc_20160428_models.DescribeServerRelatedGlobalAccelerationInstancesRequest,
    ) -> vpc_20160428_models.DescribeServerRelatedGlobalAccelerationInstancesResponse:
        """
        @summary Queries Global Accelerator (GA) instances that are associated with a backend server.
        
        @description > You can call this operation to query only dedicated-bandwidth GA instances.
        
        @param request: DescribeServerRelatedGlobalAccelerationInstancesRequest
        @return: DescribeServerRelatedGlobalAccelerationInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_server_related_global_acceleration_instances_with_options_async(request, runtime)

    def describe_snat_table_entries_with_options(
        self,
        request: vpc_20160428_models.DescribeSnatTableEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeSnatTableEntriesResponse:
        """
        @summary Queries SNAT entries.
        
        @param request: DescribeSnatTableEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSnatTableEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snat_entry_id):
            query['SnatEntryId'] = request.snat_entry_id
        if not UtilClient.is_unset(request.snat_entry_name):
            query['SnatEntryName'] = request.snat_entry_name
        if not UtilClient.is_unset(request.snat_ip):
            query['SnatIp'] = request.snat_ip
        if not UtilClient.is_unset(request.snat_table_id):
            query['SnatTableId'] = request.snat_table_id
        if not UtilClient.is_unset(request.source_cidr):
            query['SourceCIDR'] = request.source_cidr
        if not UtilClient.is_unset(request.source_vswitch_id):
            query['SourceVSwitchId'] = request.source_vswitch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSnatTableEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeSnatTableEntriesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_snat_table_entries_with_options_async(
        self,
        request: vpc_20160428_models.DescribeSnatTableEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeSnatTableEntriesResponse:
        """
        @summary Queries SNAT entries.
        
        @param request: DescribeSnatTableEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSnatTableEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snat_entry_id):
            query['SnatEntryId'] = request.snat_entry_id
        if not UtilClient.is_unset(request.snat_entry_name):
            query['SnatEntryName'] = request.snat_entry_name
        if not UtilClient.is_unset(request.snat_ip):
            query['SnatIp'] = request.snat_ip
        if not UtilClient.is_unset(request.snat_table_id):
            query['SnatTableId'] = request.snat_table_id
        if not UtilClient.is_unset(request.source_cidr):
            query['SourceCIDR'] = request.source_cidr
        if not UtilClient.is_unset(request.source_vswitch_id):
            query['SourceVSwitchId'] = request.source_vswitch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSnatTableEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeSnatTableEntriesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_snat_table_entries(
        self,
        request: vpc_20160428_models.DescribeSnatTableEntriesRequest,
    ) -> vpc_20160428_models.DescribeSnatTableEntriesResponse:
        """
        @summary Queries SNAT entries.
        
        @param request: DescribeSnatTableEntriesRequest
        @return: DescribeSnatTableEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_snat_table_entries_with_options(request, runtime)

    async def describe_snat_table_entries_async(
        self,
        request: vpc_20160428_models.DescribeSnatTableEntriesRequest,
    ) -> vpc_20160428_models.DescribeSnatTableEntriesResponse:
        """
        @summary Queries SNAT entries.
        
        @param request: DescribeSnatTableEntriesRequest
        @return: DescribeSnatTableEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_snat_table_entries_with_options_async(request, runtime)

    def describe_ssl_vpn_client_cert_with_options(
        self,
        request: vpc_20160428_models.DescribeSslVpnClientCertRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeSslVpnClientCertResponse:
        """
        @summary Queries the details of an SSL client certificate.
        
        @param request: DescribeSslVpnClientCertRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSslVpnClientCertResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.ssl_vpn_client_cert_id):
            query['SslVpnClientCertId'] = request.ssl_vpn_client_cert_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSslVpnClientCert',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeSslVpnClientCertResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_ssl_vpn_client_cert_with_options_async(
        self,
        request: vpc_20160428_models.DescribeSslVpnClientCertRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeSslVpnClientCertResponse:
        """
        @summary Queries the details of an SSL client certificate.
        
        @param request: DescribeSslVpnClientCertRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSslVpnClientCertResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.ssl_vpn_client_cert_id):
            query['SslVpnClientCertId'] = request.ssl_vpn_client_cert_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSslVpnClientCert',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeSslVpnClientCertResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_ssl_vpn_client_cert(
        self,
        request: vpc_20160428_models.DescribeSslVpnClientCertRequest,
    ) -> vpc_20160428_models.DescribeSslVpnClientCertResponse:
        """
        @summary Queries the details of an SSL client certificate.
        
        @param request: DescribeSslVpnClientCertRequest
        @return: DescribeSslVpnClientCertResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_ssl_vpn_client_cert_with_options(request, runtime)

    async def describe_ssl_vpn_client_cert_async(
        self,
        request: vpc_20160428_models.DescribeSslVpnClientCertRequest,
    ) -> vpc_20160428_models.DescribeSslVpnClientCertResponse:
        """
        @summary Queries the details of an SSL client certificate.
        
        @param request: DescribeSslVpnClientCertRequest
        @return: DescribeSslVpnClientCertResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_ssl_vpn_client_cert_with_options_async(request, runtime)

    def describe_ssl_vpn_client_certs_with_options(
        self,
        request: vpc_20160428_models.DescribeSslVpnClientCertsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeSslVpnClientCertsResponse:
        """
        @summary Queries SSL client certificates.
        
        @param request: DescribeSslVpnClientCertsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSslVpnClientCertsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.ssl_vpn_client_cert_id):
            query['SslVpnClientCertId'] = request.ssl_vpn_client_cert_id
        if not UtilClient.is_unset(request.ssl_vpn_server_id):
            query['SslVpnServerId'] = request.ssl_vpn_server_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSslVpnClientCerts',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeSslVpnClientCertsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_ssl_vpn_client_certs_with_options_async(
        self,
        request: vpc_20160428_models.DescribeSslVpnClientCertsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeSslVpnClientCertsResponse:
        """
        @summary Queries SSL client certificates.
        
        @param request: DescribeSslVpnClientCertsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSslVpnClientCertsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.ssl_vpn_client_cert_id):
            query['SslVpnClientCertId'] = request.ssl_vpn_client_cert_id
        if not UtilClient.is_unset(request.ssl_vpn_server_id):
            query['SslVpnServerId'] = request.ssl_vpn_server_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSslVpnClientCerts',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeSslVpnClientCertsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_ssl_vpn_client_certs(
        self,
        request: vpc_20160428_models.DescribeSslVpnClientCertsRequest,
    ) -> vpc_20160428_models.DescribeSslVpnClientCertsResponse:
        """
        @summary Queries SSL client certificates.
        
        @param request: DescribeSslVpnClientCertsRequest
        @return: DescribeSslVpnClientCertsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_ssl_vpn_client_certs_with_options(request, runtime)

    async def describe_ssl_vpn_client_certs_async(
        self,
        request: vpc_20160428_models.DescribeSslVpnClientCertsRequest,
    ) -> vpc_20160428_models.DescribeSslVpnClientCertsResponse:
        """
        @summary Queries SSL client certificates.
        
        @param request: DescribeSslVpnClientCertsRequest
        @return: DescribeSslVpnClientCertsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_ssl_vpn_client_certs_with_options_async(request, runtime)

    def describe_ssl_vpn_clients_with_options(
        self,
        request: vpc_20160428_models.DescribeSslVpnClientsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeSslVpnClientsResponse:
        """
        @summary Queries the clients that have connected to a VPN gateway through SSL-VPN connections.
        
        @description If your VPN gateway was created before December 10, 2022, you must upgrade your VPN gateway to the latest version before you can view connection information about SSL clients. For more information, see [Upgrade a VPN gateway](https://help.aliyun.com/document_detail/2671058.html).
        If your VPN gateway was created after December 10, 2022, you can view connection information about SSL clients by default.
        
        @param request: DescribeSslVpnClientsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSslVpnClientsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSslVpnClients',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeSslVpnClientsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_ssl_vpn_clients_with_options_async(
        self,
        request: vpc_20160428_models.DescribeSslVpnClientsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeSslVpnClientsResponse:
        """
        @summary Queries the clients that have connected to a VPN gateway through SSL-VPN connections.
        
        @description If your VPN gateway was created before December 10, 2022, you must upgrade your VPN gateway to the latest version before you can view connection information about SSL clients. For more information, see [Upgrade a VPN gateway](https://help.aliyun.com/document_detail/2671058.html).
        If your VPN gateway was created after December 10, 2022, you can view connection information about SSL clients by default.
        
        @param request: DescribeSslVpnClientsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSslVpnClientsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSslVpnClients',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeSslVpnClientsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_ssl_vpn_clients(
        self,
        request: vpc_20160428_models.DescribeSslVpnClientsRequest,
    ) -> vpc_20160428_models.DescribeSslVpnClientsResponse:
        """
        @summary Queries the clients that have connected to a VPN gateway through SSL-VPN connections.
        
        @description If your VPN gateway was created before December 10, 2022, you must upgrade your VPN gateway to the latest version before you can view connection information about SSL clients. For more information, see [Upgrade a VPN gateway](https://help.aliyun.com/document_detail/2671058.html).
        If your VPN gateway was created after December 10, 2022, you can view connection information about SSL clients by default.
        
        @param request: DescribeSslVpnClientsRequest
        @return: DescribeSslVpnClientsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_ssl_vpn_clients_with_options(request, runtime)

    async def describe_ssl_vpn_clients_async(
        self,
        request: vpc_20160428_models.DescribeSslVpnClientsRequest,
    ) -> vpc_20160428_models.DescribeSslVpnClientsResponse:
        """
        @summary Queries the clients that have connected to a VPN gateway through SSL-VPN connections.
        
        @description If your VPN gateway was created before December 10, 2022, you must upgrade your VPN gateway to the latest version before you can view connection information about SSL clients. For more information, see [Upgrade a VPN gateway](https://help.aliyun.com/document_detail/2671058.html).
        If your VPN gateway was created after December 10, 2022, you can view connection information about SSL clients by default.
        
        @param request: DescribeSslVpnClientsRequest
        @return: DescribeSslVpnClientsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_ssl_vpn_clients_with_options_async(request, runtime)

    def describe_ssl_vpn_servers_with_options(
        self,
        request: vpc_20160428_models.DescribeSslVpnServersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeSslVpnServersResponse:
        """
        @summary Queries one or more SSL-VPN servers.
        
        @param request: DescribeSslVpnServersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSslVpnServersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.ssl_vpn_server_id):
            query['SslVpnServerId'] = request.ssl_vpn_server_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSslVpnServers',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeSslVpnServersResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_ssl_vpn_servers_with_options_async(
        self,
        request: vpc_20160428_models.DescribeSslVpnServersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeSslVpnServersResponse:
        """
        @summary Queries one or more SSL-VPN servers.
        
        @param request: DescribeSslVpnServersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeSslVpnServersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.ssl_vpn_server_id):
            query['SslVpnServerId'] = request.ssl_vpn_server_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeSslVpnServers',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeSslVpnServersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_ssl_vpn_servers(
        self,
        request: vpc_20160428_models.DescribeSslVpnServersRequest,
    ) -> vpc_20160428_models.DescribeSslVpnServersResponse:
        """
        @summary Queries one or more SSL-VPN servers.
        
        @param request: DescribeSslVpnServersRequest
        @return: DescribeSslVpnServersResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_ssl_vpn_servers_with_options(request, runtime)

    async def describe_ssl_vpn_servers_async(
        self,
        request: vpc_20160428_models.DescribeSslVpnServersRequest,
    ) -> vpc_20160428_models.DescribeSslVpnServersResponse:
        """
        @summary Queries one or more SSL-VPN servers.
        
        @param request: DescribeSslVpnServersRequest
        @return: DescribeSslVpnServersResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_ssl_vpn_servers_with_options_async(request, runtime)

    def describe_tag_keys_with_options(
        self,
        request: vpc_20160428_models.DescribeTagKeysRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeTagKeysResponse:
        """
        @summary 
        
        @param request: DescribeTagKeysRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeTagKeysResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.keyword):
            query['Keyword'] = request.keyword
        if not UtilClient.is_unset(request.max_result):
            query['MaxResult'] = request.max_result
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeTagKeys',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeTagKeysResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_tag_keys_with_options_async(
        self,
        request: vpc_20160428_models.DescribeTagKeysRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeTagKeysResponse:
        """
        @summary 
        
        @param request: DescribeTagKeysRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeTagKeysResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.keyword):
            query['Keyword'] = request.keyword
        if not UtilClient.is_unset(request.max_result):
            query['MaxResult'] = request.max_result
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeTagKeys',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeTagKeysResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_tag_keys(
        self,
        request: vpc_20160428_models.DescribeTagKeysRequest,
    ) -> vpc_20160428_models.DescribeTagKeysResponse:
        """
        @summary 
        
        @param request: DescribeTagKeysRequest
        @return: DescribeTagKeysResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_tag_keys_with_options(request, runtime)

    async def describe_tag_keys_async(
        self,
        request: vpc_20160428_models.DescribeTagKeysRequest,
    ) -> vpc_20160428_models.DescribeTagKeysResponse:
        """
        @summary 
        
        @param request: DescribeTagKeysRequest
        @return: DescribeTagKeysResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_tag_keys_with_options_async(request, runtime)

    def describe_tag_keys_for_express_connect_with_options(
        self,
        request: vpc_20160428_models.DescribeTagKeysForExpressConnectRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeTagKeysForExpressConnectResponse:
        """
        @summary Queries the tags of an Express Connect circuit.
        
        @param request: DescribeTagKeysForExpressConnectRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeTagKeysForExpressConnectResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.keyword):
            query['Keyword'] = request.keyword
        if not UtilClient.is_unset(request.max_result):
            query['MaxResult'] = request.max_result
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeTagKeysForExpressConnect',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeTagKeysForExpressConnectResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_tag_keys_for_express_connect_with_options_async(
        self,
        request: vpc_20160428_models.DescribeTagKeysForExpressConnectRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeTagKeysForExpressConnectResponse:
        """
        @summary Queries the tags of an Express Connect circuit.
        
        @param request: DescribeTagKeysForExpressConnectRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeTagKeysForExpressConnectResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.keyword):
            query['Keyword'] = request.keyword
        if not UtilClient.is_unset(request.max_result):
            query['MaxResult'] = request.max_result
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeTagKeysForExpressConnect',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeTagKeysForExpressConnectResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_tag_keys_for_express_connect(
        self,
        request: vpc_20160428_models.DescribeTagKeysForExpressConnectRequest,
    ) -> vpc_20160428_models.DescribeTagKeysForExpressConnectResponse:
        """
        @summary Queries the tags of an Express Connect circuit.
        
        @param request: DescribeTagKeysForExpressConnectRequest
        @return: DescribeTagKeysForExpressConnectResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_tag_keys_for_express_connect_with_options(request, runtime)

    async def describe_tag_keys_for_express_connect_async(
        self,
        request: vpc_20160428_models.DescribeTagKeysForExpressConnectRequest,
    ) -> vpc_20160428_models.DescribeTagKeysForExpressConnectResponse:
        """
        @summary Queries the tags of an Express Connect circuit.
        
        @param request: DescribeTagKeysForExpressConnectRequest
        @return: DescribeTagKeysForExpressConnectResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_tag_keys_for_express_connect_with_options_async(request, runtime)

    def describe_tags_with_options(
        self,
        request: vpc_20160428_models.DescribeTagsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeTagsResponse:
        """
        @summary 
        
        @description    You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
        **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Tag.N.Value**, an error message is returned.
        If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
        If you specify multiple key-value pairs, all tags that match the key-value pairs are returned.
        
        @param request: DescribeTagsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeTagsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_result):
            query['MaxResult'] = request.max_result
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeTags',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeTagsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_tags_with_options_async(
        self,
        request: vpc_20160428_models.DescribeTagsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeTagsResponse:
        """
        @summary 
        
        @description    You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
        **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Tag.N.Value**, an error message is returned.
        If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
        If you specify multiple key-value pairs, all tags that match the key-value pairs are returned.
        
        @param request: DescribeTagsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeTagsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_result):
            query['MaxResult'] = request.max_result
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeTags',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeTagsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_tags(
        self,
        request: vpc_20160428_models.DescribeTagsRequest,
    ) -> vpc_20160428_models.DescribeTagsResponse:
        """
        @summary 
        
        @description    You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
        **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Tag.N.Value**, an error message is returned.
        If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
        If you specify multiple key-value pairs, all tags that match the key-value pairs are returned.
        
        @param request: DescribeTagsRequest
        @return: DescribeTagsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_tags_with_options(request, runtime)

    async def describe_tags_async(
        self,
        request: vpc_20160428_models.DescribeTagsRequest,
    ) -> vpc_20160428_models.DescribeTagsResponse:
        """
        @summary 
        
        @description    You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
        **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Tag.N.Value**, an error message is returned.
        If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
        If you specify multiple key-value pairs, all tags that match the key-value pairs are returned.
        
        @param request: DescribeTagsRequest
        @return: DescribeTagsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_tags_with_options_async(request, runtime)

    def describe_vrouters_with_options(
        self,
        request: vpc_20160428_models.DescribeVRoutersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVRoutersResponse:
        """
        @summary 
        
        @param request: DescribeVRoutersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVRoutersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vrouter_id):
            query['VRouterId'] = request.vrouter_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVRouters',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVRoutersResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vrouters_with_options_async(
        self,
        request: vpc_20160428_models.DescribeVRoutersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVRoutersResponse:
        """
        @summary 
        
        @param request: DescribeVRoutersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVRoutersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vrouter_id):
            query['VRouterId'] = request.vrouter_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVRouters',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVRoutersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vrouters(
        self,
        request: vpc_20160428_models.DescribeVRoutersRequest,
    ) -> vpc_20160428_models.DescribeVRoutersResponse:
        """
        @summary 
        
        @param request: DescribeVRoutersRequest
        @return: DescribeVRoutersResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vrouters_with_options(request, runtime)

    async def describe_vrouters_async(
        self,
        request: vpc_20160428_models.DescribeVRoutersRequest,
    ) -> vpc_20160428_models.DescribeVRoutersResponse:
        """
        @summary 
        
        @param request: DescribeVRoutersRequest
        @return: DescribeVRoutersResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vrouters_with_options_async(request, runtime)

    def describe_vswitch_attributes_with_options(
        self,
        request: vpc_20160428_models.DescribeVSwitchAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVSwitchAttributesResponse:
        """
        @summary Queries the detailed information about a vSwitch.
        
        @param request: DescribeVSwitchAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVSwitchAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVSwitchAttributes',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVSwitchAttributesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vswitch_attributes_with_options_async(
        self,
        request: vpc_20160428_models.DescribeVSwitchAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVSwitchAttributesResponse:
        """
        @summary Queries the detailed information about a vSwitch.
        
        @param request: DescribeVSwitchAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVSwitchAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVSwitchAttributes',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVSwitchAttributesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vswitch_attributes(
        self,
        request: vpc_20160428_models.DescribeVSwitchAttributesRequest,
    ) -> vpc_20160428_models.DescribeVSwitchAttributesResponse:
        """
        @summary Queries the detailed information about a vSwitch.
        
        @param request: DescribeVSwitchAttributesRequest
        @return: DescribeVSwitchAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vswitch_attributes_with_options(request, runtime)

    async def describe_vswitch_attributes_async(
        self,
        request: vpc_20160428_models.DescribeVSwitchAttributesRequest,
    ) -> vpc_20160428_models.DescribeVSwitchAttributesResponse:
        """
        @summary Queries the detailed information about a vSwitch.
        
        @param request: DescribeVSwitchAttributesRequest
        @return: DescribeVSwitchAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vswitch_attributes_with_options_async(request, runtime)

    def describe_vswitches_with_options(
        self,
        request: vpc_20160428_models.DescribeVSwitchesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVSwitchesResponse:
        """
        @summary Queries the information about available vSwitches that are used for an internal network.
        
        @param request: DescribeVSwitchesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVSwitchesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.enable_ipv_6):
            query['EnableIpv6'] = request.enable_ipv_6
        if not UtilClient.is_unset(request.is_default):
            query['IsDefault'] = request.is_default
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.v_switch_name):
            query['VSwitchName'] = request.v_switch_name
        if not UtilClient.is_unset(request.v_switch_owner_id):
            query['VSwitchOwnerId'] = request.v_switch_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVSwitches',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVSwitchesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vswitches_with_options_async(
        self,
        request: vpc_20160428_models.DescribeVSwitchesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVSwitchesResponse:
        """
        @summary Queries the information about available vSwitches that are used for an internal network.
        
        @param request: DescribeVSwitchesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVSwitchesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.enable_ipv_6):
            query['EnableIpv6'] = request.enable_ipv_6
        if not UtilClient.is_unset(request.is_default):
            query['IsDefault'] = request.is_default
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.v_switch_name):
            query['VSwitchName'] = request.v_switch_name
        if not UtilClient.is_unset(request.v_switch_owner_id):
            query['VSwitchOwnerId'] = request.v_switch_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVSwitches',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVSwitchesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vswitches(
        self,
        request: vpc_20160428_models.DescribeVSwitchesRequest,
    ) -> vpc_20160428_models.DescribeVSwitchesResponse:
        """
        @summary Queries the information about available vSwitches that are used for an internal network.
        
        @param request: DescribeVSwitchesRequest
        @return: DescribeVSwitchesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vswitches_with_options(request, runtime)

    async def describe_vswitches_async(
        self,
        request: vpc_20160428_models.DescribeVSwitchesRequest,
    ) -> vpc_20160428_models.DescribeVSwitchesResponse:
        """
        @summary Queries the information about available vSwitches that are used for an internal network.
        
        @param request: DescribeVSwitchesRequest
        @return: DescribeVSwitchesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vswitches_with_options_async(request, runtime)

    def describe_vbr_ha_with_options(
        self,
        request: vpc_20160428_models.DescribeVbrHaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVbrHaResponse:
        """
        @summary Queries virtual border router (VBR) failover groups.
        
        @param request: DescribeVbrHaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVbrHaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vbr_ha_id):
            query['VbrHaId'] = request.vbr_ha_id
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVbrHa',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVbrHaResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vbr_ha_with_options_async(
        self,
        request: vpc_20160428_models.DescribeVbrHaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVbrHaResponse:
        """
        @summary Queries virtual border router (VBR) failover groups.
        
        @param request: DescribeVbrHaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVbrHaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vbr_ha_id):
            query['VbrHaId'] = request.vbr_ha_id
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVbrHa',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVbrHaResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vbr_ha(
        self,
        request: vpc_20160428_models.DescribeVbrHaRequest,
    ) -> vpc_20160428_models.DescribeVbrHaResponse:
        """
        @summary Queries virtual border router (VBR) failover groups.
        
        @param request: DescribeVbrHaRequest
        @return: DescribeVbrHaResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vbr_ha_with_options(request, runtime)

    async def describe_vbr_ha_async(
        self,
        request: vpc_20160428_models.DescribeVbrHaRequest,
    ) -> vpc_20160428_models.DescribeVbrHaResponse:
        """
        @summary Queries virtual border router (VBR) failover groups.
        
        @param request: DescribeVbrHaRequest
        @return: DescribeVbrHaResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vbr_ha_with_options_async(request, runtime)

    def describe_vco_route_entries_with_options(
        self,
        request: vpc_20160428_models.DescribeVcoRouteEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVcoRouteEntriesResponse:
        """
        @summary Queries the routes of an IPsec-VPN connection.
        
        @param request: DescribeVcoRouteEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVcoRouteEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_entry_type):
            query['RouteEntryType'] = request.route_entry_type
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVcoRouteEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVcoRouteEntriesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vco_route_entries_with_options_async(
        self,
        request: vpc_20160428_models.DescribeVcoRouteEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVcoRouteEntriesResponse:
        """
        @summary Queries the routes of an IPsec-VPN connection.
        
        @param request: DescribeVcoRouteEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVcoRouteEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_entry_type):
            query['RouteEntryType'] = request.route_entry_type
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVcoRouteEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVcoRouteEntriesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vco_route_entries(
        self,
        request: vpc_20160428_models.DescribeVcoRouteEntriesRequest,
    ) -> vpc_20160428_models.DescribeVcoRouteEntriesResponse:
        """
        @summary Queries the routes of an IPsec-VPN connection.
        
        @param request: DescribeVcoRouteEntriesRequest
        @return: DescribeVcoRouteEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vco_route_entries_with_options(request, runtime)

    async def describe_vco_route_entries_async(
        self,
        request: vpc_20160428_models.DescribeVcoRouteEntriesRequest,
    ) -> vpc_20160428_models.DescribeVcoRouteEntriesResponse:
        """
        @summary Queries the routes of an IPsec-VPN connection.
        
        @param request: DescribeVcoRouteEntriesRequest
        @return: DescribeVcoRouteEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vco_route_entries_with_options_async(request, runtime)

    def describe_virtual_border_routers_with_options(
        self,
        request: vpc_20160428_models.DescribeVirtualBorderRoutersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVirtualBorderRoutersResponse:
        """
        @summary Queries virtual border routers (VBRs).
        
        @param request: DescribeVirtualBorderRoutersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVirtualBorderRoutersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.include_cross_account_vbr):
            query['IncludeCrossAccountVbr'] = request.include_cross_account_vbr
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVirtualBorderRouters',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVirtualBorderRoutersResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_virtual_border_routers_with_options_async(
        self,
        request: vpc_20160428_models.DescribeVirtualBorderRoutersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVirtualBorderRoutersResponse:
        """
        @summary Queries virtual border routers (VBRs).
        
        @param request: DescribeVirtualBorderRoutersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVirtualBorderRoutersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.include_cross_account_vbr):
            query['IncludeCrossAccountVbr'] = request.include_cross_account_vbr
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVirtualBorderRouters',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVirtualBorderRoutersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_virtual_border_routers(
        self,
        request: vpc_20160428_models.DescribeVirtualBorderRoutersRequest,
    ) -> vpc_20160428_models.DescribeVirtualBorderRoutersResponse:
        """
        @summary Queries virtual border routers (VBRs).
        
        @param request: DescribeVirtualBorderRoutersRequest
        @return: DescribeVirtualBorderRoutersResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_virtual_border_routers_with_options(request, runtime)

    async def describe_virtual_border_routers_async(
        self,
        request: vpc_20160428_models.DescribeVirtualBorderRoutersRequest,
    ) -> vpc_20160428_models.DescribeVirtualBorderRoutersResponse:
        """
        @summary Queries virtual border routers (VBRs).
        
        @param request: DescribeVirtualBorderRoutersRequest
        @return: DescribeVirtualBorderRoutersResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_virtual_border_routers_with_options_async(request, runtime)

    def describe_virtual_border_routers_for_physical_connection_with_options(
        self,
        request: vpc_20160428_models.DescribeVirtualBorderRoutersForPhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVirtualBorderRoutersForPhysicalConnectionResponse:
        """
        @summary Queries the virtual border routers (VBRs) that are associated with an Express Connect circuit. The VBRs can be created by the owner of the Express Connect circuit and by other Alibaba Cloud accounts.
        
        @param request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVirtualBorderRoutersForPhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVirtualBorderRoutersForPhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVirtualBorderRoutersForPhysicalConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_virtual_border_routers_for_physical_connection_with_options_async(
        self,
        request: vpc_20160428_models.DescribeVirtualBorderRoutersForPhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVirtualBorderRoutersForPhysicalConnectionResponse:
        """
        @summary Queries the virtual border routers (VBRs) that are associated with an Express Connect circuit. The VBRs can be created by the owner of the Express Connect circuit and by other Alibaba Cloud accounts.
        
        @param request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVirtualBorderRoutersForPhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVirtualBorderRoutersForPhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVirtualBorderRoutersForPhysicalConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_virtual_border_routers_for_physical_connection(
        self,
        request: vpc_20160428_models.DescribeVirtualBorderRoutersForPhysicalConnectionRequest,
    ) -> vpc_20160428_models.DescribeVirtualBorderRoutersForPhysicalConnectionResponse:
        """
        @summary Queries the virtual border routers (VBRs) that are associated with an Express Connect circuit. The VBRs can be created by the owner of the Express Connect circuit and by other Alibaba Cloud accounts.
        
        @param request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest
        @return: DescribeVirtualBorderRoutersForPhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_virtual_border_routers_for_physical_connection_with_options(request, runtime)

    async def describe_virtual_border_routers_for_physical_connection_async(
        self,
        request: vpc_20160428_models.DescribeVirtualBorderRoutersForPhysicalConnectionRequest,
    ) -> vpc_20160428_models.DescribeVirtualBorderRoutersForPhysicalConnectionResponse:
        """
        @summary Queries the virtual border routers (VBRs) that are associated with an Express Connect circuit. The VBRs can be created by the owner of the Express Connect circuit and by other Alibaba Cloud accounts.
        
        @param request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest
        @return: DescribeVirtualBorderRoutersForPhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_virtual_border_routers_for_physical_connection_with_options_async(request, runtime)

    def describe_vpc_attribute_with_options(
        self,
        request: vpc_20160428_models.DescribeVpcAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpcAttributeResponse:
        """
        @summary Queries the configuration of a virtual private cloud (VPC).
        
        @param request: DescribeVpcAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpcAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.is_default):
            query['IsDefault'] = request.is_default
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpcAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpcAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vpc_attribute_with_options_async(
        self,
        request: vpc_20160428_models.DescribeVpcAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpcAttributeResponse:
        """
        @summary Queries the configuration of a virtual private cloud (VPC).
        
        @param request: DescribeVpcAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpcAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.is_default):
            query['IsDefault'] = request.is_default
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpcAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpcAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vpc_attribute(
        self,
        request: vpc_20160428_models.DescribeVpcAttributeRequest,
    ) -> vpc_20160428_models.DescribeVpcAttributeResponse:
        """
        @summary Queries the configuration of a virtual private cloud (VPC).
        
        @param request: DescribeVpcAttributeRequest
        @return: DescribeVpcAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vpc_attribute_with_options(request, runtime)

    async def describe_vpc_attribute_async(
        self,
        request: vpc_20160428_models.DescribeVpcAttributeRequest,
    ) -> vpc_20160428_models.DescribeVpcAttributeResponse:
        """
        @summary Queries the configuration of a virtual private cloud (VPC).
        
        @param request: DescribeVpcAttributeRequest
        @return: DescribeVpcAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vpc_attribute_with_options_async(request, runtime)

    def describe_vpcs_with_options(
        self,
        request: vpc_20160428_models.DescribeVpcsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpcsResponse:
        """
        @summary Queries virtual private clouds (VPCs).
        
        @param request: DescribeVpcsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpcsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dhcp_options_set_id):
            query['DhcpOptionsSetId'] = request.dhcp_options_set_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.enable_ipv_6):
            query['EnableIpv6'] = request.enable_ipv_6
        if not UtilClient.is_unset(request.is_default):
            query['IsDefault'] = request.is_default
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.vpc_name):
            query['VpcName'] = request.vpc_name
        if not UtilClient.is_unset(request.vpc_owner_id):
            query['VpcOwnerId'] = request.vpc_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpcs',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpcsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vpcs_with_options_async(
        self,
        request: vpc_20160428_models.DescribeVpcsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpcsResponse:
        """
        @summary Queries virtual private clouds (VPCs).
        
        @param request: DescribeVpcsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpcsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dhcp_options_set_id):
            query['DhcpOptionsSetId'] = request.dhcp_options_set_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.enable_ipv_6):
            query['EnableIpv6'] = request.enable_ipv_6
        if not UtilClient.is_unset(request.is_default):
            query['IsDefault'] = request.is_default
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.vpc_name):
            query['VpcName'] = request.vpc_name
        if not UtilClient.is_unset(request.vpc_owner_id):
            query['VpcOwnerId'] = request.vpc_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpcs',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpcsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vpcs(
        self,
        request: vpc_20160428_models.DescribeVpcsRequest,
    ) -> vpc_20160428_models.DescribeVpcsResponse:
        """
        @summary Queries virtual private clouds (VPCs).
        
        @param request: DescribeVpcsRequest
        @return: DescribeVpcsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vpcs_with_options(request, runtime)

    async def describe_vpcs_async(
        self,
        request: vpc_20160428_models.DescribeVpcsRequest,
    ) -> vpc_20160428_models.DescribeVpcsResponse:
        """
        @summary Queries virtual private clouds (VPCs).
        
        @param request: DescribeVpcsRequest
        @return: DescribeVpcsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vpcs_with_options_async(request, runtime)

    def describe_vpn_attachments_with_options(
        self,
        request: vpc_20160428_models.DescribeVpnAttachmentsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnAttachmentsResponse:
        """
        @summary Queries the IPsec-VPN connections associated with a transit router.
        
        @param request: DescribeVpnAttachmentsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnAttachmentsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.attach_type):
            query['AttachType'] = request.attach_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnAttachments',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnAttachmentsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vpn_attachments_with_options_async(
        self,
        request: vpc_20160428_models.DescribeVpnAttachmentsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnAttachmentsResponse:
        """
        @summary Queries the IPsec-VPN connections associated with a transit router.
        
        @param request: DescribeVpnAttachmentsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnAttachmentsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.attach_type):
            query['AttachType'] = request.attach_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnAttachments',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnAttachmentsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vpn_attachments(
        self,
        request: vpc_20160428_models.DescribeVpnAttachmentsRequest,
    ) -> vpc_20160428_models.DescribeVpnAttachmentsResponse:
        """
        @summary Queries the IPsec-VPN connections associated with a transit router.
        
        @param request: DescribeVpnAttachmentsRequest
        @return: DescribeVpnAttachmentsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vpn_attachments_with_options(request, runtime)

    async def describe_vpn_attachments_async(
        self,
        request: vpc_20160428_models.DescribeVpnAttachmentsRequest,
    ) -> vpc_20160428_models.DescribeVpnAttachmentsResponse:
        """
        @summary Queries the IPsec-VPN connections associated with a transit router.
        
        @param request: DescribeVpnAttachmentsRequest
        @return: DescribeVpnAttachmentsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vpn_attachments_with_options_async(request, runtime)

    def describe_vpn_connection_with_options(
        self,
        request: vpc_20160428_models.DescribeVpnConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnConnectionResponse:
        """
        @summary Queries the detailed information about an IPsec-VPN connection.
        
        @param request: DescribeVpnConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vpn_connection_with_options_async(
        self,
        request: vpc_20160428_models.DescribeVpnConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnConnectionResponse:
        """
        @summary Queries the detailed information about an IPsec-VPN connection.
        
        @param request: DescribeVpnConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vpn_connection(
        self,
        request: vpc_20160428_models.DescribeVpnConnectionRequest,
    ) -> vpc_20160428_models.DescribeVpnConnectionResponse:
        """
        @summary Queries the detailed information about an IPsec-VPN connection.
        
        @param request: DescribeVpnConnectionRequest
        @return: DescribeVpnConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vpn_connection_with_options(request, runtime)

    async def describe_vpn_connection_async(
        self,
        request: vpc_20160428_models.DescribeVpnConnectionRequest,
    ) -> vpc_20160428_models.DescribeVpnConnectionResponse:
        """
        @summary Queries the detailed information about an IPsec-VPN connection.
        
        @param request: DescribeVpnConnectionRequest
        @return: DescribeVpnConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vpn_connection_with_options_async(request, runtime)

    def describe_vpn_connection_logs_with_options(
        self,
        request: vpc_20160428_models.DescribeVpnConnectionLogsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnConnectionLogsResponse:
        """
        @summary Queries logs of IPsec-VPN connections.
        
        @param request: DescribeVpnConnectionLogsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnConnectionLogsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.from_):
            query['From'] = request.from_
        if not UtilClient.is_unset(request.minute_period):
            query['MinutePeriod'] = request.minute_period
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.to):
            query['To'] = request.to
        if not UtilClient.is_unset(request.tunnel_id):
            query['TunnelId'] = request.tunnel_id
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnConnectionLogs',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnConnectionLogsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vpn_connection_logs_with_options_async(
        self,
        request: vpc_20160428_models.DescribeVpnConnectionLogsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnConnectionLogsResponse:
        """
        @summary Queries logs of IPsec-VPN connections.
        
        @param request: DescribeVpnConnectionLogsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnConnectionLogsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.from_):
            query['From'] = request.from_
        if not UtilClient.is_unset(request.minute_period):
            query['MinutePeriod'] = request.minute_period
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.to):
            query['To'] = request.to
        if not UtilClient.is_unset(request.tunnel_id):
            query['TunnelId'] = request.tunnel_id
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnConnectionLogs',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnConnectionLogsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vpn_connection_logs(
        self,
        request: vpc_20160428_models.DescribeVpnConnectionLogsRequest,
    ) -> vpc_20160428_models.DescribeVpnConnectionLogsResponse:
        """
        @summary Queries logs of IPsec-VPN connections.
        
        @param request: DescribeVpnConnectionLogsRequest
        @return: DescribeVpnConnectionLogsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vpn_connection_logs_with_options(request, runtime)

    async def describe_vpn_connection_logs_async(
        self,
        request: vpc_20160428_models.DescribeVpnConnectionLogsRequest,
    ) -> vpc_20160428_models.DescribeVpnConnectionLogsResponse:
        """
        @summary Queries logs of IPsec-VPN connections.
        
        @param request: DescribeVpnConnectionLogsRequest
        @return: DescribeVpnConnectionLogsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vpn_connection_logs_with_options_async(request, runtime)

    def describe_vpn_connections_with_options(
        self,
        request: vpc_20160428_models.DescribeVpnConnectionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnConnectionsResponse:
        """
        @summary Queries IPsec-VPN connections.
        
        @param request: DescribeVpnConnectionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnConnectionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.customer_gateway_id):
            query['CustomerGatewayId'] = request.customer_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnConnections',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnConnectionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vpn_connections_with_options_async(
        self,
        request: vpc_20160428_models.DescribeVpnConnectionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnConnectionsResponse:
        """
        @summary Queries IPsec-VPN connections.
        
        @param request: DescribeVpnConnectionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnConnectionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.customer_gateway_id):
            query['CustomerGatewayId'] = request.customer_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnConnections',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnConnectionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vpn_connections(
        self,
        request: vpc_20160428_models.DescribeVpnConnectionsRequest,
    ) -> vpc_20160428_models.DescribeVpnConnectionsResponse:
        """
        @summary Queries IPsec-VPN connections.
        
        @param request: DescribeVpnConnectionsRequest
        @return: DescribeVpnConnectionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vpn_connections_with_options(request, runtime)

    async def describe_vpn_connections_async(
        self,
        request: vpc_20160428_models.DescribeVpnConnectionsRequest,
    ) -> vpc_20160428_models.DescribeVpnConnectionsResponse:
        """
        @summary Queries IPsec-VPN connections.
        
        @param request: DescribeVpnConnectionsRequest
        @return: DescribeVpnConnectionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vpn_connections_with_options_async(request, runtime)

    def describe_vpn_cross_account_authorizations_with_options(
        self,
        request: vpc_20160428_models.DescribeVpnCrossAccountAuthorizationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnCrossAccountAuthorizationsResponse:
        """
        @summary Queries the cross-account authorization information about an IPsec-VPN connection.
        
        @param request: DescribeVpnCrossAccountAuthorizationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnCrossAccountAuthorizationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnCrossAccountAuthorizations',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnCrossAccountAuthorizationsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vpn_cross_account_authorizations_with_options_async(
        self,
        request: vpc_20160428_models.DescribeVpnCrossAccountAuthorizationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnCrossAccountAuthorizationsResponse:
        """
        @summary Queries the cross-account authorization information about an IPsec-VPN connection.
        
        @param request: DescribeVpnCrossAccountAuthorizationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnCrossAccountAuthorizationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnCrossAccountAuthorizations',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnCrossAccountAuthorizationsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vpn_cross_account_authorizations(
        self,
        request: vpc_20160428_models.DescribeVpnCrossAccountAuthorizationsRequest,
    ) -> vpc_20160428_models.DescribeVpnCrossAccountAuthorizationsResponse:
        """
        @summary Queries the cross-account authorization information about an IPsec-VPN connection.
        
        @param request: DescribeVpnCrossAccountAuthorizationsRequest
        @return: DescribeVpnCrossAccountAuthorizationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vpn_cross_account_authorizations_with_options(request, runtime)

    async def describe_vpn_cross_account_authorizations_async(
        self,
        request: vpc_20160428_models.DescribeVpnCrossAccountAuthorizationsRequest,
    ) -> vpc_20160428_models.DescribeVpnCrossAccountAuthorizationsResponse:
        """
        @summary Queries the cross-account authorization information about an IPsec-VPN connection.
        
        @param request: DescribeVpnCrossAccountAuthorizationsRequest
        @return: DescribeVpnCrossAccountAuthorizationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vpn_cross_account_authorizations_with_options_async(request, runtime)

    def describe_vpn_gateway_with_options(
        self,
        request: vpc_20160428_models.DescribeVpnGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnGatewayResponse:
        """
        @summary Queries the detailed information about a VPN gateway.
        
        @param request: DescribeVpnGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.include_reservation_data):
            query['IncludeReservationData'] = request.include_reservation_data
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnGatewayResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vpn_gateway_with_options_async(
        self,
        request: vpc_20160428_models.DescribeVpnGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnGatewayResponse:
        """
        @summary Queries the detailed information about a VPN gateway.
        
        @param request: DescribeVpnGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.include_reservation_data):
            query['IncludeReservationData'] = request.include_reservation_data
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnGatewayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vpn_gateway(
        self,
        request: vpc_20160428_models.DescribeVpnGatewayRequest,
    ) -> vpc_20160428_models.DescribeVpnGatewayResponse:
        """
        @summary Queries the detailed information about a VPN gateway.
        
        @param request: DescribeVpnGatewayRequest
        @return: DescribeVpnGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vpn_gateway_with_options(request, runtime)

    async def describe_vpn_gateway_async(
        self,
        request: vpc_20160428_models.DescribeVpnGatewayRequest,
    ) -> vpc_20160428_models.DescribeVpnGatewayResponse:
        """
        @summary Queries the detailed information about a VPN gateway.
        
        @param request: DescribeVpnGatewayRequest
        @return: DescribeVpnGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vpn_gateway_with_options_async(request, runtime)

    def describe_vpn_gateway_available_zones_with_options(
        self,
        request: vpc_20160428_models.DescribeVpnGatewayAvailableZonesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnGatewayAvailableZonesResponse:
        """
        @summary VPNIPSecCEN
        
        @param request: DescribeVpnGatewayAvailableZonesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnGatewayAvailableZonesResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnGatewayAvailableZones',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnGatewayAvailableZonesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vpn_gateway_available_zones_with_options_async(
        self,
        request: vpc_20160428_models.DescribeVpnGatewayAvailableZonesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnGatewayAvailableZonesResponse:
        """
        @summary VPNIPSecCEN
        
        @param request: DescribeVpnGatewayAvailableZonesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnGatewayAvailableZonesResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnGatewayAvailableZones',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnGatewayAvailableZonesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vpn_gateway_available_zones(
        self,
        request: vpc_20160428_models.DescribeVpnGatewayAvailableZonesRequest,
    ) -> vpc_20160428_models.DescribeVpnGatewayAvailableZonesResponse:
        """
        @summary VPNIPSecCEN
        
        @param request: DescribeVpnGatewayAvailableZonesRequest
        @return: DescribeVpnGatewayAvailableZonesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vpn_gateway_available_zones_with_options(request, runtime)

    async def describe_vpn_gateway_available_zones_async(
        self,
        request: vpc_20160428_models.DescribeVpnGatewayAvailableZonesRequest,
    ) -> vpc_20160428_models.DescribeVpnGatewayAvailableZonesResponse:
        """
        @summary VPNIPSecCEN
        
        @param request: DescribeVpnGatewayAvailableZonesRequest
        @return: DescribeVpnGatewayAvailableZonesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vpn_gateway_available_zones_with_options_async(request, runtime)

    def describe_vpn_gateways_with_options(
        self,
        request: vpc_20160428_models.DescribeVpnGatewaysRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnGatewaysResponse:
        """
        @summary Queries VPN gateways in a region.
        
        @param request: DescribeVpnGatewaysRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnGatewaysResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.business_status):
            query['BusinessStatus'] = request.business_status
        if not UtilClient.is_unset(request.include_reservation_data):
            query['IncludeReservationData'] = request.include_reservation_data
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnGateways',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnGatewaysResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vpn_gateways_with_options_async(
        self,
        request: vpc_20160428_models.DescribeVpnGatewaysRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnGatewaysResponse:
        """
        @summary Queries VPN gateways in a region.
        
        @param request: DescribeVpnGatewaysRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnGatewaysResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.business_status):
            query['BusinessStatus'] = request.business_status
        if not UtilClient.is_unset(request.include_reservation_data):
            query['IncludeReservationData'] = request.include_reservation_data
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnGateways',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnGatewaysResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vpn_gateways(
        self,
        request: vpc_20160428_models.DescribeVpnGatewaysRequest,
    ) -> vpc_20160428_models.DescribeVpnGatewaysResponse:
        """
        @summary Queries VPN gateways in a region.
        
        @param request: DescribeVpnGatewaysRequest
        @return: DescribeVpnGatewaysResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vpn_gateways_with_options(request, runtime)

    async def describe_vpn_gateways_async(
        self,
        request: vpc_20160428_models.DescribeVpnGatewaysRequest,
    ) -> vpc_20160428_models.DescribeVpnGatewaysResponse:
        """
        @summary Queries VPN gateways in a region.
        
        @param request: DescribeVpnGatewaysRequest
        @return: DescribeVpnGatewaysResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vpn_gateways_with_options_async(request, runtime)

    def describe_vpn_pbr_route_entries_with_options(
        self,
        request: vpc_20160428_models.DescribeVpnPbrRouteEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnPbrRouteEntriesResponse:
        """
        @summary Queries policy-based routes configured for a VPN gateway.
        
        @param request: DescribeVpnPbrRouteEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnPbrRouteEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnPbrRouteEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnPbrRouteEntriesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vpn_pbr_route_entries_with_options_async(
        self,
        request: vpc_20160428_models.DescribeVpnPbrRouteEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnPbrRouteEntriesResponse:
        """
        @summary Queries policy-based routes configured for a VPN gateway.
        
        @param request: DescribeVpnPbrRouteEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnPbrRouteEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnPbrRouteEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnPbrRouteEntriesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vpn_pbr_route_entries(
        self,
        request: vpc_20160428_models.DescribeVpnPbrRouteEntriesRequest,
    ) -> vpc_20160428_models.DescribeVpnPbrRouteEntriesResponse:
        """
        @summary Queries policy-based routes configured for a VPN gateway.
        
        @param request: DescribeVpnPbrRouteEntriesRequest
        @return: DescribeVpnPbrRouteEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vpn_pbr_route_entries_with_options(request, runtime)

    async def describe_vpn_pbr_route_entries_async(
        self,
        request: vpc_20160428_models.DescribeVpnPbrRouteEntriesRequest,
    ) -> vpc_20160428_models.DescribeVpnPbrRouteEntriesResponse:
        """
        @summary Queries policy-based routes configured for a VPN gateway.
        
        @param request: DescribeVpnPbrRouteEntriesRequest
        @return: DescribeVpnPbrRouteEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vpn_pbr_route_entries_with_options_async(request, runtime)

    def describe_vpn_route_entries_with_options(
        self,
        request: vpc_20160428_models.DescribeVpnRouteEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnRouteEntriesResponse:
        """
        @summary Queries destination-based and BGP route entries of a VPN gateway.
        
        @param request: DescribeVpnRouteEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnRouteEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_entry_type):
            query['RouteEntryType'] = request.route_entry_type
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnRouteEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnRouteEntriesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vpn_route_entries_with_options_async(
        self,
        request: vpc_20160428_models.DescribeVpnRouteEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnRouteEntriesResponse:
        """
        @summary Queries destination-based and BGP route entries of a VPN gateway.
        
        @param request: DescribeVpnRouteEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnRouteEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_entry_type):
            query['RouteEntryType'] = request.route_entry_type
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnRouteEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnRouteEntriesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vpn_route_entries(
        self,
        request: vpc_20160428_models.DescribeVpnRouteEntriesRequest,
    ) -> vpc_20160428_models.DescribeVpnRouteEntriesResponse:
        """
        @summary Queries destination-based and BGP route entries of a VPN gateway.
        
        @param request: DescribeVpnRouteEntriesRequest
        @return: DescribeVpnRouteEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vpn_route_entries_with_options(request, runtime)

    async def describe_vpn_route_entries_async(
        self,
        request: vpc_20160428_models.DescribeVpnRouteEntriesRequest,
    ) -> vpc_20160428_models.DescribeVpnRouteEntriesResponse:
        """
        @summary Queries destination-based and BGP route entries of a VPN gateway.
        
        @param request: DescribeVpnRouteEntriesRequest
        @return: DescribeVpnRouteEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vpn_route_entries_with_options_async(request, runtime)

    def describe_vpn_ssl_server_logs_with_options(
        self,
        request: vpc_20160428_models.DescribeVpnSslServerLogsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnSslServerLogsResponse:
        """
        @param request: DescribeVpnSslServerLogsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnSslServerLogsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.from_):
            query['From'] = request.from_
        if not UtilClient.is_unset(request.minute_period):
            query['MinutePeriod'] = request.minute_period
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.ssl_vpn_client_cert_id):
            query['SslVpnClientCertId'] = request.ssl_vpn_client_cert_id
        if not UtilClient.is_unset(request.to):
            query['To'] = request.to
        if not UtilClient.is_unset(request.vpn_ssl_server_id):
            query['VpnSslServerId'] = request.vpn_ssl_server_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnSslServerLogs',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnSslServerLogsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vpn_ssl_server_logs_with_options_async(
        self,
        request: vpc_20160428_models.DescribeVpnSslServerLogsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeVpnSslServerLogsResponse:
        """
        @param request: DescribeVpnSslServerLogsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVpnSslServerLogsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.from_):
            query['From'] = request.from_
        if not UtilClient.is_unset(request.minute_period):
            query['MinutePeriod'] = request.minute_period
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.ssl_vpn_client_cert_id):
            query['SslVpnClientCertId'] = request.ssl_vpn_client_cert_id
        if not UtilClient.is_unset(request.to):
            query['To'] = request.to
        if not UtilClient.is_unset(request.vpn_ssl_server_id):
            query['VpnSslServerId'] = request.vpn_ssl_server_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVpnSslServerLogs',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeVpnSslServerLogsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vpn_ssl_server_logs(
        self,
        request: vpc_20160428_models.DescribeVpnSslServerLogsRequest,
    ) -> vpc_20160428_models.DescribeVpnSslServerLogsResponse:
        """
        @param request: DescribeVpnSslServerLogsRequest
        @return: DescribeVpnSslServerLogsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vpn_ssl_server_logs_with_options(request, runtime)

    async def describe_vpn_ssl_server_logs_async(
        self,
        request: vpc_20160428_models.DescribeVpnSslServerLogsRequest,
    ) -> vpc_20160428_models.DescribeVpnSslServerLogsResponse:
        """
        @param request: DescribeVpnSslServerLogsRequest
        @return: DescribeVpnSslServerLogsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vpn_ssl_server_logs_with_options_async(request, runtime)

    def describe_zones_with_options(
        self,
        request: vpc_20160428_models.DescribeZonesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeZonesResponse:
        """
        @summary Queries zones in a region.
        
        @param request: DescribeZonesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeZonesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.accept_language):
            query['AcceptLanguage'] = request.accept_language
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.zone_type):
            query['ZoneType'] = request.zone_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeZones',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeZonesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_zones_with_options_async(
        self,
        request: vpc_20160428_models.DescribeZonesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DescribeZonesResponse:
        """
        @summary Queries zones in a region.
        
        @param request: DescribeZonesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeZonesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.accept_language):
            query['AcceptLanguage'] = request.accept_language
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.zone_type):
            query['ZoneType'] = request.zone_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeZones',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DescribeZonesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_zones(
        self,
        request: vpc_20160428_models.DescribeZonesRequest,
    ) -> vpc_20160428_models.DescribeZonesResponse:
        """
        @summary Queries zones in a region.
        
        @param request: DescribeZonesRequest
        @return: DescribeZonesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_zones_with_options(request, runtime)

    async def describe_zones_async(
        self,
        request: vpc_20160428_models.DescribeZonesRequest,
    ) -> vpc_20160428_models.DescribeZonesResponse:
        """
        @summary Queries zones in a region.
        
        @param request: DescribeZonesRequest
        @return: DescribeZonesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_zones_with_options_async(request, runtime)

    def detach_dhcp_options_set_from_vpc_with_options(
        self,
        request: vpc_20160428_models.DetachDhcpOptionsSetFromVpcRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DetachDhcpOptionsSetFromVpcResponse:
        """
        @summary Disassociates a DHCP options set from a virtual private cloud (VPC).
        
        @description ## [](#)Description
        **DetachDhcpOptionsSetFromVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task.
        If the DHCP options set is in the **Pending** state, the DHCP options set is being disassociated.
        If the DHCP options set is in the **UnUsed** state, the DHCP options set is disassociated.
        You cannot repeatedly call the **DetachDhcpOptionsSetFromVpc** operation to disassociate a DHCP options set from a VPC within the specified period of time.
        
        @param request: DetachDhcpOptionsSetFromVpcRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DetachDhcpOptionsSetFromVpcResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dhcp_options_set_id):
            query['DhcpOptionsSetId'] = request.dhcp_options_set_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DetachDhcpOptionsSetFromVpc',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DetachDhcpOptionsSetFromVpcResponse(),
            self.call_api(params, req, runtime)
        )

    async def detach_dhcp_options_set_from_vpc_with_options_async(
        self,
        request: vpc_20160428_models.DetachDhcpOptionsSetFromVpcRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DetachDhcpOptionsSetFromVpcResponse:
        """
        @summary Disassociates a DHCP options set from a virtual private cloud (VPC).
        
        @description ## [](#)Description
        **DetachDhcpOptionsSetFromVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task.
        If the DHCP options set is in the **Pending** state, the DHCP options set is being disassociated.
        If the DHCP options set is in the **UnUsed** state, the DHCP options set is disassociated.
        You cannot repeatedly call the **DetachDhcpOptionsSetFromVpc** operation to disassociate a DHCP options set from a VPC within the specified period of time.
        
        @param request: DetachDhcpOptionsSetFromVpcRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DetachDhcpOptionsSetFromVpcResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dhcp_options_set_id):
            query['DhcpOptionsSetId'] = request.dhcp_options_set_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DetachDhcpOptionsSetFromVpc',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DetachDhcpOptionsSetFromVpcResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def detach_dhcp_options_set_from_vpc(
        self,
        request: vpc_20160428_models.DetachDhcpOptionsSetFromVpcRequest,
    ) -> vpc_20160428_models.DetachDhcpOptionsSetFromVpcResponse:
        """
        @summary Disassociates a DHCP options set from a virtual private cloud (VPC).
        
        @description ## [](#)Description
        **DetachDhcpOptionsSetFromVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task.
        If the DHCP options set is in the **Pending** state, the DHCP options set is being disassociated.
        If the DHCP options set is in the **UnUsed** state, the DHCP options set is disassociated.
        You cannot repeatedly call the **DetachDhcpOptionsSetFromVpc** operation to disassociate a DHCP options set from a VPC within the specified period of time.
        
        @param request: DetachDhcpOptionsSetFromVpcRequest
        @return: DetachDhcpOptionsSetFromVpcResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.detach_dhcp_options_set_from_vpc_with_options(request, runtime)

    async def detach_dhcp_options_set_from_vpc_async(
        self,
        request: vpc_20160428_models.DetachDhcpOptionsSetFromVpcRequest,
    ) -> vpc_20160428_models.DetachDhcpOptionsSetFromVpcResponse:
        """
        @summary Disassociates a DHCP options set from a virtual private cloud (VPC).
        
        @description ## [](#)Description
        **DetachDhcpOptionsSetFromVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task.
        If the DHCP options set is in the **Pending** state, the DHCP options set is being disassociated.
        If the DHCP options set is in the **UnUsed** state, the DHCP options set is disassociated.
        You cannot repeatedly call the **DetachDhcpOptionsSetFromVpc** operation to disassociate a DHCP options set from a VPC within the specified period of time.
        
        @param request: DetachDhcpOptionsSetFromVpcRequest
        @return: DetachDhcpOptionsSetFromVpcResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.detach_dhcp_options_set_from_vpc_with_options_async(request, runtime)

    def diagnose_vpn_connections_with_options(
        self,
        request: vpc_20160428_models.DiagnoseVpnConnectionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DiagnoseVpnConnectionsResponse:
        """
        @summary Diagnoses IPsec-VPN connections.
        
        @description    If the IPsec-VPN connection is in single-tunnel mode, the request parameter `VpnConnectionIds` is required when you call the **DiagnoseVpnConnections** operation.
        If the IPsec-VPN connection is in dual-tunnel mode, the request parameter `TunnelIds` is required when you call the **DiagnoseVpnConnections** operation.
        After you call the **DiagnoseVpnConnections** operation, if the current IPsec-VPN connection is faulty, the operation returns the corresponding error code (**FailedReasonCode**) and log (**SourceLog**). You can troubleshoot based on the error code and log information. For more information, see [Common errors and troubleshooting methods for IPsec-VPN connections](https://help.aliyun.com/document_detail/477862.html).
        
        @param request: DiagnoseVpnConnectionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DiagnoseVpnConnectionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tunnel_ids):
            query['TunnelIds'] = request.tunnel_ids
        if not UtilClient.is_unset(request.vpn_connection_ids):
            query['VpnConnectionIds'] = request.vpn_connection_ids
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DiagnoseVpnConnections',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DiagnoseVpnConnectionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def diagnose_vpn_connections_with_options_async(
        self,
        request: vpc_20160428_models.DiagnoseVpnConnectionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DiagnoseVpnConnectionsResponse:
        """
        @summary Diagnoses IPsec-VPN connections.
        
        @description    If the IPsec-VPN connection is in single-tunnel mode, the request parameter `VpnConnectionIds` is required when you call the **DiagnoseVpnConnections** operation.
        If the IPsec-VPN connection is in dual-tunnel mode, the request parameter `TunnelIds` is required when you call the **DiagnoseVpnConnections** operation.
        After you call the **DiagnoseVpnConnections** operation, if the current IPsec-VPN connection is faulty, the operation returns the corresponding error code (**FailedReasonCode**) and log (**SourceLog**). You can troubleshoot based on the error code and log information. For more information, see [Common errors and troubleshooting methods for IPsec-VPN connections](https://help.aliyun.com/document_detail/477862.html).
        
        @param request: DiagnoseVpnConnectionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DiagnoseVpnConnectionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tunnel_ids):
            query['TunnelIds'] = request.tunnel_ids
        if not UtilClient.is_unset(request.vpn_connection_ids):
            query['VpnConnectionIds'] = request.vpn_connection_ids
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DiagnoseVpnConnections',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DiagnoseVpnConnectionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def diagnose_vpn_connections(
        self,
        request: vpc_20160428_models.DiagnoseVpnConnectionsRequest,
    ) -> vpc_20160428_models.DiagnoseVpnConnectionsResponse:
        """
        @summary Diagnoses IPsec-VPN connections.
        
        @description    If the IPsec-VPN connection is in single-tunnel mode, the request parameter `VpnConnectionIds` is required when you call the **DiagnoseVpnConnections** operation.
        If the IPsec-VPN connection is in dual-tunnel mode, the request parameter `TunnelIds` is required when you call the **DiagnoseVpnConnections** operation.
        After you call the **DiagnoseVpnConnections** operation, if the current IPsec-VPN connection is faulty, the operation returns the corresponding error code (**FailedReasonCode**) and log (**SourceLog**). You can troubleshoot based on the error code and log information. For more information, see [Common errors and troubleshooting methods for IPsec-VPN connections](https://help.aliyun.com/document_detail/477862.html).
        
        @param request: DiagnoseVpnConnectionsRequest
        @return: DiagnoseVpnConnectionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.diagnose_vpn_connections_with_options(request, runtime)

    async def diagnose_vpn_connections_async(
        self,
        request: vpc_20160428_models.DiagnoseVpnConnectionsRequest,
    ) -> vpc_20160428_models.DiagnoseVpnConnectionsResponse:
        """
        @summary Diagnoses IPsec-VPN connections.
        
        @description    If the IPsec-VPN connection is in single-tunnel mode, the request parameter `VpnConnectionIds` is required when you call the **DiagnoseVpnConnections** operation.
        If the IPsec-VPN connection is in dual-tunnel mode, the request parameter `TunnelIds` is required when you call the **DiagnoseVpnConnections** operation.
        After you call the **DiagnoseVpnConnections** operation, if the current IPsec-VPN connection is faulty, the operation returns the corresponding error code (**FailedReasonCode**) and log (**SourceLog**). You can troubleshoot based on the error code and log information. For more information, see [Common errors and troubleshooting methods for IPsec-VPN connections](https://help.aliyun.com/document_detail/477862.html).
        
        @param request: DiagnoseVpnConnectionsRequest
        @return: DiagnoseVpnConnectionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.diagnose_vpn_connections_with_options_async(request, runtime)

    def diagnose_vpn_gateway_with_options(
        self,
        request: vpc_20160428_models.DiagnoseVpnGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DiagnoseVpnGatewayResponse:
        """
        @summary Diagnoses a VPN gateway.
        
        @description Only VPN gateways in specific regions support the quick diagnostics feature. For more information about the supported regions, see [Supported regions](https://help.aliyun.com/document_detail/430697.html).
        
        @param request: DiagnoseVpnGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DiagnoseVpnGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ipsec_extend_info):
            query['IPsecExtendInfo'] = request.ipsec_extend_info
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DiagnoseVpnGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DiagnoseVpnGatewayResponse(),
            self.call_api(params, req, runtime)
        )

    async def diagnose_vpn_gateway_with_options_async(
        self,
        request: vpc_20160428_models.DiagnoseVpnGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DiagnoseVpnGatewayResponse:
        """
        @summary Diagnoses a VPN gateway.
        
        @description Only VPN gateways in specific regions support the quick diagnostics feature. For more information about the supported regions, see [Supported regions](https://help.aliyun.com/document_detail/430697.html).
        
        @param request: DiagnoseVpnGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DiagnoseVpnGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ipsec_extend_info):
            query['IPsecExtendInfo'] = request.ipsec_extend_info
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DiagnoseVpnGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DiagnoseVpnGatewayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def diagnose_vpn_gateway(
        self,
        request: vpc_20160428_models.DiagnoseVpnGatewayRequest,
    ) -> vpc_20160428_models.DiagnoseVpnGatewayResponse:
        """
        @summary Diagnoses a VPN gateway.
        
        @description Only VPN gateways in specific regions support the quick diagnostics feature. For more information about the supported regions, see [Supported regions](https://help.aliyun.com/document_detail/430697.html).
        
        @param request: DiagnoseVpnGatewayRequest
        @return: DiagnoseVpnGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.diagnose_vpn_gateway_with_options(request, runtime)

    async def diagnose_vpn_gateway_async(
        self,
        request: vpc_20160428_models.DiagnoseVpnGatewayRequest,
    ) -> vpc_20160428_models.DiagnoseVpnGatewayResponse:
        """
        @summary Diagnoses a VPN gateway.
        
        @description Only VPN gateways in specific regions support the quick diagnostics feature. For more information about the supported regions, see [Supported regions](https://help.aliyun.com/document_detail/430697.html).
        
        @param request: DiagnoseVpnGatewayRequest
        @return: DiagnoseVpnGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.diagnose_vpn_gateway_with_options_async(request, runtime)

    def disable_nat_gateway_ecs_metric_with_options(
        self,
        request: vpc_20160428_models.DisableNatGatewayEcsMetricRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DisableNatGatewayEcsMetricResponse:
        """
        @summary Disables traffic monitoring for an Elastic Compute Service (ECS) instance.
        
        @param request: DisableNatGatewayEcsMetricRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableNatGatewayEcsMetricResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableNatGatewayEcsMetric',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DisableNatGatewayEcsMetricResponse(),
            self.call_api(params, req, runtime)
        )

    async def disable_nat_gateway_ecs_metric_with_options_async(
        self,
        request: vpc_20160428_models.DisableNatGatewayEcsMetricRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DisableNatGatewayEcsMetricResponse:
        """
        @summary Disables traffic monitoring for an Elastic Compute Service (ECS) instance.
        
        @param request: DisableNatGatewayEcsMetricRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableNatGatewayEcsMetricResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableNatGatewayEcsMetric',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DisableNatGatewayEcsMetricResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def disable_nat_gateway_ecs_metric(
        self,
        request: vpc_20160428_models.DisableNatGatewayEcsMetricRequest,
    ) -> vpc_20160428_models.DisableNatGatewayEcsMetricResponse:
        """
        @summary Disables traffic monitoring for an Elastic Compute Service (ECS) instance.
        
        @param request: DisableNatGatewayEcsMetricRequest
        @return: DisableNatGatewayEcsMetricResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.disable_nat_gateway_ecs_metric_with_options(request, runtime)

    async def disable_nat_gateway_ecs_metric_async(
        self,
        request: vpc_20160428_models.DisableNatGatewayEcsMetricRequest,
    ) -> vpc_20160428_models.DisableNatGatewayEcsMetricResponse:
        """
        @summary Disables traffic monitoring for an Elastic Compute Service (ECS) instance.
        
        @param request: DisableNatGatewayEcsMetricRequest
        @return: DisableNatGatewayEcsMetricResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.disable_nat_gateway_ecs_metric_with_options_async(request, runtime)

    def disable_vpc_classic_link_with_options(
        self,
        request: vpc_20160428_models.DisableVpcClassicLinkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DisableVpcClassicLinkResponse:
        """
        @summary Disables ClassicLink for a virtual private cloud (VPC).
        
        @param request: DisableVpcClassicLinkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableVpcClassicLinkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableVpcClassicLink',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DisableVpcClassicLinkResponse(),
            self.call_api(params, req, runtime)
        )

    async def disable_vpc_classic_link_with_options_async(
        self,
        request: vpc_20160428_models.DisableVpcClassicLinkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DisableVpcClassicLinkResponse:
        """
        @summary Disables ClassicLink for a virtual private cloud (VPC).
        
        @param request: DisableVpcClassicLinkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableVpcClassicLinkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableVpcClassicLink',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DisableVpcClassicLinkResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def disable_vpc_classic_link(
        self,
        request: vpc_20160428_models.DisableVpcClassicLinkRequest,
    ) -> vpc_20160428_models.DisableVpcClassicLinkResponse:
        """
        @summary Disables ClassicLink for a virtual private cloud (VPC).
        
        @param request: DisableVpcClassicLinkRequest
        @return: DisableVpcClassicLinkResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.disable_vpc_classic_link_with_options(request, runtime)

    async def disable_vpc_classic_link_async(
        self,
        request: vpc_20160428_models.DisableVpcClassicLinkRequest,
    ) -> vpc_20160428_models.DisableVpcClassicLinkResponse:
        """
        @summary Disables ClassicLink for a virtual private cloud (VPC).
        
        @param request: DisableVpcClassicLinkRequest
        @return: DisableVpcClassicLinkResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.disable_vpc_classic_link_with_options_async(request, runtime)

    def dissociate_route_table_from_gateway_with_options(
        self,
        request: vpc_20160428_models.DissociateRouteTableFromGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DissociateRouteTableFromGatewayResponse:
        """
        @summary Disassociates a gateway route table from an IPv4 gateway.
        
        @param request: DissociateRouteTableFromGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DissociateRouteTableFromGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.gateway_id):
            query['GatewayId'] = request.gateway_id
        if not UtilClient.is_unset(request.gateway_type):
            query['GatewayType'] = request.gateway_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DissociateRouteTableFromGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DissociateRouteTableFromGatewayResponse(),
            self.call_api(params, req, runtime)
        )

    async def dissociate_route_table_from_gateway_with_options_async(
        self,
        request: vpc_20160428_models.DissociateRouteTableFromGatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DissociateRouteTableFromGatewayResponse:
        """
        @summary Disassociates a gateway route table from an IPv4 gateway.
        
        @param request: DissociateRouteTableFromGatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DissociateRouteTableFromGatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.gateway_id):
            query['GatewayId'] = request.gateway_id
        if not UtilClient.is_unset(request.gateway_type):
            query['GatewayType'] = request.gateway_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DissociateRouteTableFromGateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DissociateRouteTableFromGatewayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def dissociate_route_table_from_gateway(
        self,
        request: vpc_20160428_models.DissociateRouteTableFromGatewayRequest,
    ) -> vpc_20160428_models.DissociateRouteTableFromGatewayResponse:
        """
        @summary Disassociates a gateway route table from an IPv4 gateway.
        
        @param request: DissociateRouteTableFromGatewayRequest
        @return: DissociateRouteTableFromGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.dissociate_route_table_from_gateway_with_options(request, runtime)

    async def dissociate_route_table_from_gateway_async(
        self,
        request: vpc_20160428_models.DissociateRouteTableFromGatewayRequest,
    ) -> vpc_20160428_models.DissociateRouteTableFromGatewayResponse:
        """
        @summary Disassociates a gateway route table from an IPv4 gateway.
        
        @param request: DissociateRouteTableFromGatewayRequest
        @return: DissociateRouteTableFromGatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.dissociate_route_table_from_gateway_with_options_async(request, runtime)

    def dissociate_route_tables_from_vpc_gateway_endpoint_with_options(
        self,
        request: vpc_20160428_models.DissociateRouteTablesFromVpcGatewayEndpointRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DissociateRouteTablesFromVpcGatewayEndpointResponse:
        """
        @summary Disassociates a gateway endpoint from a route table.
        
        @param request: DissociateRouteTablesFromVpcGatewayEndpointRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DissociateRouteTablesFromVpcGatewayEndpointResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.endpoint_id):
            query['EndpointId'] = request.endpoint_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_ids):
            query['RouteTableIds'] = request.route_table_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DissociateRouteTablesFromVpcGatewayEndpoint',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DissociateRouteTablesFromVpcGatewayEndpointResponse(),
            self.call_api(params, req, runtime)
        )

    async def dissociate_route_tables_from_vpc_gateway_endpoint_with_options_async(
        self,
        request: vpc_20160428_models.DissociateRouteTablesFromVpcGatewayEndpointRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DissociateRouteTablesFromVpcGatewayEndpointResponse:
        """
        @summary Disassociates a gateway endpoint from a route table.
        
        @param request: DissociateRouteTablesFromVpcGatewayEndpointRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DissociateRouteTablesFromVpcGatewayEndpointResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.endpoint_id):
            query['EndpointId'] = request.endpoint_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_ids):
            query['RouteTableIds'] = request.route_table_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DissociateRouteTablesFromVpcGatewayEndpoint',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DissociateRouteTablesFromVpcGatewayEndpointResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def dissociate_route_tables_from_vpc_gateway_endpoint(
        self,
        request: vpc_20160428_models.DissociateRouteTablesFromVpcGatewayEndpointRequest,
    ) -> vpc_20160428_models.DissociateRouteTablesFromVpcGatewayEndpointResponse:
        """
        @summary Disassociates a gateway endpoint from a route table.
        
        @param request: DissociateRouteTablesFromVpcGatewayEndpointRequest
        @return: DissociateRouteTablesFromVpcGatewayEndpointResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.dissociate_route_tables_from_vpc_gateway_endpoint_with_options(request, runtime)

    async def dissociate_route_tables_from_vpc_gateway_endpoint_async(
        self,
        request: vpc_20160428_models.DissociateRouteTablesFromVpcGatewayEndpointRequest,
    ) -> vpc_20160428_models.DissociateRouteTablesFromVpcGatewayEndpointResponse:
        """
        @summary Disassociates a gateway endpoint from a route table.
        
        @param request: DissociateRouteTablesFromVpcGatewayEndpointRequest
        @return: DissociateRouteTablesFromVpcGatewayEndpointResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.dissociate_route_tables_from_vpc_gateway_endpoint_with_options_async(request, runtime)

    def dissociate_vpn_gateway_with_certificate_with_options(
        self,
        request: vpc_20160428_models.DissociateVpnGatewayWithCertificateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DissociateVpnGatewayWithCertificateResponse:
        """
        @summary Disassociates a certificate from a VPN gateway.
        
        @description    **DissociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status the task.
        If the VPN gateway is in the **updating** state, the SSL certificate is being disassociated from the VPN gateway.
        If the VPN gateway is in the **active** state, the SSL certificate is disassociated from the VPN gateway.
        You cannot repeatedly call **DissociateVpnGatewayWithCertificate** within a specific period of time.
        
        @param request: DissociateVpnGatewayWithCertificateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DissociateVpnGatewayWithCertificateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.certificate_id):
            query['CertificateId'] = request.certificate_id
        if not UtilClient.is_unset(request.certificate_type):
            query['CertificateType'] = request.certificate_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DissociateVpnGatewayWithCertificate',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DissociateVpnGatewayWithCertificateResponse(),
            self.call_api(params, req, runtime)
        )

    async def dissociate_vpn_gateway_with_certificate_with_options_async(
        self,
        request: vpc_20160428_models.DissociateVpnGatewayWithCertificateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DissociateVpnGatewayWithCertificateResponse:
        """
        @summary Disassociates a certificate from a VPN gateway.
        
        @description    **DissociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status the task.
        If the VPN gateway is in the **updating** state, the SSL certificate is being disassociated from the VPN gateway.
        If the VPN gateway is in the **active** state, the SSL certificate is disassociated from the VPN gateway.
        You cannot repeatedly call **DissociateVpnGatewayWithCertificate** within a specific period of time.
        
        @param request: DissociateVpnGatewayWithCertificateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DissociateVpnGatewayWithCertificateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.certificate_id):
            query['CertificateId'] = request.certificate_id
        if not UtilClient.is_unset(request.certificate_type):
            query['CertificateType'] = request.certificate_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DissociateVpnGatewayWithCertificate',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DissociateVpnGatewayWithCertificateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def dissociate_vpn_gateway_with_certificate(
        self,
        request: vpc_20160428_models.DissociateVpnGatewayWithCertificateRequest,
    ) -> vpc_20160428_models.DissociateVpnGatewayWithCertificateResponse:
        """
        @summary Disassociates a certificate from a VPN gateway.
        
        @description    **DissociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status the task.
        If the VPN gateway is in the **updating** state, the SSL certificate is being disassociated from the VPN gateway.
        If the VPN gateway is in the **active** state, the SSL certificate is disassociated from the VPN gateway.
        You cannot repeatedly call **DissociateVpnGatewayWithCertificate** within a specific period of time.
        
        @param request: DissociateVpnGatewayWithCertificateRequest
        @return: DissociateVpnGatewayWithCertificateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.dissociate_vpn_gateway_with_certificate_with_options(request, runtime)

    async def dissociate_vpn_gateway_with_certificate_async(
        self,
        request: vpc_20160428_models.DissociateVpnGatewayWithCertificateRequest,
    ) -> vpc_20160428_models.DissociateVpnGatewayWithCertificateResponse:
        """
        @summary Disassociates a certificate from a VPN gateway.
        
        @description    **DissociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status the task.
        If the VPN gateway is in the **updating** state, the SSL certificate is being disassociated from the VPN gateway.
        If the VPN gateway is in the **active** state, the SSL certificate is disassociated from the VPN gateway.
        You cannot repeatedly call **DissociateVpnGatewayWithCertificate** within a specific period of time.
        
        @param request: DissociateVpnGatewayWithCertificateRequest
        @return: DissociateVpnGatewayWithCertificateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.dissociate_vpn_gateway_with_certificate_with_options_async(request, runtime)

    def download_vpn_connection_config_with_options(
        self,
        request: vpc_20160428_models.DownloadVpnConnectionConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DownloadVpnConnectionConfigResponse:
        """
        @summary Queries the configuration of an IPsec-VPN connection.
        
        @param request: DownloadVpnConnectionConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DownloadVpnConnectionConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DownloadVpnConnectionConfig',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DownloadVpnConnectionConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def download_vpn_connection_config_with_options_async(
        self,
        request: vpc_20160428_models.DownloadVpnConnectionConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.DownloadVpnConnectionConfigResponse:
        """
        @summary Queries the configuration of an IPsec-VPN connection.
        
        @param request: DownloadVpnConnectionConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DownloadVpnConnectionConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DownloadVpnConnectionConfig',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.DownloadVpnConnectionConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def download_vpn_connection_config(
        self,
        request: vpc_20160428_models.DownloadVpnConnectionConfigRequest,
    ) -> vpc_20160428_models.DownloadVpnConnectionConfigResponse:
        """
        @summary Queries the configuration of an IPsec-VPN connection.
        
        @param request: DownloadVpnConnectionConfigRequest
        @return: DownloadVpnConnectionConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.download_vpn_connection_config_with_options(request, runtime)

    async def download_vpn_connection_config_async(
        self,
        request: vpc_20160428_models.DownloadVpnConnectionConfigRequest,
    ) -> vpc_20160428_models.DownloadVpnConnectionConfigResponse:
        """
        @summary Queries the configuration of an IPsec-VPN connection.
        
        @param request: DownloadVpnConnectionConfigRequest
        @return: DownloadVpnConnectionConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.download_vpn_connection_config_with_options_async(request, runtime)

    def enable_nat_gateway_ecs_metric_with_options(
        self,
        request: vpc_20160428_models.EnableNatGatewayEcsMetricRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.EnableNatGatewayEcsMetricResponse:
        """
        @summary Enables Elastic Compute Service (ECS) traffic monitoring.
        
        @param request: EnableNatGatewayEcsMetricRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableNatGatewayEcsMetricResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableNatGatewayEcsMetric',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.EnableNatGatewayEcsMetricResponse(),
            self.call_api(params, req, runtime)
        )

    async def enable_nat_gateway_ecs_metric_with_options_async(
        self,
        request: vpc_20160428_models.EnableNatGatewayEcsMetricRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.EnableNatGatewayEcsMetricResponse:
        """
        @summary Enables Elastic Compute Service (ECS) traffic monitoring.
        
        @param request: EnableNatGatewayEcsMetricRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableNatGatewayEcsMetricResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableNatGatewayEcsMetric',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.EnableNatGatewayEcsMetricResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def enable_nat_gateway_ecs_metric(
        self,
        request: vpc_20160428_models.EnableNatGatewayEcsMetricRequest,
    ) -> vpc_20160428_models.EnableNatGatewayEcsMetricResponse:
        """
        @summary Enables Elastic Compute Service (ECS) traffic monitoring.
        
        @param request: EnableNatGatewayEcsMetricRequest
        @return: EnableNatGatewayEcsMetricResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.enable_nat_gateway_ecs_metric_with_options(request, runtime)

    async def enable_nat_gateway_ecs_metric_async(
        self,
        request: vpc_20160428_models.EnableNatGatewayEcsMetricRequest,
    ) -> vpc_20160428_models.EnableNatGatewayEcsMetricResponse:
        """
        @summary Enables Elastic Compute Service (ECS) traffic monitoring.
        
        @param request: EnableNatGatewayEcsMetricRequest
        @return: EnableNatGatewayEcsMetricResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.enable_nat_gateway_ecs_metric_with_options_async(request, runtime)

    def enable_physical_connection_with_options(
        self,
        request: vpc_20160428_models.EnablePhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.EnablePhysicalConnectionResponse:
        """
        @summary Enables an Express Connect circuit that is in the Confirmed state. After you perform this operation, the Express Connect circuit enters the Enabled state.
        
        @description When you call this operation, take note of the following limits:
        You can enable only an Express Connect circuit that is in the **Confirmed** state.
        After you enable an Express Connect circuit, it enters the **Enabled** state.
        **EnablePhysicalConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribePhysicalConnections](https://help.aliyun.com/document_detail/36042.html) operation to query the status of the task.
        You cannot repeatedly call **EnablePhysicalConnection** for an Express Connect circuit in the **Confirmed** state within a specific time period.
        
        @param request: EnablePhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnablePhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.by_pass_sp):
            query['ByPassSp'] = request.by_pass_sp
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnablePhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.EnablePhysicalConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def enable_physical_connection_with_options_async(
        self,
        request: vpc_20160428_models.EnablePhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.EnablePhysicalConnectionResponse:
        """
        @summary Enables an Express Connect circuit that is in the Confirmed state. After you perform this operation, the Express Connect circuit enters the Enabled state.
        
        @description When you call this operation, take note of the following limits:
        You can enable only an Express Connect circuit that is in the **Confirmed** state.
        After you enable an Express Connect circuit, it enters the **Enabled** state.
        **EnablePhysicalConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribePhysicalConnections](https://help.aliyun.com/document_detail/36042.html) operation to query the status of the task.
        You cannot repeatedly call **EnablePhysicalConnection** for an Express Connect circuit in the **Confirmed** state within a specific time period.
        
        @param request: EnablePhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnablePhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.by_pass_sp):
            query['ByPassSp'] = request.by_pass_sp
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnablePhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.EnablePhysicalConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def enable_physical_connection(
        self,
        request: vpc_20160428_models.EnablePhysicalConnectionRequest,
    ) -> vpc_20160428_models.EnablePhysicalConnectionResponse:
        """
        @summary Enables an Express Connect circuit that is in the Confirmed state. After you perform this operation, the Express Connect circuit enters the Enabled state.
        
        @description When you call this operation, take note of the following limits:
        You can enable only an Express Connect circuit that is in the **Confirmed** state.
        After you enable an Express Connect circuit, it enters the **Enabled** state.
        **EnablePhysicalConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribePhysicalConnections](https://help.aliyun.com/document_detail/36042.html) operation to query the status of the task.
        You cannot repeatedly call **EnablePhysicalConnection** for an Express Connect circuit in the **Confirmed** state within a specific time period.
        
        @param request: EnablePhysicalConnectionRequest
        @return: EnablePhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.enable_physical_connection_with_options(request, runtime)

    async def enable_physical_connection_async(
        self,
        request: vpc_20160428_models.EnablePhysicalConnectionRequest,
    ) -> vpc_20160428_models.EnablePhysicalConnectionResponse:
        """
        @summary Enables an Express Connect circuit that is in the Confirmed state. After you perform this operation, the Express Connect circuit enters the Enabled state.
        
        @description When you call this operation, take note of the following limits:
        You can enable only an Express Connect circuit that is in the **Confirmed** state.
        After you enable an Express Connect circuit, it enters the **Enabled** state.
        **EnablePhysicalConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribePhysicalConnections](https://help.aliyun.com/document_detail/36042.html) operation to query the status of the task.
        You cannot repeatedly call **EnablePhysicalConnection** for an Express Connect circuit in the **Confirmed** state within a specific time period.
        
        @param request: EnablePhysicalConnectionRequest
        @return: EnablePhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.enable_physical_connection_with_options_async(request, runtime)

    def enable_vpc_classic_link_with_options(
        self,
        request: vpc_20160428_models.EnableVpcClassicLinkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.EnableVpcClassicLinkResponse:
        """
        @summary Enables ClassicLink for a VPC.
        
        @param request: EnableVpcClassicLinkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableVpcClassicLinkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableVpcClassicLink',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.EnableVpcClassicLinkResponse(),
            self.call_api(params, req, runtime)
        )

    async def enable_vpc_classic_link_with_options_async(
        self,
        request: vpc_20160428_models.EnableVpcClassicLinkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.EnableVpcClassicLinkResponse:
        """
        @summary Enables ClassicLink for a VPC.
        
        @param request: EnableVpcClassicLinkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableVpcClassicLinkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableVpcClassicLink',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.EnableVpcClassicLinkResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def enable_vpc_classic_link(
        self,
        request: vpc_20160428_models.EnableVpcClassicLinkRequest,
    ) -> vpc_20160428_models.EnableVpcClassicLinkResponse:
        """
        @summary Enables ClassicLink for a VPC.
        
        @param request: EnableVpcClassicLinkRequest
        @return: EnableVpcClassicLinkResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.enable_vpc_classic_link_with_options(request, runtime)

    async def enable_vpc_classic_link_async(
        self,
        request: vpc_20160428_models.EnableVpcClassicLinkRequest,
    ) -> vpc_20160428_models.EnableVpcClassicLinkResponse:
        """
        @summary Enables ClassicLink for a VPC.
        
        @param request: EnableVpcClassicLinkRequest
        @return: EnableVpcClassicLinkResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.enable_vpc_classic_link_with_options_async(request, runtime)

    def enable_vpc_ipv_4gateway_with_options(
        self,
        request: vpc_20160428_models.EnableVpcIpv4GatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.EnableVpcIpv4GatewayResponse:
        """
        @summary Activates an IPv4 gateway.
        
        @description ## [](#)Description
        **EnableVpcIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway.
        If the IPv4 gateway is in the **Activating** state, the IPv4 gateway is being activated.
        If the IPv4 gateway is in the **Created** state, the IPv4 gateway is activated.
        You cannot repeatedly call the **EnableVpcIpv4Gateway** operation to activate an IPv4 gateway within the specified period of time.
        
        @param request: EnableVpcIpv4GatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableVpcIpv4GatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.ipv_4gateway_id):
            query['Ipv4GatewayId'] = request.ipv_4gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_list):
            query['RouteTableList'] = request.route_table_list
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableVpcIpv4Gateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.EnableVpcIpv4GatewayResponse(),
            self.call_api(params, req, runtime)
        )

    async def enable_vpc_ipv_4gateway_with_options_async(
        self,
        request: vpc_20160428_models.EnableVpcIpv4GatewayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.EnableVpcIpv4GatewayResponse:
        """
        @summary Activates an IPv4 gateway.
        
        @description ## [](#)Description
        **EnableVpcIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway.
        If the IPv4 gateway is in the **Activating** state, the IPv4 gateway is being activated.
        If the IPv4 gateway is in the **Created** state, the IPv4 gateway is activated.
        You cannot repeatedly call the **EnableVpcIpv4Gateway** operation to activate an IPv4 gateway within the specified period of time.
        
        @param request: EnableVpcIpv4GatewayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableVpcIpv4GatewayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.ipv_4gateway_id):
            query['Ipv4GatewayId'] = request.ipv_4gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_list):
            query['RouteTableList'] = request.route_table_list
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableVpcIpv4Gateway',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.EnableVpcIpv4GatewayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def enable_vpc_ipv_4gateway(
        self,
        request: vpc_20160428_models.EnableVpcIpv4GatewayRequest,
    ) -> vpc_20160428_models.EnableVpcIpv4GatewayResponse:
        """
        @summary Activates an IPv4 gateway.
        
        @description ## [](#)Description
        **EnableVpcIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway.
        If the IPv4 gateway is in the **Activating** state, the IPv4 gateway is being activated.
        If the IPv4 gateway is in the **Created** state, the IPv4 gateway is activated.
        You cannot repeatedly call the **EnableVpcIpv4Gateway** operation to activate an IPv4 gateway within the specified period of time.
        
        @param request: EnableVpcIpv4GatewayRequest
        @return: EnableVpcIpv4GatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.enable_vpc_ipv_4gateway_with_options(request, runtime)

    async def enable_vpc_ipv_4gateway_async(
        self,
        request: vpc_20160428_models.EnableVpcIpv4GatewayRequest,
    ) -> vpc_20160428_models.EnableVpcIpv4GatewayResponse:
        """
        @summary Activates an IPv4 gateway.
        
        @description ## [](#)Description
        **EnableVpcIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway.
        If the IPv4 gateway is in the **Activating** state, the IPv4 gateway is being activated.
        If the IPv4 gateway is in the **Created** state, the IPv4 gateway is activated.
        You cannot repeatedly call the **EnableVpcIpv4Gateway** operation to activate an IPv4 gateway within the specified period of time.
        
        @param request: EnableVpcIpv4GatewayRequest
        @return: EnableVpcIpv4GatewayResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.enable_vpc_ipv_4gateway_with_options_async(request, runtime)

    def get_dhcp_options_set_with_options(
        self,
        request: vpc_20160428_models.GetDhcpOptionsSetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetDhcpOptionsSetResponse:
        """
        @summary Queries a DHCP options set.
        
        @param request: GetDhcpOptionsSetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDhcpOptionsSetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dhcp_options_set_id):
            query['DhcpOptionsSetId'] = request.dhcp_options_set_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDhcpOptionsSet',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetDhcpOptionsSetResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_dhcp_options_set_with_options_async(
        self,
        request: vpc_20160428_models.GetDhcpOptionsSetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetDhcpOptionsSetResponse:
        """
        @summary Queries a DHCP options set.
        
        @param request: GetDhcpOptionsSetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDhcpOptionsSetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dhcp_options_set_id):
            query['DhcpOptionsSetId'] = request.dhcp_options_set_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDhcpOptionsSet',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetDhcpOptionsSetResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_dhcp_options_set(
        self,
        request: vpc_20160428_models.GetDhcpOptionsSetRequest,
    ) -> vpc_20160428_models.GetDhcpOptionsSetResponse:
        """
        @summary Queries a DHCP options set.
        
        @param request: GetDhcpOptionsSetRequest
        @return: GetDhcpOptionsSetResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_dhcp_options_set_with_options(request, runtime)

    async def get_dhcp_options_set_async(
        self,
        request: vpc_20160428_models.GetDhcpOptionsSetRequest,
    ) -> vpc_20160428_models.GetDhcpOptionsSetResponse:
        """
        @summary Queries a DHCP options set.
        
        @param request: GetDhcpOptionsSetRequest
        @return: GetDhcpOptionsSetResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_dhcp_options_set_with_options_async(request, runtime)

    def get_flow_log_service_status_with_options(
        self,
        request: vpc_20160428_models.GetFlowLogServiceStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetFlowLogServiceStatusResponse:
        """
        @summary Queries the status of a flow log.
        
        @param request: GetFlowLogServiceStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetFlowLogServiceStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetFlowLogServiceStatus',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetFlowLogServiceStatusResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_flow_log_service_status_with_options_async(
        self,
        request: vpc_20160428_models.GetFlowLogServiceStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetFlowLogServiceStatusResponse:
        """
        @summary Queries the status of a flow log.
        
        @param request: GetFlowLogServiceStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetFlowLogServiceStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetFlowLogServiceStatus',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetFlowLogServiceStatusResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_flow_log_service_status(
        self,
        request: vpc_20160428_models.GetFlowLogServiceStatusRequest,
    ) -> vpc_20160428_models.GetFlowLogServiceStatusResponse:
        """
        @summary Queries the status of a flow log.
        
        @param request: GetFlowLogServiceStatusRequest
        @return: GetFlowLogServiceStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_flow_log_service_status_with_options(request, runtime)

    async def get_flow_log_service_status_async(
        self,
        request: vpc_20160428_models.GetFlowLogServiceStatusRequest,
    ) -> vpc_20160428_models.GetFlowLogServiceStatusResponse:
        """
        @summary Queries the status of a flow log.
        
        @param request: GetFlowLogServiceStatusRequest
        @return: GetFlowLogServiceStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_flow_log_service_status_with_options_async(request, runtime)

    def get_ipv_4gateway_attribute_with_options(
        self,
        request: vpc_20160428_models.GetIpv4GatewayAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetIpv4GatewayAttributeResponse:
        """
        @summary Queries an IPv4 gateway.
        
        @param request: GetIpv4GatewayAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetIpv4GatewayAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipv_4gateway_id):
            query['Ipv4GatewayId'] = request.ipv_4gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetIpv4GatewayAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetIpv4GatewayAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_ipv_4gateway_attribute_with_options_async(
        self,
        request: vpc_20160428_models.GetIpv4GatewayAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetIpv4GatewayAttributeResponse:
        """
        @summary Queries an IPv4 gateway.
        
        @param request: GetIpv4GatewayAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetIpv4GatewayAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipv_4gateway_id):
            query['Ipv4GatewayId'] = request.ipv_4gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetIpv4GatewayAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetIpv4GatewayAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_ipv_4gateway_attribute(
        self,
        request: vpc_20160428_models.GetIpv4GatewayAttributeRequest,
    ) -> vpc_20160428_models.GetIpv4GatewayAttributeResponse:
        """
        @summary Queries an IPv4 gateway.
        
        @param request: GetIpv4GatewayAttributeRequest
        @return: GetIpv4GatewayAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_ipv_4gateway_attribute_with_options(request, runtime)

    async def get_ipv_4gateway_attribute_async(
        self,
        request: vpc_20160428_models.GetIpv4GatewayAttributeRequest,
    ) -> vpc_20160428_models.GetIpv4GatewayAttributeResponse:
        """
        @summary Queries an IPv4 gateway.
        
        @param request: GetIpv4GatewayAttributeRequest
        @return: GetIpv4GatewayAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_ipv_4gateway_attribute_with_options_async(request, runtime)

    def get_nat_gateway_attribute_with_options(
        self,
        request: vpc_20160428_models.GetNatGatewayAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetNatGatewayAttributeResponse:
        """
        @summary NAT
        
        @description You can call this operation to query information about a specified Internet NAT gateway or Virtual Private Cloud (VPC) NAT gateway. In this topic, "NAT gateway" refers to both gateway types.
        
        @param request: GetNatGatewayAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetNatGatewayAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetNatGatewayAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetNatGatewayAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_nat_gateway_attribute_with_options_async(
        self,
        request: vpc_20160428_models.GetNatGatewayAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetNatGatewayAttributeResponse:
        """
        @summary NAT
        
        @description You can call this operation to query information about a specified Internet NAT gateway or Virtual Private Cloud (VPC) NAT gateway. In this topic, "NAT gateway" refers to both gateway types.
        
        @param request: GetNatGatewayAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetNatGatewayAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetNatGatewayAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetNatGatewayAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_nat_gateway_attribute(
        self,
        request: vpc_20160428_models.GetNatGatewayAttributeRequest,
    ) -> vpc_20160428_models.GetNatGatewayAttributeResponse:
        """
        @summary NAT
        
        @description You can call this operation to query information about a specified Internet NAT gateway or Virtual Private Cloud (VPC) NAT gateway. In this topic, "NAT gateway" refers to both gateway types.
        
        @param request: GetNatGatewayAttributeRequest
        @return: GetNatGatewayAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_nat_gateway_attribute_with_options(request, runtime)

    async def get_nat_gateway_attribute_async(
        self,
        request: vpc_20160428_models.GetNatGatewayAttributeRequest,
    ) -> vpc_20160428_models.GetNatGatewayAttributeResponse:
        """
        @summary NAT
        
        @description You can call this operation to query information about a specified Internet NAT gateway or Virtual Private Cloud (VPC) NAT gateway. In this topic, "NAT gateway" refers to both gateway types.
        
        @param request: GetNatGatewayAttributeRequest
        @return: GetNatGatewayAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_nat_gateway_attribute_with_options_async(request, runtime)

    def get_physical_connection_service_status_with_options(
        self,
        request: vpc_20160428_models.GetPhysicalConnectionServiceStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetPhysicalConnectionServiceStatusResponse:
        """
        @summary 
        
        @description You can call this API operation to query the status of outbound data transfer billing for the current account. For more information about outbound data transfer billing, see [Outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html) and [Billing](https://help.aliyun.com/document_detail/54582.html).
        
        @param request: GetPhysicalConnectionServiceStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPhysicalConnectionServiceStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPhysicalConnectionServiceStatus',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetPhysicalConnectionServiceStatusResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_physical_connection_service_status_with_options_async(
        self,
        request: vpc_20160428_models.GetPhysicalConnectionServiceStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetPhysicalConnectionServiceStatusResponse:
        """
        @summary 
        
        @description You can call this API operation to query the status of outbound data transfer billing for the current account. For more information about outbound data transfer billing, see [Outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html) and [Billing](https://help.aliyun.com/document_detail/54582.html).
        
        @param request: GetPhysicalConnectionServiceStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPhysicalConnectionServiceStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPhysicalConnectionServiceStatus',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetPhysicalConnectionServiceStatusResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_physical_connection_service_status(
        self,
        request: vpc_20160428_models.GetPhysicalConnectionServiceStatusRequest,
    ) -> vpc_20160428_models.GetPhysicalConnectionServiceStatusResponse:
        """
        @summary 
        
        @description You can call this API operation to query the status of outbound data transfer billing for the current account. For more information about outbound data transfer billing, see [Outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html) and [Billing](https://help.aliyun.com/document_detail/54582.html).
        
        @param request: GetPhysicalConnectionServiceStatusRequest
        @return: GetPhysicalConnectionServiceStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_physical_connection_service_status_with_options(request, runtime)

    async def get_physical_connection_service_status_async(
        self,
        request: vpc_20160428_models.GetPhysicalConnectionServiceStatusRequest,
    ) -> vpc_20160428_models.GetPhysicalConnectionServiceStatusResponse:
        """
        @summary 
        
        @description You can call this API operation to query the status of outbound data transfer billing for the current account. For more information about outbound data transfer billing, see [Outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html) and [Billing](https://help.aliyun.com/document_detail/54582.html).
        
        @param request: GetPhysicalConnectionServiceStatusRequest
        @return: GetPhysicalConnectionServiceStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_physical_connection_service_status_with_options_async(request, runtime)

    def get_public_ip_address_pool_service_status_with_options(
        self,
        request: vpc_20160428_models.GetPublicIpAddressPoolServiceStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetPublicIpAddressPoolServiceStatusResponse:
        """
        @summary Queries whether the IP address pool feature is enabled.
        
        @param request: GetPublicIpAddressPoolServiceStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPublicIpAddressPoolServiceStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPublicIpAddressPoolServiceStatus',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetPublicIpAddressPoolServiceStatusResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_public_ip_address_pool_service_status_with_options_async(
        self,
        request: vpc_20160428_models.GetPublicIpAddressPoolServiceStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetPublicIpAddressPoolServiceStatusResponse:
        """
        @summary Queries whether the IP address pool feature is enabled.
        
        @param request: GetPublicIpAddressPoolServiceStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPublicIpAddressPoolServiceStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPublicIpAddressPoolServiceStatus',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetPublicIpAddressPoolServiceStatusResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_public_ip_address_pool_service_status(
        self,
        request: vpc_20160428_models.GetPublicIpAddressPoolServiceStatusRequest,
    ) -> vpc_20160428_models.GetPublicIpAddressPoolServiceStatusResponse:
        """
        @summary Queries whether the IP address pool feature is enabled.
        
        @param request: GetPublicIpAddressPoolServiceStatusRequest
        @return: GetPublicIpAddressPoolServiceStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_public_ip_address_pool_service_status_with_options(request, runtime)

    async def get_public_ip_address_pool_service_status_async(
        self,
        request: vpc_20160428_models.GetPublicIpAddressPoolServiceStatusRequest,
    ) -> vpc_20160428_models.GetPublicIpAddressPoolServiceStatusResponse:
        """
        @summary Queries whether the IP address pool feature is enabled.
        
        @param request: GetPublicIpAddressPoolServiceStatusRequest
        @return: GetPublicIpAddressPoolServiceStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_public_ip_address_pool_service_status_with_options_async(request, runtime)

    def get_traffic_mirror_service_status_with_options(
        self,
        request: vpc_20160428_models.GetTrafficMirrorServiceStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetTrafficMirrorServiceStatusResponse:
        """
        @summary Queries the status of the traffic mirroring feature.
        
        @param request: GetTrafficMirrorServiceStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTrafficMirrorServiceStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTrafficMirrorServiceStatus',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetTrafficMirrorServiceStatusResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_traffic_mirror_service_status_with_options_async(
        self,
        request: vpc_20160428_models.GetTrafficMirrorServiceStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetTrafficMirrorServiceStatusResponse:
        """
        @summary Queries the status of the traffic mirroring feature.
        
        @param request: GetTrafficMirrorServiceStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTrafficMirrorServiceStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTrafficMirrorServiceStatus',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetTrafficMirrorServiceStatusResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_traffic_mirror_service_status(
        self,
        request: vpc_20160428_models.GetTrafficMirrorServiceStatusRequest,
    ) -> vpc_20160428_models.GetTrafficMirrorServiceStatusResponse:
        """
        @summary Queries the status of the traffic mirroring feature.
        
        @param request: GetTrafficMirrorServiceStatusRequest
        @return: GetTrafficMirrorServiceStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_traffic_mirror_service_status_with_options(request, runtime)

    async def get_traffic_mirror_service_status_async(
        self,
        request: vpc_20160428_models.GetTrafficMirrorServiceStatusRequest,
    ) -> vpc_20160428_models.GetTrafficMirrorServiceStatusResponse:
        """
        @summary Queries the status of the traffic mirroring feature.
        
        @param request: GetTrafficMirrorServiceStatusRequest
        @return: GetTrafficMirrorServiceStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_traffic_mirror_service_status_with_options_async(request, runtime)

    def get_vswitch_cidr_reservation_usage_with_options(
        self,
        request: vpc_20160428_models.GetVSwitchCidrReservationUsageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetVSwitchCidrReservationUsageResponse:
        """
        @summary Queries the usage of a prefix list.
        
        @param request: GetVSwitchCidrReservationUsageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVSwitchCidrReservationUsageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_id):
            query['VSwitchCidrReservationId'] = request.v_switch_cidr_reservation_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVSwitchCidrReservationUsage',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetVSwitchCidrReservationUsageResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_vswitch_cidr_reservation_usage_with_options_async(
        self,
        request: vpc_20160428_models.GetVSwitchCidrReservationUsageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetVSwitchCidrReservationUsageResponse:
        """
        @summary Queries the usage of a prefix list.
        
        @param request: GetVSwitchCidrReservationUsageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVSwitchCidrReservationUsageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_id):
            query['VSwitchCidrReservationId'] = request.v_switch_cidr_reservation_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVSwitchCidrReservationUsage',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetVSwitchCidrReservationUsageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_vswitch_cidr_reservation_usage(
        self,
        request: vpc_20160428_models.GetVSwitchCidrReservationUsageRequest,
    ) -> vpc_20160428_models.GetVSwitchCidrReservationUsageResponse:
        """
        @summary Queries the usage of a prefix list.
        
        @param request: GetVSwitchCidrReservationUsageRequest
        @return: GetVSwitchCidrReservationUsageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_vswitch_cidr_reservation_usage_with_options(request, runtime)

    async def get_vswitch_cidr_reservation_usage_async(
        self,
        request: vpc_20160428_models.GetVSwitchCidrReservationUsageRequest,
    ) -> vpc_20160428_models.GetVSwitchCidrReservationUsageResponse:
        """
        @summary Queries the usage of a prefix list.
        
        @param request: GetVSwitchCidrReservationUsageRequest
        @return: GetVSwitchCidrReservationUsageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_vswitch_cidr_reservation_usage_with_options_async(request, runtime)

    def get_vpc_gateway_endpoint_attribute_with_options(
        self,
        request: vpc_20160428_models.GetVpcGatewayEndpointAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetVpcGatewayEndpointAttributeResponse:
        """
        @summary Queries the attributes of a gateway endpoint.
        
        @param request: GetVpcGatewayEndpointAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVpcGatewayEndpointAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.endpoint_id):
            query['EndpointId'] = request.endpoint_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVpcGatewayEndpointAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetVpcGatewayEndpointAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_vpc_gateway_endpoint_attribute_with_options_async(
        self,
        request: vpc_20160428_models.GetVpcGatewayEndpointAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetVpcGatewayEndpointAttributeResponse:
        """
        @summary Queries the attributes of a gateway endpoint.
        
        @param request: GetVpcGatewayEndpointAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVpcGatewayEndpointAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.endpoint_id):
            query['EndpointId'] = request.endpoint_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVpcGatewayEndpointAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetVpcGatewayEndpointAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_vpc_gateway_endpoint_attribute(
        self,
        request: vpc_20160428_models.GetVpcGatewayEndpointAttributeRequest,
    ) -> vpc_20160428_models.GetVpcGatewayEndpointAttributeResponse:
        """
        @summary Queries the attributes of a gateway endpoint.
        
        @param request: GetVpcGatewayEndpointAttributeRequest
        @return: GetVpcGatewayEndpointAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_vpc_gateway_endpoint_attribute_with_options(request, runtime)

    async def get_vpc_gateway_endpoint_attribute_async(
        self,
        request: vpc_20160428_models.GetVpcGatewayEndpointAttributeRequest,
    ) -> vpc_20160428_models.GetVpcGatewayEndpointAttributeResponse:
        """
        @summary Queries the attributes of a gateway endpoint.
        
        @param request: GetVpcGatewayEndpointAttributeRequest
        @return: GetVpcGatewayEndpointAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_vpc_gateway_endpoint_attribute_with_options_async(request, runtime)

    def get_vpc_prefix_list_associations_with_options(
        self,
        request: vpc_20160428_models.GetVpcPrefixListAssociationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetVpcPrefixListAssociationsResponse:
        """
        @summary Queries the resources that are associated with a prefix list.
        
        @param request: GetVpcPrefixListAssociationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVpcPrefixListAssociationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_id):
            query['PrefixListId'] = request.prefix_list_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVpcPrefixListAssociations',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetVpcPrefixListAssociationsResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_vpc_prefix_list_associations_with_options_async(
        self,
        request: vpc_20160428_models.GetVpcPrefixListAssociationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetVpcPrefixListAssociationsResponse:
        """
        @summary Queries the resources that are associated with a prefix list.
        
        @param request: GetVpcPrefixListAssociationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVpcPrefixListAssociationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_id):
            query['PrefixListId'] = request.prefix_list_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVpcPrefixListAssociations',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetVpcPrefixListAssociationsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_vpc_prefix_list_associations(
        self,
        request: vpc_20160428_models.GetVpcPrefixListAssociationsRequest,
    ) -> vpc_20160428_models.GetVpcPrefixListAssociationsResponse:
        """
        @summary Queries the resources that are associated with a prefix list.
        
        @param request: GetVpcPrefixListAssociationsRequest
        @return: GetVpcPrefixListAssociationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_vpc_prefix_list_associations_with_options(request, runtime)

    async def get_vpc_prefix_list_associations_async(
        self,
        request: vpc_20160428_models.GetVpcPrefixListAssociationsRequest,
    ) -> vpc_20160428_models.GetVpcPrefixListAssociationsResponse:
        """
        @summary Queries the resources that are associated with a prefix list.
        
        @param request: GetVpcPrefixListAssociationsRequest
        @return: GetVpcPrefixListAssociationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_vpc_prefix_list_associations_with_options_async(request, runtime)

    def get_vpc_prefix_list_entries_with_options(
        self,
        request: vpc_20160428_models.GetVpcPrefixListEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetVpcPrefixListEntriesResponse:
        """
        @summary Queries the information about a prefix list.
        
        @param request: GetVpcPrefixListEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVpcPrefixListEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_id):
            query['PrefixListId'] = request.prefix_list_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVpcPrefixListEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetVpcPrefixListEntriesResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_vpc_prefix_list_entries_with_options_async(
        self,
        request: vpc_20160428_models.GetVpcPrefixListEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetVpcPrefixListEntriesResponse:
        """
        @summary Queries the information about a prefix list.
        
        @param request: GetVpcPrefixListEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVpcPrefixListEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_id):
            query['PrefixListId'] = request.prefix_list_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVpcPrefixListEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetVpcPrefixListEntriesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_vpc_prefix_list_entries(
        self,
        request: vpc_20160428_models.GetVpcPrefixListEntriesRequest,
    ) -> vpc_20160428_models.GetVpcPrefixListEntriesResponse:
        """
        @summary Queries the information about a prefix list.
        
        @param request: GetVpcPrefixListEntriesRequest
        @return: GetVpcPrefixListEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_vpc_prefix_list_entries_with_options(request, runtime)

    async def get_vpc_prefix_list_entries_async(
        self,
        request: vpc_20160428_models.GetVpcPrefixListEntriesRequest,
    ) -> vpc_20160428_models.GetVpcPrefixListEntriesResponse:
        """
        @summary Queries the information about a prefix list.
        
        @param request: GetVpcPrefixListEntriesRequest
        @return: GetVpcPrefixListEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_vpc_prefix_list_entries_with_options_async(request, runtime)

    def get_vpc_route_entry_summary_with_options(
        self,
        request: vpc_20160428_models.GetVpcRouteEntrySummaryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetVpcRouteEntrySummaryResponse:
        """
        @summary 
        
        @param request: GetVpcRouteEntrySummaryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVpcRouteEntrySummaryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_entry_type):
            query['RouteEntryType'] = request.route_entry_type
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVpcRouteEntrySummary',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetVpcRouteEntrySummaryResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_vpc_route_entry_summary_with_options_async(
        self,
        request: vpc_20160428_models.GetVpcRouteEntrySummaryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetVpcRouteEntrySummaryResponse:
        """
        @summary 
        
        @param request: GetVpcRouteEntrySummaryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVpcRouteEntrySummaryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_entry_type):
            query['RouteEntryType'] = request.route_entry_type
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVpcRouteEntrySummary',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetVpcRouteEntrySummaryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_vpc_route_entry_summary(
        self,
        request: vpc_20160428_models.GetVpcRouteEntrySummaryRequest,
    ) -> vpc_20160428_models.GetVpcRouteEntrySummaryResponse:
        """
        @summary 
        
        @param request: GetVpcRouteEntrySummaryRequest
        @return: GetVpcRouteEntrySummaryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_vpc_route_entry_summary_with_options(request, runtime)

    async def get_vpc_route_entry_summary_async(
        self,
        request: vpc_20160428_models.GetVpcRouteEntrySummaryRequest,
    ) -> vpc_20160428_models.GetVpcRouteEntrySummaryResponse:
        """
        @summary 
        
        @param request: GetVpcRouteEntrySummaryRequest
        @return: GetVpcRouteEntrySummaryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_vpc_route_entry_summary_with_options_async(request, runtime)

    def get_vpn_gateway_diagnose_result_with_options(
        self,
        request: vpc_20160428_models.GetVpnGatewayDiagnoseResultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetVpnGatewayDiagnoseResultResponse:
        """
        @summary Queries the diagnostic result of a VPN gateway.
        
        @description When you call the *GetVpnGatewayDiagnoseResult** operation, you must specify one of **DiagnoseId** and **VpnGatewayId**.
        
        @param request: GetVpnGatewayDiagnoseResultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVpnGatewayDiagnoseResultResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.diagnose_id):
            query['DiagnoseId'] = request.diagnose_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVpnGatewayDiagnoseResult',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetVpnGatewayDiagnoseResultResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_vpn_gateway_diagnose_result_with_options_async(
        self,
        request: vpc_20160428_models.GetVpnGatewayDiagnoseResultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GetVpnGatewayDiagnoseResultResponse:
        """
        @summary Queries the diagnostic result of a VPN gateway.
        
        @description When you call the *GetVpnGatewayDiagnoseResult** operation, you must specify one of **DiagnoseId** and **VpnGatewayId**.
        
        @param request: GetVpnGatewayDiagnoseResultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVpnGatewayDiagnoseResultResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.diagnose_id):
            query['DiagnoseId'] = request.diagnose_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVpnGatewayDiagnoseResult',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GetVpnGatewayDiagnoseResultResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_vpn_gateway_diagnose_result(
        self,
        request: vpc_20160428_models.GetVpnGatewayDiagnoseResultRequest,
    ) -> vpc_20160428_models.GetVpnGatewayDiagnoseResultResponse:
        """
        @summary Queries the diagnostic result of a VPN gateway.
        
        @description When you call the *GetVpnGatewayDiagnoseResult** operation, you must specify one of **DiagnoseId** and **VpnGatewayId**.
        
        @param request: GetVpnGatewayDiagnoseResultRequest
        @return: GetVpnGatewayDiagnoseResultResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_vpn_gateway_diagnose_result_with_options(request, runtime)

    async def get_vpn_gateway_diagnose_result_async(
        self,
        request: vpc_20160428_models.GetVpnGatewayDiagnoseResultRequest,
    ) -> vpc_20160428_models.GetVpnGatewayDiagnoseResultResponse:
        """
        @summary Queries the diagnostic result of a VPN gateway.
        
        @description When you call the *GetVpnGatewayDiagnoseResult** operation, you must specify one of **DiagnoseId** and **VpnGatewayId**.
        
        @param request: GetVpnGatewayDiagnoseResultRequest
        @return: GetVpnGatewayDiagnoseResultResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_vpn_gateway_diagnose_result_with_options_async(request, runtime)

    def grant_instance_to_cen_with_options(
        self,
        request: vpc_20160428_models.GrantInstanceToCenRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GrantInstanceToCenResponse:
        """
        @summary Grants permissions to a Cloud Enterprise Network (CEN) instance.
        
        @description    Before you can attach a network instance that belongs to another Alibaba Cloud account to your CEN instance, you must grant permissions to your CEN instance.
        >  *GrantInstanceToCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use the `vpc.aliyuncs.com` domain name to call this operation. The API version is `2016-04-28`.
        You cannot repeatedly call the **GrantInstanceToCen** operation to grant the permissions on a network instance to a CEN instance. The network instance can be a VPC, a virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
        
        @param request: GrantInstanceToCenRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GrantInstanceToCenResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cen_id):
            query['CenId'] = request.cen_id
        if not UtilClient.is_unset(request.cen_owner_id):
            query['CenOwnerId'] = request.cen_owner_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GrantInstanceToCen',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GrantInstanceToCenResponse(),
            self.call_api(params, req, runtime)
        )

    async def grant_instance_to_cen_with_options_async(
        self,
        request: vpc_20160428_models.GrantInstanceToCenRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GrantInstanceToCenResponse:
        """
        @summary Grants permissions to a Cloud Enterprise Network (CEN) instance.
        
        @description    Before you can attach a network instance that belongs to another Alibaba Cloud account to your CEN instance, you must grant permissions to your CEN instance.
        >  *GrantInstanceToCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use the `vpc.aliyuncs.com` domain name to call this operation. The API version is `2016-04-28`.
        You cannot repeatedly call the **GrantInstanceToCen** operation to grant the permissions on a network instance to a CEN instance. The network instance can be a VPC, a virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
        
        @param request: GrantInstanceToCenRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GrantInstanceToCenResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cen_id):
            query['CenId'] = request.cen_id
        if not UtilClient.is_unset(request.cen_owner_id):
            query['CenOwnerId'] = request.cen_owner_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GrantInstanceToCen',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GrantInstanceToCenResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def grant_instance_to_cen(
        self,
        request: vpc_20160428_models.GrantInstanceToCenRequest,
    ) -> vpc_20160428_models.GrantInstanceToCenResponse:
        """
        @summary Grants permissions to a Cloud Enterprise Network (CEN) instance.
        
        @description    Before you can attach a network instance that belongs to another Alibaba Cloud account to your CEN instance, you must grant permissions to your CEN instance.
        >  *GrantInstanceToCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use the `vpc.aliyuncs.com` domain name to call this operation. The API version is `2016-04-28`.
        You cannot repeatedly call the **GrantInstanceToCen** operation to grant the permissions on a network instance to a CEN instance. The network instance can be a VPC, a virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
        
        @param request: GrantInstanceToCenRequest
        @return: GrantInstanceToCenResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.grant_instance_to_cen_with_options(request, runtime)

    async def grant_instance_to_cen_async(
        self,
        request: vpc_20160428_models.GrantInstanceToCenRequest,
    ) -> vpc_20160428_models.GrantInstanceToCenResponse:
        """
        @summary Grants permissions to a Cloud Enterprise Network (CEN) instance.
        
        @description    Before you can attach a network instance that belongs to another Alibaba Cloud account to your CEN instance, you must grant permissions to your CEN instance.
        >  *GrantInstanceToCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use the `vpc.aliyuncs.com` domain name to call this operation. The API version is `2016-04-28`.
        You cannot repeatedly call the **GrantInstanceToCen** operation to grant the permissions on a network instance to a CEN instance. The network instance can be a VPC, a virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
        
        @param request: GrantInstanceToCenRequest
        @return: GrantInstanceToCenResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.grant_instance_to_cen_with_options_async(request, runtime)

    def grant_instance_to_vbr_with_options(
        self,
        tmp_req: vpc_20160428_models.GrantInstanceToVbrRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GrantInstanceToVbrResponse:
        """
        @summary Grants a virtual border router (VBR) the permissions to connect to a virtual private cloud (VPC) that belongs to another Alibaba Cloud account.
        
        @description ## Usage notes
        When you connect a VBR to a VPC that belongs to another Alibaba Cloud account, the VBR must acquire the required permissions from the VPC.
        
        @param tmp_req: GrantInstanceToVbrRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GrantInstanceToVbrResponse
        """
        UtilClient.validate_model(tmp_req)
        request = vpc_20160428_models.GrantInstanceToVbrShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.vbr_instance_ids):
            request.vbr_instance_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.vbr_instance_ids, 'VbrInstanceIds', 'simple')
        query = {}
        if not UtilClient.is_unset(request.grant_type):
            query['GrantType'] = request.grant_type
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.vbr_instance_ids_shrink):
            query['VbrInstanceIds'] = request.vbr_instance_ids_shrink
        if not UtilClient.is_unset(request.vbr_owner_uid):
            query['VbrOwnerUid'] = request.vbr_owner_uid
        if not UtilClient.is_unset(request.vbr_region_no):
            query['VbrRegionNo'] = request.vbr_region_no
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GrantInstanceToVbr',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GrantInstanceToVbrResponse(),
            self.call_api(params, req, runtime)
        )

    async def grant_instance_to_vbr_with_options_async(
        self,
        tmp_req: vpc_20160428_models.GrantInstanceToVbrRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.GrantInstanceToVbrResponse:
        """
        @summary Grants a virtual border router (VBR) the permissions to connect to a virtual private cloud (VPC) that belongs to another Alibaba Cloud account.
        
        @description ## Usage notes
        When you connect a VBR to a VPC that belongs to another Alibaba Cloud account, the VBR must acquire the required permissions from the VPC.
        
        @param tmp_req: GrantInstanceToVbrRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GrantInstanceToVbrResponse
        """
        UtilClient.validate_model(tmp_req)
        request = vpc_20160428_models.GrantInstanceToVbrShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.vbr_instance_ids):
            request.vbr_instance_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.vbr_instance_ids, 'VbrInstanceIds', 'simple')
        query = {}
        if not UtilClient.is_unset(request.grant_type):
            query['GrantType'] = request.grant_type
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.vbr_instance_ids_shrink):
            query['VbrInstanceIds'] = request.vbr_instance_ids_shrink
        if not UtilClient.is_unset(request.vbr_owner_uid):
            query['VbrOwnerUid'] = request.vbr_owner_uid
        if not UtilClient.is_unset(request.vbr_region_no):
            query['VbrRegionNo'] = request.vbr_region_no
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GrantInstanceToVbr',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.GrantInstanceToVbrResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def grant_instance_to_vbr(
        self,
        request: vpc_20160428_models.GrantInstanceToVbrRequest,
    ) -> vpc_20160428_models.GrantInstanceToVbrResponse:
        """
        @summary Grants a virtual border router (VBR) the permissions to connect to a virtual private cloud (VPC) that belongs to another Alibaba Cloud account.
        
        @description ## Usage notes
        When you connect a VBR to a VPC that belongs to another Alibaba Cloud account, the VBR must acquire the required permissions from the VPC.
        
        @param request: GrantInstanceToVbrRequest
        @return: GrantInstanceToVbrResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.grant_instance_to_vbr_with_options(request, runtime)

    async def grant_instance_to_vbr_async(
        self,
        request: vpc_20160428_models.GrantInstanceToVbrRequest,
    ) -> vpc_20160428_models.GrantInstanceToVbrResponse:
        """
        @summary Grants a virtual border router (VBR) the permissions to connect to a virtual private cloud (VPC) that belongs to another Alibaba Cloud account.
        
        @description ## Usage notes
        When you connect a VBR to a VPC that belongs to another Alibaba Cloud account, the VBR must acquire the required permissions from the VPC.
        
        @param request: GrantInstanceToVbrRequest
        @return: GrantInstanceToVbrResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.grant_instance_to_vbr_with_options_async(request, runtime)

    def list_business_access_points_with_options(
        self,
        request: vpc_20160428_models.ListBusinessAccessPointsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListBusinessAccessPointsResponse:
        """
        @summary Queries the access points of an Express Connect circuit.
        
        @param request: ListBusinessAccessPointsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListBusinessAccessPointsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListBusinessAccessPoints',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListBusinessAccessPointsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_business_access_points_with_options_async(
        self,
        request: vpc_20160428_models.ListBusinessAccessPointsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListBusinessAccessPointsResponse:
        """
        @summary Queries the access points of an Express Connect circuit.
        
        @param request: ListBusinessAccessPointsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListBusinessAccessPointsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListBusinessAccessPoints',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListBusinessAccessPointsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_business_access_points(
        self,
        request: vpc_20160428_models.ListBusinessAccessPointsRequest,
    ) -> vpc_20160428_models.ListBusinessAccessPointsResponse:
        """
        @summary Queries the access points of an Express Connect circuit.
        
        @param request: ListBusinessAccessPointsRequest
        @return: ListBusinessAccessPointsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_business_access_points_with_options(request, runtime)

    async def list_business_access_points_async(
        self,
        request: vpc_20160428_models.ListBusinessAccessPointsRequest,
    ) -> vpc_20160428_models.ListBusinessAccessPointsResponse:
        """
        @summary Queries the access points of an Express Connect circuit.
        
        @param request: ListBusinessAccessPointsRequest
        @return: ListBusinessAccessPointsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_business_access_points_with_options_async(request, runtime)

    def list_dhcp_options_sets_with_options(
        self,
        request: vpc_20160428_models.ListDhcpOptionsSetsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListDhcpOptionsSetsResponse:
        """
        @summary Queries Dynamic Host Configuration Protocol (DHCP) options sets.
        
        @param request: ListDhcpOptionsSetsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDhcpOptionsSetsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dhcp_options_set_id):
            query['DhcpOptionsSetId'] = request.dhcp_options_set_id
        if not UtilClient.is_unset(request.dhcp_options_set_name):
            query['DhcpOptionsSetName'] = request.dhcp_options_set_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDhcpOptionsSets',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListDhcpOptionsSetsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_dhcp_options_sets_with_options_async(
        self,
        request: vpc_20160428_models.ListDhcpOptionsSetsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListDhcpOptionsSetsResponse:
        """
        @summary Queries Dynamic Host Configuration Protocol (DHCP) options sets.
        
        @param request: ListDhcpOptionsSetsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDhcpOptionsSetsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dhcp_options_set_id):
            query['DhcpOptionsSetId'] = request.dhcp_options_set_id
        if not UtilClient.is_unset(request.dhcp_options_set_name):
            query['DhcpOptionsSetName'] = request.dhcp_options_set_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDhcpOptionsSets',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListDhcpOptionsSetsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_dhcp_options_sets(
        self,
        request: vpc_20160428_models.ListDhcpOptionsSetsRequest,
    ) -> vpc_20160428_models.ListDhcpOptionsSetsResponse:
        """
        @summary Queries Dynamic Host Configuration Protocol (DHCP) options sets.
        
        @param request: ListDhcpOptionsSetsRequest
        @return: ListDhcpOptionsSetsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_dhcp_options_sets_with_options(request, runtime)

    async def list_dhcp_options_sets_async(
        self,
        request: vpc_20160428_models.ListDhcpOptionsSetsRequest,
    ) -> vpc_20160428_models.ListDhcpOptionsSetsResponse:
        """
        @summary Queries Dynamic Host Configuration Protocol (DHCP) options sets.
        
        @param request: ListDhcpOptionsSetsRequest
        @return: ListDhcpOptionsSetsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_dhcp_options_sets_with_options_async(request, runtime)

    def list_enhanhced_nat_gateway_available_zones_with_options(
        self,
        request: vpc_20160428_models.ListEnhanhcedNatGatewayAvailableZonesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListEnhanhcedNatGatewayAvailableZonesResponse:
        """
        @summary Queries the zones that support NAT gateways.
        
        @description You can call this operation to query zones that support NAT gateways, including Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways.
        
        @param request: ListEnhanhcedNatGatewayAvailableZonesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEnhanhcedNatGatewayAvailableZonesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.accept_language):
            query['AcceptLanguage'] = request.accept_language
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEnhanhcedNatGatewayAvailableZones',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListEnhanhcedNatGatewayAvailableZonesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_enhanhced_nat_gateway_available_zones_with_options_async(
        self,
        request: vpc_20160428_models.ListEnhanhcedNatGatewayAvailableZonesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListEnhanhcedNatGatewayAvailableZonesResponse:
        """
        @summary Queries the zones that support NAT gateways.
        
        @description You can call this operation to query zones that support NAT gateways, including Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways.
        
        @param request: ListEnhanhcedNatGatewayAvailableZonesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEnhanhcedNatGatewayAvailableZonesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.accept_language):
            query['AcceptLanguage'] = request.accept_language
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEnhanhcedNatGatewayAvailableZones',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListEnhanhcedNatGatewayAvailableZonesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_enhanhced_nat_gateway_available_zones(
        self,
        request: vpc_20160428_models.ListEnhanhcedNatGatewayAvailableZonesRequest,
    ) -> vpc_20160428_models.ListEnhanhcedNatGatewayAvailableZonesResponse:
        """
        @summary Queries the zones that support NAT gateways.
        
        @description You can call this operation to query zones that support NAT gateways, including Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways.
        
        @param request: ListEnhanhcedNatGatewayAvailableZonesRequest
        @return: ListEnhanhcedNatGatewayAvailableZonesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_enhanhced_nat_gateway_available_zones_with_options(request, runtime)

    async def list_enhanhced_nat_gateway_available_zones_async(
        self,
        request: vpc_20160428_models.ListEnhanhcedNatGatewayAvailableZonesRequest,
    ) -> vpc_20160428_models.ListEnhanhcedNatGatewayAvailableZonesResponse:
        """
        @summary Queries the zones that support NAT gateways.
        
        @description You can call this operation to query zones that support NAT gateways, including Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways.
        
        @param request: ListEnhanhcedNatGatewayAvailableZonesRequest
        @return: ListEnhanhcedNatGatewayAvailableZonesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_enhanhced_nat_gateway_available_zones_with_options_async(request, runtime)

    def list_full_nat_entries_with_options(
        self,
        request: vpc_20160428_models.ListFullNatEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListFullNatEntriesResponse:
        """
        @summary Queries FULLNAT entries.
        
        @param request: ListFullNatEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListFullNatEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.full_nat_entry_id):
            query['FullNatEntryId'] = request.full_nat_entry_id
        if not UtilClient.is_unset(request.full_nat_entry_names):
            query['FullNatEntryNames'] = request.full_nat_entry_names
        if not UtilClient.is_unset(request.full_nat_table_id):
            query['FullNatTableId'] = request.full_nat_table_id
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.nat_ip):
            query['NatIp'] = request.nat_ip
        if not UtilClient.is_unset(request.nat_ip_port):
            query['NatIpPort'] = request.nat_ip_port
        if not UtilClient.is_unset(request.network_interface_ids):
            query['NetworkInterfaceIds'] = request.network_interface_ids
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListFullNatEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListFullNatEntriesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_full_nat_entries_with_options_async(
        self,
        request: vpc_20160428_models.ListFullNatEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListFullNatEntriesResponse:
        """
        @summary Queries FULLNAT entries.
        
        @param request: ListFullNatEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListFullNatEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.full_nat_entry_id):
            query['FullNatEntryId'] = request.full_nat_entry_id
        if not UtilClient.is_unset(request.full_nat_entry_names):
            query['FullNatEntryNames'] = request.full_nat_entry_names
        if not UtilClient.is_unset(request.full_nat_table_id):
            query['FullNatTableId'] = request.full_nat_table_id
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.nat_ip):
            query['NatIp'] = request.nat_ip
        if not UtilClient.is_unset(request.nat_ip_port):
            query['NatIpPort'] = request.nat_ip_port
        if not UtilClient.is_unset(request.network_interface_ids):
            query['NetworkInterfaceIds'] = request.network_interface_ids
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListFullNatEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListFullNatEntriesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_full_nat_entries(
        self,
        request: vpc_20160428_models.ListFullNatEntriesRequest,
    ) -> vpc_20160428_models.ListFullNatEntriesResponse:
        """
        @summary Queries FULLNAT entries.
        
        @param request: ListFullNatEntriesRequest
        @return: ListFullNatEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_full_nat_entries_with_options(request, runtime)

    async def list_full_nat_entries_async(
        self,
        request: vpc_20160428_models.ListFullNatEntriesRequest,
    ) -> vpc_20160428_models.ListFullNatEntriesResponse:
        """
        @summary Queries FULLNAT entries.
        
        @param request: ListFullNatEntriesRequest
        @return: ListFullNatEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_full_nat_entries_with_options_async(request, runtime)

    def list_gateway_route_table_entries_with_options(
        self,
        request: vpc_20160428_models.ListGatewayRouteTableEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListGatewayRouteTableEntriesResponse:
        """
        @summary Queries route entries of a gateway route table.
        
        @param request: ListGatewayRouteTableEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListGatewayRouteTableEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.destination_cidr_block):
            query['DestinationCidrBlock'] = request.destination_cidr_block
        if not UtilClient.is_unset(request.gateway_route_table_id):
            query['GatewayRouteTableId'] = request.gateway_route_table_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListGatewayRouteTableEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListGatewayRouteTableEntriesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_gateway_route_table_entries_with_options_async(
        self,
        request: vpc_20160428_models.ListGatewayRouteTableEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListGatewayRouteTableEntriesResponse:
        """
        @summary Queries route entries of a gateway route table.
        
        @param request: ListGatewayRouteTableEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListGatewayRouteTableEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.destination_cidr_block):
            query['DestinationCidrBlock'] = request.destination_cidr_block
        if not UtilClient.is_unset(request.gateway_route_table_id):
            query['GatewayRouteTableId'] = request.gateway_route_table_id
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListGatewayRouteTableEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListGatewayRouteTableEntriesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_gateway_route_table_entries(
        self,
        request: vpc_20160428_models.ListGatewayRouteTableEntriesRequest,
    ) -> vpc_20160428_models.ListGatewayRouteTableEntriesResponse:
        """
        @summary Queries route entries of a gateway route table.
        
        @param request: ListGatewayRouteTableEntriesRequest
        @return: ListGatewayRouteTableEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_gateway_route_table_entries_with_options(request, runtime)

    async def list_gateway_route_table_entries_async(
        self,
        request: vpc_20160428_models.ListGatewayRouteTableEntriesRequest,
    ) -> vpc_20160428_models.ListGatewayRouteTableEntriesResponse:
        """
        @summary Queries route entries of a gateway route table.
        
        @param request: ListGatewayRouteTableEntriesRequest
        @return: ListGatewayRouteTableEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_gateway_route_table_entries_with_options_async(request, runtime)

    def list_geographic_sub_regions_with_options(
        self,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListGeographicSubRegionsResponse:
        """
        @summary Queries the most recent region list.
        
        @param request: ListGeographicSubRegionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListGeographicSubRegionsResponse
        """
        req = open_api_models.OpenApiRequest()
        params = open_api_models.Params(
            action='ListGeographicSubRegions',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListGeographicSubRegionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_geographic_sub_regions_with_options_async(
        self,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListGeographicSubRegionsResponse:
        """
        @summary Queries the most recent region list.
        
        @param request: ListGeographicSubRegionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListGeographicSubRegionsResponse
        """
        req = open_api_models.OpenApiRequest()
        params = open_api_models.Params(
            action='ListGeographicSubRegions',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListGeographicSubRegionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_geographic_sub_regions(self) -> vpc_20160428_models.ListGeographicSubRegionsResponse:
        """
        @summary Queries the most recent region list.
        
        @return: ListGeographicSubRegionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_geographic_sub_regions_with_options(runtime)

    async def list_geographic_sub_regions_async(self) -> vpc_20160428_models.ListGeographicSubRegionsResponse:
        """
        @summary Queries the most recent region list.
        
        @return: ListGeographicSubRegionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_geographic_sub_regions_with_options_async(runtime)

    def list_ipsec_server_logs_with_options(
        self,
        request: vpc_20160428_models.ListIpsecServerLogsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListIpsecServerLogsResponse:
        """
        @param request: ListIpsecServerLogsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIpsecServerLogsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.from_):
            query['From'] = request.from_
        if not UtilClient.is_unset(request.ipsec_server_id):
            query['IpsecServerId'] = request.ipsec_server_id
        if not UtilClient.is_unset(request.minute_period):
            query['MinutePeriod'] = request.minute_period
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.to):
            query['To'] = request.to
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIpsecServerLogs',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListIpsecServerLogsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_ipsec_server_logs_with_options_async(
        self,
        request: vpc_20160428_models.ListIpsecServerLogsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListIpsecServerLogsResponse:
        """
        @param request: ListIpsecServerLogsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIpsecServerLogsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.from_):
            query['From'] = request.from_
        if not UtilClient.is_unset(request.ipsec_server_id):
            query['IpsecServerId'] = request.ipsec_server_id
        if not UtilClient.is_unset(request.minute_period):
            query['MinutePeriod'] = request.minute_period
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.to):
            query['To'] = request.to
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIpsecServerLogs',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListIpsecServerLogsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_ipsec_server_logs(
        self,
        request: vpc_20160428_models.ListIpsecServerLogsRequest,
    ) -> vpc_20160428_models.ListIpsecServerLogsResponse:
        """
        @param request: ListIpsecServerLogsRequest
        @return: ListIpsecServerLogsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_ipsec_server_logs_with_options(request, runtime)

    async def list_ipsec_server_logs_async(
        self,
        request: vpc_20160428_models.ListIpsecServerLogsRequest,
    ) -> vpc_20160428_models.ListIpsecServerLogsResponse:
        """
        @param request: ListIpsecServerLogsRequest
        @return: ListIpsecServerLogsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_ipsec_server_logs_with_options_async(request, runtime)

    def list_ipsec_servers_with_options(
        self,
        request: vpc_20160428_models.ListIpsecServersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListIpsecServersResponse:
        """
        @summary Queries IPsec servers.
        
        @param request: ListIpsecServersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIpsecServersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipsec_server_id):
            query['IpsecServerId'] = request.ipsec_server_id
        if not UtilClient.is_unset(request.ipsec_server_name):
            query['IpsecServerName'] = request.ipsec_server_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIpsecServers',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListIpsecServersResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_ipsec_servers_with_options_async(
        self,
        request: vpc_20160428_models.ListIpsecServersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListIpsecServersResponse:
        """
        @summary Queries IPsec servers.
        
        @param request: ListIpsecServersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIpsecServersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipsec_server_id):
            query['IpsecServerId'] = request.ipsec_server_id
        if not UtilClient.is_unset(request.ipsec_server_name):
            query['IpsecServerName'] = request.ipsec_server_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIpsecServers',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListIpsecServersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_ipsec_servers(
        self,
        request: vpc_20160428_models.ListIpsecServersRequest,
    ) -> vpc_20160428_models.ListIpsecServersResponse:
        """
        @summary Queries IPsec servers.
        
        @param request: ListIpsecServersRequest
        @return: ListIpsecServersResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_ipsec_servers_with_options(request, runtime)

    async def list_ipsec_servers_async(
        self,
        request: vpc_20160428_models.ListIpsecServersRequest,
    ) -> vpc_20160428_models.ListIpsecServersResponse:
        """
        @summary Queries IPsec servers.
        
        @param request: ListIpsecServersRequest
        @return: ListIpsecServersResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_ipsec_servers_with_options_async(request, runtime)

    def list_ipv_4gateways_with_options(
        self,
        request: vpc_20160428_models.ListIpv4GatewaysRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListIpv4GatewaysResponse:
        """
        @summary Queries IPv4 gateways.
        
        @param request: ListIpv4GatewaysRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIpv4GatewaysResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipv_4gateway_id):
            query['Ipv4GatewayId'] = request.ipv_4gateway_id
        if not UtilClient.is_unset(request.ipv_4gateway_name):
            query['Ipv4GatewayName'] = request.ipv_4gateway_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIpv4Gateways',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListIpv4GatewaysResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_ipv_4gateways_with_options_async(
        self,
        request: vpc_20160428_models.ListIpv4GatewaysRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListIpv4GatewaysResponse:
        """
        @summary Queries IPv4 gateways.
        
        @param request: ListIpv4GatewaysRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIpv4GatewaysResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipv_4gateway_id):
            query['Ipv4GatewayId'] = request.ipv_4gateway_id
        if not UtilClient.is_unset(request.ipv_4gateway_name):
            query['Ipv4GatewayName'] = request.ipv_4gateway_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIpv4Gateways',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListIpv4GatewaysResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_ipv_4gateways(
        self,
        request: vpc_20160428_models.ListIpv4GatewaysRequest,
    ) -> vpc_20160428_models.ListIpv4GatewaysResponse:
        """
        @summary Queries IPv4 gateways.
        
        @param request: ListIpv4GatewaysRequest
        @return: ListIpv4GatewaysResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_ipv_4gateways_with_options(request, runtime)

    async def list_ipv_4gateways_async(
        self,
        request: vpc_20160428_models.ListIpv4GatewaysRequest,
    ) -> vpc_20160428_models.ListIpv4GatewaysResponse:
        """
        @summary Queries IPv4 gateways.
        
        @param request: ListIpv4GatewaysRequest
        @return: ListIpv4GatewaysResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_ipv_4gateways_with_options_async(request, runtime)

    def list_nat_ip_cidrs_with_options(
        self,
        request: vpc_20160428_models.ListNatIpCidrsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListNatIpCidrsResponse:
        """
        @summary Queries the CIDR blocks of a specified NAT gateway.
        
        @param request: ListNatIpCidrsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListNatIpCidrsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.nat_ip_cidr):
            query['NatIpCidr'] = request.nat_ip_cidr
        if not UtilClient.is_unset(request.nat_ip_cidr_name):
            query['NatIpCidrName'] = request.nat_ip_cidr_name
        if not UtilClient.is_unset(request.nat_ip_cidr_status):
            query['NatIpCidrStatus'] = request.nat_ip_cidr_status
        if not UtilClient.is_unset(request.nat_ip_cidrs):
            query['NatIpCidrs'] = request.nat_ip_cidrs
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListNatIpCidrs',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListNatIpCidrsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_nat_ip_cidrs_with_options_async(
        self,
        request: vpc_20160428_models.ListNatIpCidrsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListNatIpCidrsResponse:
        """
        @summary Queries the CIDR blocks of a specified NAT gateway.
        
        @param request: ListNatIpCidrsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListNatIpCidrsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.nat_ip_cidr):
            query['NatIpCidr'] = request.nat_ip_cidr
        if not UtilClient.is_unset(request.nat_ip_cidr_name):
            query['NatIpCidrName'] = request.nat_ip_cidr_name
        if not UtilClient.is_unset(request.nat_ip_cidr_status):
            query['NatIpCidrStatus'] = request.nat_ip_cidr_status
        if not UtilClient.is_unset(request.nat_ip_cidrs):
            query['NatIpCidrs'] = request.nat_ip_cidrs
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListNatIpCidrs',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListNatIpCidrsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_nat_ip_cidrs(
        self,
        request: vpc_20160428_models.ListNatIpCidrsRequest,
    ) -> vpc_20160428_models.ListNatIpCidrsResponse:
        """
        @summary Queries the CIDR blocks of a specified NAT gateway.
        
        @param request: ListNatIpCidrsRequest
        @return: ListNatIpCidrsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_nat_ip_cidrs_with_options(request, runtime)

    async def list_nat_ip_cidrs_async(
        self,
        request: vpc_20160428_models.ListNatIpCidrsRequest,
    ) -> vpc_20160428_models.ListNatIpCidrsResponse:
        """
        @summary Queries the CIDR blocks of a specified NAT gateway.
        
        @param request: ListNatIpCidrsRequest
        @return: ListNatIpCidrsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_nat_ip_cidrs_with_options_async(request, runtime)

    def list_nat_ips_with_options(
        self,
        request: vpc_20160428_models.ListNatIpsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListNatIpsResponse:
        """
        @summary Queries the IP addresses on a NAT gateway.
        
        @param request: ListNatIpsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListNatIpsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.nat_ip_cidr):
            query['NatIpCidr'] = request.nat_ip_cidr
        if not UtilClient.is_unset(request.nat_ip_ids):
            query['NatIpIds'] = request.nat_ip_ids
        if not UtilClient.is_unset(request.nat_ip_name):
            query['NatIpName'] = request.nat_ip_name
        if not UtilClient.is_unset(request.nat_ip_status):
            query['NatIpStatus'] = request.nat_ip_status
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListNatIps',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListNatIpsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_nat_ips_with_options_async(
        self,
        request: vpc_20160428_models.ListNatIpsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListNatIpsResponse:
        """
        @summary Queries the IP addresses on a NAT gateway.
        
        @param request: ListNatIpsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListNatIpsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.nat_ip_cidr):
            query['NatIpCidr'] = request.nat_ip_cidr
        if not UtilClient.is_unset(request.nat_ip_ids):
            query['NatIpIds'] = request.nat_ip_ids
        if not UtilClient.is_unset(request.nat_ip_name):
            query['NatIpName'] = request.nat_ip_name
        if not UtilClient.is_unset(request.nat_ip_status):
            query['NatIpStatus'] = request.nat_ip_status
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListNatIps',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListNatIpsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_nat_ips(
        self,
        request: vpc_20160428_models.ListNatIpsRequest,
    ) -> vpc_20160428_models.ListNatIpsResponse:
        """
        @summary Queries the IP addresses on a NAT gateway.
        
        @param request: ListNatIpsRequest
        @return: ListNatIpsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_nat_ips_with_options(request, runtime)

    async def list_nat_ips_async(
        self,
        request: vpc_20160428_models.ListNatIpsRequest,
    ) -> vpc_20160428_models.ListNatIpsResponse:
        """
        @summary Queries the IP addresses on a NAT gateway.
        
        @param request: ListNatIpsRequest
        @return: ListNatIpsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_nat_ips_with_options_async(request, runtime)

    def list_prefix_lists_with_options(
        self,
        request: vpc_20160428_models.ListPrefixListsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListPrefixListsResponse:
        """
        @summary Queries prefix lists.
        
        @param request: ListPrefixListsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPrefixListsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_ids):
            query['PrefixListIds'] = request.prefix_list_ids
        if not UtilClient.is_unset(request.prefix_list_name):
            query['PrefixListName'] = request.prefix_list_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPrefixLists',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListPrefixListsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_prefix_lists_with_options_async(
        self,
        request: vpc_20160428_models.ListPrefixListsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListPrefixListsResponse:
        """
        @summary Queries prefix lists.
        
        @param request: ListPrefixListsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPrefixListsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_ids):
            query['PrefixListIds'] = request.prefix_list_ids
        if not UtilClient.is_unset(request.prefix_list_name):
            query['PrefixListName'] = request.prefix_list_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPrefixLists',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListPrefixListsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_prefix_lists(
        self,
        request: vpc_20160428_models.ListPrefixListsRequest,
    ) -> vpc_20160428_models.ListPrefixListsResponse:
        """
        @summary Queries prefix lists.
        
        @param request: ListPrefixListsRequest
        @return: ListPrefixListsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_prefix_lists_with_options(request, runtime)

    async def list_prefix_lists_async(
        self,
        request: vpc_20160428_models.ListPrefixListsRequest,
    ) -> vpc_20160428_models.ListPrefixListsResponse:
        """
        @summary Queries prefix lists.
        
        @param request: ListPrefixListsRequest
        @return: ListPrefixListsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_prefix_lists_with_options_async(request, runtime)

    def list_public_ip_address_pool_cidr_blocks_with_options(
        self,
        request: vpc_20160428_models.ListPublicIpAddressPoolCidrBlocksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListPublicIpAddressPoolCidrBlocksResponse:
        """
        @param request: ListPublicIpAddressPoolCidrBlocksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPublicIpAddressPoolCidrBlocksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cidr_block):
            query['CidrBlock'] = request.cidr_block
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.public_ip_address_pool_id):
            query['PublicIpAddressPoolId'] = request.public_ip_address_pool_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPublicIpAddressPoolCidrBlocks',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListPublicIpAddressPoolCidrBlocksResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_public_ip_address_pool_cidr_blocks_with_options_async(
        self,
        request: vpc_20160428_models.ListPublicIpAddressPoolCidrBlocksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListPublicIpAddressPoolCidrBlocksResponse:
        """
        @param request: ListPublicIpAddressPoolCidrBlocksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPublicIpAddressPoolCidrBlocksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cidr_block):
            query['CidrBlock'] = request.cidr_block
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.public_ip_address_pool_id):
            query['PublicIpAddressPoolId'] = request.public_ip_address_pool_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPublicIpAddressPoolCidrBlocks',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListPublicIpAddressPoolCidrBlocksResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_public_ip_address_pool_cidr_blocks(
        self,
        request: vpc_20160428_models.ListPublicIpAddressPoolCidrBlocksRequest,
    ) -> vpc_20160428_models.ListPublicIpAddressPoolCidrBlocksResponse:
        """
        @param request: ListPublicIpAddressPoolCidrBlocksRequest
        @return: ListPublicIpAddressPoolCidrBlocksResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_public_ip_address_pool_cidr_blocks_with_options(request, runtime)

    async def list_public_ip_address_pool_cidr_blocks_async(
        self,
        request: vpc_20160428_models.ListPublicIpAddressPoolCidrBlocksRequest,
    ) -> vpc_20160428_models.ListPublicIpAddressPoolCidrBlocksResponse:
        """
        @param request: ListPublicIpAddressPoolCidrBlocksRequest
        @return: ListPublicIpAddressPoolCidrBlocksResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_public_ip_address_pool_cidr_blocks_with_options_async(request, runtime)

    def list_public_ip_address_pools_with_options(
        self,
        request: vpc_20160428_models.ListPublicIpAddressPoolsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListPublicIpAddressPoolsResponse:
        """
        @summary Queries available IP address pools.
        
        @param request: ListPublicIpAddressPoolsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPublicIpAddressPoolsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.isp):
            query['Isp'] = request.isp
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.public_ip_address_pool_ids):
            query['PublicIpAddressPoolIds'] = request.public_ip_address_pool_ids
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_protection_enabled):
            query['SecurityProtectionEnabled'] = request.security_protection_enabled
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPublicIpAddressPools',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListPublicIpAddressPoolsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_public_ip_address_pools_with_options_async(
        self,
        request: vpc_20160428_models.ListPublicIpAddressPoolsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListPublicIpAddressPoolsResponse:
        """
        @summary Queries available IP address pools.
        
        @param request: ListPublicIpAddressPoolsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPublicIpAddressPoolsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.isp):
            query['Isp'] = request.isp
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.public_ip_address_pool_ids):
            query['PublicIpAddressPoolIds'] = request.public_ip_address_pool_ids
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.security_protection_enabled):
            query['SecurityProtectionEnabled'] = request.security_protection_enabled
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPublicIpAddressPools',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListPublicIpAddressPoolsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_public_ip_address_pools(
        self,
        request: vpc_20160428_models.ListPublicIpAddressPoolsRequest,
    ) -> vpc_20160428_models.ListPublicIpAddressPoolsResponse:
        """
        @summary Queries available IP address pools.
        
        @param request: ListPublicIpAddressPoolsRequest
        @return: ListPublicIpAddressPoolsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_public_ip_address_pools_with_options(request, runtime)

    async def list_public_ip_address_pools_async(
        self,
        request: vpc_20160428_models.ListPublicIpAddressPoolsRequest,
    ) -> vpc_20160428_models.ListPublicIpAddressPoolsResponse:
        """
        @summary Queries available IP address pools.
        
        @param request: ListPublicIpAddressPoolsRequest
        @return: ListPublicIpAddressPoolsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_public_ip_address_pools_with_options_async(request, runtime)

    def list_tag_resources_with_options(
        self,
        request: vpc_20160428_models.ListTagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListTagResourcesResponse:
        """
        @summary Queries the tags that are added to resources.
        
        @description ## Usage notes
        You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
        **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
        If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
        If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
        
        @param request: ListTagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTagResources',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListTagResourcesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_tag_resources_with_options_async(
        self,
        request: vpc_20160428_models.ListTagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListTagResourcesResponse:
        """
        @summary Queries the tags that are added to resources.
        
        @description ## Usage notes
        You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
        **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
        If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
        If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
        
        @param request: ListTagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTagResources',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListTagResourcesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_tag_resources(
        self,
        request: vpc_20160428_models.ListTagResourcesRequest,
    ) -> vpc_20160428_models.ListTagResourcesResponse:
        """
        @summary Queries the tags that are added to resources.
        
        @description ## Usage notes
        You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
        **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
        If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
        If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
        
        @param request: ListTagResourcesRequest
        @return: ListTagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_tag_resources_with_options(request, runtime)

    async def list_tag_resources_async(
        self,
        request: vpc_20160428_models.ListTagResourcesRequest,
    ) -> vpc_20160428_models.ListTagResourcesResponse:
        """
        @summary Queries the tags that are added to resources.
        
        @description ## Usage notes
        You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
        **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
        If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
        If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
        
        @param request: ListTagResourcesRequest
        @return: ListTagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_tag_resources_with_options_async(request, runtime)

    def list_tag_resources_for_express_connect_with_options(
        self,
        request: vpc_20160428_models.ListTagResourcesForExpressConnectRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListTagResourcesForExpressConnectResponse:
        """
        @summary Queries the tags that are added to an Express Connect circuit.
        
        @description ## [](#)
        If you want to query a specific object, you must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request.
        **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
        If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
        If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
        
        @param request: ListTagResourcesForExpressConnectRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTagResourcesForExpressConnectResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTagResourcesForExpressConnect',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListTagResourcesForExpressConnectResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_tag_resources_for_express_connect_with_options_async(
        self,
        request: vpc_20160428_models.ListTagResourcesForExpressConnectRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListTagResourcesForExpressConnectResponse:
        """
        @summary Queries the tags that are added to an Express Connect circuit.
        
        @description ## [](#)
        If you want to query a specific object, you must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request.
        **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
        If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
        If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
        
        @param request: ListTagResourcesForExpressConnectRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTagResourcesForExpressConnectResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTagResourcesForExpressConnect',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListTagResourcesForExpressConnectResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_tag_resources_for_express_connect(
        self,
        request: vpc_20160428_models.ListTagResourcesForExpressConnectRequest,
    ) -> vpc_20160428_models.ListTagResourcesForExpressConnectResponse:
        """
        @summary Queries the tags that are added to an Express Connect circuit.
        
        @description ## [](#)
        If you want to query a specific object, you must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request.
        **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
        If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
        If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
        
        @param request: ListTagResourcesForExpressConnectRequest
        @return: ListTagResourcesForExpressConnectResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_tag_resources_for_express_connect_with_options(request, runtime)

    async def list_tag_resources_for_express_connect_async(
        self,
        request: vpc_20160428_models.ListTagResourcesForExpressConnectRequest,
    ) -> vpc_20160428_models.ListTagResourcesForExpressConnectResponse:
        """
        @summary Queries the tags that are added to an Express Connect circuit.
        
        @description ## [](#)
        If you want to query a specific object, you must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request.
        **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
        If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
        If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
        
        @param request: ListTagResourcesForExpressConnectRequest
        @return: ListTagResourcesForExpressConnectResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_tag_resources_for_express_connect_with_options_async(request, runtime)

    def list_traffic_mirror_filters_with_options(
        self,
        request: vpc_20160428_models.ListTrafficMirrorFiltersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListTrafficMirrorFiltersResponse:
        """
        @summary Queries filters for traffic mirroring.
        
        @param request: ListTrafficMirrorFiltersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTrafficMirrorFiltersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.traffic_mirror_filter_ids):
            query['TrafficMirrorFilterIds'] = request.traffic_mirror_filter_ids
        if not UtilClient.is_unset(request.traffic_mirror_filter_name):
            query['TrafficMirrorFilterName'] = request.traffic_mirror_filter_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTrafficMirrorFilters',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListTrafficMirrorFiltersResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_traffic_mirror_filters_with_options_async(
        self,
        request: vpc_20160428_models.ListTrafficMirrorFiltersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListTrafficMirrorFiltersResponse:
        """
        @summary Queries filters for traffic mirroring.
        
        @param request: ListTrafficMirrorFiltersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTrafficMirrorFiltersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.traffic_mirror_filter_ids):
            query['TrafficMirrorFilterIds'] = request.traffic_mirror_filter_ids
        if not UtilClient.is_unset(request.traffic_mirror_filter_name):
            query['TrafficMirrorFilterName'] = request.traffic_mirror_filter_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTrafficMirrorFilters',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListTrafficMirrorFiltersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_traffic_mirror_filters(
        self,
        request: vpc_20160428_models.ListTrafficMirrorFiltersRequest,
    ) -> vpc_20160428_models.ListTrafficMirrorFiltersResponse:
        """
        @summary Queries filters for traffic mirroring.
        
        @param request: ListTrafficMirrorFiltersRequest
        @return: ListTrafficMirrorFiltersResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_traffic_mirror_filters_with_options(request, runtime)

    async def list_traffic_mirror_filters_async(
        self,
        request: vpc_20160428_models.ListTrafficMirrorFiltersRequest,
    ) -> vpc_20160428_models.ListTrafficMirrorFiltersResponse:
        """
        @summary Queries filters for traffic mirroring.
        
        @param request: ListTrafficMirrorFiltersRequest
        @return: ListTrafficMirrorFiltersResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_traffic_mirror_filters_with_options_async(request, runtime)

    def list_traffic_mirror_sessions_with_options(
        self,
        request: vpc_20160428_models.ListTrafficMirrorSessionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListTrafficMirrorSessionsResponse:
        """
        @summary Queries the details of a traffic mirror session.
        
        @param request: ListTrafficMirrorSessionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTrafficMirrorSessionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.enabled):
            query['Enabled'] = request.enabled
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.traffic_mirror_filter_id):
            query['TrafficMirrorFilterId'] = request.traffic_mirror_filter_id
        if not UtilClient.is_unset(request.traffic_mirror_session_ids):
            query['TrafficMirrorSessionIds'] = request.traffic_mirror_session_ids
        if not UtilClient.is_unset(request.traffic_mirror_session_name):
            query['TrafficMirrorSessionName'] = request.traffic_mirror_session_name
        if not UtilClient.is_unset(request.traffic_mirror_source_id):
            query['TrafficMirrorSourceId'] = request.traffic_mirror_source_id
        if not UtilClient.is_unset(request.traffic_mirror_target_id):
            query['TrafficMirrorTargetId'] = request.traffic_mirror_target_id
        if not UtilClient.is_unset(request.virtual_network_id):
            query['VirtualNetworkId'] = request.virtual_network_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTrafficMirrorSessions',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListTrafficMirrorSessionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_traffic_mirror_sessions_with_options_async(
        self,
        request: vpc_20160428_models.ListTrafficMirrorSessionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListTrafficMirrorSessionsResponse:
        """
        @summary Queries the details of a traffic mirror session.
        
        @param request: ListTrafficMirrorSessionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTrafficMirrorSessionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.enabled):
            query['Enabled'] = request.enabled
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.traffic_mirror_filter_id):
            query['TrafficMirrorFilterId'] = request.traffic_mirror_filter_id
        if not UtilClient.is_unset(request.traffic_mirror_session_ids):
            query['TrafficMirrorSessionIds'] = request.traffic_mirror_session_ids
        if not UtilClient.is_unset(request.traffic_mirror_session_name):
            query['TrafficMirrorSessionName'] = request.traffic_mirror_session_name
        if not UtilClient.is_unset(request.traffic_mirror_source_id):
            query['TrafficMirrorSourceId'] = request.traffic_mirror_source_id
        if not UtilClient.is_unset(request.traffic_mirror_target_id):
            query['TrafficMirrorTargetId'] = request.traffic_mirror_target_id
        if not UtilClient.is_unset(request.virtual_network_id):
            query['VirtualNetworkId'] = request.virtual_network_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTrafficMirrorSessions',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListTrafficMirrorSessionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_traffic_mirror_sessions(
        self,
        request: vpc_20160428_models.ListTrafficMirrorSessionsRequest,
    ) -> vpc_20160428_models.ListTrafficMirrorSessionsResponse:
        """
        @summary Queries the details of a traffic mirror session.
        
        @param request: ListTrafficMirrorSessionsRequest
        @return: ListTrafficMirrorSessionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_traffic_mirror_sessions_with_options(request, runtime)

    async def list_traffic_mirror_sessions_async(
        self,
        request: vpc_20160428_models.ListTrafficMirrorSessionsRequest,
    ) -> vpc_20160428_models.ListTrafficMirrorSessionsResponse:
        """
        @summary Queries the details of a traffic mirror session.
        
        @param request: ListTrafficMirrorSessionsRequest
        @return: ListTrafficMirrorSessionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_traffic_mirror_sessions_with_options_async(request, runtime)

    def list_vswitch_cidr_reservations_with_options(
        self,
        request: vpc_20160428_models.ListVSwitchCidrReservationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListVSwitchCidrReservationsResponse:
        """
        @summary Queries the CIDR reservation information about vSwitches.
        
        @param request: ListVSwitchCidrReservationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVSwitchCidrReservationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ip_version):
            query['IpVersion'] = request.ip_version
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_ids):
            query['VSwitchCidrReservationIds'] = request.v_switch_cidr_reservation_ids
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_type):
            query['VSwitchCidrReservationType'] = request.v_switch_cidr_reservation_type
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVSwitchCidrReservations',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListVSwitchCidrReservationsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_vswitch_cidr_reservations_with_options_async(
        self,
        request: vpc_20160428_models.ListVSwitchCidrReservationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListVSwitchCidrReservationsResponse:
        """
        @summary Queries the CIDR reservation information about vSwitches.
        
        @param request: ListVSwitchCidrReservationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVSwitchCidrReservationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ip_version):
            query['IpVersion'] = request.ip_version
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_ids):
            query['VSwitchCidrReservationIds'] = request.v_switch_cidr_reservation_ids
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_type):
            query['VSwitchCidrReservationType'] = request.v_switch_cidr_reservation_type
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVSwitchCidrReservations',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListVSwitchCidrReservationsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_vswitch_cidr_reservations(
        self,
        request: vpc_20160428_models.ListVSwitchCidrReservationsRequest,
    ) -> vpc_20160428_models.ListVSwitchCidrReservationsResponse:
        """
        @summary Queries the CIDR reservation information about vSwitches.
        
        @param request: ListVSwitchCidrReservationsRequest
        @return: ListVSwitchCidrReservationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_vswitch_cidr_reservations_with_options(request, runtime)

    async def list_vswitch_cidr_reservations_async(
        self,
        request: vpc_20160428_models.ListVSwitchCidrReservationsRequest,
    ) -> vpc_20160428_models.ListVSwitchCidrReservationsResponse:
        """
        @summary Queries the CIDR reservation information about vSwitches.
        
        @param request: ListVSwitchCidrReservationsRequest
        @return: ListVSwitchCidrReservationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_vswitch_cidr_reservations_with_options_async(request, runtime)

    def list_virtual_physical_connections_with_options(
        self,
        request: vpc_20160428_models.ListVirtualPhysicalConnectionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListVirtualPhysicalConnectionsResponse:
        """
        @summary Queries hosted connections.
        
        @param request: ListVirtualPhysicalConnectionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVirtualPhysicalConnectionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.is_confirmed):
            query['IsConfirmed'] = request.is_confirmed
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.virtual_physical_connection_ali_uids):
            query['VirtualPhysicalConnectionAliUids'] = request.virtual_physical_connection_ali_uids
        if not UtilClient.is_unset(request.virtual_physical_connection_business_status):
            query['VirtualPhysicalConnectionBusinessStatus'] = request.virtual_physical_connection_business_status
        if not UtilClient.is_unset(request.virtual_physical_connection_ids):
            query['VirtualPhysicalConnectionIds'] = request.virtual_physical_connection_ids
        if not UtilClient.is_unset(request.virtual_physical_connection_statuses):
            query['VirtualPhysicalConnectionStatuses'] = request.virtual_physical_connection_statuses
        if not UtilClient.is_unset(request.vlan_ids):
            query['VlanIds'] = request.vlan_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVirtualPhysicalConnections',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListVirtualPhysicalConnectionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_virtual_physical_connections_with_options_async(
        self,
        request: vpc_20160428_models.ListVirtualPhysicalConnectionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListVirtualPhysicalConnectionsResponse:
        """
        @summary Queries hosted connections.
        
        @param request: ListVirtualPhysicalConnectionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVirtualPhysicalConnectionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.is_confirmed):
            query['IsConfirmed'] = request.is_confirmed
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.virtual_physical_connection_ali_uids):
            query['VirtualPhysicalConnectionAliUids'] = request.virtual_physical_connection_ali_uids
        if not UtilClient.is_unset(request.virtual_physical_connection_business_status):
            query['VirtualPhysicalConnectionBusinessStatus'] = request.virtual_physical_connection_business_status
        if not UtilClient.is_unset(request.virtual_physical_connection_ids):
            query['VirtualPhysicalConnectionIds'] = request.virtual_physical_connection_ids
        if not UtilClient.is_unset(request.virtual_physical_connection_statuses):
            query['VirtualPhysicalConnectionStatuses'] = request.virtual_physical_connection_statuses
        if not UtilClient.is_unset(request.vlan_ids):
            query['VlanIds'] = request.vlan_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVirtualPhysicalConnections',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListVirtualPhysicalConnectionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_virtual_physical_connections(
        self,
        request: vpc_20160428_models.ListVirtualPhysicalConnectionsRequest,
    ) -> vpc_20160428_models.ListVirtualPhysicalConnectionsResponse:
        """
        @summary Queries hosted connections.
        
        @param request: ListVirtualPhysicalConnectionsRequest
        @return: ListVirtualPhysicalConnectionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_virtual_physical_connections_with_options(request, runtime)

    async def list_virtual_physical_connections_async(
        self,
        request: vpc_20160428_models.ListVirtualPhysicalConnectionsRequest,
    ) -> vpc_20160428_models.ListVirtualPhysicalConnectionsResponse:
        """
        @summary Queries hosted connections.
        
        @param request: ListVirtualPhysicalConnectionsRequest
        @return: ListVirtualPhysicalConnectionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_virtual_physical_connections_with_options_async(request, runtime)

    def list_vpc_endpoint_services_by_end_user_with_options(
        self,
        request: vpc_20160428_models.ListVpcEndpointServicesByEndUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListVpcEndpointServicesByEndUserResponse:
        """
        @summary Queries available endpoint services.
        
        @param request: ListVpcEndpointServicesByEndUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVpcEndpointServicesByEndUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.service_name):
            query['ServiceName'] = request.service_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVpcEndpointServicesByEndUser',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListVpcEndpointServicesByEndUserResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_vpc_endpoint_services_by_end_user_with_options_async(
        self,
        request: vpc_20160428_models.ListVpcEndpointServicesByEndUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListVpcEndpointServicesByEndUserResponse:
        """
        @summary Queries available endpoint services.
        
        @param request: ListVpcEndpointServicesByEndUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVpcEndpointServicesByEndUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.service_name):
            query['ServiceName'] = request.service_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVpcEndpointServicesByEndUser',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListVpcEndpointServicesByEndUserResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_vpc_endpoint_services_by_end_user(
        self,
        request: vpc_20160428_models.ListVpcEndpointServicesByEndUserRequest,
    ) -> vpc_20160428_models.ListVpcEndpointServicesByEndUserResponse:
        """
        @summary Queries available endpoint services.
        
        @param request: ListVpcEndpointServicesByEndUserRequest
        @return: ListVpcEndpointServicesByEndUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_vpc_endpoint_services_by_end_user_with_options(request, runtime)

    async def list_vpc_endpoint_services_by_end_user_async(
        self,
        request: vpc_20160428_models.ListVpcEndpointServicesByEndUserRequest,
    ) -> vpc_20160428_models.ListVpcEndpointServicesByEndUserResponse:
        """
        @summary Queries available endpoint services.
        
        @param request: ListVpcEndpointServicesByEndUserRequest
        @return: ListVpcEndpointServicesByEndUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_vpc_endpoint_services_by_end_user_with_options_async(request, runtime)

    def list_vpc_gateway_endpoints_with_options(
        self,
        request: vpc_20160428_models.ListVpcGatewayEndpointsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListVpcGatewayEndpointsResponse:
        """
        @summary Queries gateway endpoints.
        
        @param request: ListVpcGatewayEndpointsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVpcGatewayEndpointsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.endpoint_id):
            query['EndpointId'] = request.endpoint_id
        if not UtilClient.is_unset(request.endpoint_name):
            query['EndpointName'] = request.endpoint_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.service_name):
            query['ServiceName'] = request.service_name
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVpcGatewayEndpoints',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListVpcGatewayEndpointsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_vpc_gateway_endpoints_with_options_async(
        self,
        request: vpc_20160428_models.ListVpcGatewayEndpointsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListVpcGatewayEndpointsResponse:
        """
        @summary Queries gateway endpoints.
        
        @param request: ListVpcGatewayEndpointsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVpcGatewayEndpointsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.endpoint_id):
            query['EndpointId'] = request.endpoint_id
        if not UtilClient.is_unset(request.endpoint_name):
            query['EndpointName'] = request.endpoint_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.service_name):
            query['ServiceName'] = request.service_name
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVpcGatewayEndpoints',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListVpcGatewayEndpointsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_vpc_gateway_endpoints(
        self,
        request: vpc_20160428_models.ListVpcGatewayEndpointsRequest,
    ) -> vpc_20160428_models.ListVpcGatewayEndpointsResponse:
        """
        @summary Queries gateway endpoints.
        
        @param request: ListVpcGatewayEndpointsRequest
        @return: ListVpcGatewayEndpointsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_vpc_gateway_endpoints_with_options(request, runtime)

    async def list_vpc_gateway_endpoints_async(
        self,
        request: vpc_20160428_models.ListVpcGatewayEndpointsRequest,
    ) -> vpc_20160428_models.ListVpcGatewayEndpointsResponse:
        """
        @summary Queries gateway endpoints.
        
        @param request: ListVpcGatewayEndpointsRequest
        @return: ListVpcGatewayEndpointsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_vpc_gateway_endpoints_with_options_async(request, runtime)

    def list_vpn_certificate_associations_with_options(
        self,
        request: vpc_20160428_models.ListVpnCertificateAssociationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListVpnCertificateAssociationsResponse:
        """
        @summary Queries the association between VPN gateways and certificates in a region.
        
        @description When you call *ListVpnCertificateAssociations**, take note of the following information:
        If you specify only **RegionId**, the SSL certificates associated with all VPN gateways in the specified region are queried.
        If you specify **RegionId** and **CertificateType**, the SSL certificates of the specified type that are associated with the VPN gateways in the specified region are queried.
        If you specify **RegionId** and **VpnGatewayId**, the SSL certificates associated with the specified VPN gateway in the specified region are queried.
        If you specify **RegionId** and **CertificateId**, the VPN gateways associated with the specified SSL certificate in the specified region are queried.
        
        @param request: ListVpnCertificateAssociationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVpnCertificateAssociationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.certificate_id):
            query['CertificateId'] = request.certificate_id
        if not UtilClient.is_unset(request.certificate_type):
            query['CertificateType'] = request.certificate_type
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVpnCertificateAssociations',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListVpnCertificateAssociationsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_vpn_certificate_associations_with_options_async(
        self,
        request: vpc_20160428_models.ListVpnCertificateAssociationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ListVpnCertificateAssociationsResponse:
        """
        @summary Queries the association between VPN gateways and certificates in a region.
        
        @description When you call *ListVpnCertificateAssociations**, take note of the following information:
        If you specify only **RegionId**, the SSL certificates associated with all VPN gateways in the specified region are queried.
        If you specify **RegionId** and **CertificateType**, the SSL certificates of the specified type that are associated with the VPN gateways in the specified region are queried.
        If you specify **RegionId** and **VpnGatewayId**, the SSL certificates associated with the specified VPN gateway in the specified region are queried.
        If you specify **RegionId** and **CertificateId**, the VPN gateways associated with the specified SSL certificate in the specified region are queried.
        
        @param request: ListVpnCertificateAssociationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVpnCertificateAssociationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.certificate_id):
            query['CertificateId'] = request.certificate_id
        if not UtilClient.is_unset(request.certificate_type):
            query['CertificateType'] = request.certificate_type
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVpnCertificateAssociations',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ListVpnCertificateAssociationsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_vpn_certificate_associations(
        self,
        request: vpc_20160428_models.ListVpnCertificateAssociationsRequest,
    ) -> vpc_20160428_models.ListVpnCertificateAssociationsResponse:
        """
        @summary Queries the association between VPN gateways and certificates in a region.
        
        @description When you call *ListVpnCertificateAssociations**, take note of the following information:
        If you specify only **RegionId**, the SSL certificates associated with all VPN gateways in the specified region are queried.
        If you specify **RegionId** and **CertificateType**, the SSL certificates of the specified type that are associated with the VPN gateways in the specified region are queried.
        If you specify **RegionId** and **VpnGatewayId**, the SSL certificates associated with the specified VPN gateway in the specified region are queried.
        If you specify **RegionId** and **CertificateId**, the VPN gateways associated with the specified SSL certificate in the specified region are queried.
        
        @param request: ListVpnCertificateAssociationsRequest
        @return: ListVpnCertificateAssociationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_vpn_certificate_associations_with_options(request, runtime)

    async def list_vpn_certificate_associations_async(
        self,
        request: vpc_20160428_models.ListVpnCertificateAssociationsRequest,
    ) -> vpc_20160428_models.ListVpnCertificateAssociationsResponse:
        """
        @summary Queries the association between VPN gateways and certificates in a region.
        
        @description When you call *ListVpnCertificateAssociations**, take note of the following information:
        If you specify only **RegionId**, the SSL certificates associated with all VPN gateways in the specified region are queried.
        If you specify **RegionId** and **CertificateType**, the SSL certificates of the specified type that are associated with the VPN gateways in the specified region are queried.
        If you specify **RegionId** and **VpnGatewayId**, the SSL certificates associated with the specified VPN gateway in the specified region are queried.
        If you specify **RegionId** and **CertificateId**, the VPN gateways associated with the specified SSL certificate in the specified region are queried.
        
        @param request: ListVpnCertificateAssociationsRequest
        @return: ListVpnCertificateAssociationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_vpn_certificate_associations_with_options_async(request, runtime)

    def modify_bgp_group_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyBgpGroupAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyBgpGroupAttributeResponse:
        """
        @summary Modifies the configuration of a Border Gateway Protocol (BGP) group.
        
        @param request: ModifyBgpGroupAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyBgpGroupAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auth_key):
            query['AuthKey'] = request.auth_key
        if not UtilClient.is_unset(request.bgp_group_id):
            query['BgpGroupId'] = request.bgp_group_id
        if not UtilClient.is_unset(request.clear_auth_key):
            query['ClearAuthKey'] = request.clear_auth_key
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.is_fake_asn):
            query['IsFakeAsn'] = request.is_fake_asn
        if not UtilClient.is_unset(request.local_asn):
            query['LocalAsn'] = request.local_asn
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_asn):
            query['PeerAsn'] = request.peer_asn
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_quota):
            query['RouteQuota'] = request.route_quota
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyBgpGroupAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyBgpGroupAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_bgp_group_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyBgpGroupAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyBgpGroupAttributeResponse:
        """
        @summary Modifies the configuration of a Border Gateway Protocol (BGP) group.
        
        @param request: ModifyBgpGroupAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyBgpGroupAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auth_key):
            query['AuthKey'] = request.auth_key
        if not UtilClient.is_unset(request.bgp_group_id):
            query['BgpGroupId'] = request.bgp_group_id
        if not UtilClient.is_unset(request.clear_auth_key):
            query['ClearAuthKey'] = request.clear_auth_key
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.is_fake_asn):
            query['IsFakeAsn'] = request.is_fake_asn
        if not UtilClient.is_unset(request.local_asn):
            query['LocalAsn'] = request.local_asn
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_asn):
            query['PeerAsn'] = request.peer_asn
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_quota):
            query['RouteQuota'] = request.route_quota
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyBgpGroupAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyBgpGroupAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_bgp_group_attribute(
        self,
        request: vpc_20160428_models.ModifyBgpGroupAttributeRequest,
    ) -> vpc_20160428_models.ModifyBgpGroupAttributeResponse:
        """
        @summary Modifies the configuration of a Border Gateway Protocol (BGP) group.
        
        @param request: ModifyBgpGroupAttributeRequest
        @return: ModifyBgpGroupAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_bgp_group_attribute_with_options(request, runtime)

    async def modify_bgp_group_attribute_async(
        self,
        request: vpc_20160428_models.ModifyBgpGroupAttributeRequest,
    ) -> vpc_20160428_models.ModifyBgpGroupAttributeResponse:
        """
        @summary Modifies the configuration of a Border Gateway Protocol (BGP) group.
        
        @param request: ModifyBgpGroupAttributeRequest
        @return: ModifyBgpGroupAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_bgp_group_attribute_with_options_async(request, runtime)

    def modify_bgp_peer_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyBgpPeerAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyBgpPeerAttributeResponse:
        """
        @summary Modifies the configuration of a BGP peer.
        
        @param request: ModifyBgpPeerAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyBgpPeerAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bfd_multi_hop):
            query['BfdMultiHop'] = request.bfd_multi_hop
        if not UtilClient.is_unset(request.bgp_group_id):
            query['BgpGroupId'] = request.bgp_group_id
        if not UtilClient.is_unset(request.bgp_peer_id):
            query['BgpPeerId'] = request.bgp_peer_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.enable_bfd):
            query['EnableBfd'] = request.enable_bfd
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_ip_address):
            query['PeerIpAddress'] = request.peer_ip_address
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyBgpPeerAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyBgpPeerAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_bgp_peer_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyBgpPeerAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyBgpPeerAttributeResponse:
        """
        @summary Modifies the configuration of a BGP peer.
        
        @param request: ModifyBgpPeerAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyBgpPeerAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bfd_multi_hop):
            query['BfdMultiHop'] = request.bfd_multi_hop
        if not UtilClient.is_unset(request.bgp_group_id):
            query['BgpGroupId'] = request.bgp_group_id
        if not UtilClient.is_unset(request.bgp_peer_id):
            query['BgpPeerId'] = request.bgp_peer_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.enable_bfd):
            query['EnableBfd'] = request.enable_bfd
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_ip_address):
            query['PeerIpAddress'] = request.peer_ip_address
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyBgpPeerAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyBgpPeerAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_bgp_peer_attribute(
        self,
        request: vpc_20160428_models.ModifyBgpPeerAttributeRequest,
    ) -> vpc_20160428_models.ModifyBgpPeerAttributeResponse:
        """
        @summary Modifies the configuration of a BGP peer.
        
        @param request: ModifyBgpPeerAttributeRequest
        @return: ModifyBgpPeerAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_bgp_peer_attribute_with_options(request, runtime)

    async def modify_bgp_peer_attribute_async(
        self,
        request: vpc_20160428_models.ModifyBgpPeerAttributeRequest,
    ) -> vpc_20160428_models.ModifyBgpPeerAttributeResponse:
        """
        @summary Modifies the configuration of a BGP peer.
        
        @param request: ModifyBgpPeerAttributeRequest
        @return: ModifyBgpPeerAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_bgp_peer_attribute_with_options_async(request, runtime)

    def modify_common_bandwidth_package_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyCommonBandwidthPackageAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyCommonBandwidthPackageAttributeResponse:
        """
        @summary Modifies the name and description of an EIP bandwidth plan.
        
        @param request: ModifyCommonBandwidthPackageAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCommonBandwidthPackageAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCommonBandwidthPackageAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyCommonBandwidthPackageAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_common_bandwidth_package_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyCommonBandwidthPackageAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyCommonBandwidthPackageAttributeResponse:
        """
        @summary Modifies the name and description of an EIP bandwidth plan.
        
        @param request: ModifyCommonBandwidthPackageAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCommonBandwidthPackageAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCommonBandwidthPackageAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyCommonBandwidthPackageAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_common_bandwidth_package_attribute(
        self,
        request: vpc_20160428_models.ModifyCommonBandwidthPackageAttributeRequest,
    ) -> vpc_20160428_models.ModifyCommonBandwidthPackageAttributeResponse:
        """
        @summary Modifies the name and description of an EIP bandwidth plan.
        
        @param request: ModifyCommonBandwidthPackageAttributeRequest
        @return: ModifyCommonBandwidthPackageAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_common_bandwidth_package_attribute_with_options(request, runtime)

    async def modify_common_bandwidth_package_attribute_async(
        self,
        request: vpc_20160428_models.ModifyCommonBandwidthPackageAttributeRequest,
    ) -> vpc_20160428_models.ModifyCommonBandwidthPackageAttributeResponse:
        """
        @summary Modifies the name and description of an EIP bandwidth plan.
        
        @param request: ModifyCommonBandwidthPackageAttributeRequest
        @return: ModifyCommonBandwidthPackageAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_common_bandwidth_package_attribute_with_options_async(request, runtime)

    def modify_common_bandwidth_package_ip_bandwidth_with_options(
        self,
        request: vpc_20160428_models.ModifyCommonBandwidthPackageIpBandwidthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyCommonBandwidthPackageIpBandwidthResponse:
        """
        @summary Sets the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance.
        
        @description You can call the *ModifyCommonBandwidthPackageIpBandwidth** operation to set the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance. This prevents an EIP from exhausting the bandwidth resources of an Internet Shared Bandwidth instance.
        For example, two EIPs are associated with an Internet Shared Bandwidth instance whose maximum bandwidth is 800 Mbit/s. In this case, you can set the maximum bandwidth of one EIP to 500 Mbit/s and that of the other EIP to 400 Mbit/s. After you set the maximum bandwidth values, the first EIP cannot consume bandwidth higher than 500 Mbit/s. The second EIP cannot consume bandwidth higher than 400 Mbit/s.
        When you call this operation, take note of the following items:
        This operation is valid only for EIPs that are associated with Elastic Compute Service (ECS) instances. This operation is invalid for EIPs that are associated with Server Load Balancer (SLB) instances, NAT gateways, secondary elastic network interfaces (ENIs), or high-availability virtual IP addresses (HAVIPs).
        This operation is in public preview. You can call this operation to set the maximum bandwidth of EIPs only if the EIPs are associated with an Internet Shared Bandwidth instance. The feature is not supported in the console.
        You cannot repeatedly call this operation to set the maximum bandwidth of an EIP within the specified period of time.
        
        @param request: ModifyCommonBandwidthPackageIpBandwidthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCommonBandwidthPackageIpBandwidthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.eip_id):
            query['EipId'] = request.eip_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCommonBandwidthPackageIpBandwidth',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyCommonBandwidthPackageIpBandwidthResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_common_bandwidth_package_ip_bandwidth_with_options_async(
        self,
        request: vpc_20160428_models.ModifyCommonBandwidthPackageIpBandwidthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyCommonBandwidthPackageIpBandwidthResponse:
        """
        @summary Sets the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance.
        
        @description You can call the *ModifyCommonBandwidthPackageIpBandwidth** operation to set the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance. This prevents an EIP from exhausting the bandwidth resources of an Internet Shared Bandwidth instance.
        For example, two EIPs are associated with an Internet Shared Bandwidth instance whose maximum bandwidth is 800 Mbit/s. In this case, you can set the maximum bandwidth of one EIP to 500 Mbit/s and that of the other EIP to 400 Mbit/s. After you set the maximum bandwidth values, the first EIP cannot consume bandwidth higher than 500 Mbit/s. The second EIP cannot consume bandwidth higher than 400 Mbit/s.
        When you call this operation, take note of the following items:
        This operation is valid only for EIPs that are associated with Elastic Compute Service (ECS) instances. This operation is invalid for EIPs that are associated with Server Load Balancer (SLB) instances, NAT gateways, secondary elastic network interfaces (ENIs), or high-availability virtual IP addresses (HAVIPs).
        This operation is in public preview. You can call this operation to set the maximum bandwidth of EIPs only if the EIPs are associated with an Internet Shared Bandwidth instance. The feature is not supported in the console.
        You cannot repeatedly call this operation to set the maximum bandwidth of an EIP within the specified period of time.
        
        @param request: ModifyCommonBandwidthPackageIpBandwidthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCommonBandwidthPackageIpBandwidthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.eip_id):
            query['EipId'] = request.eip_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCommonBandwidthPackageIpBandwidth',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyCommonBandwidthPackageIpBandwidthResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_common_bandwidth_package_ip_bandwidth(
        self,
        request: vpc_20160428_models.ModifyCommonBandwidthPackageIpBandwidthRequest,
    ) -> vpc_20160428_models.ModifyCommonBandwidthPackageIpBandwidthResponse:
        """
        @summary Sets the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance.
        
        @description You can call the *ModifyCommonBandwidthPackageIpBandwidth** operation to set the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance. This prevents an EIP from exhausting the bandwidth resources of an Internet Shared Bandwidth instance.
        For example, two EIPs are associated with an Internet Shared Bandwidth instance whose maximum bandwidth is 800 Mbit/s. In this case, you can set the maximum bandwidth of one EIP to 500 Mbit/s and that of the other EIP to 400 Mbit/s. After you set the maximum bandwidth values, the first EIP cannot consume bandwidth higher than 500 Mbit/s. The second EIP cannot consume bandwidth higher than 400 Mbit/s.
        When you call this operation, take note of the following items:
        This operation is valid only for EIPs that are associated with Elastic Compute Service (ECS) instances. This operation is invalid for EIPs that are associated with Server Load Balancer (SLB) instances, NAT gateways, secondary elastic network interfaces (ENIs), or high-availability virtual IP addresses (HAVIPs).
        This operation is in public preview. You can call this operation to set the maximum bandwidth of EIPs only if the EIPs are associated with an Internet Shared Bandwidth instance. The feature is not supported in the console.
        You cannot repeatedly call this operation to set the maximum bandwidth of an EIP within the specified period of time.
        
        @param request: ModifyCommonBandwidthPackageIpBandwidthRequest
        @return: ModifyCommonBandwidthPackageIpBandwidthResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_common_bandwidth_package_ip_bandwidth_with_options(request, runtime)

    async def modify_common_bandwidth_package_ip_bandwidth_async(
        self,
        request: vpc_20160428_models.ModifyCommonBandwidthPackageIpBandwidthRequest,
    ) -> vpc_20160428_models.ModifyCommonBandwidthPackageIpBandwidthResponse:
        """
        @summary Sets the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance.
        
        @description You can call the *ModifyCommonBandwidthPackageIpBandwidth** operation to set the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance. This prevents an EIP from exhausting the bandwidth resources of an Internet Shared Bandwidth instance.
        For example, two EIPs are associated with an Internet Shared Bandwidth instance whose maximum bandwidth is 800 Mbit/s. In this case, you can set the maximum bandwidth of one EIP to 500 Mbit/s and that of the other EIP to 400 Mbit/s. After you set the maximum bandwidth values, the first EIP cannot consume bandwidth higher than 500 Mbit/s. The second EIP cannot consume bandwidth higher than 400 Mbit/s.
        When you call this operation, take note of the following items:
        This operation is valid only for EIPs that are associated with Elastic Compute Service (ECS) instances. This operation is invalid for EIPs that are associated with Server Load Balancer (SLB) instances, NAT gateways, secondary elastic network interfaces (ENIs), or high-availability virtual IP addresses (HAVIPs).
        This operation is in public preview. You can call this operation to set the maximum bandwidth of EIPs only if the EIPs are associated with an Internet Shared Bandwidth instance. The feature is not supported in the console.
        You cannot repeatedly call this operation to set the maximum bandwidth of an EIP within the specified period of time.
        
        @param request: ModifyCommonBandwidthPackageIpBandwidthRequest
        @return: ModifyCommonBandwidthPackageIpBandwidthResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_common_bandwidth_package_ip_bandwidth_with_options_async(request, runtime)

    def modify_common_bandwidth_package_spec_with_options(
        self,
        request: vpc_20160428_models.ModifyCommonBandwidthPackageSpecRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyCommonBandwidthPackageSpecResponse:
        """
        @summary Modifies the maximum bandwidth of an Internet Shared Bandwidth instance.
        
        @description Before you call this operation, take note of the following items:
        **ModifyCommonBandwidthPackageSpec** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the task.
        If the Internet Shared Bandwidth instance is in the **Modifying** state, the maximum bandwidth of the Internet Shared Bandwidth instance is being modified. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
        If the Internet Shared Bandwidth instance is in the **Available** state, the maximum bandwidth of the Internet Shared Bandwidth instance is modified.
        You cannot repeatedly call the **ModifyCommonBandwidthPackageSpec** operation to modify the maximum bandwidth of an Internet Shared Bandwidth instance within the specified period of time.
        
        @param request: ModifyCommonBandwidthPackageSpecRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCommonBandwidthPackageSpecResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCommonBandwidthPackageSpec',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyCommonBandwidthPackageSpecResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_common_bandwidth_package_spec_with_options_async(
        self,
        request: vpc_20160428_models.ModifyCommonBandwidthPackageSpecRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyCommonBandwidthPackageSpecResponse:
        """
        @summary Modifies the maximum bandwidth of an Internet Shared Bandwidth instance.
        
        @description Before you call this operation, take note of the following items:
        **ModifyCommonBandwidthPackageSpec** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the task.
        If the Internet Shared Bandwidth instance is in the **Modifying** state, the maximum bandwidth of the Internet Shared Bandwidth instance is being modified. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
        If the Internet Shared Bandwidth instance is in the **Available** state, the maximum bandwidth of the Internet Shared Bandwidth instance is modified.
        You cannot repeatedly call the **ModifyCommonBandwidthPackageSpec** operation to modify the maximum bandwidth of an Internet Shared Bandwidth instance within the specified period of time.
        
        @param request: ModifyCommonBandwidthPackageSpecRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCommonBandwidthPackageSpecResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCommonBandwidthPackageSpec',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyCommonBandwidthPackageSpecResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_common_bandwidth_package_spec(
        self,
        request: vpc_20160428_models.ModifyCommonBandwidthPackageSpecRequest,
    ) -> vpc_20160428_models.ModifyCommonBandwidthPackageSpecResponse:
        """
        @summary Modifies the maximum bandwidth of an Internet Shared Bandwidth instance.
        
        @description Before you call this operation, take note of the following items:
        **ModifyCommonBandwidthPackageSpec** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the task.
        If the Internet Shared Bandwidth instance is in the **Modifying** state, the maximum bandwidth of the Internet Shared Bandwidth instance is being modified. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
        If the Internet Shared Bandwidth instance is in the **Available** state, the maximum bandwidth of the Internet Shared Bandwidth instance is modified.
        You cannot repeatedly call the **ModifyCommonBandwidthPackageSpec** operation to modify the maximum bandwidth of an Internet Shared Bandwidth instance within the specified period of time.
        
        @param request: ModifyCommonBandwidthPackageSpecRequest
        @return: ModifyCommonBandwidthPackageSpecResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_common_bandwidth_package_spec_with_options(request, runtime)

    async def modify_common_bandwidth_package_spec_async(
        self,
        request: vpc_20160428_models.ModifyCommonBandwidthPackageSpecRequest,
    ) -> vpc_20160428_models.ModifyCommonBandwidthPackageSpecResponse:
        """
        @summary Modifies the maximum bandwidth of an Internet Shared Bandwidth instance.
        
        @description Before you call this operation, take note of the following items:
        **ModifyCommonBandwidthPackageSpec** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the task.
        If the Internet Shared Bandwidth instance is in the **Modifying** state, the maximum bandwidth of the Internet Shared Bandwidth instance is being modified. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
        If the Internet Shared Bandwidth instance is in the **Available** state, the maximum bandwidth of the Internet Shared Bandwidth instance is modified.
        You cannot repeatedly call the **ModifyCommonBandwidthPackageSpec** operation to modify the maximum bandwidth of an Internet Shared Bandwidth instance within the specified period of time.
        
        @param request: ModifyCommonBandwidthPackageSpecRequest
        @return: ModifyCommonBandwidthPackageSpecResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_common_bandwidth_package_spec_with_options_async(request, runtime)

    def modify_customer_gateway_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyCustomerGatewayAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyCustomerGatewayAttributeResponse:
        """
        @summary Modifies the configuration of a customer gateway.
        
        @description    When you call **ModifyCustomerGatewayAttribute**, if a value is assigned to **AuthKey**, the operation is asynchronous. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the configurations are being modified.
        If a VPN gateway is in the **active** state, the configurations are modified.
        When you call **ModifyCustomerGatewayAttribute**, if no value is assigned to **AuthKey**, the operation is synchronous.
        You cannot repeatedly call **ModifyCustomerGatewayAttribute** to modify the configurations of a customer gateway within the specified period of time.
        
        @param request: ModifyCustomerGatewayAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCustomerGatewayAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auth_key):
            query['AuthKey'] = request.auth_key
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.customer_gateway_id):
            query['CustomerGatewayId'] = request.customer_gateway_id
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCustomerGatewayAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyCustomerGatewayAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_customer_gateway_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyCustomerGatewayAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyCustomerGatewayAttributeResponse:
        """
        @summary Modifies the configuration of a customer gateway.
        
        @description    When you call **ModifyCustomerGatewayAttribute**, if a value is assigned to **AuthKey**, the operation is asynchronous. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the configurations are being modified.
        If a VPN gateway is in the **active** state, the configurations are modified.
        When you call **ModifyCustomerGatewayAttribute**, if no value is assigned to **AuthKey**, the operation is synchronous.
        You cannot repeatedly call **ModifyCustomerGatewayAttribute** to modify the configurations of a customer gateway within the specified period of time.
        
        @param request: ModifyCustomerGatewayAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCustomerGatewayAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auth_key):
            query['AuthKey'] = request.auth_key
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.customer_gateway_id):
            query['CustomerGatewayId'] = request.customer_gateway_id
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCustomerGatewayAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyCustomerGatewayAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_customer_gateway_attribute(
        self,
        request: vpc_20160428_models.ModifyCustomerGatewayAttributeRequest,
    ) -> vpc_20160428_models.ModifyCustomerGatewayAttributeResponse:
        """
        @summary Modifies the configuration of a customer gateway.
        
        @description    When you call **ModifyCustomerGatewayAttribute**, if a value is assigned to **AuthKey**, the operation is asynchronous. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the configurations are being modified.
        If a VPN gateway is in the **active** state, the configurations are modified.
        When you call **ModifyCustomerGatewayAttribute**, if no value is assigned to **AuthKey**, the operation is synchronous.
        You cannot repeatedly call **ModifyCustomerGatewayAttribute** to modify the configurations of a customer gateway within the specified period of time.
        
        @param request: ModifyCustomerGatewayAttributeRequest
        @return: ModifyCustomerGatewayAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_customer_gateway_attribute_with_options(request, runtime)

    async def modify_customer_gateway_attribute_async(
        self,
        request: vpc_20160428_models.ModifyCustomerGatewayAttributeRequest,
    ) -> vpc_20160428_models.ModifyCustomerGatewayAttributeResponse:
        """
        @summary Modifies the configuration of a customer gateway.
        
        @description    When you call **ModifyCustomerGatewayAttribute**, if a value is assigned to **AuthKey**, the operation is asynchronous. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the configurations are being modified.
        If a VPN gateway is in the **active** state, the configurations are modified.
        When you call **ModifyCustomerGatewayAttribute**, if no value is assigned to **AuthKey**, the operation is synchronous.
        You cannot repeatedly call **ModifyCustomerGatewayAttribute** to modify the configurations of a customer gateway within the specified period of time.
        
        @param request: ModifyCustomerGatewayAttributeRequest
        @return: ModifyCustomerGatewayAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_customer_gateway_attribute_with_options_async(request, runtime)

    def modify_eip_address_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyEipAddressAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyEipAddressAttributeResponse:
        """
        @summary Modifies the name, description, and maximum bandwidth of an elastic IP address (EIP).
        
        @param request: ModifyEipAddressAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyEipAddressAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyEipAddressAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyEipAddressAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_eip_address_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyEipAddressAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyEipAddressAttributeResponse:
        """
        @summary Modifies the name, description, and maximum bandwidth of an elastic IP address (EIP).
        
        @param request: ModifyEipAddressAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyEipAddressAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyEipAddressAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyEipAddressAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_eip_address_attribute(
        self,
        request: vpc_20160428_models.ModifyEipAddressAttributeRequest,
    ) -> vpc_20160428_models.ModifyEipAddressAttributeResponse:
        """
        @summary Modifies the name, description, and maximum bandwidth of an elastic IP address (EIP).
        
        @param request: ModifyEipAddressAttributeRequest
        @return: ModifyEipAddressAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_eip_address_attribute_with_options(request, runtime)

    async def modify_eip_address_attribute_async(
        self,
        request: vpc_20160428_models.ModifyEipAddressAttributeRequest,
    ) -> vpc_20160428_models.ModifyEipAddressAttributeResponse:
        """
        @summary Modifies the name, description, and maximum bandwidth of an elastic IP address (EIP).
        
        @param request: ModifyEipAddressAttributeRequest
        @return: ModifyEipAddressAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_eip_address_attribute_with_options_async(request, runtime)

    def modify_express_cloud_connection_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyExpressCloudConnectionAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyExpressCloudConnectionAttributeResponse:
        """
        @summary Modifies the configuration of an Express Cloud Connect (ECC) instance.
        
        @param request: ModifyExpressCloudConnectionAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyExpressCloudConnectionAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bgp_as):
            query['BgpAs'] = request.bgp_as
        if not UtilClient.is_unset(request.ce_ip):
            query['CeIp'] = request.ce_ip
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ecc_id):
            query['EccId'] = request.ecc_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pe_ip):
            query['PeIp'] = request.pe_ip
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyExpressCloudConnectionAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyExpressCloudConnectionAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_express_cloud_connection_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyExpressCloudConnectionAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyExpressCloudConnectionAttributeResponse:
        """
        @summary Modifies the configuration of an Express Cloud Connect (ECC) instance.
        
        @param request: ModifyExpressCloudConnectionAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyExpressCloudConnectionAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bgp_as):
            query['BgpAs'] = request.bgp_as
        if not UtilClient.is_unset(request.ce_ip):
            query['CeIp'] = request.ce_ip
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ecc_id):
            query['EccId'] = request.ecc_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pe_ip):
            query['PeIp'] = request.pe_ip
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyExpressCloudConnectionAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyExpressCloudConnectionAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_express_cloud_connection_attribute(
        self,
        request: vpc_20160428_models.ModifyExpressCloudConnectionAttributeRequest,
    ) -> vpc_20160428_models.ModifyExpressCloudConnectionAttributeResponse:
        """
        @summary Modifies the configuration of an Express Cloud Connect (ECC) instance.
        
        @param request: ModifyExpressCloudConnectionAttributeRequest
        @return: ModifyExpressCloudConnectionAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_express_cloud_connection_attribute_with_options(request, runtime)

    async def modify_express_cloud_connection_attribute_async(
        self,
        request: vpc_20160428_models.ModifyExpressCloudConnectionAttributeRequest,
    ) -> vpc_20160428_models.ModifyExpressCloudConnectionAttributeResponse:
        """
        @summary Modifies the configuration of an Express Cloud Connect (ECC) instance.
        
        @param request: ModifyExpressCloudConnectionAttributeRequest
        @return: ModifyExpressCloudConnectionAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_express_cloud_connection_attribute_with_options_async(request, runtime)

    def modify_express_cloud_connection_bandwidth_with_options(
        self,
        request: vpc_20160428_models.ModifyExpressCloudConnectionBandwidthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyExpressCloudConnectionBandwidthResponse:
        """
        @summary Modifies the bandwidth of an Express Cloud Connect (ECC) instance.
        
        @param request: ModifyExpressCloudConnectionBandwidthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyExpressCloudConnectionBandwidthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.ecc_id):
            query['EccId'] = request.ecc_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyExpressCloudConnectionBandwidth',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyExpressCloudConnectionBandwidthResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_express_cloud_connection_bandwidth_with_options_async(
        self,
        request: vpc_20160428_models.ModifyExpressCloudConnectionBandwidthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyExpressCloudConnectionBandwidthResponse:
        """
        @summary Modifies the bandwidth of an Express Cloud Connect (ECC) instance.
        
        @param request: ModifyExpressCloudConnectionBandwidthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyExpressCloudConnectionBandwidthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.ecc_id):
            query['EccId'] = request.ecc_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyExpressCloudConnectionBandwidth',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyExpressCloudConnectionBandwidthResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_express_cloud_connection_bandwidth(
        self,
        request: vpc_20160428_models.ModifyExpressCloudConnectionBandwidthRequest,
    ) -> vpc_20160428_models.ModifyExpressCloudConnectionBandwidthResponse:
        """
        @summary Modifies the bandwidth of an Express Cloud Connect (ECC) instance.
        
        @param request: ModifyExpressCloudConnectionBandwidthRequest
        @return: ModifyExpressCloudConnectionBandwidthResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_express_cloud_connection_bandwidth_with_options(request, runtime)

    async def modify_express_cloud_connection_bandwidth_async(
        self,
        request: vpc_20160428_models.ModifyExpressCloudConnectionBandwidthRequest,
    ) -> vpc_20160428_models.ModifyExpressCloudConnectionBandwidthResponse:
        """
        @summary Modifies the bandwidth of an Express Cloud Connect (ECC) instance.
        
        @param request: ModifyExpressCloudConnectionBandwidthRequest
        @return: ModifyExpressCloudConnectionBandwidthResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_express_cloud_connection_bandwidth_with_options_async(request, runtime)

    def modify_express_connect_traffic_qos_with_options(
        self,
        request: vpc_20160428_models.ModifyExpressConnectTrafficQosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyExpressConnectTrafficQosResponse:
        """
        @summary Qos
        
        @param request: ModifyExpressConnectTrafficQosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyExpressConnectTrafficQosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.add_instance_list):
            query['AddInstanceList'] = request.add_instance_list
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.qos_description):
            query['QosDescription'] = request.qos_description
        if not UtilClient.is_unset(request.qos_id):
            query['QosId'] = request.qos_id
        if not UtilClient.is_unset(request.qos_name):
            query['QosName'] = request.qos_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remove_instance_list):
            query['RemoveInstanceList'] = request.remove_instance_list
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyExpressConnectTrafficQos',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyExpressConnectTrafficQosResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_express_connect_traffic_qos_with_options_async(
        self,
        request: vpc_20160428_models.ModifyExpressConnectTrafficQosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyExpressConnectTrafficQosResponse:
        """
        @summary Qos
        
        @param request: ModifyExpressConnectTrafficQosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyExpressConnectTrafficQosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.add_instance_list):
            query['AddInstanceList'] = request.add_instance_list
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.qos_description):
            query['QosDescription'] = request.qos_description
        if not UtilClient.is_unset(request.qos_id):
            query['QosId'] = request.qos_id
        if not UtilClient.is_unset(request.qos_name):
            query['QosName'] = request.qos_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remove_instance_list):
            query['RemoveInstanceList'] = request.remove_instance_list
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyExpressConnectTrafficQos',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyExpressConnectTrafficQosResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_express_connect_traffic_qos(
        self,
        request: vpc_20160428_models.ModifyExpressConnectTrafficQosRequest,
    ) -> vpc_20160428_models.ModifyExpressConnectTrafficQosResponse:
        """
        @summary Qos
        
        @param request: ModifyExpressConnectTrafficQosRequest
        @return: ModifyExpressConnectTrafficQosResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_express_connect_traffic_qos_with_options(request, runtime)

    async def modify_express_connect_traffic_qos_async(
        self,
        request: vpc_20160428_models.ModifyExpressConnectTrafficQosRequest,
    ) -> vpc_20160428_models.ModifyExpressConnectTrafficQosResponse:
        """
        @summary Qos
        
        @param request: ModifyExpressConnectTrafficQosRequest
        @return: ModifyExpressConnectTrafficQosResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_express_connect_traffic_qos_with_options_async(request, runtime)

    def modify_express_connect_traffic_qos_queue_with_options(
        self,
        request: vpc_20160428_models.ModifyExpressConnectTrafficQosQueueRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyExpressConnectTrafficQosQueueResponse:
        """
        @summary Qos
        
        @param request: ModifyExpressConnectTrafficQosQueueRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyExpressConnectTrafficQosQueueResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_percent):
            query['BandwidthPercent'] = request.bandwidth_percent
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.qos_id):
            query['QosId'] = request.qos_id
        if not UtilClient.is_unset(request.queue_description):
            query['QueueDescription'] = request.queue_description
        if not UtilClient.is_unset(request.queue_id):
            query['QueueId'] = request.queue_id
        if not UtilClient.is_unset(request.queue_name):
            query['QueueName'] = request.queue_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyExpressConnectTrafficQosQueue',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyExpressConnectTrafficQosQueueResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_express_connect_traffic_qos_queue_with_options_async(
        self,
        request: vpc_20160428_models.ModifyExpressConnectTrafficQosQueueRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyExpressConnectTrafficQosQueueResponse:
        """
        @summary Qos
        
        @param request: ModifyExpressConnectTrafficQosQueueRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyExpressConnectTrafficQosQueueResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_percent):
            query['BandwidthPercent'] = request.bandwidth_percent
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.qos_id):
            query['QosId'] = request.qos_id
        if not UtilClient.is_unset(request.queue_description):
            query['QueueDescription'] = request.queue_description
        if not UtilClient.is_unset(request.queue_id):
            query['QueueId'] = request.queue_id
        if not UtilClient.is_unset(request.queue_name):
            query['QueueName'] = request.queue_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyExpressConnectTrafficQosQueue',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyExpressConnectTrafficQosQueueResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_express_connect_traffic_qos_queue(
        self,
        request: vpc_20160428_models.ModifyExpressConnectTrafficQosQueueRequest,
    ) -> vpc_20160428_models.ModifyExpressConnectTrafficQosQueueResponse:
        """
        @summary Qos
        
        @param request: ModifyExpressConnectTrafficQosQueueRequest
        @return: ModifyExpressConnectTrafficQosQueueResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_express_connect_traffic_qos_queue_with_options(request, runtime)

    async def modify_express_connect_traffic_qos_queue_async(
        self,
        request: vpc_20160428_models.ModifyExpressConnectTrafficQosQueueRequest,
    ) -> vpc_20160428_models.ModifyExpressConnectTrafficQosQueueResponse:
        """
        @summary Qos
        
        @param request: ModifyExpressConnectTrafficQosQueueRequest
        @return: ModifyExpressConnectTrafficQosQueueResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_express_connect_traffic_qos_queue_with_options_async(request, runtime)

    def modify_express_connect_traffic_qos_rule_with_options(
        self,
        request: vpc_20160428_models.ModifyExpressConnectTrafficQosRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyExpressConnectTrafficQosRuleResponse:
        """
        @summary Qos
        
        @param request: ModifyExpressConnectTrafficQosRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyExpressConnectTrafficQosRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dst_cidr):
            query['DstCidr'] = request.dst_cidr
        if not UtilClient.is_unset(request.dst_ipv_6cidr):
            query['DstIPv6Cidr'] = request.dst_ipv_6cidr
        if not UtilClient.is_unset(request.dst_port_range):
            query['DstPortRange'] = request.dst_port_range
        if not UtilClient.is_unset(request.match_dscp):
            query['MatchDscp'] = request.match_dscp
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.protocol):
            query['Protocol'] = request.protocol
        if not UtilClient.is_unset(request.qos_id):
            query['QosId'] = request.qos_id
        if not UtilClient.is_unset(request.queue_id):
            query['QueueId'] = request.queue_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remarking_dscp):
            query['RemarkingDscp'] = request.remarking_dscp
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.rule_description):
            query['RuleDescription'] = request.rule_description
        if not UtilClient.is_unset(request.rule_id):
            query['RuleId'] = request.rule_id
        if not UtilClient.is_unset(request.rule_name):
            query['RuleName'] = request.rule_name
        if not UtilClient.is_unset(request.src_cidr):
            query['SrcCidr'] = request.src_cidr
        if not UtilClient.is_unset(request.src_ipv_6cidr):
            query['SrcIPv6Cidr'] = request.src_ipv_6cidr
        if not UtilClient.is_unset(request.src_port_range):
            query['SrcPortRange'] = request.src_port_range
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyExpressConnectTrafficQosRule',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyExpressConnectTrafficQosRuleResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_express_connect_traffic_qos_rule_with_options_async(
        self,
        request: vpc_20160428_models.ModifyExpressConnectTrafficQosRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyExpressConnectTrafficQosRuleResponse:
        """
        @summary Qos
        
        @param request: ModifyExpressConnectTrafficQosRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyExpressConnectTrafficQosRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dst_cidr):
            query['DstCidr'] = request.dst_cidr
        if not UtilClient.is_unset(request.dst_ipv_6cidr):
            query['DstIPv6Cidr'] = request.dst_ipv_6cidr
        if not UtilClient.is_unset(request.dst_port_range):
            query['DstPortRange'] = request.dst_port_range
        if not UtilClient.is_unset(request.match_dscp):
            query['MatchDscp'] = request.match_dscp
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.protocol):
            query['Protocol'] = request.protocol
        if not UtilClient.is_unset(request.qos_id):
            query['QosId'] = request.qos_id
        if not UtilClient.is_unset(request.queue_id):
            query['QueueId'] = request.queue_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remarking_dscp):
            query['RemarkingDscp'] = request.remarking_dscp
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.rule_description):
            query['RuleDescription'] = request.rule_description
        if not UtilClient.is_unset(request.rule_id):
            query['RuleId'] = request.rule_id
        if not UtilClient.is_unset(request.rule_name):
            query['RuleName'] = request.rule_name
        if not UtilClient.is_unset(request.src_cidr):
            query['SrcCidr'] = request.src_cidr
        if not UtilClient.is_unset(request.src_ipv_6cidr):
            query['SrcIPv6Cidr'] = request.src_ipv_6cidr
        if not UtilClient.is_unset(request.src_port_range):
            query['SrcPortRange'] = request.src_port_range
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyExpressConnectTrafficQosRule',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyExpressConnectTrafficQosRuleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_express_connect_traffic_qos_rule(
        self,
        request: vpc_20160428_models.ModifyExpressConnectTrafficQosRuleRequest,
    ) -> vpc_20160428_models.ModifyExpressConnectTrafficQosRuleResponse:
        """
        @summary Qos
        
        @param request: ModifyExpressConnectTrafficQosRuleRequest
        @return: ModifyExpressConnectTrafficQosRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_express_connect_traffic_qos_rule_with_options(request, runtime)

    async def modify_express_connect_traffic_qos_rule_async(
        self,
        request: vpc_20160428_models.ModifyExpressConnectTrafficQosRuleRequest,
    ) -> vpc_20160428_models.ModifyExpressConnectTrafficQosRuleResponse:
        """
        @summary Qos
        
        @param request: ModifyExpressConnectTrafficQosRuleRequest
        @return: ModifyExpressConnectTrafficQosRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_express_connect_traffic_qos_rule_with_options_async(request, runtime)

    def modify_flow_log_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyFlowLogAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyFlowLogAttributeResponse:
        """
        @summary Modifies the name and description of a flow log.
        
        @description    **ModifyFlowLogAttribute** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
        If the flow log is in the **Modifying** state, the flow log is being modified.
        If the flow log is in the **Active** or **Inactive** state, the flow log is modified.
        You cannot repeatedly call the **ModifyFlowLogAttribute** operation to modify a flow log within the specified period of time.
        
        @param request: ModifyFlowLogAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyFlowLogAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aggregation_interval):
            query['AggregationInterval'] = request.aggregation_interval
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.flow_log_id):
            query['FlowLogId'] = request.flow_log_id
        if not UtilClient.is_unset(request.flow_log_name):
            query['FlowLogName'] = request.flow_log_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyFlowLogAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyFlowLogAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_flow_log_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyFlowLogAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyFlowLogAttributeResponse:
        """
        @summary Modifies the name and description of a flow log.
        
        @description    **ModifyFlowLogAttribute** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
        If the flow log is in the **Modifying** state, the flow log is being modified.
        If the flow log is in the **Active** or **Inactive** state, the flow log is modified.
        You cannot repeatedly call the **ModifyFlowLogAttribute** operation to modify a flow log within the specified period of time.
        
        @param request: ModifyFlowLogAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyFlowLogAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aggregation_interval):
            query['AggregationInterval'] = request.aggregation_interval
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.flow_log_id):
            query['FlowLogId'] = request.flow_log_id
        if not UtilClient.is_unset(request.flow_log_name):
            query['FlowLogName'] = request.flow_log_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyFlowLogAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyFlowLogAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_flow_log_attribute(
        self,
        request: vpc_20160428_models.ModifyFlowLogAttributeRequest,
    ) -> vpc_20160428_models.ModifyFlowLogAttributeResponse:
        """
        @summary Modifies the name and description of a flow log.
        
        @description    **ModifyFlowLogAttribute** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
        If the flow log is in the **Modifying** state, the flow log is being modified.
        If the flow log is in the **Active** or **Inactive** state, the flow log is modified.
        You cannot repeatedly call the **ModifyFlowLogAttribute** operation to modify a flow log within the specified period of time.
        
        @param request: ModifyFlowLogAttributeRequest
        @return: ModifyFlowLogAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_flow_log_attribute_with_options(request, runtime)

    async def modify_flow_log_attribute_async(
        self,
        request: vpc_20160428_models.ModifyFlowLogAttributeRequest,
    ) -> vpc_20160428_models.ModifyFlowLogAttributeResponse:
        """
        @summary Modifies the name and description of a flow log.
        
        @description    **ModifyFlowLogAttribute** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
        If the flow log is in the **Modifying** state, the flow log is being modified.
        If the flow log is in the **Active** or **Inactive** state, the flow log is modified.
        You cannot repeatedly call the **ModifyFlowLogAttribute** operation to modify a flow log within the specified period of time.
        
        @param request: ModifyFlowLogAttributeRequest
        @return: ModifyFlowLogAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_flow_log_attribute_with_options_async(request, runtime)

    def modify_forward_entry_with_options(
        self,
        request: vpc_20160428_models.ModifyForwardEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyForwardEntryResponse:
        """
        @summary Modifies a DNAT entry.
        
        @description    **ModifyForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
        **Pending**: indicates that the system is modifying the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
        **Available**: indicates that the DNAT entry is modified.
        You cannot repeatedly call the **ModifyForwardEntry** operation to modify a DNAT entry within the specified period of time.
        
        @param request: ModifyForwardEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyForwardEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.external_ip):
            query['ExternalIp'] = request.external_ip
        if not UtilClient.is_unset(request.external_port):
            query['ExternalPort'] = request.external_port
        if not UtilClient.is_unset(request.forward_entry_id):
            query['ForwardEntryId'] = request.forward_entry_id
        if not UtilClient.is_unset(request.forward_entry_name):
            query['ForwardEntryName'] = request.forward_entry_name
        if not UtilClient.is_unset(request.forward_table_id):
            query['ForwardTableId'] = request.forward_table_id
        if not UtilClient.is_unset(request.internal_ip):
            query['InternalIp'] = request.internal_ip
        if not UtilClient.is_unset(request.internal_port):
            query['InternalPort'] = request.internal_port
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port_break):
            query['PortBreak'] = request.port_break
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyForwardEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyForwardEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_forward_entry_with_options_async(
        self,
        request: vpc_20160428_models.ModifyForwardEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyForwardEntryResponse:
        """
        @summary Modifies a DNAT entry.
        
        @description    **ModifyForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
        **Pending**: indicates that the system is modifying the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
        **Available**: indicates that the DNAT entry is modified.
        You cannot repeatedly call the **ModifyForwardEntry** operation to modify a DNAT entry within the specified period of time.
        
        @param request: ModifyForwardEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyForwardEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.external_ip):
            query['ExternalIp'] = request.external_ip
        if not UtilClient.is_unset(request.external_port):
            query['ExternalPort'] = request.external_port
        if not UtilClient.is_unset(request.forward_entry_id):
            query['ForwardEntryId'] = request.forward_entry_id
        if not UtilClient.is_unset(request.forward_entry_name):
            query['ForwardEntryName'] = request.forward_entry_name
        if not UtilClient.is_unset(request.forward_table_id):
            query['ForwardTableId'] = request.forward_table_id
        if not UtilClient.is_unset(request.internal_ip):
            query['InternalIp'] = request.internal_ip
        if not UtilClient.is_unset(request.internal_port):
            query['InternalPort'] = request.internal_port
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port_break):
            query['PortBreak'] = request.port_break
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyForwardEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyForwardEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_forward_entry(
        self,
        request: vpc_20160428_models.ModifyForwardEntryRequest,
    ) -> vpc_20160428_models.ModifyForwardEntryResponse:
        """
        @summary Modifies a DNAT entry.
        
        @description    **ModifyForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
        **Pending**: indicates that the system is modifying the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
        **Available**: indicates that the DNAT entry is modified.
        You cannot repeatedly call the **ModifyForwardEntry** operation to modify a DNAT entry within the specified period of time.
        
        @param request: ModifyForwardEntryRequest
        @return: ModifyForwardEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_forward_entry_with_options(request, runtime)

    async def modify_forward_entry_async(
        self,
        request: vpc_20160428_models.ModifyForwardEntryRequest,
    ) -> vpc_20160428_models.ModifyForwardEntryResponse:
        """
        @summary Modifies a DNAT entry.
        
        @description    **ModifyForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
        **Pending**: indicates that the system is modifying the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
        **Available**: indicates that the DNAT entry is modified.
        You cannot repeatedly call the **ModifyForwardEntry** operation to modify a DNAT entry within the specified period of time.
        
        @param request: ModifyForwardEntryRequest
        @return: ModifyForwardEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_forward_entry_with_options_async(request, runtime)

    def modify_full_nat_entry_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyFullNatEntryAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyFullNatEntryAttributeResponse:
        """
        @summary Modifies a FULLNAT entry.
        
        @description ## [](#)
        **ModifyFullNatEntryAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
        **Modifying**: indicates that the system is modifying the FULLNAT entry. You can query the FULLNAT entry, but cannot perform other operations.
        **Available**: indicates that the FULLNAT entry is modified.
        You cannot repeatedly call the **ModifyFullNatEntryAttribute** operation to modify a FULLNAT entry within the specified period of time.
        
        @param request: ModifyFullNatEntryAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyFullNatEntryAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.access_ip):
            query['AccessIp'] = request.access_ip
        if not UtilClient.is_unset(request.access_port):
            query['AccessPort'] = request.access_port
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.full_nat_entry_description):
            query['FullNatEntryDescription'] = request.full_nat_entry_description
        if not UtilClient.is_unset(request.full_nat_entry_id):
            query['FullNatEntryId'] = request.full_nat_entry_id
        if not UtilClient.is_unset(request.full_nat_entry_name):
            query['FullNatEntryName'] = request.full_nat_entry_name
        if not UtilClient.is_unset(request.full_nat_table_id):
            query['FullNatTableId'] = request.full_nat_table_id
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.nat_ip):
            query['NatIp'] = request.nat_ip
        if not UtilClient.is_unset(request.nat_ip_port):
            query['NatIpPort'] = request.nat_ip_port
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyFullNatEntryAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyFullNatEntryAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_full_nat_entry_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyFullNatEntryAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyFullNatEntryAttributeResponse:
        """
        @summary Modifies a FULLNAT entry.
        
        @description ## [](#)
        **ModifyFullNatEntryAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
        **Modifying**: indicates that the system is modifying the FULLNAT entry. You can query the FULLNAT entry, but cannot perform other operations.
        **Available**: indicates that the FULLNAT entry is modified.
        You cannot repeatedly call the **ModifyFullNatEntryAttribute** operation to modify a FULLNAT entry within the specified period of time.
        
        @param request: ModifyFullNatEntryAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyFullNatEntryAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.access_ip):
            query['AccessIp'] = request.access_ip
        if not UtilClient.is_unset(request.access_port):
            query['AccessPort'] = request.access_port
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.full_nat_entry_description):
            query['FullNatEntryDescription'] = request.full_nat_entry_description
        if not UtilClient.is_unset(request.full_nat_entry_id):
            query['FullNatEntryId'] = request.full_nat_entry_id
        if not UtilClient.is_unset(request.full_nat_entry_name):
            query['FullNatEntryName'] = request.full_nat_entry_name
        if not UtilClient.is_unset(request.full_nat_table_id):
            query['FullNatTableId'] = request.full_nat_table_id
        if not UtilClient.is_unset(request.ip_protocol):
            query['IpProtocol'] = request.ip_protocol
        if not UtilClient.is_unset(request.nat_ip):
            query['NatIp'] = request.nat_ip
        if not UtilClient.is_unset(request.nat_ip_port):
            query['NatIpPort'] = request.nat_ip_port
        if not UtilClient.is_unset(request.network_interface_id):
            query['NetworkInterfaceId'] = request.network_interface_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyFullNatEntryAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyFullNatEntryAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_full_nat_entry_attribute(
        self,
        request: vpc_20160428_models.ModifyFullNatEntryAttributeRequest,
    ) -> vpc_20160428_models.ModifyFullNatEntryAttributeResponse:
        """
        @summary Modifies a FULLNAT entry.
        
        @description ## [](#)
        **ModifyFullNatEntryAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
        **Modifying**: indicates that the system is modifying the FULLNAT entry. You can query the FULLNAT entry, but cannot perform other operations.
        **Available**: indicates that the FULLNAT entry is modified.
        You cannot repeatedly call the **ModifyFullNatEntryAttribute** operation to modify a FULLNAT entry within the specified period of time.
        
        @param request: ModifyFullNatEntryAttributeRequest
        @return: ModifyFullNatEntryAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_full_nat_entry_attribute_with_options(request, runtime)

    async def modify_full_nat_entry_attribute_async(
        self,
        request: vpc_20160428_models.ModifyFullNatEntryAttributeRequest,
    ) -> vpc_20160428_models.ModifyFullNatEntryAttributeResponse:
        """
        @summary Modifies a FULLNAT entry.
        
        @description ## [](#)
        **ModifyFullNatEntryAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
        **Modifying**: indicates that the system is modifying the FULLNAT entry. You can query the FULLNAT entry, but cannot perform other operations.
        **Available**: indicates that the FULLNAT entry is modified.
        You cannot repeatedly call the **ModifyFullNatEntryAttribute** operation to modify a FULLNAT entry within the specified period of time.
        
        @param request: ModifyFullNatEntryAttributeRequest
        @return: ModifyFullNatEntryAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_full_nat_entry_attribute_with_options_async(request, runtime)

    def modify_global_acceleration_instance_attributes_with_options(
        self,
        request: vpc_20160428_models.ModifyGlobalAccelerationInstanceAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyGlobalAccelerationInstanceAttributesResponse:
        """
        @summary Modifies the name and description of a Global Accelerator (GA) instance.
        
        @param request: ModifyGlobalAccelerationInstanceAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyGlobalAccelerationInstanceAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.global_acceleration_instance_id):
            query['GlobalAccelerationInstanceId'] = request.global_acceleration_instance_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyGlobalAccelerationInstanceAttributes',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyGlobalAccelerationInstanceAttributesResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_global_acceleration_instance_attributes_with_options_async(
        self,
        request: vpc_20160428_models.ModifyGlobalAccelerationInstanceAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyGlobalAccelerationInstanceAttributesResponse:
        """
        @summary Modifies the name and description of a Global Accelerator (GA) instance.
        
        @param request: ModifyGlobalAccelerationInstanceAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyGlobalAccelerationInstanceAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.global_acceleration_instance_id):
            query['GlobalAccelerationInstanceId'] = request.global_acceleration_instance_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyGlobalAccelerationInstanceAttributes',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyGlobalAccelerationInstanceAttributesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_global_acceleration_instance_attributes(
        self,
        request: vpc_20160428_models.ModifyGlobalAccelerationInstanceAttributesRequest,
    ) -> vpc_20160428_models.ModifyGlobalAccelerationInstanceAttributesResponse:
        """
        @summary Modifies the name and description of a Global Accelerator (GA) instance.
        
        @param request: ModifyGlobalAccelerationInstanceAttributesRequest
        @return: ModifyGlobalAccelerationInstanceAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_global_acceleration_instance_attributes_with_options(request, runtime)

    async def modify_global_acceleration_instance_attributes_async(
        self,
        request: vpc_20160428_models.ModifyGlobalAccelerationInstanceAttributesRequest,
    ) -> vpc_20160428_models.ModifyGlobalAccelerationInstanceAttributesResponse:
        """
        @summary Modifies the name and description of a Global Accelerator (GA) instance.
        
        @param request: ModifyGlobalAccelerationInstanceAttributesRequest
        @return: ModifyGlobalAccelerationInstanceAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_global_acceleration_instance_attributes_with_options_async(request, runtime)

    def modify_global_acceleration_instance_spec_with_options(
        self,
        request: vpc_20160428_models.ModifyGlobalAccelerationInstanceSpecRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyGlobalAccelerationInstanceSpecResponse:
        """
        @summary Modifies the maximum bandwidth of a Global Accelerator (GA) instance.
        
        @description ## Usage notes
        You cannot call this operation to modify the maximum bandwidth of a subscription GA instance.
        
        @param request: ModifyGlobalAccelerationInstanceSpecRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyGlobalAccelerationInstanceSpecResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.global_acceleration_instance_id):
            query['GlobalAccelerationInstanceId'] = request.global_acceleration_instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyGlobalAccelerationInstanceSpec',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyGlobalAccelerationInstanceSpecResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_global_acceleration_instance_spec_with_options_async(
        self,
        request: vpc_20160428_models.ModifyGlobalAccelerationInstanceSpecRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyGlobalAccelerationInstanceSpecResponse:
        """
        @summary Modifies the maximum bandwidth of a Global Accelerator (GA) instance.
        
        @description ## Usage notes
        You cannot call this operation to modify the maximum bandwidth of a subscription GA instance.
        
        @param request: ModifyGlobalAccelerationInstanceSpecRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyGlobalAccelerationInstanceSpecResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.global_acceleration_instance_id):
            query['GlobalAccelerationInstanceId'] = request.global_acceleration_instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyGlobalAccelerationInstanceSpec',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyGlobalAccelerationInstanceSpecResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_global_acceleration_instance_spec(
        self,
        request: vpc_20160428_models.ModifyGlobalAccelerationInstanceSpecRequest,
    ) -> vpc_20160428_models.ModifyGlobalAccelerationInstanceSpecResponse:
        """
        @summary Modifies the maximum bandwidth of a Global Accelerator (GA) instance.
        
        @description ## Usage notes
        You cannot call this operation to modify the maximum bandwidth of a subscription GA instance.
        
        @param request: ModifyGlobalAccelerationInstanceSpecRequest
        @return: ModifyGlobalAccelerationInstanceSpecResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_global_acceleration_instance_spec_with_options(request, runtime)

    async def modify_global_acceleration_instance_spec_async(
        self,
        request: vpc_20160428_models.ModifyGlobalAccelerationInstanceSpecRequest,
    ) -> vpc_20160428_models.ModifyGlobalAccelerationInstanceSpecResponse:
        """
        @summary Modifies the maximum bandwidth of a Global Accelerator (GA) instance.
        
        @description ## Usage notes
        You cannot call this operation to modify the maximum bandwidth of a subscription GA instance.
        
        @param request: ModifyGlobalAccelerationInstanceSpecRequest
        @return: ModifyGlobalAccelerationInstanceSpecResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_global_acceleration_instance_spec_with_options_async(request, runtime)

    def modify_ha_vip_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyHaVipAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyHaVipAttributeResponse:
        """
        @description You cannot repeatedly call the *ModifyHaVipAttribute** operation to modify the name and description of an HAVIP within the specified period of time.
        
        @param request: ModifyHaVipAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyHaVipAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ha_vip_id):
            query['HaVipId'] = request.ha_vip_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyHaVipAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyHaVipAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_ha_vip_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyHaVipAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyHaVipAttributeResponse:
        """
        @description You cannot repeatedly call the *ModifyHaVipAttribute** operation to modify the name and description of an HAVIP within the specified period of time.
        
        @param request: ModifyHaVipAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyHaVipAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ha_vip_id):
            query['HaVipId'] = request.ha_vip_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyHaVipAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyHaVipAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_ha_vip_attribute(
        self,
        request: vpc_20160428_models.ModifyHaVipAttributeRequest,
    ) -> vpc_20160428_models.ModifyHaVipAttributeResponse:
        """
        @description You cannot repeatedly call the *ModifyHaVipAttribute** operation to modify the name and description of an HAVIP within the specified period of time.
        
        @param request: ModifyHaVipAttributeRequest
        @return: ModifyHaVipAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_ha_vip_attribute_with_options(request, runtime)

    async def modify_ha_vip_attribute_async(
        self,
        request: vpc_20160428_models.ModifyHaVipAttributeRequest,
    ) -> vpc_20160428_models.ModifyHaVipAttributeResponse:
        """
        @description You cannot repeatedly call the *ModifyHaVipAttribute** operation to modify the name and description of an HAVIP within the specified period of time.
        
        @param request: ModifyHaVipAttributeRequest
        @return: ModifyHaVipAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_ha_vip_attribute_with_options_async(request, runtime)

    def modify_ipv_6translator_acl_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyIPv6TranslatorAclAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyIPv6TranslatorAclAttributeResponse:
        """
        @deprecated OpenAPI ModifyIPv6TranslatorAclAttribute is deprecated
        
        @summary Modifies the name of an access control list (ACL).
        
        @param request: ModifyIPv6TranslatorAclAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyIPv6TranslatorAclAttributeResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_id):
            query['AclId'] = request.acl_id
        if not UtilClient.is_unset(request.acl_name):
            query['AclName'] = request.acl_name
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyIPv6TranslatorAclAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyIPv6TranslatorAclAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_ipv_6translator_acl_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyIPv6TranslatorAclAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyIPv6TranslatorAclAttributeResponse:
        """
        @deprecated OpenAPI ModifyIPv6TranslatorAclAttribute is deprecated
        
        @summary Modifies the name of an access control list (ACL).
        
        @param request: ModifyIPv6TranslatorAclAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyIPv6TranslatorAclAttributeResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_id):
            query['AclId'] = request.acl_id
        if not UtilClient.is_unset(request.acl_name):
            query['AclName'] = request.acl_name
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyIPv6TranslatorAclAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyIPv6TranslatorAclAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_ipv_6translator_acl_attribute(
        self,
        request: vpc_20160428_models.ModifyIPv6TranslatorAclAttributeRequest,
    ) -> vpc_20160428_models.ModifyIPv6TranslatorAclAttributeResponse:
        """
        @deprecated OpenAPI ModifyIPv6TranslatorAclAttribute is deprecated
        
        @summary Modifies the name of an access control list (ACL).
        
        @param request: ModifyIPv6TranslatorAclAttributeRequest
        @return: ModifyIPv6TranslatorAclAttributeResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_ipv_6translator_acl_attribute_with_options(request, runtime)

    async def modify_ipv_6translator_acl_attribute_async(
        self,
        request: vpc_20160428_models.ModifyIPv6TranslatorAclAttributeRequest,
    ) -> vpc_20160428_models.ModifyIPv6TranslatorAclAttributeResponse:
        """
        @deprecated OpenAPI ModifyIPv6TranslatorAclAttribute is deprecated
        
        @summary Modifies the name of an access control list (ACL).
        
        @param request: ModifyIPv6TranslatorAclAttributeRequest
        @return: ModifyIPv6TranslatorAclAttributeResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_ipv_6translator_acl_attribute_with_options_async(request, runtime)

    def modify_ipv_6translator_acl_list_entry_with_options(
        self,
        request: vpc_20160428_models.ModifyIPv6TranslatorAclListEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyIPv6TranslatorAclListEntryResponse:
        """
        @summary Modifies an IP entry in an access control list (ACL).
        
        @param request: ModifyIPv6TranslatorAclListEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyIPv6TranslatorAclListEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_entry_comment):
            query['AclEntryComment'] = request.acl_entry_comment
        if not UtilClient.is_unset(request.acl_entry_id):
            query['AclEntryId'] = request.acl_entry_id
        if not UtilClient.is_unset(request.acl_id):
            query['AclId'] = request.acl_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyIPv6TranslatorAclListEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyIPv6TranslatorAclListEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_ipv_6translator_acl_list_entry_with_options_async(
        self,
        request: vpc_20160428_models.ModifyIPv6TranslatorAclListEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyIPv6TranslatorAclListEntryResponse:
        """
        @summary Modifies an IP entry in an access control list (ACL).
        
        @param request: ModifyIPv6TranslatorAclListEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyIPv6TranslatorAclListEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_entry_comment):
            query['AclEntryComment'] = request.acl_entry_comment
        if not UtilClient.is_unset(request.acl_entry_id):
            query['AclEntryId'] = request.acl_entry_id
        if not UtilClient.is_unset(request.acl_id):
            query['AclId'] = request.acl_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyIPv6TranslatorAclListEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyIPv6TranslatorAclListEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_ipv_6translator_acl_list_entry(
        self,
        request: vpc_20160428_models.ModifyIPv6TranslatorAclListEntryRequest,
    ) -> vpc_20160428_models.ModifyIPv6TranslatorAclListEntryResponse:
        """
        @summary Modifies an IP entry in an access control list (ACL).
        
        @param request: ModifyIPv6TranslatorAclListEntryRequest
        @return: ModifyIPv6TranslatorAclListEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_ipv_6translator_acl_list_entry_with_options(request, runtime)

    async def modify_ipv_6translator_acl_list_entry_async(
        self,
        request: vpc_20160428_models.ModifyIPv6TranslatorAclListEntryRequest,
    ) -> vpc_20160428_models.ModifyIPv6TranslatorAclListEntryResponse:
        """
        @summary Modifies an IP entry in an access control list (ACL).
        
        @param request: ModifyIPv6TranslatorAclListEntryRequest
        @return: ModifyIPv6TranslatorAclListEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_ipv_6translator_acl_list_entry_with_options_async(request, runtime)

    def modify_ipv_6translator_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyIPv6TranslatorAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyIPv6TranslatorAttributeResponse:
        """
        @summary Modifies the name and description of an IPv6 Translation Service instance.
        
        @param request: ModifyIPv6TranslatorAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyIPv6TranslatorAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ipv_6translator_id):
            query['Ipv6TranslatorId'] = request.ipv_6translator_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyIPv6TranslatorAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyIPv6TranslatorAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_ipv_6translator_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyIPv6TranslatorAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyIPv6TranslatorAttributeResponse:
        """
        @summary Modifies the name and description of an IPv6 Translation Service instance.
        
        @param request: ModifyIPv6TranslatorAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyIPv6TranslatorAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ipv_6translator_id):
            query['Ipv6TranslatorId'] = request.ipv_6translator_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyIPv6TranslatorAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyIPv6TranslatorAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_ipv_6translator_attribute(
        self,
        request: vpc_20160428_models.ModifyIPv6TranslatorAttributeRequest,
    ) -> vpc_20160428_models.ModifyIPv6TranslatorAttributeResponse:
        """
        @summary Modifies the name and description of an IPv6 Translation Service instance.
        
        @param request: ModifyIPv6TranslatorAttributeRequest
        @return: ModifyIPv6TranslatorAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_ipv_6translator_attribute_with_options(request, runtime)

    async def modify_ipv_6translator_attribute_async(
        self,
        request: vpc_20160428_models.ModifyIPv6TranslatorAttributeRequest,
    ) -> vpc_20160428_models.ModifyIPv6TranslatorAttributeResponse:
        """
        @summary Modifies the name and description of an IPv6 Translation Service instance.
        
        @param request: ModifyIPv6TranslatorAttributeRequest
        @return: ModifyIPv6TranslatorAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_ipv_6translator_attribute_with_options_async(request, runtime)

    def modify_ipv_6translator_bandwidth_with_options(
        self,
        request: vpc_20160428_models.ModifyIPv6TranslatorBandwidthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyIPv6TranslatorBandwidthResponse:
        """
        @summary Modifies the maximum bandwidth of an IPv6 Translation Service instance.
        
        @param request: ModifyIPv6TranslatorBandwidthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyIPv6TranslatorBandwidthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ipv_6translator_id):
            query['Ipv6TranslatorId'] = request.ipv_6translator_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyIPv6TranslatorBandwidth',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyIPv6TranslatorBandwidthResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_ipv_6translator_bandwidth_with_options_async(
        self,
        request: vpc_20160428_models.ModifyIPv6TranslatorBandwidthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyIPv6TranslatorBandwidthResponse:
        """
        @summary Modifies the maximum bandwidth of an IPv6 Translation Service instance.
        
        @param request: ModifyIPv6TranslatorBandwidthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyIPv6TranslatorBandwidthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ipv_6translator_id):
            query['Ipv6TranslatorId'] = request.ipv_6translator_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyIPv6TranslatorBandwidth',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyIPv6TranslatorBandwidthResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_ipv_6translator_bandwidth(
        self,
        request: vpc_20160428_models.ModifyIPv6TranslatorBandwidthRequest,
    ) -> vpc_20160428_models.ModifyIPv6TranslatorBandwidthResponse:
        """
        @summary Modifies the maximum bandwidth of an IPv6 Translation Service instance.
        
        @param request: ModifyIPv6TranslatorBandwidthRequest
        @return: ModifyIPv6TranslatorBandwidthResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_ipv_6translator_bandwidth_with_options(request, runtime)

    async def modify_ipv_6translator_bandwidth_async(
        self,
        request: vpc_20160428_models.ModifyIPv6TranslatorBandwidthRequest,
    ) -> vpc_20160428_models.ModifyIPv6TranslatorBandwidthResponse:
        """
        @summary Modifies the maximum bandwidth of an IPv6 Translation Service instance.
        
        @param request: ModifyIPv6TranslatorBandwidthRequest
        @return: ModifyIPv6TranslatorBandwidthResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_ipv_6translator_bandwidth_with_options_async(request, runtime)

    def modify_ipv_6translator_entry_with_options(
        self,
        request: vpc_20160428_models.ModifyIPv6TranslatorEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyIPv6TranslatorEntryResponse:
        """
        @deprecated OpenAPI ModifyIPv6TranslatorEntry is deprecated
        
        @summary Modifies an IPv6 mapping entry.
        
        @param request: ModifyIPv6TranslatorEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyIPv6TranslatorEntryResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_id):
            query['AclId'] = request.acl_id
        if not UtilClient.is_unset(request.acl_status):
            query['AclStatus'] = request.acl_status
        if not UtilClient.is_unset(request.acl_type):
            query['AclType'] = request.acl_type
        if not UtilClient.is_unset(request.allocate_ipv_6port):
            query['AllocateIpv6Port'] = request.allocate_ipv_6port
        if not UtilClient.is_unset(request.backend_ipv_4addr):
            query['BackendIpv4Addr'] = request.backend_ipv_4addr
        if not UtilClient.is_unset(request.backend_ipv_4port):
            query['BackendIpv4Port'] = request.backend_ipv_4port
        if not UtilClient.is_unset(request.entry_bandwidth):
            query['EntryBandwidth'] = request.entry_bandwidth
        if not UtilClient.is_unset(request.entry_description):
            query['EntryDescription'] = request.entry_description
        if not UtilClient.is_unset(request.entry_name):
            query['EntryName'] = request.entry_name
        if not UtilClient.is_unset(request.ipv_6translator_entry_id):
            query['Ipv6TranslatorEntryId'] = request.ipv_6translator_entry_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.trans_protocol):
            query['TransProtocol'] = request.trans_protocol
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyIPv6TranslatorEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyIPv6TranslatorEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_ipv_6translator_entry_with_options_async(
        self,
        request: vpc_20160428_models.ModifyIPv6TranslatorEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyIPv6TranslatorEntryResponse:
        """
        @deprecated OpenAPI ModifyIPv6TranslatorEntry is deprecated
        
        @summary Modifies an IPv6 mapping entry.
        
        @param request: ModifyIPv6TranslatorEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyIPv6TranslatorEntryResponse
        Deprecated
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_id):
            query['AclId'] = request.acl_id
        if not UtilClient.is_unset(request.acl_status):
            query['AclStatus'] = request.acl_status
        if not UtilClient.is_unset(request.acl_type):
            query['AclType'] = request.acl_type
        if not UtilClient.is_unset(request.allocate_ipv_6port):
            query['AllocateIpv6Port'] = request.allocate_ipv_6port
        if not UtilClient.is_unset(request.backend_ipv_4addr):
            query['BackendIpv4Addr'] = request.backend_ipv_4addr
        if not UtilClient.is_unset(request.backend_ipv_4port):
            query['BackendIpv4Port'] = request.backend_ipv_4port
        if not UtilClient.is_unset(request.entry_bandwidth):
            query['EntryBandwidth'] = request.entry_bandwidth
        if not UtilClient.is_unset(request.entry_description):
            query['EntryDescription'] = request.entry_description
        if not UtilClient.is_unset(request.entry_name):
            query['EntryName'] = request.entry_name
        if not UtilClient.is_unset(request.ipv_6translator_entry_id):
            query['Ipv6TranslatorEntryId'] = request.ipv_6translator_entry_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.trans_protocol):
            query['TransProtocol'] = request.trans_protocol
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyIPv6TranslatorEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyIPv6TranslatorEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_ipv_6translator_entry(
        self,
        request: vpc_20160428_models.ModifyIPv6TranslatorEntryRequest,
    ) -> vpc_20160428_models.ModifyIPv6TranslatorEntryResponse:
        """
        @deprecated OpenAPI ModifyIPv6TranslatorEntry is deprecated
        
        @summary Modifies an IPv6 mapping entry.
        
        @param request: ModifyIPv6TranslatorEntryRequest
        @return: ModifyIPv6TranslatorEntryResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_ipv_6translator_entry_with_options(request, runtime)

    async def modify_ipv_6translator_entry_async(
        self,
        request: vpc_20160428_models.ModifyIPv6TranslatorEntryRequest,
    ) -> vpc_20160428_models.ModifyIPv6TranslatorEntryResponse:
        """
        @deprecated OpenAPI ModifyIPv6TranslatorEntry is deprecated
        
        @summary Modifies an IPv6 mapping entry.
        
        @param request: ModifyIPv6TranslatorEntryRequest
        @return: ModifyIPv6TranslatorEntryResponse
        Deprecated
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_ipv_6translator_entry_with_options_async(request, runtime)

    def modify_ipv_6address_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyIpv6AddressAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyIpv6AddressAttributeResponse:
        """
        @summary Modifies the name and description of an IPv6 address.
        
        @param request: ModifyIpv6AddressAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyIpv6AddressAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ipv_6address_id):
            query['Ipv6AddressId'] = request.ipv_6address_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyIpv6AddressAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyIpv6AddressAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_ipv_6address_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyIpv6AddressAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyIpv6AddressAttributeResponse:
        """
        @summary Modifies the name and description of an IPv6 address.
        
        @param request: ModifyIpv6AddressAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyIpv6AddressAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ipv_6address_id):
            query['Ipv6AddressId'] = request.ipv_6address_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyIpv6AddressAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyIpv6AddressAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_ipv_6address_attribute(
        self,
        request: vpc_20160428_models.ModifyIpv6AddressAttributeRequest,
    ) -> vpc_20160428_models.ModifyIpv6AddressAttributeResponse:
        """
        @summary Modifies the name and description of an IPv6 address.
        
        @param request: ModifyIpv6AddressAttributeRequest
        @return: ModifyIpv6AddressAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_ipv_6address_attribute_with_options(request, runtime)

    async def modify_ipv_6address_attribute_async(
        self,
        request: vpc_20160428_models.ModifyIpv6AddressAttributeRequest,
    ) -> vpc_20160428_models.ModifyIpv6AddressAttributeResponse:
        """
        @summary Modifies the name and description of an IPv6 address.
        
        @param request: ModifyIpv6AddressAttributeRequest
        @return: ModifyIpv6AddressAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_ipv_6address_attribute_with_options_async(request, runtime)

    def modify_ipv_6gateway_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyIpv6GatewayAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyIpv6GatewayAttributeResponse:
        """
        @summary Modifies the name and description of an IPv6 gateway.
        
        @param request: ModifyIpv6GatewayAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyIpv6GatewayAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ipv_6gateway_id):
            query['Ipv6GatewayId'] = request.ipv_6gateway_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyIpv6GatewayAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyIpv6GatewayAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_ipv_6gateway_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyIpv6GatewayAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyIpv6GatewayAttributeResponse:
        """
        @summary Modifies the name and description of an IPv6 gateway.
        
        @param request: ModifyIpv6GatewayAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyIpv6GatewayAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.ipv_6gateway_id):
            query['Ipv6GatewayId'] = request.ipv_6gateway_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyIpv6GatewayAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyIpv6GatewayAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_ipv_6gateway_attribute(
        self,
        request: vpc_20160428_models.ModifyIpv6GatewayAttributeRequest,
    ) -> vpc_20160428_models.ModifyIpv6GatewayAttributeResponse:
        """
        @summary Modifies the name and description of an IPv6 gateway.
        
        @param request: ModifyIpv6GatewayAttributeRequest
        @return: ModifyIpv6GatewayAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_ipv_6gateway_attribute_with_options(request, runtime)

    async def modify_ipv_6gateway_attribute_async(
        self,
        request: vpc_20160428_models.ModifyIpv6GatewayAttributeRequest,
    ) -> vpc_20160428_models.ModifyIpv6GatewayAttributeResponse:
        """
        @summary Modifies the name and description of an IPv6 gateway.
        
        @param request: ModifyIpv6GatewayAttributeRequest
        @return: ModifyIpv6GatewayAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_ipv_6gateway_attribute_with_options_async(request, runtime)

    def modify_ipv_6internet_bandwidth_with_options(
        self,
        request: vpc_20160428_models.ModifyIpv6InternetBandwidthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyIpv6InternetBandwidthResponse:
        """
        @summary Modifies the Internet bandwidth value of an IPv6 address.
        
        @description You cannot repeatedly call the *ModifyIpv6InternetBandwidth** operation to modify the Internet bandwidth value of an IPv6 CIDR block within the specified period of time.
        
        @param request: ModifyIpv6InternetBandwidthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyIpv6InternetBandwidthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ipv_6address_id):
            query['Ipv6AddressId'] = request.ipv_6address_id
        if not UtilClient.is_unset(request.ipv_6internet_bandwidth_id):
            query['Ipv6InternetBandwidthId'] = request.ipv_6internet_bandwidth_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyIpv6InternetBandwidth',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyIpv6InternetBandwidthResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_ipv_6internet_bandwidth_with_options_async(
        self,
        request: vpc_20160428_models.ModifyIpv6InternetBandwidthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyIpv6InternetBandwidthResponse:
        """
        @summary Modifies the Internet bandwidth value of an IPv6 address.
        
        @description You cannot repeatedly call the *ModifyIpv6InternetBandwidth** operation to modify the Internet bandwidth value of an IPv6 CIDR block within the specified period of time.
        
        @param request: ModifyIpv6InternetBandwidthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyIpv6InternetBandwidthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ipv_6address_id):
            query['Ipv6AddressId'] = request.ipv_6address_id
        if not UtilClient.is_unset(request.ipv_6internet_bandwidth_id):
            query['Ipv6InternetBandwidthId'] = request.ipv_6internet_bandwidth_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyIpv6InternetBandwidth',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyIpv6InternetBandwidthResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_ipv_6internet_bandwidth(
        self,
        request: vpc_20160428_models.ModifyIpv6InternetBandwidthRequest,
    ) -> vpc_20160428_models.ModifyIpv6InternetBandwidthResponse:
        """
        @summary Modifies the Internet bandwidth value of an IPv6 address.
        
        @description You cannot repeatedly call the *ModifyIpv6InternetBandwidth** operation to modify the Internet bandwidth value of an IPv6 CIDR block within the specified period of time.
        
        @param request: ModifyIpv6InternetBandwidthRequest
        @return: ModifyIpv6InternetBandwidthResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_ipv_6internet_bandwidth_with_options(request, runtime)

    async def modify_ipv_6internet_bandwidth_async(
        self,
        request: vpc_20160428_models.ModifyIpv6InternetBandwidthRequest,
    ) -> vpc_20160428_models.ModifyIpv6InternetBandwidthResponse:
        """
        @summary Modifies the Internet bandwidth value of an IPv6 address.
        
        @description You cannot repeatedly call the *ModifyIpv6InternetBandwidth** operation to modify the Internet bandwidth value of an IPv6 CIDR block within the specified period of time.
        
        @param request: ModifyIpv6InternetBandwidthRequest
        @return: ModifyIpv6InternetBandwidthResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_ipv_6internet_bandwidth_with_options_async(request, runtime)

    def modify_nat_gateway_attribute_with_options(
        self,
        tmp_req: vpc_20160428_models.ModifyNatGatewayAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyNatGatewayAttributeResponse:
        """
        @summary Modifies the name and description of a NAT gateway.
        
        @description ## [](#)Description
        You can call this operation to query an Internet NAT gateway or a virtual private cloud (VPC) NAT gateway. The term NAT gateway in this topic refers to both NAT gateway types.
        
        @param tmp_req: ModifyNatGatewayAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyNatGatewayAttributeResponse
        """
        UtilClient.validate_model(tmp_req)
        request = vpc_20160428_models.ModifyNatGatewayAttributeShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.log_delivery):
            request.log_delivery_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.log_delivery, 'LogDelivery', 'json')
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.eip_bind_mode):
            query['EipBindMode'] = request.eip_bind_mode
        if not UtilClient.is_unset(request.enable_session_log):
            query['EnableSessionLog'] = request.enable_session_log
        if not UtilClient.is_unset(request.icmp_reply_enabled):
            query['IcmpReplyEnabled'] = request.icmp_reply_enabled
        if not UtilClient.is_unset(request.log_delivery_shrink):
            query['LogDelivery'] = request.log_delivery_shrink
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyNatGatewayAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyNatGatewayAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_nat_gateway_attribute_with_options_async(
        self,
        tmp_req: vpc_20160428_models.ModifyNatGatewayAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyNatGatewayAttributeResponse:
        """
        @summary Modifies the name and description of a NAT gateway.
        
        @description ## [](#)Description
        You can call this operation to query an Internet NAT gateway or a virtual private cloud (VPC) NAT gateway. The term NAT gateway in this topic refers to both NAT gateway types.
        
        @param tmp_req: ModifyNatGatewayAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyNatGatewayAttributeResponse
        """
        UtilClient.validate_model(tmp_req)
        request = vpc_20160428_models.ModifyNatGatewayAttributeShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.log_delivery):
            request.log_delivery_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.log_delivery, 'LogDelivery', 'json')
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.eip_bind_mode):
            query['EipBindMode'] = request.eip_bind_mode
        if not UtilClient.is_unset(request.enable_session_log):
            query['EnableSessionLog'] = request.enable_session_log
        if not UtilClient.is_unset(request.icmp_reply_enabled):
            query['IcmpReplyEnabled'] = request.icmp_reply_enabled
        if not UtilClient.is_unset(request.log_delivery_shrink):
            query['LogDelivery'] = request.log_delivery_shrink
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyNatGatewayAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyNatGatewayAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_nat_gateway_attribute(
        self,
        request: vpc_20160428_models.ModifyNatGatewayAttributeRequest,
    ) -> vpc_20160428_models.ModifyNatGatewayAttributeResponse:
        """
        @summary Modifies the name and description of a NAT gateway.
        
        @description ## [](#)Description
        You can call this operation to query an Internet NAT gateway or a virtual private cloud (VPC) NAT gateway. The term NAT gateway in this topic refers to both NAT gateway types.
        
        @param request: ModifyNatGatewayAttributeRequest
        @return: ModifyNatGatewayAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_nat_gateway_attribute_with_options(request, runtime)

    async def modify_nat_gateway_attribute_async(
        self,
        request: vpc_20160428_models.ModifyNatGatewayAttributeRequest,
    ) -> vpc_20160428_models.ModifyNatGatewayAttributeResponse:
        """
        @summary Modifies the name and description of a NAT gateway.
        
        @description ## [](#)Description
        You can call this operation to query an Internet NAT gateway or a virtual private cloud (VPC) NAT gateway. The term NAT gateway in this topic refers to both NAT gateway types.
        
        @param request: ModifyNatGatewayAttributeRequest
        @return: ModifyNatGatewayAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_nat_gateway_attribute_with_options_async(request, runtime)

    def modify_nat_gateway_spec_with_options(
        self,
        request: vpc_20160428_models.ModifyNatGatewaySpecRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyNatGatewaySpecResponse:
        """
        @summary Upgrades a subscription Internet NAT gateway.
        
        @description - You cannot call this operation to downgrade a subscription Internet NAT gateway. You can downgrade a subscription Internet NAT gateway only in the console.
        - When you call this operation to upgrade a subscription Internet NAT gateway, an order is generated. After you complete the payment in the order center, the Internet NAT gateway is upgraded.
        - *ModifyNatGatewaySpec** is an asynchronous operation. After you make a request, the ID of the request is returned but the Internet NAT gateway is not upgraded. The system upgrades the NAT gateway in the background. You can call the [DescribeNatGateways](/help/en/virtual-private-cloud/latest/describenatgateways) operation to query the status of an Internet NAT gateway.    - If an Internet NAT gateway is in the **Modifying** state, the NAT gateway is being upgraded. In this case, you can only query the NAT gateway but cannot perform other operations.
        - If an Internet NAT gateway is in the *Available** state, the Internet NAT gateway is upgraded.
        - You cannot repeatedly call the *ModifyNatGatewaySpec** operation to resize a pay-by-specification NAT gateway.
        Internet NAT gateways are available in different sizes. The size of an Internet NAT gateway determines the SNAT performance, which includes the maximum number of connections and the number of new connections per second. However, the size of a NAT gateway does not affect the data throughput. The following table describes the correlations between different sizes of Internet NAT gateways and SNAT performance metrics.
        | Size | Maximum number of connections | Number of new connections per second |
        | ---- | ----------------------------- | ------------------------------------ |
        | Small | 10,000 | 1,000 |
        | Medium | 50,000 | 5,000 |
        | Large | 200,000 | 10,000 |
        
        @param request: ModifyNatGatewaySpecRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyNatGatewaySpecResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.spec):
            query['Spec'] = request.spec
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyNatGatewaySpec',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyNatGatewaySpecResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_nat_gateway_spec_with_options_async(
        self,
        request: vpc_20160428_models.ModifyNatGatewaySpecRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyNatGatewaySpecResponse:
        """
        @summary Upgrades a subscription Internet NAT gateway.
        
        @description - You cannot call this operation to downgrade a subscription Internet NAT gateway. You can downgrade a subscription Internet NAT gateway only in the console.
        - When you call this operation to upgrade a subscription Internet NAT gateway, an order is generated. After you complete the payment in the order center, the Internet NAT gateway is upgraded.
        - *ModifyNatGatewaySpec** is an asynchronous operation. After you make a request, the ID of the request is returned but the Internet NAT gateway is not upgraded. The system upgrades the NAT gateway in the background. You can call the [DescribeNatGateways](/help/en/virtual-private-cloud/latest/describenatgateways) operation to query the status of an Internet NAT gateway.    - If an Internet NAT gateway is in the **Modifying** state, the NAT gateway is being upgraded. In this case, you can only query the NAT gateway but cannot perform other operations.
        - If an Internet NAT gateway is in the *Available** state, the Internet NAT gateway is upgraded.
        - You cannot repeatedly call the *ModifyNatGatewaySpec** operation to resize a pay-by-specification NAT gateway.
        Internet NAT gateways are available in different sizes. The size of an Internet NAT gateway determines the SNAT performance, which includes the maximum number of connections and the number of new connections per second. However, the size of a NAT gateway does not affect the data throughput. The following table describes the correlations between different sizes of Internet NAT gateways and SNAT performance metrics.
        | Size | Maximum number of connections | Number of new connections per second |
        | ---- | ----------------------------- | ------------------------------------ |
        | Small | 10,000 | 1,000 |
        | Medium | 50,000 | 5,000 |
        | Large | 200,000 | 10,000 |
        
        @param request: ModifyNatGatewaySpecRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyNatGatewaySpecResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_pay):
            query['AutoPay'] = request.auto_pay
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.spec):
            query['Spec'] = request.spec
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyNatGatewaySpec',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyNatGatewaySpecResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_nat_gateway_spec(
        self,
        request: vpc_20160428_models.ModifyNatGatewaySpecRequest,
    ) -> vpc_20160428_models.ModifyNatGatewaySpecResponse:
        """
        @summary Upgrades a subscription Internet NAT gateway.
        
        @description - You cannot call this operation to downgrade a subscription Internet NAT gateway. You can downgrade a subscription Internet NAT gateway only in the console.
        - When you call this operation to upgrade a subscription Internet NAT gateway, an order is generated. After you complete the payment in the order center, the Internet NAT gateway is upgraded.
        - *ModifyNatGatewaySpec** is an asynchronous operation. After you make a request, the ID of the request is returned but the Internet NAT gateway is not upgraded. The system upgrades the NAT gateway in the background. You can call the [DescribeNatGateways](/help/en/virtual-private-cloud/latest/describenatgateways) operation to query the status of an Internet NAT gateway.    - If an Internet NAT gateway is in the **Modifying** state, the NAT gateway is being upgraded. In this case, you can only query the NAT gateway but cannot perform other operations.
        - If an Internet NAT gateway is in the *Available** state, the Internet NAT gateway is upgraded.
        - You cannot repeatedly call the *ModifyNatGatewaySpec** operation to resize a pay-by-specification NAT gateway.
        Internet NAT gateways are available in different sizes. The size of an Internet NAT gateway determines the SNAT performance, which includes the maximum number of connections and the number of new connections per second. However, the size of a NAT gateway does not affect the data throughput. The following table describes the correlations between different sizes of Internet NAT gateways and SNAT performance metrics.
        | Size | Maximum number of connections | Number of new connections per second |
        | ---- | ----------------------------- | ------------------------------------ |
        | Small | 10,000 | 1,000 |
        | Medium | 50,000 | 5,000 |
        | Large | 200,000 | 10,000 |
        
        @param request: ModifyNatGatewaySpecRequest
        @return: ModifyNatGatewaySpecResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_nat_gateway_spec_with_options(request, runtime)

    async def modify_nat_gateway_spec_async(
        self,
        request: vpc_20160428_models.ModifyNatGatewaySpecRequest,
    ) -> vpc_20160428_models.ModifyNatGatewaySpecResponse:
        """
        @summary Upgrades a subscription Internet NAT gateway.
        
        @description - You cannot call this operation to downgrade a subscription Internet NAT gateway. You can downgrade a subscription Internet NAT gateway only in the console.
        - When you call this operation to upgrade a subscription Internet NAT gateway, an order is generated. After you complete the payment in the order center, the Internet NAT gateway is upgraded.
        - *ModifyNatGatewaySpec** is an asynchronous operation. After you make a request, the ID of the request is returned but the Internet NAT gateway is not upgraded. The system upgrades the NAT gateway in the background. You can call the [DescribeNatGateways](/help/en/virtual-private-cloud/latest/describenatgateways) operation to query the status of an Internet NAT gateway.    - If an Internet NAT gateway is in the **Modifying** state, the NAT gateway is being upgraded. In this case, you can only query the NAT gateway but cannot perform other operations.
        - If an Internet NAT gateway is in the *Available** state, the Internet NAT gateway is upgraded.
        - You cannot repeatedly call the *ModifyNatGatewaySpec** operation to resize a pay-by-specification NAT gateway.
        Internet NAT gateways are available in different sizes. The size of an Internet NAT gateway determines the SNAT performance, which includes the maximum number of connections and the number of new connections per second. However, the size of a NAT gateway does not affect the data throughput. The following table describes the correlations between different sizes of Internet NAT gateways and SNAT performance metrics.
        | Size | Maximum number of connections | Number of new connections per second |
        | ---- | ----------------------------- | ------------------------------------ |
        | Small | 10,000 | 1,000 |
        | Medium | 50,000 | 5,000 |
        | Large | 200,000 | 10,000 |
        
        @param request: ModifyNatGatewaySpecRequest
        @return: ModifyNatGatewaySpecResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_nat_gateway_spec_with_options_async(request, runtime)

    def modify_nat_ip_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyNatIpAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyNatIpAttributeResponse:
        """
        @summary Modifies the name and description of a NAT IP address.
        
        @description ## [](#)Description
        You cannot repeatedly call the *ModifyNatIpAttribute** operation to modify the name and description of a NAT IP address within the specified period of time.
        
        @param request: ModifyNatIpAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyNatIpAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.nat_ip_description):
            query['NatIpDescription'] = request.nat_ip_description
        if not UtilClient.is_unset(request.nat_ip_id):
            query['NatIpId'] = request.nat_ip_id
        if not UtilClient.is_unset(request.nat_ip_name):
            query['NatIpName'] = request.nat_ip_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyNatIpAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyNatIpAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_nat_ip_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyNatIpAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyNatIpAttributeResponse:
        """
        @summary Modifies the name and description of a NAT IP address.
        
        @description ## [](#)Description
        You cannot repeatedly call the *ModifyNatIpAttribute** operation to modify the name and description of a NAT IP address within the specified period of time.
        
        @param request: ModifyNatIpAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyNatIpAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.nat_ip_description):
            query['NatIpDescription'] = request.nat_ip_description
        if not UtilClient.is_unset(request.nat_ip_id):
            query['NatIpId'] = request.nat_ip_id
        if not UtilClient.is_unset(request.nat_ip_name):
            query['NatIpName'] = request.nat_ip_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyNatIpAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyNatIpAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_nat_ip_attribute(
        self,
        request: vpc_20160428_models.ModifyNatIpAttributeRequest,
    ) -> vpc_20160428_models.ModifyNatIpAttributeResponse:
        """
        @summary Modifies the name and description of a NAT IP address.
        
        @description ## [](#)Description
        You cannot repeatedly call the *ModifyNatIpAttribute** operation to modify the name and description of a NAT IP address within the specified period of time.
        
        @param request: ModifyNatIpAttributeRequest
        @return: ModifyNatIpAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_nat_ip_attribute_with_options(request, runtime)

    async def modify_nat_ip_attribute_async(
        self,
        request: vpc_20160428_models.ModifyNatIpAttributeRequest,
    ) -> vpc_20160428_models.ModifyNatIpAttributeResponse:
        """
        @summary Modifies the name and description of a NAT IP address.
        
        @description ## [](#)Description
        You cannot repeatedly call the *ModifyNatIpAttribute** operation to modify the name and description of a NAT IP address within the specified period of time.
        
        @param request: ModifyNatIpAttributeRequest
        @return: ModifyNatIpAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_nat_ip_attribute_with_options_async(request, runtime)

    def modify_nat_ip_cidr_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyNatIpCidrAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyNatIpCidrAttributeResponse:
        """
        @summary Modifies the name and description of a NAT CIDR block.
        
        @param request: ModifyNatIpCidrAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyNatIpCidrAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.nat_ip_cidr):
            query['NatIpCidr'] = request.nat_ip_cidr
        if not UtilClient.is_unset(request.nat_ip_cidr_description):
            query['NatIpCidrDescription'] = request.nat_ip_cidr_description
        if not UtilClient.is_unset(request.nat_ip_cidr_name):
            query['NatIpCidrName'] = request.nat_ip_cidr_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyNatIpCidrAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyNatIpCidrAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_nat_ip_cidr_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyNatIpCidrAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyNatIpCidrAttributeResponse:
        """
        @summary Modifies the name and description of a NAT CIDR block.
        
        @param request: ModifyNatIpCidrAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyNatIpCidrAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.nat_ip_cidr):
            query['NatIpCidr'] = request.nat_ip_cidr
        if not UtilClient.is_unset(request.nat_ip_cidr_description):
            query['NatIpCidrDescription'] = request.nat_ip_cidr_description
        if not UtilClient.is_unset(request.nat_ip_cidr_name):
            query['NatIpCidrName'] = request.nat_ip_cidr_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyNatIpCidrAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyNatIpCidrAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_nat_ip_cidr_attribute(
        self,
        request: vpc_20160428_models.ModifyNatIpCidrAttributeRequest,
    ) -> vpc_20160428_models.ModifyNatIpCidrAttributeResponse:
        """
        @summary Modifies the name and description of a NAT CIDR block.
        
        @param request: ModifyNatIpCidrAttributeRequest
        @return: ModifyNatIpCidrAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_nat_ip_cidr_attribute_with_options(request, runtime)

    async def modify_nat_ip_cidr_attribute_async(
        self,
        request: vpc_20160428_models.ModifyNatIpCidrAttributeRequest,
    ) -> vpc_20160428_models.ModifyNatIpCidrAttributeResponse:
        """
        @summary Modifies the name and description of a NAT CIDR block.
        
        @param request: ModifyNatIpCidrAttributeRequest
        @return: ModifyNatIpCidrAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_nat_ip_cidr_attribute_with_options_async(request, runtime)

    def modify_network_acl_attributes_with_options(
        self,
        request: vpc_20160428_models.ModifyNetworkAclAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyNetworkAclAttributesResponse:
        """
        @summary Modifies the attributes of a network access control list (ACL).
        
        @param request: ModifyNetworkAclAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyNetworkAclAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.network_acl_id):
            query['NetworkAclId'] = request.network_acl_id
        if not UtilClient.is_unset(request.network_acl_name):
            query['NetworkAclName'] = request.network_acl_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyNetworkAclAttributes',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyNetworkAclAttributesResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_network_acl_attributes_with_options_async(
        self,
        request: vpc_20160428_models.ModifyNetworkAclAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyNetworkAclAttributesResponse:
        """
        @summary Modifies the attributes of a network access control list (ACL).
        
        @param request: ModifyNetworkAclAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyNetworkAclAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.network_acl_id):
            query['NetworkAclId'] = request.network_acl_id
        if not UtilClient.is_unset(request.network_acl_name):
            query['NetworkAclName'] = request.network_acl_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyNetworkAclAttributes',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyNetworkAclAttributesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_network_acl_attributes(
        self,
        request: vpc_20160428_models.ModifyNetworkAclAttributesRequest,
    ) -> vpc_20160428_models.ModifyNetworkAclAttributesResponse:
        """
        @summary Modifies the attributes of a network access control list (ACL).
        
        @param request: ModifyNetworkAclAttributesRequest
        @return: ModifyNetworkAclAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_network_acl_attributes_with_options(request, runtime)

    async def modify_network_acl_attributes_async(
        self,
        request: vpc_20160428_models.ModifyNetworkAclAttributesRequest,
    ) -> vpc_20160428_models.ModifyNetworkAclAttributesResponse:
        """
        @summary Modifies the attributes of a network access control list (ACL).
        
        @param request: ModifyNetworkAclAttributesRequest
        @return: ModifyNetworkAclAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_network_acl_attributes_with_options_async(request, runtime)

    def modify_physical_connection_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyPhysicalConnectionAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyPhysicalConnectionAttributeResponse:
        """
        @summary Modifies the configurations of an Express Connect circuit.
        
        @description When you call this operation, take note of the following limits:
        If an Express Connect circuit is in the **Initial**, **Enabled**, or **Rejected** state, you can modify the specifications of the Express Connect circuit and the ID of the redundant circuit.
        If an Express Connect circuit is in the **Canceled**, **Allocating**, **AllocationFailed**, or **Terminated** state, you cannot modify the specifications of the Express Connect circuit.
        After you modify the specifications of an Express Connect circuit that is in the **Rejected** state, the Express Connect circuit enters the **Initial** state.
        
        @param request: ModifyPhysicalConnectionAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyPhysicalConnectionAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.circuit_code):
            query['CircuitCode'] = request.circuit_code
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.line_operator):
            query['LineOperator'] = request.line_operator
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_location):
            query['PeerLocation'] = request.peer_location
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.port_type):
            query['PortType'] = request.port_type
        if not UtilClient.is_unset(request.redundant_physical_connection_id):
            query['RedundantPhysicalConnectionId'] = request.redundant_physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.bandwidth):
            query['bandwidth'] = request.bandwidth
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyPhysicalConnectionAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyPhysicalConnectionAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_physical_connection_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyPhysicalConnectionAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyPhysicalConnectionAttributeResponse:
        """
        @summary Modifies the configurations of an Express Connect circuit.
        
        @description When you call this operation, take note of the following limits:
        If an Express Connect circuit is in the **Initial**, **Enabled**, or **Rejected** state, you can modify the specifications of the Express Connect circuit and the ID of the redundant circuit.
        If an Express Connect circuit is in the **Canceled**, **Allocating**, **AllocationFailed**, or **Terminated** state, you cannot modify the specifications of the Express Connect circuit.
        After you modify the specifications of an Express Connect circuit that is in the **Rejected** state, the Express Connect circuit enters the **Initial** state.
        
        @param request: ModifyPhysicalConnectionAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyPhysicalConnectionAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.circuit_code):
            query['CircuitCode'] = request.circuit_code
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.line_operator):
            query['LineOperator'] = request.line_operator
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_location):
            query['PeerLocation'] = request.peer_location
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.port_type):
            query['PortType'] = request.port_type
        if not UtilClient.is_unset(request.redundant_physical_connection_id):
            query['RedundantPhysicalConnectionId'] = request.redundant_physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.bandwidth):
            query['bandwidth'] = request.bandwidth
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyPhysicalConnectionAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyPhysicalConnectionAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_physical_connection_attribute(
        self,
        request: vpc_20160428_models.ModifyPhysicalConnectionAttributeRequest,
    ) -> vpc_20160428_models.ModifyPhysicalConnectionAttributeResponse:
        """
        @summary Modifies the configurations of an Express Connect circuit.
        
        @description When you call this operation, take note of the following limits:
        If an Express Connect circuit is in the **Initial**, **Enabled**, or **Rejected** state, you can modify the specifications of the Express Connect circuit and the ID of the redundant circuit.
        If an Express Connect circuit is in the **Canceled**, **Allocating**, **AllocationFailed**, or **Terminated** state, you cannot modify the specifications of the Express Connect circuit.
        After you modify the specifications of an Express Connect circuit that is in the **Rejected** state, the Express Connect circuit enters the **Initial** state.
        
        @param request: ModifyPhysicalConnectionAttributeRequest
        @return: ModifyPhysicalConnectionAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_physical_connection_attribute_with_options(request, runtime)

    async def modify_physical_connection_attribute_async(
        self,
        request: vpc_20160428_models.ModifyPhysicalConnectionAttributeRequest,
    ) -> vpc_20160428_models.ModifyPhysicalConnectionAttributeResponse:
        """
        @summary Modifies the configurations of an Express Connect circuit.
        
        @description When you call this operation, take note of the following limits:
        If an Express Connect circuit is in the **Initial**, **Enabled**, or **Rejected** state, you can modify the specifications of the Express Connect circuit and the ID of the redundant circuit.
        If an Express Connect circuit is in the **Canceled**, **Allocating**, **AllocationFailed**, or **Terminated** state, you cannot modify the specifications of the Express Connect circuit.
        After you modify the specifications of an Express Connect circuit that is in the **Rejected** state, the Express Connect circuit enters the **Initial** state.
        
        @param request: ModifyPhysicalConnectionAttributeRequest
        @return: ModifyPhysicalConnectionAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_physical_connection_attribute_with_options_async(request, runtime)

    def modify_route_entry_with_options(
        self,
        request: vpc_20160428_models.ModifyRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyRouteEntryResponse:
        """
        @summary 
        
        @description You cannot repeatedly call the *ModifyRouteEntry** operation to modify the name and description of a custom route within the specified period of time.
        
        @param request: ModifyRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyRouteEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.new_next_hop_id):
            query['NewNextHopId'] = request.new_next_hop_id
        if not UtilClient.is_unset(request.new_next_hop_type):
            query['NewNextHopType'] = request.new_next_hop_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_entry_id):
            query['RouteEntryId'] = request.route_entry_id
        if not UtilClient.is_unset(request.route_entry_name):
            query['RouteEntryName'] = request.route_entry_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyRouteEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyRouteEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_route_entry_with_options_async(
        self,
        request: vpc_20160428_models.ModifyRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyRouteEntryResponse:
        """
        @summary 
        
        @description You cannot repeatedly call the *ModifyRouteEntry** operation to modify the name and description of a custom route within the specified period of time.
        
        @param request: ModifyRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyRouteEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.new_next_hop_id):
            query['NewNextHopId'] = request.new_next_hop_id
        if not UtilClient.is_unset(request.new_next_hop_type):
            query['NewNextHopType'] = request.new_next_hop_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_entry_id):
            query['RouteEntryId'] = request.route_entry_id
        if not UtilClient.is_unset(request.route_entry_name):
            query['RouteEntryName'] = request.route_entry_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyRouteEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyRouteEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_route_entry(
        self,
        request: vpc_20160428_models.ModifyRouteEntryRequest,
    ) -> vpc_20160428_models.ModifyRouteEntryResponse:
        """
        @summary 
        
        @description You cannot repeatedly call the *ModifyRouteEntry** operation to modify the name and description of a custom route within the specified period of time.
        
        @param request: ModifyRouteEntryRequest
        @return: ModifyRouteEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_route_entry_with_options(request, runtime)

    async def modify_route_entry_async(
        self,
        request: vpc_20160428_models.ModifyRouteEntryRequest,
    ) -> vpc_20160428_models.ModifyRouteEntryResponse:
        """
        @summary 
        
        @description You cannot repeatedly call the *ModifyRouteEntry** operation to modify the name and description of a custom route within the specified period of time.
        
        @param request: ModifyRouteEntryRequest
        @return: ModifyRouteEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_route_entry_with_options_async(request, runtime)

    def modify_route_table_attributes_with_options(
        self,
        request: vpc_20160428_models.ModifyRouteTableAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyRouteTableAttributesResponse:
        """
        @summary Modifies the name and description of a route table.
        
        @description You cannot repeatedly call the *ModifyRouteTableAttributes** operation to modify the name and description of a route table within the specified period of time.
        
        @param request: ModifyRouteTableAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyRouteTableAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_propagation_enable):
            query['RoutePropagationEnable'] = request.route_propagation_enable
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        if not UtilClient.is_unset(request.route_table_name):
            query['RouteTableName'] = request.route_table_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyRouteTableAttributes',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyRouteTableAttributesResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_route_table_attributes_with_options_async(
        self,
        request: vpc_20160428_models.ModifyRouteTableAttributesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyRouteTableAttributesResponse:
        """
        @summary Modifies the name and description of a route table.
        
        @description You cannot repeatedly call the *ModifyRouteTableAttributes** operation to modify the name and description of a route table within the specified period of time.
        
        @param request: ModifyRouteTableAttributesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyRouteTableAttributesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_propagation_enable):
            query['RoutePropagationEnable'] = request.route_propagation_enable
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        if not UtilClient.is_unset(request.route_table_name):
            query['RouteTableName'] = request.route_table_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyRouteTableAttributes',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyRouteTableAttributesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_route_table_attributes(
        self,
        request: vpc_20160428_models.ModifyRouteTableAttributesRequest,
    ) -> vpc_20160428_models.ModifyRouteTableAttributesResponse:
        """
        @summary Modifies the name and description of a route table.
        
        @description You cannot repeatedly call the *ModifyRouteTableAttributes** operation to modify the name and description of a route table within the specified period of time.
        
        @param request: ModifyRouteTableAttributesRequest
        @return: ModifyRouteTableAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_route_table_attributes_with_options(request, runtime)

    async def modify_route_table_attributes_async(
        self,
        request: vpc_20160428_models.ModifyRouteTableAttributesRequest,
    ) -> vpc_20160428_models.ModifyRouteTableAttributesResponse:
        """
        @summary Modifies the name and description of a route table.
        
        @description You cannot repeatedly call the *ModifyRouteTableAttributes** operation to modify the name and description of a route table within the specified period of time.
        
        @param request: ModifyRouteTableAttributesRequest
        @return: ModifyRouteTableAttributesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_route_table_attributes_with_options_async(request, runtime)

    def modify_router_interface_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyRouterInterfaceAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyRouterInterfaceAttributeResponse:
        """
        @summary Modifies the configuration of a router interface.
        
        @param request: ModifyRouterInterfaceAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyRouterInterfaceAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.delete_health_check_ip):
            query['DeleteHealthCheckIp'] = request.delete_health_check_ip
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.hc_rate):
            query['HcRate'] = request.hc_rate
        if not UtilClient.is_unset(request.hc_threshold):
            query['HcThreshold'] = request.hc_threshold
        if not UtilClient.is_unset(request.health_check_source_ip):
            query['HealthCheckSourceIp'] = request.health_check_source_ip
        if not UtilClient.is_unset(request.health_check_target_ip):
            query['HealthCheckTargetIp'] = request.health_check_target_ip
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.opposite_interface_id):
            query['OppositeInterfaceId'] = request.opposite_interface_id
        if not UtilClient.is_unset(request.opposite_interface_owner_id):
            query['OppositeInterfaceOwnerId'] = request.opposite_interface_owner_id
        if not UtilClient.is_unset(request.opposite_router_id):
            query['OppositeRouterId'] = request.opposite_router_id
        if not UtilClient.is_unset(request.opposite_router_type):
            query['OppositeRouterType'] = request.opposite_router_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyRouterInterfaceAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyRouterInterfaceAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_router_interface_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyRouterInterfaceAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyRouterInterfaceAttributeResponse:
        """
        @summary Modifies the configuration of a router interface.
        
        @param request: ModifyRouterInterfaceAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyRouterInterfaceAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.delete_health_check_ip):
            query['DeleteHealthCheckIp'] = request.delete_health_check_ip
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.hc_rate):
            query['HcRate'] = request.hc_rate
        if not UtilClient.is_unset(request.hc_threshold):
            query['HcThreshold'] = request.hc_threshold
        if not UtilClient.is_unset(request.health_check_source_ip):
            query['HealthCheckSourceIp'] = request.health_check_source_ip
        if not UtilClient.is_unset(request.health_check_target_ip):
            query['HealthCheckTargetIp'] = request.health_check_target_ip
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.opposite_interface_id):
            query['OppositeInterfaceId'] = request.opposite_interface_id
        if not UtilClient.is_unset(request.opposite_interface_owner_id):
            query['OppositeInterfaceOwnerId'] = request.opposite_interface_owner_id
        if not UtilClient.is_unset(request.opposite_router_id):
            query['OppositeRouterId'] = request.opposite_router_id
        if not UtilClient.is_unset(request.opposite_router_type):
            query['OppositeRouterType'] = request.opposite_router_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyRouterInterfaceAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyRouterInterfaceAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_router_interface_attribute(
        self,
        request: vpc_20160428_models.ModifyRouterInterfaceAttributeRequest,
    ) -> vpc_20160428_models.ModifyRouterInterfaceAttributeResponse:
        """
        @summary Modifies the configuration of a router interface.
        
        @param request: ModifyRouterInterfaceAttributeRequest
        @return: ModifyRouterInterfaceAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_router_interface_attribute_with_options(request, runtime)

    async def modify_router_interface_attribute_async(
        self,
        request: vpc_20160428_models.ModifyRouterInterfaceAttributeRequest,
    ) -> vpc_20160428_models.ModifyRouterInterfaceAttributeResponse:
        """
        @summary Modifies the configuration of a router interface.
        
        @param request: ModifyRouterInterfaceAttributeRequest
        @return: ModifyRouterInterfaceAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_router_interface_attribute_with_options_async(request, runtime)

    def modify_router_interface_spec_with_options(
        self,
        request: vpc_20160428_models.ModifyRouterInterfaceSpecRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyRouterInterfaceSpecResponse:
        """
        @summary Modifies the specification of a router interface.
        
        @description After you call this operation, the router interface enters the *Activating** state. After the router interface is activated, the router interface enters the **Active** state.
        >  You cannot modify the specification of a router interface that has overdue payments.
        
        @param request: ModifyRouterInterfaceSpecRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyRouterInterfaceSpecResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        if not UtilClient.is_unset(request.spec):
            query['Spec'] = request.spec
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyRouterInterfaceSpec',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyRouterInterfaceSpecResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_router_interface_spec_with_options_async(
        self,
        request: vpc_20160428_models.ModifyRouterInterfaceSpecRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyRouterInterfaceSpecResponse:
        """
        @summary Modifies the specification of a router interface.
        
        @description After you call this operation, the router interface enters the *Activating** state. After the router interface is activated, the router interface enters the **Active** state.
        >  You cannot modify the specification of a router interface that has overdue payments.
        
        @param request: ModifyRouterInterfaceSpecRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyRouterInterfaceSpecResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.router_interface_id):
            query['RouterInterfaceId'] = request.router_interface_id
        if not UtilClient.is_unset(request.spec):
            query['Spec'] = request.spec
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyRouterInterfaceSpec',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyRouterInterfaceSpecResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_router_interface_spec(
        self,
        request: vpc_20160428_models.ModifyRouterInterfaceSpecRequest,
    ) -> vpc_20160428_models.ModifyRouterInterfaceSpecResponse:
        """
        @summary Modifies the specification of a router interface.
        
        @description After you call this operation, the router interface enters the *Activating** state. After the router interface is activated, the router interface enters the **Active** state.
        >  You cannot modify the specification of a router interface that has overdue payments.
        
        @param request: ModifyRouterInterfaceSpecRequest
        @return: ModifyRouterInterfaceSpecResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_router_interface_spec_with_options(request, runtime)

    async def modify_router_interface_spec_async(
        self,
        request: vpc_20160428_models.ModifyRouterInterfaceSpecRequest,
    ) -> vpc_20160428_models.ModifyRouterInterfaceSpecResponse:
        """
        @summary Modifies the specification of a router interface.
        
        @description After you call this operation, the router interface enters the *Activating** state. After the router interface is activated, the router interface enters the **Active** state.
        >  You cannot modify the specification of a router interface that has overdue payments.
        
        @param request: ModifyRouterInterfaceSpecRequest
        @return: ModifyRouterInterfaceSpecResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_router_interface_spec_with_options_async(request, runtime)

    def modify_snat_entry_with_options(
        self,
        request: vpc_20160428_models.ModifySnatEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifySnatEntryResponse:
        """
        @summary Modifies an SNAT entry.
        
        @description ## [](#)
        *ModifySnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
        **Pending**: indicates that the system is modifying the SNAT entry. You can only query the status of the SNAT entry, but cannot perform other operations.
        **Available**: indicates that the SNAT entry is modified.
        >  If an SNAT entry is in the *Pending** state, it indicates that you cannot modify the SNAT entry.
        You cannot repeatedly call the *ModifySnatEntry** operation to modify an SNAT entry within a specific period of time.
        
        @param request: ModifySnatEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifySnatEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.eip_affinity):
            query['EipAffinity'] = request.eip_affinity
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snat_entry_id):
            query['SnatEntryId'] = request.snat_entry_id
        if not UtilClient.is_unset(request.snat_entry_name):
            query['SnatEntryName'] = request.snat_entry_name
        if not UtilClient.is_unset(request.snat_ip):
            query['SnatIp'] = request.snat_ip
        if not UtilClient.is_unset(request.snat_table_id):
            query['SnatTableId'] = request.snat_table_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifySnatEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifySnatEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_snat_entry_with_options_async(
        self,
        request: vpc_20160428_models.ModifySnatEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifySnatEntryResponse:
        """
        @summary Modifies an SNAT entry.
        
        @description ## [](#)
        *ModifySnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
        **Pending**: indicates that the system is modifying the SNAT entry. You can only query the status of the SNAT entry, but cannot perform other operations.
        **Available**: indicates that the SNAT entry is modified.
        >  If an SNAT entry is in the *Pending** state, it indicates that you cannot modify the SNAT entry.
        You cannot repeatedly call the *ModifySnatEntry** operation to modify an SNAT entry within a specific period of time.
        
        @param request: ModifySnatEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifySnatEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.eip_affinity):
            query['EipAffinity'] = request.eip_affinity
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.snat_entry_id):
            query['SnatEntryId'] = request.snat_entry_id
        if not UtilClient.is_unset(request.snat_entry_name):
            query['SnatEntryName'] = request.snat_entry_name
        if not UtilClient.is_unset(request.snat_ip):
            query['SnatIp'] = request.snat_ip
        if not UtilClient.is_unset(request.snat_table_id):
            query['SnatTableId'] = request.snat_table_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifySnatEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifySnatEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_snat_entry(
        self,
        request: vpc_20160428_models.ModifySnatEntryRequest,
    ) -> vpc_20160428_models.ModifySnatEntryResponse:
        """
        @summary Modifies an SNAT entry.
        
        @description ## [](#)
        *ModifySnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
        **Pending**: indicates that the system is modifying the SNAT entry. You can only query the status of the SNAT entry, but cannot perform other operations.
        **Available**: indicates that the SNAT entry is modified.
        >  If an SNAT entry is in the *Pending** state, it indicates that you cannot modify the SNAT entry.
        You cannot repeatedly call the *ModifySnatEntry** operation to modify an SNAT entry within a specific period of time.
        
        @param request: ModifySnatEntryRequest
        @return: ModifySnatEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_snat_entry_with_options(request, runtime)

    async def modify_snat_entry_async(
        self,
        request: vpc_20160428_models.ModifySnatEntryRequest,
    ) -> vpc_20160428_models.ModifySnatEntryResponse:
        """
        @summary Modifies an SNAT entry.
        
        @description ## [](#)
        *ModifySnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
        **Pending**: indicates that the system is modifying the SNAT entry. You can only query the status of the SNAT entry, but cannot perform other operations.
        **Available**: indicates that the SNAT entry is modified.
        >  If an SNAT entry is in the *Pending** state, it indicates that you cannot modify the SNAT entry.
        You cannot repeatedly call the *ModifySnatEntry** operation to modify an SNAT entry within a specific period of time.
        
        @param request: ModifySnatEntryRequest
        @return: ModifySnatEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_snat_entry_with_options_async(request, runtime)

    def modify_ssl_vpn_client_cert_with_options(
        self,
        request: vpc_20160428_models.ModifySslVpnClientCertRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifySslVpnClientCertResponse:
        """
        @summary Modifies the name of an SSL-VPN client certificate.
        
        @param request: ModifySslVpnClientCertRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifySslVpnClientCertResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.ssl_vpn_client_cert_id):
            query['SslVpnClientCertId'] = request.ssl_vpn_client_cert_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifySslVpnClientCert',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifySslVpnClientCertResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_ssl_vpn_client_cert_with_options_async(
        self,
        request: vpc_20160428_models.ModifySslVpnClientCertRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifySslVpnClientCertResponse:
        """
        @summary Modifies the name of an SSL-VPN client certificate.
        
        @param request: ModifySslVpnClientCertRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifySslVpnClientCertResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.ssl_vpn_client_cert_id):
            query['SslVpnClientCertId'] = request.ssl_vpn_client_cert_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifySslVpnClientCert',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifySslVpnClientCertResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_ssl_vpn_client_cert(
        self,
        request: vpc_20160428_models.ModifySslVpnClientCertRequest,
    ) -> vpc_20160428_models.ModifySslVpnClientCertResponse:
        """
        @summary Modifies the name of an SSL-VPN client certificate.
        
        @param request: ModifySslVpnClientCertRequest
        @return: ModifySslVpnClientCertResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_ssl_vpn_client_cert_with_options(request, runtime)

    async def modify_ssl_vpn_client_cert_async(
        self,
        request: vpc_20160428_models.ModifySslVpnClientCertRequest,
    ) -> vpc_20160428_models.ModifySslVpnClientCertResponse:
        """
        @summary Modifies the name of an SSL-VPN client certificate.
        
        @param request: ModifySslVpnClientCertRequest
        @return: ModifySslVpnClientCertResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_ssl_vpn_client_cert_with_options_async(request, runtime)

    def modify_ssl_vpn_server_with_options(
        self,
        request: vpc_20160428_models.ModifySslVpnServerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifySslVpnServerResponse:
        """
        @summary Modifies the configurations of an SSL server.
        
        @description    If you modify only the **name** of the SSL server, the operation is synchronous. If you also modify other configurations besides the **name**, the operation is asynchronous.
        When **ModifySslVpnServer** is an asynchronous operation, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the configurations of the SSL server are being modified.
        If a VPN gateway is in the **active** state, the configurations of the SSL server are modified.
        You cannot repeatedly call **ModifySslVpnServer** to modify the configurations of an SSL server within the specified period of time.
        
        @param request: ModifySslVpnServerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifySslVpnServerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cipher):
            query['Cipher'] = request.cipher
        if not UtilClient.is_unset(request.client_ip_pool):
            query['ClientIpPool'] = request.client_ip_pool
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.compress):
            query['Compress'] = request.compress
        if not UtilClient.is_unset(request.enable_multi_factor_auth):
            query['EnableMultiFactorAuth'] = request.enable_multi_factor_auth
        if not UtilClient.is_unset(request.idaa_sapplication_id):
            query['IDaaSApplicationId'] = request.idaa_sapplication_id
        if not UtilClient.is_unset(request.idaa_sinstance_id):
            query['IDaaSInstanceId'] = request.idaa_sinstance_id
        if not UtilClient.is_unset(request.idaa_sregion_id):
            query['IDaaSRegionId'] = request.idaa_sregion_id
        if not UtilClient.is_unset(request.local_subnet):
            query['LocalSubnet'] = request.local_subnet
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port):
            query['Port'] = request.port
        if not UtilClient.is_unset(request.proto):
            query['Proto'] = request.proto
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.ssl_vpn_server_id):
            query['SslVpnServerId'] = request.ssl_vpn_server_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifySslVpnServer',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifySslVpnServerResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_ssl_vpn_server_with_options_async(
        self,
        request: vpc_20160428_models.ModifySslVpnServerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifySslVpnServerResponse:
        """
        @summary Modifies the configurations of an SSL server.
        
        @description    If you modify only the **name** of the SSL server, the operation is synchronous. If you also modify other configurations besides the **name**, the operation is asynchronous.
        When **ModifySslVpnServer** is an asynchronous operation, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the configurations of the SSL server are being modified.
        If a VPN gateway is in the **active** state, the configurations of the SSL server are modified.
        You cannot repeatedly call **ModifySslVpnServer** to modify the configurations of an SSL server within the specified period of time.
        
        @param request: ModifySslVpnServerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifySslVpnServerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cipher):
            query['Cipher'] = request.cipher
        if not UtilClient.is_unset(request.client_ip_pool):
            query['ClientIpPool'] = request.client_ip_pool
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.compress):
            query['Compress'] = request.compress
        if not UtilClient.is_unset(request.enable_multi_factor_auth):
            query['EnableMultiFactorAuth'] = request.enable_multi_factor_auth
        if not UtilClient.is_unset(request.idaa_sapplication_id):
            query['IDaaSApplicationId'] = request.idaa_sapplication_id
        if not UtilClient.is_unset(request.idaa_sinstance_id):
            query['IDaaSInstanceId'] = request.idaa_sinstance_id
        if not UtilClient.is_unset(request.idaa_sregion_id):
            query['IDaaSRegionId'] = request.idaa_sregion_id
        if not UtilClient.is_unset(request.local_subnet):
            query['LocalSubnet'] = request.local_subnet
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.port):
            query['Port'] = request.port
        if not UtilClient.is_unset(request.proto):
            query['Proto'] = request.proto
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.ssl_vpn_server_id):
            query['SslVpnServerId'] = request.ssl_vpn_server_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifySslVpnServer',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifySslVpnServerResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_ssl_vpn_server(
        self,
        request: vpc_20160428_models.ModifySslVpnServerRequest,
    ) -> vpc_20160428_models.ModifySslVpnServerResponse:
        """
        @summary Modifies the configurations of an SSL server.
        
        @description    If you modify only the **name** of the SSL server, the operation is synchronous. If you also modify other configurations besides the **name**, the operation is asynchronous.
        When **ModifySslVpnServer** is an asynchronous operation, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the configurations of the SSL server are being modified.
        If a VPN gateway is in the **active** state, the configurations of the SSL server are modified.
        You cannot repeatedly call **ModifySslVpnServer** to modify the configurations of an SSL server within the specified period of time.
        
        @param request: ModifySslVpnServerRequest
        @return: ModifySslVpnServerResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_ssl_vpn_server_with_options(request, runtime)

    async def modify_ssl_vpn_server_async(
        self,
        request: vpc_20160428_models.ModifySslVpnServerRequest,
    ) -> vpc_20160428_models.ModifySslVpnServerResponse:
        """
        @summary Modifies the configurations of an SSL server.
        
        @description    If you modify only the **name** of the SSL server, the operation is synchronous. If you also modify other configurations besides the **name**, the operation is asynchronous.
        When **ModifySslVpnServer** is an asynchronous operation, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the configurations of the SSL server are being modified.
        If a VPN gateway is in the **active** state, the configurations of the SSL server are modified.
        You cannot repeatedly call **ModifySslVpnServer** to modify the configurations of an SSL server within the specified period of time.
        
        @param request: ModifySslVpnServerRequest
        @return: ModifySslVpnServerResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_ssl_vpn_server_with_options_async(request, runtime)

    def modify_tunnel_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyTunnelAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyTunnelAttributeResponse:
        """
        @summary Modifies a VPN tunnel.
        
        @param request: ModifyTunnelAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyTunnelAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tunnel_id):
            query['TunnelId'] = request.tunnel_id
        if not UtilClient.is_unset(request.tunnel_options_specification):
            query['TunnelOptionsSpecification'] = request.tunnel_options_specification
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyTunnelAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyTunnelAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_tunnel_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyTunnelAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyTunnelAttributeResponse:
        """
        @summary Modifies a VPN tunnel.
        
        @param request: ModifyTunnelAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyTunnelAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.tunnel_id):
            query['TunnelId'] = request.tunnel_id
        if not UtilClient.is_unset(request.tunnel_options_specification):
            query['TunnelOptionsSpecification'] = request.tunnel_options_specification
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyTunnelAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyTunnelAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_tunnel_attribute(
        self,
        request: vpc_20160428_models.ModifyTunnelAttributeRequest,
    ) -> vpc_20160428_models.ModifyTunnelAttributeResponse:
        """
        @summary Modifies a VPN tunnel.
        
        @param request: ModifyTunnelAttributeRequest
        @return: ModifyTunnelAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_tunnel_attribute_with_options(request, runtime)

    async def modify_tunnel_attribute_async(
        self,
        request: vpc_20160428_models.ModifyTunnelAttributeRequest,
    ) -> vpc_20160428_models.ModifyTunnelAttributeResponse:
        """
        @summary Modifies a VPN tunnel.
        
        @param request: ModifyTunnelAttributeRequest
        @return: ModifyTunnelAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_tunnel_attribute_with_options_async(request, runtime)

    def modify_vrouter_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyVRouterAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVRouterAttributeResponse:
        """
        @summary Modifies the name and description of a vRouter.
        
        @description You cannot repeatedly call the *ModifyVRouterAttribute** operation within a specific period of time.
        
        @param request: ModifyVRouterAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVRouterAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vrouter_id):
            query['VRouterId'] = request.vrouter_id
        if not UtilClient.is_unset(request.vrouter_name):
            query['VRouterName'] = request.vrouter_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVRouterAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVRouterAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_vrouter_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyVRouterAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVRouterAttributeResponse:
        """
        @summary Modifies the name and description of a vRouter.
        
        @description You cannot repeatedly call the *ModifyVRouterAttribute** operation within a specific period of time.
        
        @param request: ModifyVRouterAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVRouterAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vrouter_id):
            query['VRouterId'] = request.vrouter_id
        if not UtilClient.is_unset(request.vrouter_name):
            query['VRouterName'] = request.vrouter_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVRouterAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVRouterAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_vrouter_attribute(
        self,
        request: vpc_20160428_models.ModifyVRouterAttributeRequest,
    ) -> vpc_20160428_models.ModifyVRouterAttributeResponse:
        """
        @summary Modifies the name and description of a vRouter.
        
        @description You cannot repeatedly call the *ModifyVRouterAttribute** operation within a specific period of time.
        
        @param request: ModifyVRouterAttributeRequest
        @return: ModifyVRouterAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_vrouter_attribute_with_options(request, runtime)

    async def modify_vrouter_attribute_async(
        self,
        request: vpc_20160428_models.ModifyVRouterAttributeRequest,
    ) -> vpc_20160428_models.ModifyVRouterAttributeResponse:
        """
        @summary Modifies the name and description of a vRouter.
        
        @description You cannot repeatedly call the *ModifyVRouterAttribute** operation within a specific period of time.
        
        @param request: ModifyVRouterAttributeRequest
        @return: ModifyVRouterAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_vrouter_attribute_with_options_async(request, runtime)

    def modify_vswitch_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyVSwitchAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVSwitchAttributeResponse:
        """
        @summary VSwitch
        
        @description    **ModifyVSwitchAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
        If the vSwitch is in the **Pending** state, the name and description of the vSwitch are being modified.
        If the vSwitch is in the **Available** state, the name and description of the vSwitch are modified.
        You cannot repeatedly call the **ModifyVSwitchAttribute** operation to modify the name and description of a vSwitch within the specified period of time.
        
        @param request: ModifyVSwitchAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVSwitchAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.enable_ipv_6):
            query['EnableIPv6'] = request.enable_ipv_6
        if not UtilClient.is_unset(request.ipv_6cidr_block):
            query['Ipv6CidrBlock'] = request.ipv_6cidr_block
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.v_switch_name):
            query['VSwitchName'] = request.v_switch_name
        if not UtilClient.is_unset(request.vpc_ipv_6cidr_block):
            query['VpcIpv6CidrBlock'] = request.vpc_ipv_6cidr_block
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVSwitchAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVSwitchAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_vswitch_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyVSwitchAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVSwitchAttributeResponse:
        """
        @summary VSwitch
        
        @description    **ModifyVSwitchAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
        If the vSwitch is in the **Pending** state, the name and description of the vSwitch are being modified.
        If the vSwitch is in the **Available** state, the name and description of the vSwitch are modified.
        You cannot repeatedly call the **ModifyVSwitchAttribute** operation to modify the name and description of a vSwitch within the specified period of time.
        
        @param request: ModifyVSwitchAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVSwitchAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.enable_ipv_6):
            query['EnableIPv6'] = request.enable_ipv_6
        if not UtilClient.is_unset(request.ipv_6cidr_block):
            query['Ipv6CidrBlock'] = request.ipv_6cidr_block
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.v_switch_name):
            query['VSwitchName'] = request.v_switch_name
        if not UtilClient.is_unset(request.vpc_ipv_6cidr_block):
            query['VpcIpv6CidrBlock'] = request.vpc_ipv_6cidr_block
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVSwitchAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVSwitchAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_vswitch_attribute(
        self,
        request: vpc_20160428_models.ModifyVSwitchAttributeRequest,
    ) -> vpc_20160428_models.ModifyVSwitchAttributeResponse:
        """
        @summary VSwitch
        
        @description    **ModifyVSwitchAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
        If the vSwitch is in the **Pending** state, the name and description of the vSwitch are being modified.
        If the vSwitch is in the **Available** state, the name and description of the vSwitch are modified.
        You cannot repeatedly call the **ModifyVSwitchAttribute** operation to modify the name and description of a vSwitch within the specified period of time.
        
        @param request: ModifyVSwitchAttributeRequest
        @return: ModifyVSwitchAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_vswitch_attribute_with_options(request, runtime)

    async def modify_vswitch_attribute_async(
        self,
        request: vpc_20160428_models.ModifyVSwitchAttributeRequest,
    ) -> vpc_20160428_models.ModifyVSwitchAttributeResponse:
        """
        @summary VSwitch
        
        @description    **ModifyVSwitchAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
        If the vSwitch is in the **Pending** state, the name and description of the vSwitch are being modified.
        If the vSwitch is in the **Available** state, the name and description of the vSwitch are modified.
        You cannot repeatedly call the **ModifyVSwitchAttribute** operation to modify the name and description of a vSwitch within the specified period of time.
        
        @param request: ModifyVSwitchAttributeRequest
        @return: ModifyVSwitchAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_vswitch_attribute_with_options_async(request, runtime)

    def modify_vswitch_cidr_reservation_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyVSwitchCidrReservationAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVSwitchCidrReservationAttributeResponse:
        """
        @summary 
        
        @description ## [](#)Usage notes
        You cannot repeatedly call *ModifyVSwitchCidrReservationAttribute** within a specific time period.
        
        @param request: ModifyVSwitchCidrReservationAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVSwitchCidrReservationAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_description):
            query['VSwitchCidrReservationDescription'] = request.v_switch_cidr_reservation_description
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_id):
            query['VSwitchCidrReservationId'] = request.v_switch_cidr_reservation_id
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_name):
            query['VSwitchCidrReservationName'] = request.v_switch_cidr_reservation_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVSwitchCidrReservationAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVSwitchCidrReservationAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_vswitch_cidr_reservation_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyVSwitchCidrReservationAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVSwitchCidrReservationAttributeResponse:
        """
        @summary 
        
        @description ## [](#)Usage notes
        You cannot repeatedly call *ModifyVSwitchCidrReservationAttribute** within a specific time period.
        
        @param request: ModifyVSwitchCidrReservationAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVSwitchCidrReservationAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_description):
            query['VSwitchCidrReservationDescription'] = request.v_switch_cidr_reservation_description
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_id):
            query['VSwitchCidrReservationId'] = request.v_switch_cidr_reservation_id
        if not UtilClient.is_unset(request.v_switch_cidr_reservation_name):
            query['VSwitchCidrReservationName'] = request.v_switch_cidr_reservation_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVSwitchCidrReservationAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVSwitchCidrReservationAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_vswitch_cidr_reservation_attribute(
        self,
        request: vpc_20160428_models.ModifyVSwitchCidrReservationAttributeRequest,
    ) -> vpc_20160428_models.ModifyVSwitchCidrReservationAttributeResponse:
        """
        @summary 
        
        @description ## [](#)Usage notes
        You cannot repeatedly call *ModifyVSwitchCidrReservationAttribute** within a specific time period.
        
        @param request: ModifyVSwitchCidrReservationAttributeRequest
        @return: ModifyVSwitchCidrReservationAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_vswitch_cidr_reservation_attribute_with_options(request, runtime)

    async def modify_vswitch_cidr_reservation_attribute_async(
        self,
        request: vpc_20160428_models.ModifyVSwitchCidrReservationAttributeRequest,
    ) -> vpc_20160428_models.ModifyVSwitchCidrReservationAttributeResponse:
        """
        @summary 
        
        @description ## [](#)Usage notes
        You cannot repeatedly call *ModifyVSwitchCidrReservationAttribute** within a specific time period.
        
        @param request: ModifyVSwitchCidrReservationAttributeRequest
        @return: ModifyVSwitchCidrReservationAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_vswitch_cidr_reservation_attribute_with_options_async(request, runtime)

    def modify_vco_route_entry_weight_with_options(
        self,
        request: vpc_20160428_models.ModifyVcoRouteEntryWeightRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVcoRouteEntryWeightResponse:
        """
        @summary Modifies the weight of a destination-based route for an IPsec-VPN connection.
        
        @description    **ModifyVcoRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the associated IPsec-VPN connection and determine whether the weight of the specified destination-based route is modified.
        If the IPsec-VPN connection is in the **updating** state, the weight of the destination-based route is being modified.
        If the IPsec-VPN connection is in the **attached** state, the weight of the destination-based route is modified.
        You cannot repeatedly call the **ModifyVcoRouteEntryWeight** operation for the same IPsec-VPN connection within the specified period of time.
        
        @param request: ModifyVcoRouteEntryWeightRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVcoRouteEntryWeightResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.new_weight):
            query['NewWeight'] = request.new_weight
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.overlay_mode):
            query['OverlayMode'] = request.overlay_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVcoRouteEntryWeight',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVcoRouteEntryWeightResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_vco_route_entry_weight_with_options_async(
        self,
        request: vpc_20160428_models.ModifyVcoRouteEntryWeightRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVcoRouteEntryWeightResponse:
        """
        @summary Modifies the weight of a destination-based route for an IPsec-VPN connection.
        
        @description    **ModifyVcoRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the associated IPsec-VPN connection and determine whether the weight of the specified destination-based route is modified.
        If the IPsec-VPN connection is in the **updating** state, the weight of the destination-based route is being modified.
        If the IPsec-VPN connection is in the **attached** state, the weight of the destination-based route is modified.
        You cannot repeatedly call the **ModifyVcoRouteEntryWeight** operation for the same IPsec-VPN connection within the specified period of time.
        
        @param request: ModifyVcoRouteEntryWeightRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVcoRouteEntryWeightResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.new_weight):
            query['NewWeight'] = request.new_weight
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.overlay_mode):
            query['OverlayMode'] = request.overlay_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVcoRouteEntryWeight',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVcoRouteEntryWeightResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_vco_route_entry_weight(
        self,
        request: vpc_20160428_models.ModifyVcoRouteEntryWeightRequest,
    ) -> vpc_20160428_models.ModifyVcoRouteEntryWeightResponse:
        """
        @summary Modifies the weight of a destination-based route for an IPsec-VPN connection.
        
        @description    **ModifyVcoRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the associated IPsec-VPN connection and determine whether the weight of the specified destination-based route is modified.
        If the IPsec-VPN connection is in the **updating** state, the weight of the destination-based route is being modified.
        If the IPsec-VPN connection is in the **attached** state, the weight of the destination-based route is modified.
        You cannot repeatedly call the **ModifyVcoRouteEntryWeight** operation for the same IPsec-VPN connection within the specified period of time.
        
        @param request: ModifyVcoRouteEntryWeightRequest
        @return: ModifyVcoRouteEntryWeightResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_vco_route_entry_weight_with_options(request, runtime)

    async def modify_vco_route_entry_weight_async(
        self,
        request: vpc_20160428_models.ModifyVcoRouteEntryWeightRequest,
    ) -> vpc_20160428_models.ModifyVcoRouteEntryWeightResponse:
        """
        @summary Modifies the weight of a destination-based route for an IPsec-VPN connection.
        
        @description    **ModifyVcoRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the associated IPsec-VPN connection and determine whether the weight of the specified destination-based route is modified.
        If the IPsec-VPN connection is in the **updating** state, the weight of the destination-based route is being modified.
        If the IPsec-VPN connection is in the **attached** state, the weight of the destination-based route is modified.
        You cannot repeatedly call the **ModifyVcoRouteEntryWeight** operation for the same IPsec-VPN connection within the specified period of time.
        
        @param request: ModifyVcoRouteEntryWeightRequest
        @return: ModifyVcoRouteEntryWeightResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_vco_route_entry_weight_with_options_async(request, runtime)

    def modify_virtual_border_router_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyVirtualBorderRouterAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVirtualBorderRouterAttributeResponse:
        """
        @summary Modifies the configuration of a virtual border router (VBR).
        
        @description # [](#)
        Only the owner of an Express Connect circuit can modify the **VlanId** parameter.
        One VLAN ID of an Express Connect circuit cannot be used only by one VBR at the same time.
        The VLAN ID of a VBR in the **Terminated** state is reserved for seven days and cannot be used by other VBRs. The VLAN ID can be used by other VBRs after 7 days.
        You cannot set **LocalGatewayIp**, **PeerGatewayIp**, or **PeeringSubnetMask** for VBRs that do not belong to your Alibaba Cloud account.
        Set **PeeringSubnetMask** to a subnet mask with 24 to 30 bits in length (255.255.255.0255.255.255.252).
        Set **LocalGatewayIp** and **PeerGatewayIp** to IP addresses that belong to the same CIDR block. For example, you can set LocalGatewayIp to 192.168.XX.XX, PeerGatewayIp to 192.168.XX.XX, and PeeringSubnetMask to 255.255.255.248.
        
        @param request: ModifyVirtualBorderRouterAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVirtualBorderRouterAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.associated_physical_connections):
            query['AssociatedPhysicalConnections'] = request.associated_physical_connections
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.circuit_code):
            query['CircuitCode'] = request.circuit_code
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.detect_multiplier):
            query['DetectMultiplier'] = request.detect_multiplier
        if not UtilClient.is_unset(request.enable_ipv_6):
            query['EnableIpv6'] = request.enable_ipv_6
        if not UtilClient.is_unset(request.local_gateway_ip):
            query['LocalGatewayIp'] = request.local_gateway_ip
        if not UtilClient.is_unset(request.local_ipv_6gateway_ip):
            query['LocalIpv6GatewayIp'] = request.local_ipv_6gateway_ip
        if not UtilClient.is_unset(request.min_rx_interval):
            query['MinRxInterval'] = request.min_rx_interval
        if not UtilClient.is_unset(request.min_tx_interval):
            query['MinTxInterval'] = request.min_tx_interval
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_gateway_ip):
            query['PeerGatewayIp'] = request.peer_gateway_ip
        if not UtilClient.is_unset(request.peer_ipv_6gateway_ip):
            query['PeerIpv6GatewayIp'] = request.peer_ipv_6gateway_ip
        if not UtilClient.is_unset(request.peering_ipv_6subnet_mask):
            query['PeeringIpv6SubnetMask'] = request.peering_ipv_6subnet_mask
        if not UtilClient.is_unset(request.peering_subnet_mask):
            query['PeeringSubnetMask'] = request.peering_subnet_mask
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.sitelink_enable):
            query['SitelinkEnable'] = request.sitelink_enable
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        if not UtilClient.is_unset(request.vlan_id):
            query['VlanId'] = request.vlan_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVirtualBorderRouterAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVirtualBorderRouterAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_virtual_border_router_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyVirtualBorderRouterAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVirtualBorderRouterAttributeResponse:
        """
        @summary Modifies the configuration of a virtual border router (VBR).
        
        @description # [](#)
        Only the owner of an Express Connect circuit can modify the **VlanId** parameter.
        One VLAN ID of an Express Connect circuit cannot be used only by one VBR at the same time.
        The VLAN ID of a VBR in the **Terminated** state is reserved for seven days and cannot be used by other VBRs. The VLAN ID can be used by other VBRs after 7 days.
        You cannot set **LocalGatewayIp**, **PeerGatewayIp**, or **PeeringSubnetMask** for VBRs that do not belong to your Alibaba Cloud account.
        Set **PeeringSubnetMask** to a subnet mask with 24 to 30 bits in length (255.255.255.0255.255.255.252).
        Set **LocalGatewayIp** and **PeerGatewayIp** to IP addresses that belong to the same CIDR block. For example, you can set LocalGatewayIp to 192.168.XX.XX, PeerGatewayIp to 192.168.XX.XX, and PeeringSubnetMask to 255.255.255.248.
        
        @param request: ModifyVirtualBorderRouterAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVirtualBorderRouterAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.associated_physical_connections):
            query['AssociatedPhysicalConnections'] = request.associated_physical_connections
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.circuit_code):
            query['CircuitCode'] = request.circuit_code
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.detect_multiplier):
            query['DetectMultiplier'] = request.detect_multiplier
        if not UtilClient.is_unset(request.enable_ipv_6):
            query['EnableIpv6'] = request.enable_ipv_6
        if not UtilClient.is_unset(request.local_gateway_ip):
            query['LocalGatewayIp'] = request.local_gateway_ip
        if not UtilClient.is_unset(request.local_ipv_6gateway_ip):
            query['LocalIpv6GatewayIp'] = request.local_ipv_6gateway_ip
        if not UtilClient.is_unset(request.min_rx_interval):
            query['MinRxInterval'] = request.min_rx_interval
        if not UtilClient.is_unset(request.min_tx_interval):
            query['MinTxInterval'] = request.min_tx_interval
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.peer_gateway_ip):
            query['PeerGatewayIp'] = request.peer_gateway_ip
        if not UtilClient.is_unset(request.peer_ipv_6gateway_ip):
            query['PeerIpv6GatewayIp'] = request.peer_ipv_6gateway_ip
        if not UtilClient.is_unset(request.peering_ipv_6subnet_mask):
            query['PeeringIpv6SubnetMask'] = request.peering_ipv_6subnet_mask
        if not UtilClient.is_unset(request.peering_subnet_mask):
            query['PeeringSubnetMask'] = request.peering_subnet_mask
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.sitelink_enable):
            query['SitelinkEnable'] = request.sitelink_enable
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        if not UtilClient.is_unset(request.vlan_id):
            query['VlanId'] = request.vlan_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVirtualBorderRouterAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVirtualBorderRouterAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_virtual_border_router_attribute(
        self,
        request: vpc_20160428_models.ModifyVirtualBorderRouterAttributeRequest,
    ) -> vpc_20160428_models.ModifyVirtualBorderRouterAttributeResponse:
        """
        @summary Modifies the configuration of a virtual border router (VBR).
        
        @description # [](#)
        Only the owner of an Express Connect circuit can modify the **VlanId** parameter.
        One VLAN ID of an Express Connect circuit cannot be used only by one VBR at the same time.
        The VLAN ID of a VBR in the **Terminated** state is reserved for seven days and cannot be used by other VBRs. The VLAN ID can be used by other VBRs after 7 days.
        You cannot set **LocalGatewayIp**, **PeerGatewayIp**, or **PeeringSubnetMask** for VBRs that do not belong to your Alibaba Cloud account.
        Set **PeeringSubnetMask** to a subnet mask with 24 to 30 bits in length (255.255.255.0255.255.255.252).
        Set **LocalGatewayIp** and **PeerGatewayIp** to IP addresses that belong to the same CIDR block. For example, you can set LocalGatewayIp to 192.168.XX.XX, PeerGatewayIp to 192.168.XX.XX, and PeeringSubnetMask to 255.255.255.248.
        
        @param request: ModifyVirtualBorderRouterAttributeRequest
        @return: ModifyVirtualBorderRouterAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_virtual_border_router_attribute_with_options(request, runtime)

    async def modify_virtual_border_router_attribute_async(
        self,
        request: vpc_20160428_models.ModifyVirtualBorderRouterAttributeRequest,
    ) -> vpc_20160428_models.ModifyVirtualBorderRouterAttributeResponse:
        """
        @summary Modifies the configuration of a virtual border router (VBR).
        
        @description # [](#)
        Only the owner of an Express Connect circuit can modify the **VlanId** parameter.
        One VLAN ID of an Express Connect circuit cannot be used only by one VBR at the same time.
        The VLAN ID of a VBR in the **Terminated** state is reserved for seven days and cannot be used by other VBRs. The VLAN ID can be used by other VBRs after 7 days.
        You cannot set **LocalGatewayIp**, **PeerGatewayIp**, or **PeeringSubnetMask** for VBRs that do not belong to your Alibaba Cloud account.
        Set **PeeringSubnetMask** to a subnet mask with 24 to 30 bits in length (255.255.255.0255.255.255.252).
        Set **LocalGatewayIp** and **PeerGatewayIp** to IP addresses that belong to the same CIDR block. For example, you can set LocalGatewayIp to 192.168.XX.XX, PeerGatewayIp to 192.168.XX.XX, and PeeringSubnetMask to 255.255.255.248.
        
        @param request: ModifyVirtualBorderRouterAttributeRequest
        @return: ModifyVirtualBorderRouterAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_virtual_border_router_attribute_with_options_async(request, runtime)

    def modify_vpc_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyVpcAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVpcAttributeResponse:
        """
        @summary Modifies the name and description of a virtual private cloud (VPC).
        
        @description ## [](#)Description
        You cannot repeatedly call the *ModifyVpcAttribute** operation to modify the name and description of a VPC within the specified period of time.
        
        @param request: ModifyVpcAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVpcAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cidr_block):
            query['CidrBlock'] = request.cidr_block
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.enable_ipv_6):
            query['EnableIPv6'] = request.enable_ipv_6
        if not UtilClient.is_unset(request.ipv_6cidr_block):
            query['Ipv6CidrBlock'] = request.ipv_6cidr_block
        if not UtilClient.is_unset(request.ipv_6isp):
            query['Ipv6Isp'] = request.ipv_6isp
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.vpc_name):
            query['VpcName'] = request.vpc_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVpcAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVpcAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_vpc_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyVpcAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVpcAttributeResponse:
        """
        @summary Modifies the name and description of a virtual private cloud (VPC).
        
        @description ## [](#)Description
        You cannot repeatedly call the *ModifyVpcAttribute** operation to modify the name and description of a VPC within the specified period of time.
        
        @param request: ModifyVpcAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVpcAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cidr_block):
            query['CidrBlock'] = request.cidr_block
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.enable_ipv_6):
            query['EnableIPv6'] = request.enable_ipv_6
        if not UtilClient.is_unset(request.ipv_6cidr_block):
            query['Ipv6CidrBlock'] = request.ipv_6cidr_block
        if not UtilClient.is_unset(request.ipv_6isp):
            query['Ipv6Isp'] = request.ipv_6isp
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.vpc_name):
            query['VpcName'] = request.vpc_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVpcAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVpcAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_vpc_attribute(
        self,
        request: vpc_20160428_models.ModifyVpcAttributeRequest,
    ) -> vpc_20160428_models.ModifyVpcAttributeResponse:
        """
        @summary Modifies the name and description of a virtual private cloud (VPC).
        
        @description ## [](#)Description
        You cannot repeatedly call the *ModifyVpcAttribute** operation to modify the name and description of a VPC within the specified period of time.
        
        @param request: ModifyVpcAttributeRequest
        @return: ModifyVpcAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_vpc_attribute_with_options(request, runtime)

    async def modify_vpc_attribute_async(
        self,
        request: vpc_20160428_models.ModifyVpcAttributeRequest,
    ) -> vpc_20160428_models.ModifyVpcAttributeResponse:
        """
        @summary Modifies the name and description of a virtual private cloud (VPC).
        
        @description ## [](#)Description
        You cannot repeatedly call the *ModifyVpcAttribute** operation to modify the name and description of a VPC within the specified period of time.
        
        @param request: ModifyVpcAttributeRequest
        @return: ModifyVpcAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_vpc_attribute_with_options_async(request, runtime)

    def modify_vpc_prefix_list_with_options(
        self,
        request: vpc_20160428_models.ModifyVpcPrefixListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVpcPrefixListResponse:
        """
        @summary Modifies the configuration of a prefix list.
        
        @description    **ModifyVpcPrefixList** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPrefixLists](https://help.aliyun.com/document_detail/311535.html) to query the status of the task.
        If the prefix list is in the **Modifying** state, the configuration of the prefix list is being modified.
        If the prefix list is in the **Created** state, the configuration of the prefix list is modified.
        After the configuration of the prefix list is modified, you can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) operation to query the information about the network instances that are associated with the prefix list and determine whether the associated network instances use the new CIDR blocks. If the association **status** of the prefix list is **Created**, the new CIDR blocks are used by the network instances that are associated with the prefix list.
        You cannot repeatedly call **ModifyVpcPrefixList** to modify the configuration of a prefix list within the specified period of time.
        
        @param request: ModifyVpcPrefixListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVpcPrefixListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.add_prefix_list_entry):
            query['AddPrefixListEntry'] = request.add_prefix_list_entry
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.max_entries):
            query['MaxEntries'] = request.max_entries
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_description):
            query['PrefixListDescription'] = request.prefix_list_description
        if not UtilClient.is_unset(request.prefix_list_id):
            query['PrefixListId'] = request.prefix_list_id
        if not UtilClient.is_unset(request.prefix_list_name):
            query['PrefixListName'] = request.prefix_list_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remove_prefix_list_entry):
            query['RemovePrefixListEntry'] = request.remove_prefix_list_entry
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVpcPrefixList',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVpcPrefixListResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_vpc_prefix_list_with_options_async(
        self,
        request: vpc_20160428_models.ModifyVpcPrefixListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVpcPrefixListResponse:
        """
        @summary Modifies the configuration of a prefix list.
        
        @description    **ModifyVpcPrefixList** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPrefixLists](https://help.aliyun.com/document_detail/311535.html) to query the status of the task.
        If the prefix list is in the **Modifying** state, the configuration of the prefix list is being modified.
        If the prefix list is in the **Created** state, the configuration of the prefix list is modified.
        After the configuration of the prefix list is modified, you can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) operation to query the information about the network instances that are associated with the prefix list and determine whether the associated network instances use the new CIDR blocks. If the association **status** of the prefix list is **Created**, the new CIDR blocks are used by the network instances that are associated with the prefix list.
        You cannot repeatedly call **ModifyVpcPrefixList** to modify the configuration of a prefix list within the specified period of time.
        
        @param request: ModifyVpcPrefixListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVpcPrefixListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.add_prefix_list_entry):
            query['AddPrefixListEntry'] = request.add_prefix_list_entry
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.max_entries):
            query['MaxEntries'] = request.max_entries
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_description):
            query['PrefixListDescription'] = request.prefix_list_description
        if not UtilClient.is_unset(request.prefix_list_id):
            query['PrefixListId'] = request.prefix_list_id
        if not UtilClient.is_unset(request.prefix_list_name):
            query['PrefixListName'] = request.prefix_list_name
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remove_prefix_list_entry):
            query['RemovePrefixListEntry'] = request.remove_prefix_list_entry
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVpcPrefixList',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVpcPrefixListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_vpc_prefix_list(
        self,
        request: vpc_20160428_models.ModifyVpcPrefixListRequest,
    ) -> vpc_20160428_models.ModifyVpcPrefixListResponse:
        """
        @summary Modifies the configuration of a prefix list.
        
        @description    **ModifyVpcPrefixList** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPrefixLists](https://help.aliyun.com/document_detail/311535.html) to query the status of the task.
        If the prefix list is in the **Modifying** state, the configuration of the prefix list is being modified.
        If the prefix list is in the **Created** state, the configuration of the prefix list is modified.
        After the configuration of the prefix list is modified, you can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) operation to query the information about the network instances that are associated with the prefix list and determine whether the associated network instances use the new CIDR blocks. If the association **status** of the prefix list is **Created**, the new CIDR blocks are used by the network instances that are associated with the prefix list.
        You cannot repeatedly call **ModifyVpcPrefixList** to modify the configuration of a prefix list within the specified period of time.
        
        @param request: ModifyVpcPrefixListRequest
        @return: ModifyVpcPrefixListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_vpc_prefix_list_with_options(request, runtime)

    async def modify_vpc_prefix_list_async(
        self,
        request: vpc_20160428_models.ModifyVpcPrefixListRequest,
    ) -> vpc_20160428_models.ModifyVpcPrefixListResponse:
        """
        @summary Modifies the configuration of a prefix list.
        
        @description    **ModifyVpcPrefixList** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPrefixLists](https://help.aliyun.com/document_detail/311535.html) to query the status of the task.
        If the prefix list is in the **Modifying** state, the configuration of the prefix list is being modified.
        If the prefix list is in the **Created** state, the configuration of the prefix list is modified.
        After the configuration of the prefix list is modified, you can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) operation to query the information about the network instances that are associated with the prefix list and determine whether the associated network instances use the new CIDR blocks. If the association **status** of the prefix list is **Created**, the new CIDR blocks are used by the network instances that are associated with the prefix list.
        You cannot repeatedly call **ModifyVpcPrefixList** to modify the configuration of a prefix list within the specified period of time.
        
        @param request: ModifyVpcPrefixListRequest
        @return: ModifyVpcPrefixListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_vpc_prefix_list_with_options_async(request, runtime)

    def modify_vpn_attachment_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyVpnAttachmentAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVpnAttachmentAttributeResponse:
        """
        @summary Modifies the configuration of an IPsec-VPN connection.
        
        @description    **ModifyVpnAttachmentAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task to modify the configuration of an IPsec-VPN connection in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task.
        If the IPsec-VPN connection is in the **updating** state, the configuration of the IPsec-VPN connection is being modified.
        If the IPsec-VPN connection is in the **attached** state, the configuration of the IPsec-VPN connection is modified.
        You cannot call the **ModifyVpnAttachmentAttribute** operation again on the same IPsec-VPN connection before the previous operation is complete.
        When you call the **ModifyVpnAttachmentAttribute** operation, take note of the following items:
        If the IPsec-VPN connection is associated with a transit router, you cannot change the type of the gateway connected to the IPsec-VPN connection.
        If the IPsec-VPN connection is not associated with a resource, you cannot change the type of the gateway connected to the IPsec-VPN connection or the customer gateway connected to the IPsec-VPN connection.
        
        @param request: ModifyVpnAttachmentAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVpnAttachmentAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_config_route):
            query['AutoConfigRoute'] = request.auto_config_route
        if not UtilClient.is_unset(request.bgp_config):
            query['BgpConfig'] = request.bgp_config
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.customer_gateway_id):
            query['CustomerGatewayId'] = request.customer_gateway_id
        if not UtilClient.is_unset(request.effect_immediately):
            query['EffectImmediately'] = request.effect_immediately
        if not UtilClient.is_unset(request.enable_dpd):
            query['EnableDpd'] = request.enable_dpd
        if not UtilClient.is_unset(request.enable_nat_traversal):
            query['EnableNatTraversal'] = request.enable_nat_traversal
        if not UtilClient.is_unset(request.health_check_config):
            query['HealthCheckConfig'] = request.health_check_config
        if not UtilClient.is_unset(request.ike_config):
            query['IkeConfig'] = request.ike_config
        if not UtilClient.is_unset(request.ipsec_config):
            query['IpsecConfig'] = request.ipsec_config
        if not UtilClient.is_unset(request.local_subnet):
            query['LocalSubnet'] = request.local_subnet
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remote_ca_cert):
            query['RemoteCaCert'] = request.remote_ca_cert
        if not UtilClient.is_unset(request.remote_subnet):
            query['RemoteSubnet'] = request.remote_subnet
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVpnAttachmentAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVpnAttachmentAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_vpn_attachment_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyVpnAttachmentAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVpnAttachmentAttributeResponse:
        """
        @summary Modifies the configuration of an IPsec-VPN connection.
        
        @description    **ModifyVpnAttachmentAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task to modify the configuration of an IPsec-VPN connection in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task.
        If the IPsec-VPN connection is in the **updating** state, the configuration of the IPsec-VPN connection is being modified.
        If the IPsec-VPN connection is in the **attached** state, the configuration of the IPsec-VPN connection is modified.
        You cannot call the **ModifyVpnAttachmentAttribute** operation again on the same IPsec-VPN connection before the previous operation is complete.
        When you call the **ModifyVpnAttachmentAttribute** operation, take note of the following items:
        If the IPsec-VPN connection is associated with a transit router, you cannot change the type of the gateway connected to the IPsec-VPN connection.
        If the IPsec-VPN connection is not associated with a resource, you cannot change the type of the gateway connected to the IPsec-VPN connection or the customer gateway connected to the IPsec-VPN connection.
        
        @param request: ModifyVpnAttachmentAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVpnAttachmentAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_config_route):
            query['AutoConfigRoute'] = request.auto_config_route
        if not UtilClient.is_unset(request.bgp_config):
            query['BgpConfig'] = request.bgp_config
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.customer_gateway_id):
            query['CustomerGatewayId'] = request.customer_gateway_id
        if not UtilClient.is_unset(request.effect_immediately):
            query['EffectImmediately'] = request.effect_immediately
        if not UtilClient.is_unset(request.enable_dpd):
            query['EnableDpd'] = request.enable_dpd
        if not UtilClient.is_unset(request.enable_nat_traversal):
            query['EnableNatTraversal'] = request.enable_nat_traversal
        if not UtilClient.is_unset(request.health_check_config):
            query['HealthCheckConfig'] = request.health_check_config
        if not UtilClient.is_unset(request.ike_config):
            query['IkeConfig'] = request.ike_config
        if not UtilClient.is_unset(request.ipsec_config):
            query['IpsecConfig'] = request.ipsec_config
        if not UtilClient.is_unset(request.local_subnet):
            query['LocalSubnet'] = request.local_subnet
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remote_ca_cert):
            query['RemoteCaCert'] = request.remote_ca_cert
        if not UtilClient.is_unset(request.remote_subnet):
            query['RemoteSubnet'] = request.remote_subnet
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVpnAttachmentAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVpnAttachmentAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_vpn_attachment_attribute(
        self,
        request: vpc_20160428_models.ModifyVpnAttachmentAttributeRequest,
    ) -> vpc_20160428_models.ModifyVpnAttachmentAttributeResponse:
        """
        @summary Modifies the configuration of an IPsec-VPN connection.
        
        @description    **ModifyVpnAttachmentAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task to modify the configuration of an IPsec-VPN connection in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task.
        If the IPsec-VPN connection is in the **updating** state, the configuration of the IPsec-VPN connection is being modified.
        If the IPsec-VPN connection is in the **attached** state, the configuration of the IPsec-VPN connection is modified.
        You cannot call the **ModifyVpnAttachmentAttribute** operation again on the same IPsec-VPN connection before the previous operation is complete.
        When you call the **ModifyVpnAttachmentAttribute** operation, take note of the following items:
        If the IPsec-VPN connection is associated with a transit router, you cannot change the type of the gateway connected to the IPsec-VPN connection.
        If the IPsec-VPN connection is not associated with a resource, you cannot change the type of the gateway connected to the IPsec-VPN connection or the customer gateway connected to the IPsec-VPN connection.
        
        @param request: ModifyVpnAttachmentAttributeRequest
        @return: ModifyVpnAttachmentAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_vpn_attachment_attribute_with_options(request, runtime)

    async def modify_vpn_attachment_attribute_async(
        self,
        request: vpc_20160428_models.ModifyVpnAttachmentAttributeRequest,
    ) -> vpc_20160428_models.ModifyVpnAttachmentAttributeResponse:
        """
        @summary Modifies the configuration of an IPsec-VPN connection.
        
        @description    **ModifyVpnAttachmentAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task to modify the configuration of an IPsec-VPN connection in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task.
        If the IPsec-VPN connection is in the **updating** state, the configuration of the IPsec-VPN connection is being modified.
        If the IPsec-VPN connection is in the **attached** state, the configuration of the IPsec-VPN connection is modified.
        You cannot call the **ModifyVpnAttachmentAttribute** operation again on the same IPsec-VPN connection before the previous operation is complete.
        When you call the **ModifyVpnAttachmentAttribute** operation, take note of the following items:
        If the IPsec-VPN connection is associated with a transit router, you cannot change the type of the gateway connected to the IPsec-VPN connection.
        If the IPsec-VPN connection is not associated with a resource, you cannot change the type of the gateway connected to the IPsec-VPN connection or the customer gateway connected to the IPsec-VPN connection.
        
        @param request: ModifyVpnAttachmentAttributeRequest
        @return: ModifyVpnAttachmentAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_vpn_attachment_attribute_with_options_async(request, runtime)

    def modify_vpn_connection_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyVpnConnectionAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVpnConnectionAttributeResponse:
        """
        @summary Modifies the configuration of an IPsec-VPN connection.
        
        @description    If you want to modify a IPsec-VPN connection in dual-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
        *ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification**, and **EnableTunnelsBgp**.
        If you want to modify a IPsec-VPN connection in single-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
        *ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **RemoteCaCertificate**.
        **ModifyVpnConnectionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and modifies the configuration of the IPsec-VPN connection in the backend. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
        If the VPN gateway is in the **updating** state, the configuration of the IPsec-VPN connection is being modified.
        If the VPN gateway is in the **active** state, the configuration of the IPsec-VPN connection is modified.
        You cannot repeatedly call the **ModifyVpnConnectionAttribute** operation for the same VPN gateway within the specified period of time.
        
        @param request: ModifyVpnConnectionAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVpnConnectionAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_config_route):
            query['AutoConfigRoute'] = request.auto_config_route
        if not UtilClient.is_unset(request.bgp_config):
            query['BgpConfig'] = request.bgp_config
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.effect_immediately):
            query['EffectImmediately'] = request.effect_immediately
        if not UtilClient.is_unset(request.enable_dpd):
            query['EnableDpd'] = request.enable_dpd
        if not UtilClient.is_unset(request.enable_nat_traversal):
            query['EnableNatTraversal'] = request.enable_nat_traversal
        if not UtilClient.is_unset(request.enable_tunnels_bgp):
            query['EnableTunnelsBgp'] = request.enable_tunnels_bgp
        if not UtilClient.is_unset(request.health_check_config):
            query['HealthCheckConfig'] = request.health_check_config
        if not UtilClient.is_unset(request.ike_config):
            query['IkeConfig'] = request.ike_config
        if not UtilClient.is_unset(request.ipsec_config):
            query['IpsecConfig'] = request.ipsec_config
        if not UtilClient.is_unset(request.local_subnet):
            query['LocalSubnet'] = request.local_subnet
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remote_ca_certificate):
            query['RemoteCaCertificate'] = request.remote_ca_certificate
        if not UtilClient.is_unset(request.remote_subnet):
            query['RemoteSubnet'] = request.remote_subnet
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        body = {}
        body_flat = {}
        if not UtilClient.is_unset(request.tunnel_options_specification):
            body_flat['TunnelOptionsSpecification'] = request.tunnel_options_specification
        body = TeaCore.merge(body,
            OpenApiUtilClient.query(body_flat))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ModifyVpnConnectionAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVpnConnectionAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_vpn_connection_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyVpnConnectionAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVpnConnectionAttributeResponse:
        """
        @summary Modifies the configuration of an IPsec-VPN connection.
        
        @description    If you want to modify a IPsec-VPN connection in dual-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
        *ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification**, and **EnableTunnelsBgp**.
        If you want to modify a IPsec-VPN connection in single-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
        *ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **RemoteCaCertificate**.
        **ModifyVpnConnectionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and modifies the configuration of the IPsec-VPN connection in the backend. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
        If the VPN gateway is in the **updating** state, the configuration of the IPsec-VPN connection is being modified.
        If the VPN gateway is in the **active** state, the configuration of the IPsec-VPN connection is modified.
        You cannot repeatedly call the **ModifyVpnConnectionAttribute** operation for the same VPN gateway within the specified period of time.
        
        @param request: ModifyVpnConnectionAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVpnConnectionAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_config_route):
            query['AutoConfigRoute'] = request.auto_config_route
        if not UtilClient.is_unset(request.bgp_config):
            query['BgpConfig'] = request.bgp_config
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.effect_immediately):
            query['EffectImmediately'] = request.effect_immediately
        if not UtilClient.is_unset(request.enable_dpd):
            query['EnableDpd'] = request.enable_dpd
        if not UtilClient.is_unset(request.enable_nat_traversal):
            query['EnableNatTraversal'] = request.enable_nat_traversal
        if not UtilClient.is_unset(request.enable_tunnels_bgp):
            query['EnableTunnelsBgp'] = request.enable_tunnels_bgp
        if not UtilClient.is_unset(request.health_check_config):
            query['HealthCheckConfig'] = request.health_check_config
        if not UtilClient.is_unset(request.ike_config):
            query['IkeConfig'] = request.ike_config
        if not UtilClient.is_unset(request.ipsec_config):
            query['IpsecConfig'] = request.ipsec_config
        if not UtilClient.is_unset(request.local_subnet):
            query['LocalSubnet'] = request.local_subnet
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remote_ca_certificate):
            query['RemoteCaCertificate'] = request.remote_ca_certificate
        if not UtilClient.is_unset(request.remote_subnet):
            query['RemoteSubnet'] = request.remote_subnet
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_connection_id):
            query['VpnConnectionId'] = request.vpn_connection_id
        body = {}
        body_flat = {}
        if not UtilClient.is_unset(request.tunnel_options_specification):
            body_flat['TunnelOptionsSpecification'] = request.tunnel_options_specification
        body = TeaCore.merge(body,
            OpenApiUtilClient.query(body_flat))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ModifyVpnConnectionAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVpnConnectionAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_vpn_connection_attribute(
        self,
        request: vpc_20160428_models.ModifyVpnConnectionAttributeRequest,
    ) -> vpc_20160428_models.ModifyVpnConnectionAttributeResponse:
        """
        @summary Modifies the configuration of an IPsec-VPN connection.
        
        @description    If you want to modify a IPsec-VPN connection in dual-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
        *ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification**, and **EnableTunnelsBgp**.
        If you want to modify a IPsec-VPN connection in single-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
        *ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **RemoteCaCertificate**.
        **ModifyVpnConnectionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and modifies the configuration of the IPsec-VPN connection in the backend. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
        If the VPN gateway is in the **updating** state, the configuration of the IPsec-VPN connection is being modified.
        If the VPN gateway is in the **active** state, the configuration of the IPsec-VPN connection is modified.
        You cannot repeatedly call the **ModifyVpnConnectionAttribute** operation for the same VPN gateway within the specified period of time.
        
        @param request: ModifyVpnConnectionAttributeRequest
        @return: ModifyVpnConnectionAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_vpn_connection_attribute_with_options(request, runtime)

    async def modify_vpn_connection_attribute_async(
        self,
        request: vpc_20160428_models.ModifyVpnConnectionAttributeRequest,
    ) -> vpc_20160428_models.ModifyVpnConnectionAttributeResponse:
        """
        @summary Modifies the configuration of an IPsec-VPN connection.
        
        @description    If you want to modify a IPsec-VPN connection in dual-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
        *ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification**, and **EnableTunnelsBgp**.
        If you want to modify a IPsec-VPN connection in single-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
        *ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **RemoteCaCertificate**.
        **ModifyVpnConnectionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and modifies the configuration of the IPsec-VPN connection in the backend. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
        If the VPN gateway is in the **updating** state, the configuration of the IPsec-VPN connection is being modified.
        If the VPN gateway is in the **active** state, the configuration of the IPsec-VPN connection is modified.
        You cannot repeatedly call the **ModifyVpnConnectionAttribute** operation for the same VPN gateway within the specified period of time.
        
        @param request: ModifyVpnConnectionAttributeRequest
        @return: ModifyVpnConnectionAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_vpn_connection_attribute_with_options_async(request, runtime)

    def modify_vpn_gateway_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyVpnGatewayAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVpnGatewayAttributeResponse:
        """
        @summary Modifies the name and description of a VPN gateway.
        
        @description    **ModifyVpnGatewayAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If the VPN gateway is in the **updating** state, the VPN gateway is being modified.
        If the VPN gateway is in the **active** state, the VPN gateway is modified.
        You cannot repeatedly call **ModifyVpnGatewayAttribute** to modify a VPN gateway within the specified period of time.
        
        @param request: ModifyVpnGatewayAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVpnGatewayAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_propagate):
            query['AutoPropagate'] = request.auto_propagate
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVpnGatewayAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVpnGatewayAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_vpn_gateway_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyVpnGatewayAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVpnGatewayAttributeResponse:
        """
        @summary Modifies the name and description of a VPN gateway.
        
        @description    **ModifyVpnGatewayAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If the VPN gateway is in the **updating** state, the VPN gateway is being modified.
        If the VPN gateway is in the **active** state, the VPN gateway is modified.
        You cannot repeatedly call **ModifyVpnGatewayAttribute** to modify a VPN gateway within the specified period of time.
        
        @param request: ModifyVpnGatewayAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVpnGatewayAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_propagate):
            query['AutoPropagate'] = request.auto_propagate
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVpnGatewayAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVpnGatewayAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_vpn_gateway_attribute(
        self,
        request: vpc_20160428_models.ModifyVpnGatewayAttributeRequest,
    ) -> vpc_20160428_models.ModifyVpnGatewayAttributeResponse:
        """
        @summary Modifies the name and description of a VPN gateway.
        
        @description    **ModifyVpnGatewayAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If the VPN gateway is in the **updating** state, the VPN gateway is being modified.
        If the VPN gateway is in the **active** state, the VPN gateway is modified.
        You cannot repeatedly call **ModifyVpnGatewayAttribute** to modify a VPN gateway within the specified period of time.
        
        @param request: ModifyVpnGatewayAttributeRequest
        @return: ModifyVpnGatewayAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_vpn_gateway_attribute_with_options(request, runtime)

    async def modify_vpn_gateway_attribute_async(
        self,
        request: vpc_20160428_models.ModifyVpnGatewayAttributeRequest,
    ) -> vpc_20160428_models.ModifyVpnGatewayAttributeResponse:
        """
        @summary Modifies the name and description of a VPN gateway.
        
        @description    **ModifyVpnGatewayAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If the VPN gateway is in the **updating** state, the VPN gateway is being modified.
        If the VPN gateway is in the **active** state, the VPN gateway is modified.
        You cannot repeatedly call **ModifyVpnGatewayAttribute** to modify a VPN gateway within the specified period of time.
        
        @param request: ModifyVpnGatewayAttributeRequest
        @return: ModifyVpnGatewayAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_vpn_gateway_attribute_with_options_async(request, runtime)

    def modify_vpn_pbr_route_entry_attribute_with_options(
        self,
        request: vpc_20160428_models.ModifyVpnPbrRouteEntryAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVpnPbrRouteEntryAttributeResponse:
        """
        @summary Modifies the weight and priority of a policy-based route.
        
        @description    You can call the **ModifyVpnPbrRouteEntryAttribute** operation to modify the weight and priority of a policy-based route.
        If you want to modify only the weight of a policy-based route, call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html).
        If you want to modify only the priority of a policy-based route, call [ModifyVpnPbrRouteEntryPriority](https://help.aliyun.com/document_detail/466870.html).
        If a policy-based route does not support priorities, you can only call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html) to modify its weight.
        The **ModifyVpnPbrRouteEntryAttribute** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
        If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
        If a VPN gateway is in the **active** state, the policy-based route entry is modified.
        You cannot repeatedly call the **ModifyVpnPbrRouteEntryAttribute** operation for the same VPN gateway within the specified period of time.
        
        @param request: ModifyVpnPbrRouteEntryAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVpnPbrRouteEntryAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.new_priority):
            query['NewPriority'] = request.new_priority
        if not UtilClient.is_unset(request.new_weight):
            query['NewWeight'] = request.new_weight
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.route_source):
            query['RouteSource'] = request.route_source
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVpnPbrRouteEntryAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVpnPbrRouteEntryAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_vpn_pbr_route_entry_attribute_with_options_async(
        self,
        request: vpc_20160428_models.ModifyVpnPbrRouteEntryAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVpnPbrRouteEntryAttributeResponse:
        """
        @summary Modifies the weight and priority of a policy-based route.
        
        @description    You can call the **ModifyVpnPbrRouteEntryAttribute** operation to modify the weight and priority of a policy-based route.
        If you want to modify only the weight of a policy-based route, call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html).
        If you want to modify only the priority of a policy-based route, call [ModifyVpnPbrRouteEntryPriority](https://help.aliyun.com/document_detail/466870.html).
        If a policy-based route does not support priorities, you can only call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html) to modify its weight.
        The **ModifyVpnPbrRouteEntryAttribute** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
        If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
        If a VPN gateway is in the **active** state, the policy-based route entry is modified.
        You cannot repeatedly call the **ModifyVpnPbrRouteEntryAttribute** operation for the same VPN gateway within the specified period of time.
        
        @param request: ModifyVpnPbrRouteEntryAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVpnPbrRouteEntryAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.new_priority):
            query['NewPriority'] = request.new_priority
        if not UtilClient.is_unset(request.new_weight):
            query['NewWeight'] = request.new_weight
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.route_source):
            query['RouteSource'] = request.route_source
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVpnPbrRouteEntryAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVpnPbrRouteEntryAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_vpn_pbr_route_entry_attribute(
        self,
        request: vpc_20160428_models.ModifyVpnPbrRouteEntryAttributeRequest,
    ) -> vpc_20160428_models.ModifyVpnPbrRouteEntryAttributeResponse:
        """
        @summary Modifies the weight and priority of a policy-based route.
        
        @description    You can call the **ModifyVpnPbrRouteEntryAttribute** operation to modify the weight and priority of a policy-based route.
        If you want to modify only the weight of a policy-based route, call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html).
        If you want to modify only the priority of a policy-based route, call [ModifyVpnPbrRouteEntryPriority](https://help.aliyun.com/document_detail/466870.html).
        If a policy-based route does not support priorities, you can only call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html) to modify its weight.
        The **ModifyVpnPbrRouteEntryAttribute** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
        If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
        If a VPN gateway is in the **active** state, the policy-based route entry is modified.
        You cannot repeatedly call the **ModifyVpnPbrRouteEntryAttribute** operation for the same VPN gateway within the specified period of time.
        
        @param request: ModifyVpnPbrRouteEntryAttributeRequest
        @return: ModifyVpnPbrRouteEntryAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_vpn_pbr_route_entry_attribute_with_options(request, runtime)

    async def modify_vpn_pbr_route_entry_attribute_async(
        self,
        request: vpc_20160428_models.ModifyVpnPbrRouteEntryAttributeRequest,
    ) -> vpc_20160428_models.ModifyVpnPbrRouteEntryAttributeResponse:
        """
        @summary Modifies the weight and priority of a policy-based route.
        
        @description    You can call the **ModifyVpnPbrRouteEntryAttribute** operation to modify the weight and priority of a policy-based route.
        If you want to modify only the weight of a policy-based route, call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html).
        If you want to modify only the priority of a policy-based route, call [ModifyVpnPbrRouteEntryPriority](https://help.aliyun.com/document_detail/466870.html).
        If a policy-based route does not support priorities, you can only call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html) to modify its weight.
        The **ModifyVpnPbrRouteEntryAttribute** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
        If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
        If a VPN gateway is in the **active** state, the policy-based route entry is modified.
        You cannot repeatedly call the **ModifyVpnPbrRouteEntryAttribute** operation for the same VPN gateway within the specified period of time.
        
        @param request: ModifyVpnPbrRouteEntryAttributeRequest
        @return: ModifyVpnPbrRouteEntryAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_vpn_pbr_route_entry_attribute_with_options_async(request, runtime)

    def modify_vpn_pbr_route_entry_priority_with_options(
        self,
        request: vpc_20160428_models.ModifyVpnPbrRouteEntryPriorityRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVpnPbrRouteEntryPriorityResponse:
        """
        @summary Modifies the priority of a policy-based route.
        
        @description    **ModifyVpnPbrRouteEntryPriority** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
        If the VPN gateway is in the **active** state, the policy-based route is created.
        You cannot repeatedly call the **ModifyVpnPbrRouteEntryPriority** operation for the same VPN gateway within the specified period of time.
        
        @param request: ModifyVpnPbrRouteEntryPriorityRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVpnPbrRouteEntryPriorityResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.new_priority):
            query['NewPriority'] = request.new_priority
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.route_source):
            query['RouteSource'] = request.route_source
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVpnPbrRouteEntryPriority',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVpnPbrRouteEntryPriorityResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_vpn_pbr_route_entry_priority_with_options_async(
        self,
        request: vpc_20160428_models.ModifyVpnPbrRouteEntryPriorityRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVpnPbrRouteEntryPriorityResponse:
        """
        @summary Modifies the priority of a policy-based route.
        
        @description    **ModifyVpnPbrRouteEntryPriority** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
        If the VPN gateway is in the **active** state, the policy-based route is created.
        You cannot repeatedly call the **ModifyVpnPbrRouteEntryPriority** operation for the same VPN gateway within the specified period of time.
        
        @param request: ModifyVpnPbrRouteEntryPriorityRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVpnPbrRouteEntryPriorityResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.new_priority):
            query['NewPriority'] = request.new_priority
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.route_source):
            query['RouteSource'] = request.route_source
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVpnPbrRouteEntryPriority',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVpnPbrRouteEntryPriorityResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_vpn_pbr_route_entry_priority(
        self,
        request: vpc_20160428_models.ModifyVpnPbrRouteEntryPriorityRequest,
    ) -> vpc_20160428_models.ModifyVpnPbrRouteEntryPriorityResponse:
        """
        @summary Modifies the priority of a policy-based route.
        
        @description    **ModifyVpnPbrRouteEntryPriority** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
        If the VPN gateway is in the **active** state, the policy-based route is created.
        You cannot repeatedly call the **ModifyVpnPbrRouteEntryPriority** operation for the same VPN gateway within the specified period of time.
        
        @param request: ModifyVpnPbrRouteEntryPriorityRequest
        @return: ModifyVpnPbrRouteEntryPriorityResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_vpn_pbr_route_entry_priority_with_options(request, runtime)

    async def modify_vpn_pbr_route_entry_priority_async(
        self,
        request: vpc_20160428_models.ModifyVpnPbrRouteEntryPriorityRequest,
    ) -> vpc_20160428_models.ModifyVpnPbrRouteEntryPriorityResponse:
        """
        @summary Modifies the priority of a policy-based route.
        
        @description    **ModifyVpnPbrRouteEntryPriority** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
        If the VPN gateway is in the **active** state, the policy-based route is created.
        You cannot repeatedly call the **ModifyVpnPbrRouteEntryPriority** operation for the same VPN gateway within the specified period of time.
        
        @param request: ModifyVpnPbrRouteEntryPriorityRequest
        @return: ModifyVpnPbrRouteEntryPriorityResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_vpn_pbr_route_entry_priority_with_options_async(request, runtime)

    def modify_vpn_pbr_route_entry_weight_with_options(
        self,
        request: vpc_20160428_models.ModifyVpnPbrRouteEntryWeightRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVpnPbrRouteEntryWeightResponse:
        """
        @summary Modifies the weight of a policy-based route of a VPN gateway.
        
        @description    **ModifyVpnPbrRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
        If a VPN gateway is in the **active** state, the policy-based route entry is modified.
        You cannot repeatedly call the **ModifyVpnPbrRouteEntryWeight** operation for the same VPN gateway within the specified period of time.
        
        @param request: ModifyVpnPbrRouteEntryWeightRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVpnPbrRouteEntryWeightResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.new_weight):
            query['NewWeight'] = request.new_weight
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.overlay_mode):
            query['OverlayMode'] = request.overlay_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.route_source):
            query['RouteSource'] = request.route_source
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVpnPbrRouteEntryWeight',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVpnPbrRouteEntryWeightResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_vpn_pbr_route_entry_weight_with_options_async(
        self,
        request: vpc_20160428_models.ModifyVpnPbrRouteEntryWeightRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVpnPbrRouteEntryWeightResponse:
        """
        @summary Modifies the weight of a policy-based route of a VPN gateway.
        
        @description    **ModifyVpnPbrRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
        If a VPN gateway is in the **active** state, the policy-based route entry is modified.
        You cannot repeatedly call the **ModifyVpnPbrRouteEntryWeight** operation for the same VPN gateway within the specified period of time.
        
        @param request: ModifyVpnPbrRouteEntryWeightRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVpnPbrRouteEntryWeightResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.new_weight):
            query['NewWeight'] = request.new_weight
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.overlay_mode):
            query['OverlayMode'] = request.overlay_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.route_source):
            query['RouteSource'] = request.route_source
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVpnPbrRouteEntryWeight',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVpnPbrRouteEntryWeightResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_vpn_pbr_route_entry_weight(
        self,
        request: vpc_20160428_models.ModifyVpnPbrRouteEntryWeightRequest,
    ) -> vpc_20160428_models.ModifyVpnPbrRouteEntryWeightResponse:
        """
        @summary Modifies the weight of a policy-based route of a VPN gateway.
        
        @description    **ModifyVpnPbrRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
        If a VPN gateway is in the **active** state, the policy-based route entry is modified.
        You cannot repeatedly call the **ModifyVpnPbrRouteEntryWeight** operation for the same VPN gateway within the specified period of time.
        
        @param request: ModifyVpnPbrRouteEntryWeightRequest
        @return: ModifyVpnPbrRouteEntryWeightResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_vpn_pbr_route_entry_weight_with_options(request, runtime)

    async def modify_vpn_pbr_route_entry_weight_async(
        self,
        request: vpc_20160428_models.ModifyVpnPbrRouteEntryWeightRequest,
    ) -> vpc_20160428_models.ModifyVpnPbrRouteEntryWeightResponse:
        """
        @summary Modifies the weight of a policy-based route of a VPN gateway.
        
        @description    **ModifyVpnPbrRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
        If a VPN gateway is in the **active** state, the policy-based route entry is modified.
        You cannot repeatedly call the **ModifyVpnPbrRouteEntryWeight** operation for the same VPN gateway within the specified period of time.
        
        @param request: ModifyVpnPbrRouteEntryWeightRequest
        @return: ModifyVpnPbrRouteEntryWeightResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_vpn_pbr_route_entry_weight_with_options_async(request, runtime)

    def modify_vpn_route_entry_weight_with_options(
        self,
        request: vpc_20160428_models.ModifyVpnRouteEntryWeightRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVpnRouteEntryWeightResponse:
        """
        @summary Modifies the weight of a destination-based route.
        
        @description    In scenarios where a VPN gateway has an active and a standby destination-based route, if you need to modify the weight of the active destination-based route, you must first delete the standby destination-based route. After you modify the active destination-based route, configure a standby destination-based route. If you need to modify the weight of the standby destination-based route, you also need to delete the active destination-based route first. After you modify the standby destination-based route, configure an active destination-based route. For more information about how to delete a destination-based route, see [DeleteVpnRouteEntry](https://help.aliyun.com/document_detail/2526961.html).
        **ModifyVpnRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If the VPN gateway is in the **updating** state, the weight of the destination-based route is being modified.
        If the VPN gateway is in the **active** state, the weight of the destination-based route is modified.
        You cannot repeatedly call the **ModifyVpnRouteEntryWeight** operation to modify the weight of destination-based route for the same VPN gateway within the specified period of time.
        
        @param request: ModifyVpnRouteEntryWeightRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVpnRouteEntryWeightResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.new_weight):
            query['NewWeight'] = request.new_weight
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.overlay_mode):
            query['OverlayMode'] = request.overlay_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVpnRouteEntryWeight',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVpnRouteEntryWeightResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_vpn_route_entry_weight_with_options_async(
        self,
        request: vpc_20160428_models.ModifyVpnRouteEntryWeightRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ModifyVpnRouteEntryWeightResponse:
        """
        @summary Modifies the weight of a destination-based route.
        
        @description    In scenarios where a VPN gateway has an active and a standby destination-based route, if you need to modify the weight of the active destination-based route, you must first delete the standby destination-based route. After you modify the active destination-based route, configure a standby destination-based route. If you need to modify the weight of the standby destination-based route, you also need to delete the active destination-based route first. After you modify the standby destination-based route, configure an active destination-based route. For more information about how to delete a destination-based route, see [DeleteVpnRouteEntry](https://help.aliyun.com/document_detail/2526961.html).
        **ModifyVpnRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If the VPN gateway is in the **updating** state, the weight of the destination-based route is being modified.
        If the VPN gateway is in the **active** state, the weight of the destination-based route is modified.
        You cannot repeatedly call the **ModifyVpnRouteEntryWeight** operation to modify the weight of destination-based route for the same VPN gateway within the specified period of time.
        
        @param request: ModifyVpnRouteEntryWeightRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVpnRouteEntryWeightResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.new_weight):
            query['NewWeight'] = request.new_weight
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.overlay_mode):
            query['OverlayMode'] = request.overlay_mode
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVpnRouteEntryWeight',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ModifyVpnRouteEntryWeightResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_vpn_route_entry_weight(
        self,
        request: vpc_20160428_models.ModifyVpnRouteEntryWeightRequest,
    ) -> vpc_20160428_models.ModifyVpnRouteEntryWeightResponse:
        """
        @summary Modifies the weight of a destination-based route.
        
        @description    In scenarios where a VPN gateway has an active and a standby destination-based route, if you need to modify the weight of the active destination-based route, you must first delete the standby destination-based route. After you modify the active destination-based route, configure a standby destination-based route. If you need to modify the weight of the standby destination-based route, you also need to delete the active destination-based route first. After you modify the standby destination-based route, configure an active destination-based route. For more information about how to delete a destination-based route, see [DeleteVpnRouteEntry](https://help.aliyun.com/document_detail/2526961.html).
        **ModifyVpnRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If the VPN gateway is in the **updating** state, the weight of the destination-based route is being modified.
        If the VPN gateway is in the **active** state, the weight of the destination-based route is modified.
        You cannot repeatedly call the **ModifyVpnRouteEntryWeight** operation to modify the weight of destination-based route for the same VPN gateway within the specified period of time.
        
        @param request: ModifyVpnRouteEntryWeightRequest
        @return: ModifyVpnRouteEntryWeightResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_vpn_route_entry_weight_with_options(request, runtime)

    async def modify_vpn_route_entry_weight_async(
        self,
        request: vpc_20160428_models.ModifyVpnRouteEntryWeightRequest,
    ) -> vpc_20160428_models.ModifyVpnRouteEntryWeightResponse:
        """
        @summary Modifies the weight of a destination-based route.
        
        @description    In scenarios where a VPN gateway has an active and a standby destination-based route, if you need to modify the weight of the active destination-based route, you must first delete the standby destination-based route. After you modify the active destination-based route, configure a standby destination-based route. If you need to modify the weight of the standby destination-based route, you also need to delete the active destination-based route first. After you modify the standby destination-based route, configure an active destination-based route. For more information about how to delete a destination-based route, see [DeleteVpnRouteEntry](https://help.aliyun.com/document_detail/2526961.html).
        **ModifyVpnRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
        If the VPN gateway is in the **updating** state, the weight of the destination-based route is being modified.
        If the VPN gateway is in the **active** state, the weight of the destination-based route is modified.
        You cannot repeatedly call the **ModifyVpnRouteEntryWeight** operation to modify the weight of destination-based route for the same VPN gateway within the specified period of time.
        
        @param request: ModifyVpnRouteEntryWeightRequest
        @return: ModifyVpnRouteEntryWeightResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_vpn_route_entry_weight_with_options_async(request, runtime)

    def move_resource_group_with_options(
        self,
        request: vpc_20160428_models.MoveResourceGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.MoveResourceGroupResponse:
        """
        @summary Moves a resource to another resource group.
        
        @param request: MoveResourceGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: MoveResourceGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.new_resource_group_id):
            query['NewResourceGroupId'] = request.new_resource_group_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='MoveResourceGroup',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.MoveResourceGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def move_resource_group_with_options_async(
        self,
        request: vpc_20160428_models.MoveResourceGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.MoveResourceGroupResponse:
        """
        @summary Moves a resource to another resource group.
        
        @param request: MoveResourceGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: MoveResourceGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.new_resource_group_id):
            query['NewResourceGroupId'] = request.new_resource_group_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='MoveResourceGroup',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.MoveResourceGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def move_resource_group(
        self,
        request: vpc_20160428_models.MoveResourceGroupRequest,
    ) -> vpc_20160428_models.MoveResourceGroupResponse:
        """
        @summary Moves a resource to another resource group.
        
        @param request: MoveResourceGroupRequest
        @return: MoveResourceGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.move_resource_group_with_options(request, runtime)

    async def move_resource_group_async(
        self,
        request: vpc_20160428_models.MoveResourceGroupRequest,
    ) -> vpc_20160428_models.MoveResourceGroupResponse:
        """
        @summary Moves a resource to another resource group.
        
        @param request: MoveResourceGroupRequest
        @return: MoveResourceGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.move_resource_group_with_options_async(request, runtime)

    def move_vpn_resource_group_with_options(
        self,
        request: vpc_20160428_models.MoveVpnResourceGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.MoveVpnResourceGroupResponse:
        """
        @summary Moves a VPN gateway resource to a new resource group.
        
        @param request: MoveVpnResourceGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: MoveVpnResourceGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.new_resource_group_id):
            query['NewResourceGroupId'] = request.new_resource_group_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='MoveVpnResourceGroup',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.MoveVpnResourceGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def move_vpn_resource_group_with_options_async(
        self,
        request: vpc_20160428_models.MoveVpnResourceGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.MoveVpnResourceGroupResponse:
        """
        @summary Moves a VPN gateway resource to a new resource group.
        
        @param request: MoveVpnResourceGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: MoveVpnResourceGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.new_resource_group_id):
            query['NewResourceGroupId'] = request.new_resource_group_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='MoveVpnResourceGroup',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.MoveVpnResourceGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def move_vpn_resource_group(
        self,
        request: vpc_20160428_models.MoveVpnResourceGroupRequest,
    ) -> vpc_20160428_models.MoveVpnResourceGroupResponse:
        """
        @summary Moves a VPN gateway resource to a new resource group.
        
        @param request: MoveVpnResourceGroupRequest
        @return: MoveVpnResourceGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.move_vpn_resource_group_with_options(request, runtime)

    async def move_vpn_resource_group_async(
        self,
        request: vpc_20160428_models.MoveVpnResourceGroupRequest,
    ) -> vpc_20160428_models.MoveVpnResourceGroupResponse:
        """
        @summary Moves a VPN gateway resource to a new resource group.
        
        @param request: MoveVpnResourceGroupRequest
        @return: MoveVpnResourceGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.move_vpn_resource_group_with_options_async(request, runtime)

    def open_flow_log_service_with_options(
        self,
        request: vpc_20160428_models.OpenFlowLogServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.OpenFlowLogServiceResponse:
        """
        @summary Enables the flow log feature.
        
        @description    You cannot repeatedly call the **OpenFlowLogService** operation within the specified period of time by using an Alibaba Cloud account.
        You can call the [GetFlowLogServiceStatus](https://help.aliyun.com/document_detail/449624.html) operation to query the status of the flow log feature.
        
        @param request: OpenFlowLogServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: OpenFlowLogServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='OpenFlowLogService',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.OpenFlowLogServiceResponse(),
            self.call_api(params, req, runtime)
        )

    async def open_flow_log_service_with_options_async(
        self,
        request: vpc_20160428_models.OpenFlowLogServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.OpenFlowLogServiceResponse:
        """
        @summary Enables the flow log feature.
        
        @description    You cannot repeatedly call the **OpenFlowLogService** operation within the specified period of time by using an Alibaba Cloud account.
        You can call the [GetFlowLogServiceStatus](https://help.aliyun.com/document_detail/449624.html) operation to query the status of the flow log feature.
        
        @param request: OpenFlowLogServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: OpenFlowLogServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='OpenFlowLogService',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.OpenFlowLogServiceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def open_flow_log_service(
        self,
        request: vpc_20160428_models.OpenFlowLogServiceRequest,
    ) -> vpc_20160428_models.OpenFlowLogServiceResponse:
        """
        @summary Enables the flow log feature.
        
        @description    You cannot repeatedly call the **OpenFlowLogService** operation within the specified period of time by using an Alibaba Cloud account.
        You can call the [GetFlowLogServiceStatus](https://help.aliyun.com/document_detail/449624.html) operation to query the status of the flow log feature.
        
        @param request: OpenFlowLogServiceRequest
        @return: OpenFlowLogServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.open_flow_log_service_with_options(request, runtime)

    async def open_flow_log_service_async(
        self,
        request: vpc_20160428_models.OpenFlowLogServiceRequest,
    ) -> vpc_20160428_models.OpenFlowLogServiceResponse:
        """
        @summary Enables the flow log feature.
        
        @description    You cannot repeatedly call the **OpenFlowLogService** operation within the specified period of time by using an Alibaba Cloud account.
        You can call the [GetFlowLogServiceStatus](https://help.aliyun.com/document_detail/449624.html) operation to query the status of the flow log feature.
        
        @param request: OpenFlowLogServiceRequest
        @return: OpenFlowLogServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.open_flow_log_service_with_options_async(request, runtime)

    def open_physical_connection_service_with_options(
        self,
        request: vpc_20160428_models.OpenPhysicalConnectionServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.OpenPhysicalConnectionServiceResponse:
        """
        @summary 
        
        @param request: OpenPhysicalConnectionServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: OpenPhysicalConnectionServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='OpenPhysicalConnectionService',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.OpenPhysicalConnectionServiceResponse(),
            self.call_api(params, req, runtime)
        )

    async def open_physical_connection_service_with_options_async(
        self,
        request: vpc_20160428_models.OpenPhysicalConnectionServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.OpenPhysicalConnectionServiceResponse:
        """
        @summary 
        
        @param request: OpenPhysicalConnectionServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: OpenPhysicalConnectionServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='OpenPhysicalConnectionService',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.OpenPhysicalConnectionServiceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def open_physical_connection_service(
        self,
        request: vpc_20160428_models.OpenPhysicalConnectionServiceRequest,
    ) -> vpc_20160428_models.OpenPhysicalConnectionServiceResponse:
        """
        @summary 
        
        @param request: OpenPhysicalConnectionServiceRequest
        @return: OpenPhysicalConnectionServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.open_physical_connection_service_with_options(request, runtime)

    async def open_physical_connection_service_async(
        self,
        request: vpc_20160428_models.OpenPhysicalConnectionServiceRequest,
    ) -> vpc_20160428_models.OpenPhysicalConnectionServiceResponse:
        """
        @summary 
        
        @param request: OpenPhysicalConnectionServiceRequest
        @return: OpenPhysicalConnectionServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.open_physical_connection_service_with_options_async(request, runtime)

    def open_public_ip_address_pool_service_with_options(
        self,
        request: vpc_20160428_models.OpenPublicIpAddressPoolServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.OpenPublicIpAddressPoolServiceResponse:
        """
        @summary IP
        
        @param request: OpenPublicIpAddressPoolServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: OpenPublicIpAddressPoolServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='OpenPublicIpAddressPoolService',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.OpenPublicIpAddressPoolServiceResponse(),
            self.call_api(params, req, runtime)
        )

    async def open_public_ip_address_pool_service_with_options_async(
        self,
        request: vpc_20160428_models.OpenPublicIpAddressPoolServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.OpenPublicIpAddressPoolServiceResponse:
        """
        @summary IP
        
        @param request: OpenPublicIpAddressPoolServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: OpenPublicIpAddressPoolServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='OpenPublicIpAddressPoolService',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.OpenPublicIpAddressPoolServiceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def open_public_ip_address_pool_service(
        self,
        request: vpc_20160428_models.OpenPublicIpAddressPoolServiceRequest,
    ) -> vpc_20160428_models.OpenPublicIpAddressPoolServiceResponse:
        """
        @summary IP
        
        @param request: OpenPublicIpAddressPoolServiceRequest
        @return: OpenPublicIpAddressPoolServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.open_public_ip_address_pool_service_with_options(request, runtime)

    async def open_public_ip_address_pool_service_async(
        self,
        request: vpc_20160428_models.OpenPublicIpAddressPoolServiceRequest,
    ) -> vpc_20160428_models.OpenPublicIpAddressPoolServiceResponse:
        """
        @summary IP
        
        @param request: OpenPublicIpAddressPoolServiceRequest
        @return: OpenPublicIpAddressPoolServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.open_public_ip_address_pool_service_with_options_async(request, runtime)

    def open_traffic_mirror_service_with_options(
        self,
        request: vpc_20160428_models.OpenTrafficMirrorServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.OpenTrafficMirrorServiceResponse:
        """
        @summary Enables traffic mirroring.
        
        @description ## [](#)Usage notes
        You can enable traffic mirroring for different regions. You cannot repeatedly call the *OpenTrafficMirrorService** operation to enable traffic mirroring for one region within the specified period of time.
        
        @param request: OpenTrafficMirrorServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: OpenTrafficMirrorServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='OpenTrafficMirrorService',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.OpenTrafficMirrorServiceResponse(),
            self.call_api(params, req, runtime)
        )

    async def open_traffic_mirror_service_with_options_async(
        self,
        request: vpc_20160428_models.OpenTrafficMirrorServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.OpenTrafficMirrorServiceResponse:
        """
        @summary Enables traffic mirroring.
        
        @description ## [](#)Usage notes
        You can enable traffic mirroring for different regions. You cannot repeatedly call the *OpenTrafficMirrorService** operation to enable traffic mirroring for one region within the specified period of time.
        
        @param request: OpenTrafficMirrorServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: OpenTrafficMirrorServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='OpenTrafficMirrorService',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.OpenTrafficMirrorServiceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def open_traffic_mirror_service(
        self,
        request: vpc_20160428_models.OpenTrafficMirrorServiceRequest,
    ) -> vpc_20160428_models.OpenTrafficMirrorServiceResponse:
        """
        @summary Enables traffic mirroring.
        
        @description ## [](#)Usage notes
        You can enable traffic mirroring for different regions. You cannot repeatedly call the *OpenTrafficMirrorService** operation to enable traffic mirroring for one region within the specified period of time.
        
        @param request: OpenTrafficMirrorServiceRequest
        @return: OpenTrafficMirrorServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.open_traffic_mirror_service_with_options(request, runtime)

    async def open_traffic_mirror_service_async(
        self,
        request: vpc_20160428_models.OpenTrafficMirrorServiceRequest,
    ) -> vpc_20160428_models.OpenTrafficMirrorServiceResponse:
        """
        @summary Enables traffic mirroring.
        
        @description ## [](#)Usage notes
        You can enable traffic mirroring for different regions. You cannot repeatedly call the *OpenTrafficMirrorService** operation to enable traffic mirroring for one region within the specified period of time.
        
        @param request: OpenTrafficMirrorServiceRequest
        @return: OpenTrafficMirrorServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.open_traffic_mirror_service_with_options_async(request, runtime)

    def publish_vpn_route_entry_with_options(
        self,
        request: vpc_20160428_models.PublishVpnRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.PublishVpnRouteEntryResponse:
        """
        @summary Advertises a VPN route to a VPC.
        
        @param request: PublishVpnRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PublishVpnRouteEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.publish_vpc):
            query['PublishVpc'] = request.publish_vpc
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.route_type):
            query['RouteType'] = request.route_type
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PublishVpnRouteEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.PublishVpnRouteEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def publish_vpn_route_entry_with_options_async(
        self,
        request: vpc_20160428_models.PublishVpnRouteEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.PublishVpnRouteEntryResponse:
        """
        @summary Advertises a VPN route to a VPC.
        
        @param request: PublishVpnRouteEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PublishVpnRouteEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.next_hop):
            query['NextHop'] = request.next_hop
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.publish_vpc):
            query['PublishVpc'] = request.publish_vpc
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_dest):
            query['RouteDest'] = request.route_dest
        if not UtilClient.is_unset(request.route_type):
            query['RouteType'] = request.route_type
        if not UtilClient.is_unset(request.vpn_gateway_id):
            query['VpnGatewayId'] = request.vpn_gateway_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PublishVpnRouteEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.PublishVpnRouteEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def publish_vpn_route_entry(
        self,
        request: vpc_20160428_models.PublishVpnRouteEntryRequest,
    ) -> vpc_20160428_models.PublishVpnRouteEntryResponse:
        """
        @summary Advertises a VPN route to a VPC.
        
        @param request: PublishVpnRouteEntryRequest
        @return: PublishVpnRouteEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.publish_vpn_route_entry_with_options(request, runtime)

    async def publish_vpn_route_entry_async(
        self,
        request: vpc_20160428_models.PublishVpnRouteEntryRequest,
    ) -> vpc_20160428_models.PublishVpnRouteEntryResponse:
        """
        @summary Advertises a VPN route to a VPC.
        
        @param request: PublishVpnRouteEntryRequest
        @return: PublishVpnRouteEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.publish_vpn_route_entry_with_options_async(request, runtime)

    def recover_physical_connection_with_options(
        self,
        request: vpc_20160428_models.RecoverPhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.RecoverPhysicalConnectionResponse:
        """
        @summary Resumes an Express Connect circuit.
        
        @description # [](#)Description
        You can call this API operation to resume a suspended Express Connect circuit. You can resume only shared Express Connect circuits by calling this API operation.
        
        @param request: RecoverPhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RecoverPhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.token):
            query['Token'] = request.token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RecoverPhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.RecoverPhysicalConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def recover_physical_connection_with_options_async(
        self,
        request: vpc_20160428_models.RecoverPhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.RecoverPhysicalConnectionResponse:
        """
        @summary Resumes an Express Connect circuit.
        
        @description # [](#)Description
        You can call this API operation to resume a suspended Express Connect circuit. You can resume only shared Express Connect circuits by calling this API operation.
        
        @param request: RecoverPhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RecoverPhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.token):
            query['Token'] = request.token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RecoverPhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.RecoverPhysicalConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def recover_physical_connection(
        self,
        request: vpc_20160428_models.RecoverPhysicalConnectionRequest,
    ) -> vpc_20160428_models.RecoverPhysicalConnectionResponse:
        """
        @summary Resumes an Express Connect circuit.
        
        @description # [](#)Description
        You can call this API operation to resume a suspended Express Connect circuit. You can resume only shared Express Connect circuits by calling this API operation.
        
        @param request: RecoverPhysicalConnectionRequest
        @return: RecoverPhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.recover_physical_connection_with_options(request, runtime)

    async def recover_physical_connection_async(
        self,
        request: vpc_20160428_models.RecoverPhysicalConnectionRequest,
    ) -> vpc_20160428_models.RecoverPhysicalConnectionResponse:
        """
        @summary Resumes an Express Connect circuit.
        
        @description # [](#)Description
        You can call this API operation to resume a suspended Express Connect circuit. You can resume only shared Express Connect circuits by calling this API operation.
        
        @param request: RecoverPhysicalConnectionRequest
        @return: RecoverPhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.recover_physical_connection_with_options_async(request, runtime)

    def recover_virtual_border_router_with_options(
        self,
        request: vpc_20160428_models.RecoverVirtualBorderRouterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.RecoverVirtualBorderRouterResponse:
        """
        @summary Enables a disabled virtual border router (VBR).
        
        @description After you call this operation, the VBR changes from the *terminated** state to the **recovering** state. After the operation is performed, the VBR enters the **active** state.
        When you call this operation, take note of the following items:
        Only the owner of the Express Connect circuit can call this operation.
        The Express Connect circuit to which the VBR connects must be in the **Enabled** state.
        
        @param request: RecoverVirtualBorderRouterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RecoverVirtualBorderRouterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RecoverVirtualBorderRouter',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.RecoverVirtualBorderRouterResponse(),
            self.call_api(params, req, runtime)
        )

    async def recover_virtual_border_router_with_options_async(
        self,
        request: vpc_20160428_models.RecoverVirtualBorderRouterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.RecoverVirtualBorderRouterResponse:
        """
        @summary Enables a disabled virtual border router (VBR).
        
        @description After you call this operation, the VBR changes from the *terminated** state to the **recovering** state. After the operation is performed, the VBR enters the **active** state.
        When you call this operation, take note of the following items:
        Only the owner of the Express Connect circuit can call this operation.
        The Express Connect circuit to which the VBR connects must be in the **Enabled** state.
        
        @param request: RecoverVirtualBorderRouterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RecoverVirtualBorderRouterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RecoverVirtualBorderRouter',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.RecoverVirtualBorderRouterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def recover_virtual_border_router(
        self,
        request: vpc_20160428_models.RecoverVirtualBorderRouterRequest,
    ) -> vpc_20160428_models.RecoverVirtualBorderRouterResponse:
        """
        @summary Enables a disabled virtual border router (VBR).
        
        @description After you call this operation, the VBR changes from the *terminated** state to the **recovering** state. After the operation is performed, the VBR enters the **active** state.
        When you call this operation, take note of the following items:
        Only the owner of the Express Connect circuit can call this operation.
        The Express Connect circuit to which the VBR connects must be in the **Enabled** state.
        
        @param request: RecoverVirtualBorderRouterRequest
        @return: RecoverVirtualBorderRouterResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.recover_virtual_border_router_with_options(request, runtime)

    async def recover_virtual_border_router_async(
        self,
        request: vpc_20160428_models.RecoverVirtualBorderRouterRequest,
    ) -> vpc_20160428_models.RecoverVirtualBorderRouterResponse:
        """
        @summary Enables a disabled virtual border router (VBR).
        
        @description After you call this operation, the VBR changes from the *terminated** state to the **recovering** state. After the operation is performed, the VBR enters the **active** state.
        When you call this operation, take note of the following items:
        Only the owner of the Express Connect circuit can call this operation.
        The Express Connect circuit to which the VBR connects must be in the **Enabled** state.
        
        @param request: RecoverVirtualBorderRouterRequest
        @return: RecoverVirtualBorderRouterResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.recover_virtual_border_router_with_options_async(request, runtime)

    def release_eip_address_with_options(
        self,
        request: vpc_20160428_models.ReleaseEipAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ReleaseEipAddressResponse:
        """
        @summary Releases an elastic IP address (EIP).
        
        @description Before you call this operation, take note of the following items:
        Before you release an EIP, make sure that the EIP meets the following requirements:
        You can release only an EIP that is in the **Available** state.
        You can release only a pay-as-you-go EIP. You cannot release a subscription EIP.
        **ReleaseEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task:
        If the EIP is in the **Releasing** state, the EIP is being released. In this state, you can only query the EIP and cannot perform other operations.
        If you cannot query the EIP, the EIP is released.
        You cannot repeatedly call the **ReleaseEipAddress** operation to release an EIP within the specified period of time.
        
        @param request: ReleaseEipAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReleaseEipAddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReleaseEipAddress',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ReleaseEipAddressResponse(),
            self.call_api(params, req, runtime)
        )

    async def release_eip_address_with_options_async(
        self,
        request: vpc_20160428_models.ReleaseEipAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ReleaseEipAddressResponse:
        """
        @summary Releases an elastic IP address (EIP).
        
        @description Before you call this operation, take note of the following items:
        Before you release an EIP, make sure that the EIP meets the following requirements:
        You can release only an EIP that is in the **Available** state.
        You can release only a pay-as-you-go EIP. You cannot release a subscription EIP.
        **ReleaseEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task:
        If the EIP is in the **Releasing** state, the EIP is being released. In this state, you can only query the EIP and cannot perform other operations.
        If you cannot query the EIP, the EIP is released.
        You cannot repeatedly call the **ReleaseEipAddress** operation to release an EIP within the specified period of time.
        
        @param request: ReleaseEipAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReleaseEipAddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReleaseEipAddress',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ReleaseEipAddressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def release_eip_address(
        self,
        request: vpc_20160428_models.ReleaseEipAddressRequest,
    ) -> vpc_20160428_models.ReleaseEipAddressResponse:
        """
        @summary Releases an elastic IP address (EIP).
        
        @description Before you call this operation, take note of the following items:
        Before you release an EIP, make sure that the EIP meets the following requirements:
        You can release only an EIP that is in the **Available** state.
        You can release only a pay-as-you-go EIP. You cannot release a subscription EIP.
        **ReleaseEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task:
        If the EIP is in the **Releasing** state, the EIP is being released. In this state, you can only query the EIP and cannot perform other operations.
        If you cannot query the EIP, the EIP is released.
        You cannot repeatedly call the **ReleaseEipAddress** operation to release an EIP within the specified period of time.
        
        @param request: ReleaseEipAddressRequest
        @return: ReleaseEipAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.release_eip_address_with_options(request, runtime)

    async def release_eip_address_async(
        self,
        request: vpc_20160428_models.ReleaseEipAddressRequest,
    ) -> vpc_20160428_models.ReleaseEipAddressResponse:
        """
        @summary Releases an elastic IP address (EIP).
        
        @description Before you call this operation, take note of the following items:
        Before you release an EIP, make sure that the EIP meets the following requirements:
        You can release only an EIP that is in the **Available** state.
        You can release only a pay-as-you-go EIP. You cannot release a subscription EIP.
        **ReleaseEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task:
        If the EIP is in the **Releasing** state, the EIP is being released. In this state, you can only query the EIP and cannot perform other operations.
        If you cannot query the EIP, the EIP is released.
        You cannot repeatedly call the **ReleaseEipAddress** operation to release an EIP within the specified period of time.
        
        @param request: ReleaseEipAddressRequest
        @return: ReleaseEipAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.release_eip_address_with_options_async(request, runtime)

    def release_eip_segment_address_with_options(
        self,
        request: vpc_20160428_models.ReleaseEipSegmentAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ReleaseEipSegmentAddressResponse:
        """
        @summary Releases contiguous elastic IP addresses (EIPs).
        
        @description    After you call the **ReleaseEipSegmentAddress** operation, all EIPs in the specified group are released.
        **ReleaseEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
        If the group is in the **Releasing** state, EIPs in the group are being released. In this state, you can only query the group and cannot perform other operations.
        If you cannot query the group of contiguous EIPs, the contiguous EIPs are released.
        You cannot repeatedly call the **ReleaseEipSegmentAddress** operation to release a group of contiguous EIPs within the specified period of time.
        
        @param request: ReleaseEipSegmentAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReleaseEipSegmentAddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.segment_instance_id):
            query['SegmentInstanceId'] = request.segment_instance_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReleaseEipSegmentAddress',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ReleaseEipSegmentAddressResponse(),
            self.call_api(params, req, runtime)
        )

    async def release_eip_segment_address_with_options_async(
        self,
        request: vpc_20160428_models.ReleaseEipSegmentAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ReleaseEipSegmentAddressResponse:
        """
        @summary Releases contiguous elastic IP addresses (EIPs).
        
        @description    After you call the **ReleaseEipSegmentAddress** operation, all EIPs in the specified group are released.
        **ReleaseEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
        If the group is in the **Releasing** state, EIPs in the group are being released. In this state, you can only query the group and cannot perform other operations.
        If you cannot query the group of contiguous EIPs, the contiguous EIPs are released.
        You cannot repeatedly call the **ReleaseEipSegmentAddress** operation to release a group of contiguous EIPs within the specified period of time.
        
        @param request: ReleaseEipSegmentAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReleaseEipSegmentAddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.segment_instance_id):
            query['SegmentInstanceId'] = request.segment_instance_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReleaseEipSegmentAddress',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ReleaseEipSegmentAddressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def release_eip_segment_address(
        self,
        request: vpc_20160428_models.ReleaseEipSegmentAddressRequest,
    ) -> vpc_20160428_models.ReleaseEipSegmentAddressResponse:
        """
        @summary Releases contiguous elastic IP addresses (EIPs).
        
        @description    After you call the **ReleaseEipSegmentAddress** operation, all EIPs in the specified group are released.
        **ReleaseEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
        If the group is in the **Releasing** state, EIPs in the group are being released. In this state, you can only query the group and cannot perform other operations.
        If you cannot query the group of contiguous EIPs, the contiguous EIPs are released.
        You cannot repeatedly call the **ReleaseEipSegmentAddress** operation to release a group of contiguous EIPs within the specified period of time.
        
        @param request: ReleaseEipSegmentAddressRequest
        @return: ReleaseEipSegmentAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.release_eip_segment_address_with_options(request, runtime)

    async def release_eip_segment_address_async(
        self,
        request: vpc_20160428_models.ReleaseEipSegmentAddressRequest,
    ) -> vpc_20160428_models.ReleaseEipSegmentAddressResponse:
        """
        @summary Releases contiguous elastic IP addresses (EIPs).
        
        @description    After you call the **ReleaseEipSegmentAddress** operation, all EIPs in the specified group are released.
        **ReleaseEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
        If the group is in the **Releasing** state, EIPs in the group are being released. In this state, you can only query the group and cannot perform other operations.
        If you cannot query the group of contiguous EIPs, the contiguous EIPs are released.
        You cannot repeatedly call the **ReleaseEipSegmentAddress** operation to release a group of contiguous EIPs within the specified period of time.
        
        @param request: ReleaseEipSegmentAddressRequest
        @return: ReleaseEipSegmentAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.release_eip_segment_address_with_options_async(request, runtime)

    def release_ipv_6address_with_options(
        self,
        request: vpc_20160428_models.ReleaseIpv6AddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ReleaseIpv6AddressResponse:
        """
        @summary Releases an idle IPv6 address.
        
        @param request: ReleaseIpv6AddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReleaseIpv6AddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.ipv_6address_id):
            query['Ipv6AddressId'] = request.ipv_6address_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReleaseIpv6Address',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ReleaseIpv6AddressResponse(),
            self.call_api(params, req, runtime)
        )

    async def release_ipv_6address_with_options_async(
        self,
        request: vpc_20160428_models.ReleaseIpv6AddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ReleaseIpv6AddressResponse:
        """
        @summary Releases an idle IPv6 address.
        
        @param request: ReleaseIpv6AddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReleaseIpv6AddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.ipv_6address_id):
            query['Ipv6AddressId'] = request.ipv_6address_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReleaseIpv6Address',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ReleaseIpv6AddressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def release_ipv_6address(
        self,
        request: vpc_20160428_models.ReleaseIpv6AddressRequest,
    ) -> vpc_20160428_models.ReleaseIpv6AddressResponse:
        """
        @summary Releases an idle IPv6 address.
        
        @param request: ReleaseIpv6AddressRequest
        @return: ReleaseIpv6AddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.release_ipv_6address_with_options(request, runtime)

    async def release_ipv_6address_async(
        self,
        request: vpc_20160428_models.ReleaseIpv6AddressRequest,
    ) -> vpc_20160428_models.ReleaseIpv6AddressResponse:
        """
        @summary Releases an idle IPv6 address.
        
        @param request: ReleaseIpv6AddressRequest
        @return: ReleaseIpv6AddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.release_ipv_6address_with_options_async(request, runtime)

    def remove_common_bandwidth_package_ip_with_options(
        self,
        request: vpc_20160428_models.RemoveCommonBandwidthPackageIpRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.RemoveCommonBandwidthPackageIpResponse:
        """
        @summary Disassociates an EIP from an Internet Shared Bandwidth instance.
        
        @param request: RemoveCommonBandwidthPackageIpRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveCommonBandwidthPackageIpResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ip_instance_id):
            query['IpInstanceId'] = request.ip_instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveCommonBandwidthPackageIp',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.RemoveCommonBandwidthPackageIpResponse(),
            self.call_api(params, req, runtime)
        )

    async def remove_common_bandwidth_package_ip_with_options_async(
        self,
        request: vpc_20160428_models.RemoveCommonBandwidthPackageIpRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.RemoveCommonBandwidthPackageIpResponse:
        """
        @summary Disassociates an EIP from an Internet Shared Bandwidth instance.
        
        @param request: RemoveCommonBandwidthPackageIpRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveCommonBandwidthPackageIpResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth_package_id):
            query['BandwidthPackageId'] = request.bandwidth_package_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.ip_instance_id):
            query['IpInstanceId'] = request.ip_instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveCommonBandwidthPackageIp',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.RemoveCommonBandwidthPackageIpResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def remove_common_bandwidth_package_ip(
        self,
        request: vpc_20160428_models.RemoveCommonBandwidthPackageIpRequest,
    ) -> vpc_20160428_models.RemoveCommonBandwidthPackageIpResponse:
        """
        @summary Disassociates an EIP from an Internet Shared Bandwidth instance.
        
        @param request: RemoveCommonBandwidthPackageIpRequest
        @return: RemoveCommonBandwidthPackageIpResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.remove_common_bandwidth_package_ip_with_options(request, runtime)

    async def remove_common_bandwidth_package_ip_async(
        self,
        request: vpc_20160428_models.RemoveCommonBandwidthPackageIpRequest,
    ) -> vpc_20160428_models.RemoveCommonBandwidthPackageIpResponse:
        """
        @summary Disassociates an EIP from an Internet Shared Bandwidth instance.
        
        @param request: RemoveCommonBandwidthPackageIpRequest
        @return: RemoveCommonBandwidthPackageIpResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.remove_common_bandwidth_package_ip_with_options_async(request, runtime)

    def remove_global_acceleration_instance_ip_with_options(
        self,
        request: vpc_20160428_models.RemoveGlobalAccelerationInstanceIpRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.RemoveGlobalAccelerationInstanceIpResponse:
        """
        @param request: RemoveGlobalAccelerationInstanceIpRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveGlobalAccelerationInstanceIpResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.global_acceleration_instance_id):
            query['GlobalAccelerationInstanceId'] = request.global_acceleration_instance_id
        if not UtilClient.is_unset(request.ip_instance_id):
            query['IpInstanceId'] = request.ip_instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveGlobalAccelerationInstanceIp',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.RemoveGlobalAccelerationInstanceIpResponse(),
            self.call_api(params, req, runtime)
        )

    async def remove_global_acceleration_instance_ip_with_options_async(
        self,
        request: vpc_20160428_models.RemoveGlobalAccelerationInstanceIpRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.RemoveGlobalAccelerationInstanceIpResponse:
        """
        @param request: RemoveGlobalAccelerationInstanceIpRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveGlobalAccelerationInstanceIpResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.global_acceleration_instance_id):
            query['GlobalAccelerationInstanceId'] = request.global_acceleration_instance_id
        if not UtilClient.is_unset(request.ip_instance_id):
            query['IpInstanceId'] = request.ip_instance_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveGlobalAccelerationInstanceIp',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.RemoveGlobalAccelerationInstanceIpResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def remove_global_acceleration_instance_ip(
        self,
        request: vpc_20160428_models.RemoveGlobalAccelerationInstanceIpRequest,
    ) -> vpc_20160428_models.RemoveGlobalAccelerationInstanceIpResponse:
        """
        @param request: RemoveGlobalAccelerationInstanceIpRequest
        @return: RemoveGlobalAccelerationInstanceIpResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.remove_global_acceleration_instance_ip_with_options(request, runtime)

    async def remove_global_acceleration_instance_ip_async(
        self,
        request: vpc_20160428_models.RemoveGlobalAccelerationInstanceIpRequest,
    ) -> vpc_20160428_models.RemoveGlobalAccelerationInstanceIpResponse:
        """
        @param request: RemoveGlobalAccelerationInstanceIpRequest
        @return: RemoveGlobalAccelerationInstanceIpResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.remove_global_acceleration_instance_ip_with_options_async(request, runtime)

    def remove_ipv_6translator_acl_list_entry_with_options(
        self,
        request: vpc_20160428_models.RemoveIPv6TranslatorAclListEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.RemoveIPv6TranslatorAclListEntryResponse:
        """
        @summary Deletes an IP entry from an ACL.
        
        @param request: RemoveIPv6TranslatorAclListEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveIPv6TranslatorAclListEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_entry_id):
            query['AclEntryId'] = request.acl_entry_id
        if not UtilClient.is_unset(request.acl_id):
            query['AclId'] = request.acl_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveIPv6TranslatorAclListEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.RemoveIPv6TranslatorAclListEntryResponse(),
            self.call_api(params, req, runtime)
        )

    async def remove_ipv_6translator_acl_list_entry_with_options_async(
        self,
        request: vpc_20160428_models.RemoveIPv6TranslatorAclListEntryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.RemoveIPv6TranslatorAclListEntryResponse:
        """
        @summary Deletes an IP entry from an ACL.
        
        @param request: RemoveIPv6TranslatorAclListEntryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveIPv6TranslatorAclListEntryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acl_entry_id):
            query['AclEntryId'] = request.acl_entry_id
        if not UtilClient.is_unset(request.acl_id):
            query['AclId'] = request.acl_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveIPv6TranslatorAclListEntry',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.RemoveIPv6TranslatorAclListEntryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def remove_ipv_6translator_acl_list_entry(
        self,
        request: vpc_20160428_models.RemoveIPv6TranslatorAclListEntryRequest,
    ) -> vpc_20160428_models.RemoveIPv6TranslatorAclListEntryResponse:
        """
        @summary Deletes an IP entry from an ACL.
        
        @param request: RemoveIPv6TranslatorAclListEntryRequest
        @return: RemoveIPv6TranslatorAclListEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.remove_ipv_6translator_acl_list_entry_with_options(request, runtime)

    async def remove_ipv_6translator_acl_list_entry_async(
        self,
        request: vpc_20160428_models.RemoveIPv6TranslatorAclListEntryRequest,
    ) -> vpc_20160428_models.RemoveIPv6TranslatorAclListEntryResponse:
        """
        @summary Deletes an IP entry from an ACL.
        
        @param request: RemoveIPv6TranslatorAclListEntryRequest
        @return: RemoveIPv6TranslatorAclListEntryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.remove_ipv_6translator_acl_list_entry_with_options_async(request, runtime)

    def remove_sources_from_traffic_mirror_session_with_options(
        self,
        request: vpc_20160428_models.RemoveSourcesFromTrafficMirrorSessionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.RemoveSourcesFromTrafficMirrorSessionResponse:
        """
        @summary Deletes a traffic mirror source from a traffic mirror session.
        
        @description    **RemoveSourcesFromTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
        If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being deleted.
        If the traffic mirror session is in the **Created** state, the traffic mirror source is deleted.
        You cannot repeatedly call **RemoveSourcesFromTrafficMirrorSession** within the specified period of time.
        
        @param request: RemoveSourcesFromTrafficMirrorSessionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveSourcesFromTrafficMirrorSessionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.traffic_mirror_session_id):
            query['TrafficMirrorSessionId'] = request.traffic_mirror_session_id
        if not UtilClient.is_unset(request.traffic_mirror_source_ids):
            query['TrafficMirrorSourceIds'] = request.traffic_mirror_source_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveSourcesFromTrafficMirrorSession',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.RemoveSourcesFromTrafficMirrorSessionResponse(),
            self.call_api(params, req, runtime)
        )

    async def remove_sources_from_traffic_mirror_session_with_options_async(
        self,
        request: vpc_20160428_models.RemoveSourcesFromTrafficMirrorSessionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.RemoveSourcesFromTrafficMirrorSessionResponse:
        """
        @summary Deletes a traffic mirror source from a traffic mirror session.
        
        @description    **RemoveSourcesFromTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
        If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being deleted.
        If the traffic mirror session is in the **Created** state, the traffic mirror source is deleted.
        You cannot repeatedly call **RemoveSourcesFromTrafficMirrorSession** within the specified period of time.
        
        @param request: RemoveSourcesFromTrafficMirrorSessionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveSourcesFromTrafficMirrorSessionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.traffic_mirror_session_id):
            query['TrafficMirrorSessionId'] = request.traffic_mirror_session_id
        if not UtilClient.is_unset(request.traffic_mirror_source_ids):
            query['TrafficMirrorSourceIds'] = request.traffic_mirror_source_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveSourcesFromTrafficMirrorSession',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.RemoveSourcesFromTrafficMirrorSessionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def remove_sources_from_traffic_mirror_session(
        self,
        request: vpc_20160428_models.RemoveSourcesFromTrafficMirrorSessionRequest,
    ) -> vpc_20160428_models.RemoveSourcesFromTrafficMirrorSessionResponse:
        """
        @summary Deletes a traffic mirror source from a traffic mirror session.
        
        @description    **RemoveSourcesFromTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
        If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being deleted.
        If the traffic mirror session is in the **Created** state, the traffic mirror source is deleted.
        You cannot repeatedly call **RemoveSourcesFromTrafficMirrorSession** within the specified period of time.
        
        @param request: RemoveSourcesFromTrafficMirrorSessionRequest
        @return: RemoveSourcesFromTrafficMirrorSessionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.remove_sources_from_traffic_mirror_session_with_options(request, runtime)

    async def remove_sources_from_traffic_mirror_session_async(
        self,
        request: vpc_20160428_models.RemoveSourcesFromTrafficMirrorSessionRequest,
    ) -> vpc_20160428_models.RemoveSourcesFromTrafficMirrorSessionResponse:
        """
        @summary Deletes a traffic mirror source from a traffic mirror session.
        
        @description    **RemoveSourcesFromTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
        If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being deleted.
        If the traffic mirror session is in the **Created** state, the traffic mirror source is deleted.
        You cannot repeatedly call **RemoveSourcesFromTrafficMirrorSession** within the specified period of time.
        
        @param request: RemoveSourcesFromTrafficMirrorSessionRequest
        @return: RemoveSourcesFromTrafficMirrorSessionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.remove_sources_from_traffic_mirror_session_with_options_async(request, runtime)

    def replace_vpc_dhcp_options_set_with_options(
        self,
        request: vpc_20160428_models.ReplaceVpcDhcpOptionsSetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ReplaceVpcDhcpOptionsSetResponse:
        """
        @summary DHCPVPC
        
        @description    The **ReplaceVpcDhcpOptionsSet** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
        If the DHCP options set is in the **Pending** state, the DHCP options set is being replaced.
        If the DHCP options set is in the **InUse** state, the DHCP options set is replaced.
        You cannot repeatedly call the **ReplaceVpcDhcpOptionsSet** operation to replace the DHCP options set associated with a VPC within the specified period of time.
        
        @param request: ReplaceVpcDhcpOptionsSetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReplaceVpcDhcpOptionsSetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dhcp_options_set_id):
            query['DhcpOptionsSetId'] = request.dhcp_options_set_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReplaceVpcDhcpOptionsSet',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ReplaceVpcDhcpOptionsSetResponse(),
            self.call_api(params, req, runtime)
        )

    async def replace_vpc_dhcp_options_set_with_options_async(
        self,
        request: vpc_20160428_models.ReplaceVpcDhcpOptionsSetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.ReplaceVpcDhcpOptionsSetResponse:
        """
        @summary DHCPVPC
        
        @description    The **ReplaceVpcDhcpOptionsSet** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
        If the DHCP options set is in the **Pending** state, the DHCP options set is being replaced.
        If the DHCP options set is in the **InUse** state, the DHCP options set is replaced.
        You cannot repeatedly call the **ReplaceVpcDhcpOptionsSet** operation to replace the DHCP options set associated with a VPC within the specified period of time.
        
        @param request: ReplaceVpcDhcpOptionsSetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReplaceVpcDhcpOptionsSetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dhcp_options_set_id):
            query['DhcpOptionsSetId'] = request.dhcp_options_set_id
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReplaceVpcDhcpOptionsSet',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.ReplaceVpcDhcpOptionsSetResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def replace_vpc_dhcp_options_set(
        self,
        request: vpc_20160428_models.ReplaceVpcDhcpOptionsSetRequest,
    ) -> vpc_20160428_models.ReplaceVpcDhcpOptionsSetResponse:
        """
        @summary DHCPVPC
        
        @description    The **ReplaceVpcDhcpOptionsSet** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
        If the DHCP options set is in the **Pending** state, the DHCP options set is being replaced.
        If the DHCP options set is in the **InUse** state, the DHCP options set is replaced.
        You cannot repeatedly call the **ReplaceVpcDhcpOptionsSet** operation to replace the DHCP options set associated with a VPC within the specified period of time.
        
        @param request: ReplaceVpcDhcpOptionsSetRequest
        @return: ReplaceVpcDhcpOptionsSetResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.replace_vpc_dhcp_options_set_with_options(request, runtime)

    async def replace_vpc_dhcp_options_set_async(
        self,
        request: vpc_20160428_models.ReplaceVpcDhcpOptionsSetRequest,
    ) -> vpc_20160428_models.ReplaceVpcDhcpOptionsSetResponse:
        """
        @summary DHCPVPC
        
        @description    The **ReplaceVpcDhcpOptionsSet** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
        If the DHCP options set is in the **Pending** state, the DHCP options set is being replaced.
        If the DHCP options set is in the **InUse** state, the DHCP options set is replaced.
        You cannot repeatedly call the **ReplaceVpcDhcpOptionsSet** operation to replace the DHCP options set associated with a VPC within the specified period of time.
        
        @param request: ReplaceVpcDhcpOptionsSetRequest
        @return: ReplaceVpcDhcpOptionsSetResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.replace_vpc_dhcp_options_set_with_options_async(request, runtime)

    def retry_vpc_prefix_list_association_with_options(
        self,
        request: vpc_20160428_models.RetryVpcPrefixListAssociationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.RetryVpcPrefixListAssociationResponse:
        """
        @summary Re-applies a prefix list.
        
        @description    If you modify the information about a prefix list but the modification is not automatically applied to the route table that is associated with the prefix list, you can call this operation to apply the latest prefix list to the associated route table.
        The **RetryVpcPrefixListAssociation** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the background. You can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) to check whether the prefix list is re-applied.
        If the prefix list is in the **Modifying** state, the prefix list is being re-applied.
        If the prefix list is in the **ModifyFailed** state, the prefix list fails to be re-applied.
        If the prefix list is in the **Created** state, the prefix list is re-applied.
        After you call the **RetryVpcPrefixListAssociation** operation to re-apply a prefix list, you cannot call the operation again until the current task is complete.
        
        @param request: RetryVpcPrefixListAssociationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RetryVpcPrefixListAssociationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_id):
            query['PrefixListId'] = request.prefix_list_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RetryVpcPrefixListAssociation',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.RetryVpcPrefixListAssociationResponse(),
            self.call_api(params, req, runtime)
        )

    async def retry_vpc_prefix_list_association_with_options_async(
        self,
        request: vpc_20160428_models.RetryVpcPrefixListAssociationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.RetryVpcPrefixListAssociationResponse:
        """
        @summary Re-applies a prefix list.
        
        @description    If you modify the information about a prefix list but the modification is not automatically applied to the route table that is associated with the prefix list, you can call this operation to apply the latest prefix list to the associated route table.
        The **RetryVpcPrefixListAssociation** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the background. You can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) to check whether the prefix list is re-applied.
        If the prefix list is in the **Modifying** state, the prefix list is being re-applied.
        If the prefix list is in the **ModifyFailed** state, the prefix list fails to be re-applied.
        If the prefix list is in the **Created** state, the prefix list is re-applied.
        After you call the **RetryVpcPrefixListAssociation** operation to re-apply a prefix list, you cannot call the operation again until the current task is complete.
        
        @param request: RetryVpcPrefixListAssociationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RetryVpcPrefixListAssociationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix_list_id):
            query['PrefixListId'] = request.prefix_list_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RetryVpcPrefixListAssociation',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.RetryVpcPrefixListAssociationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def retry_vpc_prefix_list_association(
        self,
        request: vpc_20160428_models.RetryVpcPrefixListAssociationRequest,
    ) -> vpc_20160428_models.RetryVpcPrefixListAssociationResponse:
        """
        @summary Re-applies a prefix list.
        
        @description    If you modify the information about a prefix list but the modification is not automatically applied to the route table that is associated with the prefix list, you can call this operation to apply the latest prefix list to the associated route table.
        The **RetryVpcPrefixListAssociation** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the background. You can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) to check whether the prefix list is re-applied.
        If the prefix list is in the **Modifying** state, the prefix list is being re-applied.
        If the prefix list is in the **ModifyFailed** state, the prefix list fails to be re-applied.
        If the prefix list is in the **Created** state, the prefix list is re-applied.
        After you call the **RetryVpcPrefixListAssociation** operation to re-apply a prefix list, you cannot call the operation again until the current task is complete.
        
        @param request: RetryVpcPrefixListAssociationRequest
        @return: RetryVpcPrefixListAssociationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.retry_vpc_prefix_list_association_with_options(request, runtime)

    async def retry_vpc_prefix_list_association_async(
        self,
        request: vpc_20160428_models.RetryVpcPrefixListAssociationRequest,
    ) -> vpc_20160428_models.RetryVpcPrefixListAssociationResponse:
        """
        @summary Re-applies a prefix list.
        
        @description    If you modify the information about a prefix list but the modification is not automatically applied to the route table that is associated with the prefix list, you can call this operation to apply the latest prefix list to the associated route table.
        The **RetryVpcPrefixListAssociation** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the background. You can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) to check whether the prefix list is re-applied.
        If the prefix list is in the **Modifying** state, the prefix list is being re-applied.
        If the prefix list is in the **ModifyFailed** state, the prefix list fails to be re-applied.
        If the prefix list is in the **Created** state, the prefix list is re-applied.
        After you call the **RetryVpcPrefixListAssociation** operation to re-apply a prefix list, you cannot call the operation again until the current task is complete.
        
        @param request: RetryVpcPrefixListAssociationRequest
        @return: RetryVpcPrefixListAssociationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.retry_vpc_prefix_list_association_with_options_async(request, runtime)

    def revoke_instance_from_cen_with_options(
        self,
        request: vpc_20160428_models.RevokeInstanceFromCenRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.RevokeInstanceFromCenResponse:
        """
        @summary Revokes the permissions granted to a Cloud Enterprise Network (CEN) instance on a network instance.
        
        @description ## [](#)Usage notes
        **RevokeInstanceFromCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use `vpc.aliyuncs.com` as the domain name when you call this operation. The API version is `2016-04-28`.
        You cannot repeatedly call the **RevokeInstanceFromCen** operation to revoke the permissions on a network instance that is attached to a CEN instance within the specified period of time. The network instance can be a VPC, virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
        
        @param request: RevokeInstanceFromCenRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RevokeInstanceFromCenResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cen_id):
            query['CenId'] = request.cen_id
        if not UtilClient.is_unset(request.cen_owner_id):
            query['CenOwnerId'] = request.cen_owner_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RevokeInstanceFromCen',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.RevokeInstanceFromCenResponse(),
            self.call_api(params, req, runtime)
        )

    async def revoke_instance_from_cen_with_options_async(
        self,
        request: vpc_20160428_models.RevokeInstanceFromCenRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.RevokeInstanceFromCenResponse:
        """
        @summary Revokes the permissions granted to a Cloud Enterprise Network (CEN) instance on a network instance.
        
        @description ## [](#)Usage notes
        **RevokeInstanceFromCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use `vpc.aliyuncs.com` as the domain name when you call this operation. The API version is `2016-04-28`.
        You cannot repeatedly call the **RevokeInstanceFromCen** operation to revoke the permissions on a network instance that is attached to a CEN instance within the specified period of time. The network instance can be a VPC, virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
        
        @param request: RevokeInstanceFromCenRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RevokeInstanceFromCenResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cen_id):
            query['CenId'] = request.cen_id
        if not UtilClient.is_unset(request.cen_owner_id):
            query['CenOwnerId'] = request.cen_owner_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RevokeInstanceFromCen',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.RevokeInstanceFromCenResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def revoke_instance_from_cen(
        self,
        request: vpc_20160428_models.RevokeInstanceFromCenRequest,
    ) -> vpc_20160428_models.RevokeInstanceFromCenResponse:
        """
        @summary Revokes the permissions granted to a Cloud Enterprise Network (CEN) instance on a network instance.
        
        @description ## [](#)Usage notes
        **RevokeInstanceFromCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use `vpc.aliyuncs.com` as the domain name when you call this operation. The API version is `2016-04-28`.
        You cannot repeatedly call the **RevokeInstanceFromCen** operation to revoke the permissions on a network instance that is attached to a CEN instance within the specified period of time. The network instance can be a VPC, virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
        
        @param request: RevokeInstanceFromCenRequest
        @return: RevokeInstanceFromCenResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.revoke_instance_from_cen_with_options(request, runtime)

    async def revoke_instance_from_cen_async(
        self,
        request: vpc_20160428_models.RevokeInstanceFromCenRequest,
    ) -> vpc_20160428_models.RevokeInstanceFromCenResponse:
        """
        @summary Revokes the permissions granted to a Cloud Enterprise Network (CEN) instance on a network instance.
        
        @description ## [](#)Usage notes
        **RevokeInstanceFromCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use `vpc.aliyuncs.com` as the domain name when you call this operation. The API version is `2016-04-28`.
        You cannot repeatedly call the **RevokeInstanceFromCen** operation to revoke the permissions on a network instance that is attached to a CEN instance within the specified period of time. The network instance can be a VPC, virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
        
        @param request: RevokeInstanceFromCenRequest
        @return: RevokeInstanceFromCenResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.revoke_instance_from_cen_with_options_async(request, runtime)

    def revoke_instance_from_vbr_with_options(
        self,
        tmp_req: vpc_20160428_models.RevokeInstanceFromVbrRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.RevokeInstanceFromVbrResponse:
        """
        @summary Revokes the permissions granted to a virtual border router (VBR) on a virtual private cloud (VPC).
        
        @param tmp_req: RevokeInstanceFromVbrRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RevokeInstanceFromVbrResponse
        """
        UtilClient.validate_model(tmp_req)
        request = vpc_20160428_models.RevokeInstanceFromVbrShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.vbr_instance_ids):
            request.vbr_instance_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.vbr_instance_ids, 'VbrInstanceIds', 'simple')
        query = {}
        if not UtilClient.is_unset(request.grant_type):
            query['GrantType'] = request.grant_type
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.vbr_instance_ids_shrink):
            query['VbrInstanceIds'] = request.vbr_instance_ids_shrink
        if not UtilClient.is_unset(request.vbr_owner_uid):
            query['VbrOwnerUid'] = request.vbr_owner_uid
        if not UtilClient.is_unset(request.vbr_region_no):
            query['VbrRegionNo'] = request.vbr_region_no
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RevokeInstanceFromVbr',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.RevokeInstanceFromVbrResponse(),
            self.call_api(params, req, runtime)
        )

    async def revoke_instance_from_vbr_with_options_async(
        self,
        tmp_req: vpc_20160428_models.RevokeInstanceFromVbrRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.RevokeInstanceFromVbrResponse:
        """
        @summary Revokes the permissions granted to a virtual border router (VBR) on a virtual private cloud (VPC).
        
        @param tmp_req: RevokeInstanceFromVbrRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RevokeInstanceFromVbrResponse
        """
        UtilClient.validate_model(tmp_req)
        request = vpc_20160428_models.RevokeInstanceFromVbrShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.vbr_instance_ids):
            request.vbr_instance_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.vbr_instance_ids, 'VbrInstanceIds', 'simple')
        query = {}
        if not UtilClient.is_unset(request.grant_type):
            query['GrantType'] = request.grant_type
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.vbr_instance_ids_shrink):
            query['VbrInstanceIds'] = request.vbr_instance_ids_shrink
        if not UtilClient.is_unset(request.vbr_owner_uid):
            query['VbrOwnerUid'] = request.vbr_owner_uid
        if not UtilClient.is_unset(request.vbr_region_no):
            query['VbrRegionNo'] = request.vbr_region_no
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RevokeInstanceFromVbr',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.RevokeInstanceFromVbrResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def revoke_instance_from_vbr(
        self,
        request: vpc_20160428_models.RevokeInstanceFromVbrRequest,
    ) -> vpc_20160428_models.RevokeInstanceFromVbrResponse:
        """
        @summary Revokes the permissions granted to a virtual border router (VBR) on a virtual private cloud (VPC).
        
        @param request: RevokeInstanceFromVbrRequest
        @return: RevokeInstanceFromVbrResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.revoke_instance_from_vbr_with_options(request, runtime)

    async def revoke_instance_from_vbr_async(
        self,
        request: vpc_20160428_models.RevokeInstanceFromVbrRequest,
    ) -> vpc_20160428_models.RevokeInstanceFromVbrResponse:
        """
        @summary Revokes the permissions granted to a virtual border router (VBR) on a virtual private cloud (VPC).
        
        @param request: RevokeInstanceFromVbrRequest
        @return: RevokeInstanceFromVbrResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.revoke_instance_from_vbr_with_options_async(request, runtime)

    def second_apply_physical_connection_loawith_options(
        self,
        request: vpc_20160428_models.SecondApplyPhysicalConnectionLOARequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.SecondApplyPhysicalConnectionLOAResponse:
        """
        @summary If your application for a Letter of Authorization (LOA) by calling the ApplyPhysicalConnectionLOA operation is denied, you can call this operation to apply again.
        
        @param request: SecondApplyPhysicalConnectionLOARequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SecondApplyPhysicalConnectionLOAResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.company_name):
            query['CompanyName'] = request.company_name
        if not UtilClient.is_unset(request.construction_time):
            query['ConstructionTime'] = request.construction_time
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.line_type):
            query['LineType'] = request.line_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pminfo):
            query['PMInfo'] = request.pminfo
        if not UtilClient.is_unset(request.peer_location):
            query['PeerLocation'] = request.peer_location
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.si):
            query['Si'] = request.si
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SecondApplyPhysicalConnectionLOA',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.SecondApplyPhysicalConnectionLOAResponse(),
            self.call_api(params, req, runtime)
        )

    async def second_apply_physical_connection_loawith_options_async(
        self,
        request: vpc_20160428_models.SecondApplyPhysicalConnectionLOARequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.SecondApplyPhysicalConnectionLOAResponse:
        """
        @summary If your application for a Letter of Authorization (LOA) by calling the ApplyPhysicalConnectionLOA operation is denied, you can call this operation to apply again.
        
        @param request: SecondApplyPhysicalConnectionLOARequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SecondApplyPhysicalConnectionLOAResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.company_name):
            query['CompanyName'] = request.company_name
        if not UtilClient.is_unset(request.construction_time):
            query['ConstructionTime'] = request.construction_time
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.line_type):
            query['LineType'] = request.line_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pminfo):
            query['PMInfo'] = request.pminfo
        if not UtilClient.is_unset(request.peer_location):
            query['PeerLocation'] = request.peer_location
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.si):
            query['Si'] = request.si
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SecondApplyPhysicalConnectionLOA',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.SecondApplyPhysicalConnectionLOAResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def second_apply_physical_connection_loa(
        self,
        request: vpc_20160428_models.SecondApplyPhysicalConnectionLOARequest,
    ) -> vpc_20160428_models.SecondApplyPhysicalConnectionLOAResponse:
        """
        @summary If your application for a Letter of Authorization (LOA) by calling the ApplyPhysicalConnectionLOA operation is denied, you can call this operation to apply again.
        
        @param request: SecondApplyPhysicalConnectionLOARequest
        @return: SecondApplyPhysicalConnectionLOAResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.second_apply_physical_connection_loawith_options(request, runtime)

    async def second_apply_physical_connection_loa_async(
        self,
        request: vpc_20160428_models.SecondApplyPhysicalConnectionLOARequest,
    ) -> vpc_20160428_models.SecondApplyPhysicalConnectionLOAResponse:
        """
        @summary If your application for a Letter of Authorization (LOA) by calling the ApplyPhysicalConnectionLOA operation is denied, you can call this operation to apply again.
        
        @param request: SecondApplyPhysicalConnectionLOARequest
        @return: SecondApplyPhysicalConnectionLOAResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.second_apply_physical_connection_loawith_options_async(request, runtime)

    def set_high_definition_monitor_log_status_with_options(
        self,
        request: vpc_20160428_models.SetHighDefinitionMonitorLogStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.SetHighDefinitionMonitorLogStatusResponse:
        """
        @summary Configures fine-grained monitoring for an elastic IP address (EIP).
        
        @description You cannot repeatedly call *SetHighDefinitionMonitorLogStatus** within a specific period of time.
        
        @param request: SetHighDefinitionMonitorLogStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetHighDefinitionMonitorLogStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.log_project):
            query['LogProject'] = request.log_project
        if not UtilClient.is_unset(request.log_store):
            query['LogStore'] = request.log_store
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetHighDefinitionMonitorLogStatus',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.SetHighDefinitionMonitorLogStatusResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_high_definition_monitor_log_status_with_options_async(
        self,
        request: vpc_20160428_models.SetHighDefinitionMonitorLogStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.SetHighDefinitionMonitorLogStatusResponse:
        """
        @summary Configures fine-grained monitoring for an elastic IP address (EIP).
        
        @description You cannot repeatedly call *SetHighDefinitionMonitorLogStatus** within a specific period of time.
        
        @param request: SetHighDefinitionMonitorLogStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetHighDefinitionMonitorLogStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.log_project):
            query['LogProject'] = request.log_project
        if not UtilClient.is_unset(request.log_store):
            query['LogStore'] = request.log_store
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetHighDefinitionMonitorLogStatus',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.SetHighDefinitionMonitorLogStatusResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_high_definition_monitor_log_status(
        self,
        request: vpc_20160428_models.SetHighDefinitionMonitorLogStatusRequest,
    ) -> vpc_20160428_models.SetHighDefinitionMonitorLogStatusResponse:
        """
        @summary Configures fine-grained monitoring for an elastic IP address (EIP).
        
        @description You cannot repeatedly call *SetHighDefinitionMonitorLogStatus** within a specific period of time.
        
        @param request: SetHighDefinitionMonitorLogStatusRequest
        @return: SetHighDefinitionMonitorLogStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_high_definition_monitor_log_status_with_options(request, runtime)

    async def set_high_definition_monitor_log_status_async(
        self,
        request: vpc_20160428_models.SetHighDefinitionMonitorLogStatusRequest,
    ) -> vpc_20160428_models.SetHighDefinitionMonitorLogStatusResponse:
        """
        @summary Configures fine-grained monitoring for an elastic IP address (EIP).
        
        @description You cannot repeatedly call *SetHighDefinitionMonitorLogStatus** within a specific period of time.
        
        @param request: SetHighDefinitionMonitorLogStatusRequest
        @return: SetHighDefinitionMonitorLogStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_high_definition_monitor_log_status_with_options_async(request, runtime)

    def start_failover_test_job_with_options(
        self,
        request: vpc_20160428_models.StartFailoverTestJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.StartFailoverTestJobResponse:
        """
        @summary 
        
        @param request: StartFailoverTestJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartFailoverTestJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartFailoverTestJob',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.StartFailoverTestJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def start_failover_test_job_with_options_async(
        self,
        request: vpc_20160428_models.StartFailoverTestJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.StartFailoverTestJobResponse:
        """
        @summary 
        
        @param request: StartFailoverTestJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartFailoverTestJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartFailoverTestJob',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.StartFailoverTestJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def start_failover_test_job(
        self,
        request: vpc_20160428_models.StartFailoverTestJobRequest,
    ) -> vpc_20160428_models.StartFailoverTestJobResponse:
        """
        @summary 
        
        @param request: StartFailoverTestJobRequest
        @return: StartFailoverTestJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.start_failover_test_job_with_options(request, runtime)

    async def start_failover_test_job_async(
        self,
        request: vpc_20160428_models.StartFailoverTestJobRequest,
    ) -> vpc_20160428_models.StartFailoverTestJobResponse:
        """
        @summary 
        
        @param request: StartFailoverTestJobRequest
        @return: StartFailoverTestJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.start_failover_test_job_with_options_async(request, runtime)

    def stop_failover_test_job_with_options(
        self,
        request: vpc_20160428_models.StopFailoverTestJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.StopFailoverTestJobResponse:
        """
        @summary 
        
        @param request: StopFailoverTestJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopFailoverTestJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopFailoverTestJob',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.StopFailoverTestJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def stop_failover_test_job_with_options_async(
        self,
        request: vpc_20160428_models.StopFailoverTestJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.StopFailoverTestJobResponse:
        """
        @summary 
        
        @param request: StopFailoverTestJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopFailoverTestJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopFailoverTestJob',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.StopFailoverTestJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def stop_failover_test_job(
        self,
        request: vpc_20160428_models.StopFailoverTestJobRequest,
    ) -> vpc_20160428_models.StopFailoverTestJobResponse:
        """
        @summary 
        
        @param request: StopFailoverTestJobRequest
        @return: StopFailoverTestJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.stop_failover_test_job_with_options(request, runtime)

    async def stop_failover_test_job_async(
        self,
        request: vpc_20160428_models.StopFailoverTestJobRequest,
    ) -> vpc_20160428_models.StopFailoverTestJobResponse:
        """
        @summary 
        
        @param request: StopFailoverTestJobRequest
        @return: StopFailoverTestJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.stop_failover_test_job_with_options_async(request, runtime)

    def tag_resources_with_options(
        self,
        request: vpc_20160428_models.TagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.TagResourcesResponse:
        """
        @summary Creates and adds tags to resources.
        
        @description Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following limits:
        The keys of tags that are added to the same instance must be unique.
        You cannot create tags without adding them to instances. All tags must be added to instances.
        Tag information is not shared across regions.
        For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
        Virtual private clouds (VPCs), route tables, vSwitches, and elastic IP addresses (EIPs) that belong to the same Alibaba Cloud account and are deployed in the same region share tag information with each other.
        For example, if you added a tag to a VPC, the tag is available to vSwitches, route tables, and EIPs that belong to the same account and are deployed in the same region in which the VPC is created. You can select this tag from the editing page without the need to enter the tag again. You can modify the key and the value of a tag or remove a tag from an instance. After you delete an instance, all tags that are added to the instance are deleted.
        You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
        
        @param request: TagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TagResources',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.TagResourcesResponse(),
            self.call_api(params, req, runtime)
        )

    async def tag_resources_with_options_async(
        self,
        request: vpc_20160428_models.TagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.TagResourcesResponse:
        """
        @summary Creates and adds tags to resources.
        
        @description Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following limits:
        The keys of tags that are added to the same instance must be unique.
        You cannot create tags without adding them to instances. All tags must be added to instances.
        Tag information is not shared across regions.
        For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
        Virtual private clouds (VPCs), route tables, vSwitches, and elastic IP addresses (EIPs) that belong to the same Alibaba Cloud account and are deployed in the same region share tag information with each other.
        For example, if you added a tag to a VPC, the tag is available to vSwitches, route tables, and EIPs that belong to the same account and are deployed in the same region in which the VPC is created. You can select this tag from the editing page without the need to enter the tag again. You can modify the key and the value of a tag or remove a tag from an instance. After you delete an instance, all tags that are added to the instance are deleted.
        You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
        
        @param request: TagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TagResources',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.TagResourcesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def tag_resources(
        self,
        request: vpc_20160428_models.TagResourcesRequest,
    ) -> vpc_20160428_models.TagResourcesResponse:
        """
        @summary Creates and adds tags to resources.
        
        @description Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following limits:
        The keys of tags that are added to the same instance must be unique.
        You cannot create tags without adding them to instances. All tags must be added to instances.
        Tag information is not shared across regions.
        For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
        Virtual private clouds (VPCs), route tables, vSwitches, and elastic IP addresses (EIPs) that belong to the same Alibaba Cloud account and are deployed in the same region share tag information with each other.
        For example, if you added a tag to a VPC, the tag is available to vSwitches, route tables, and EIPs that belong to the same account and are deployed in the same region in which the VPC is created. You can select this tag from the editing page without the need to enter the tag again. You can modify the key and the value of a tag or remove a tag from an instance. After you delete an instance, all tags that are added to the instance are deleted.
        You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
        
        @param request: TagResourcesRequest
        @return: TagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.tag_resources_with_options(request, runtime)

    async def tag_resources_async(
        self,
        request: vpc_20160428_models.TagResourcesRequest,
    ) -> vpc_20160428_models.TagResourcesResponse:
        """
        @summary Creates and adds tags to resources.
        
        @description Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following limits:
        The keys of tags that are added to the same instance must be unique.
        You cannot create tags without adding them to instances. All tags must be added to instances.
        Tag information is not shared across regions.
        For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
        Virtual private clouds (VPCs), route tables, vSwitches, and elastic IP addresses (EIPs) that belong to the same Alibaba Cloud account and are deployed in the same region share tag information with each other.
        For example, if you added a tag to a VPC, the tag is available to vSwitches, route tables, and EIPs that belong to the same account and are deployed in the same region in which the VPC is created. You can select this tag from the editing page without the need to enter the tag again. You can modify the key and the value of a tag or remove a tag from an instance. After you delete an instance, all tags that are added to the instance are deleted.
        You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
        
        @param request: TagResourcesRequest
        @return: TagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.tag_resources_with_options_async(request, runtime)

    def tag_resources_for_express_connect_with_options(
        self,
        request: vpc_20160428_models.TagResourcesForExpressConnectRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.TagResourcesForExpressConnectResponse:
        """
        @summary Creates tags and adds the tags to an Express Connect circuit.
        
        @description ## [](#)
        Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following items:
        Each tag key that is added to an instance must be unique.
        You cannot create tags without adding them to instances. All tags must be added to instances.
        Tag information is not shared across regions.
        For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
        You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
        
        @param request: TagResourcesForExpressConnectRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TagResourcesForExpressConnectResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TagResourcesForExpressConnect',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.TagResourcesForExpressConnectResponse(),
            self.call_api(params, req, runtime)
        )

    async def tag_resources_for_express_connect_with_options_async(
        self,
        request: vpc_20160428_models.TagResourcesForExpressConnectRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.TagResourcesForExpressConnectResponse:
        """
        @summary Creates tags and adds the tags to an Express Connect circuit.
        
        @description ## [](#)
        Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following items:
        Each tag key that is added to an instance must be unique.
        You cannot create tags without adding them to instances. All tags must be added to instances.
        Tag information is not shared across regions.
        For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
        You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
        
        @param request: TagResourcesForExpressConnectRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TagResourcesForExpressConnectResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TagResourcesForExpressConnect',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.TagResourcesForExpressConnectResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def tag_resources_for_express_connect(
        self,
        request: vpc_20160428_models.TagResourcesForExpressConnectRequest,
    ) -> vpc_20160428_models.TagResourcesForExpressConnectResponse:
        """
        @summary Creates tags and adds the tags to an Express Connect circuit.
        
        @description ## [](#)
        Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following items:
        Each tag key that is added to an instance must be unique.
        You cannot create tags without adding them to instances. All tags must be added to instances.
        Tag information is not shared across regions.
        For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
        You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
        
        @param request: TagResourcesForExpressConnectRequest
        @return: TagResourcesForExpressConnectResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.tag_resources_for_express_connect_with_options(request, runtime)

    async def tag_resources_for_express_connect_async(
        self,
        request: vpc_20160428_models.TagResourcesForExpressConnectRequest,
    ) -> vpc_20160428_models.TagResourcesForExpressConnectResponse:
        """
        @summary Creates tags and adds the tags to an Express Connect circuit.
        
        @description ## [](#)
        Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following items:
        Each tag key that is added to an instance must be unique.
        You cannot create tags without adding them to instances. All tags must be added to instances.
        Tag information is not shared across regions.
        For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
        You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
        
        @param request: TagResourcesForExpressConnectRequest
        @return: TagResourcesForExpressConnectResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.tag_resources_for_express_connect_with_options_async(request, runtime)

    def terminate_physical_connection_with_options(
        self,
        request: vpc_20160428_models.TerminatePhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.TerminatePhysicalConnectionResponse:
        """
        @summary Disables an Express Connect circuit after it is enabled.
        
        @description After you call this operation, the specified Express Connect circuit changes to the *Terminating** state. After the Express Connect circuit is disabled, it changes to the **Terminated** state. When you call this operation, take note of the following limits:
        You can only disable an Express Connect circuit that is in the **Enabled** state.
        Before you disable an Express Connect circuit, you must delete the virtual border routers (VBRs) associated with it.
        
        @param request: TerminatePhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TerminatePhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TerminatePhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.TerminatePhysicalConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def terminate_physical_connection_with_options_async(
        self,
        request: vpc_20160428_models.TerminatePhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.TerminatePhysicalConnectionResponse:
        """
        @summary Disables an Express Connect circuit after it is enabled.
        
        @description After you call this operation, the specified Express Connect circuit changes to the *Terminating** state. After the Express Connect circuit is disabled, it changes to the **Terminated** state. When you call this operation, take note of the following limits:
        You can only disable an Express Connect circuit that is in the **Enabled** state.
        Before you disable an Express Connect circuit, you must delete the virtual border routers (VBRs) associated with it.
        
        @param request: TerminatePhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TerminatePhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TerminatePhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.TerminatePhysicalConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def terminate_physical_connection(
        self,
        request: vpc_20160428_models.TerminatePhysicalConnectionRequest,
    ) -> vpc_20160428_models.TerminatePhysicalConnectionResponse:
        """
        @summary Disables an Express Connect circuit after it is enabled.
        
        @description After you call this operation, the specified Express Connect circuit changes to the *Terminating** state. After the Express Connect circuit is disabled, it changes to the **Terminated** state. When you call this operation, take note of the following limits:
        You can only disable an Express Connect circuit that is in the **Enabled** state.
        Before you disable an Express Connect circuit, you must delete the virtual border routers (VBRs) associated with it.
        
        @param request: TerminatePhysicalConnectionRequest
        @return: TerminatePhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.terminate_physical_connection_with_options(request, runtime)

    async def terminate_physical_connection_async(
        self,
        request: vpc_20160428_models.TerminatePhysicalConnectionRequest,
    ) -> vpc_20160428_models.TerminatePhysicalConnectionResponse:
        """
        @summary Disables an Express Connect circuit after it is enabled.
        
        @description After you call this operation, the specified Express Connect circuit changes to the *Terminating** state. After the Express Connect circuit is disabled, it changes to the **Terminated** state. When you call this operation, take note of the following limits:
        You can only disable an Express Connect circuit that is in the **Enabled** state.
        Before you disable an Express Connect circuit, you must delete the virtual border routers (VBRs) associated with it.
        
        @param request: TerminatePhysicalConnectionRequest
        @return: TerminatePhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.terminate_physical_connection_with_options_async(request, runtime)

    def terminate_virtual_border_router_with_options(
        self,
        request: vpc_20160428_models.TerminateVirtualBorderRouterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.TerminateVirtualBorderRouterResponse:
        """
        @summary Terminates a virtual border router (VBR).
        
        @description After you call this operation, the VBR enters the *terminating** state from the **active** state. After the VBR is terminated, the VBR enters the **terminated** state.
        >  Only the owner of an Express Connect circuit can call this operation.
        
        @param request: TerminateVirtualBorderRouterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TerminateVirtualBorderRouterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TerminateVirtualBorderRouter',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.TerminateVirtualBorderRouterResponse(),
            self.call_api(params, req, runtime)
        )

    async def terminate_virtual_border_router_with_options_async(
        self,
        request: vpc_20160428_models.TerminateVirtualBorderRouterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.TerminateVirtualBorderRouterResponse:
        """
        @summary Terminates a virtual border router (VBR).
        
        @description After you call this operation, the VBR enters the *terminating** state from the **active** state. After the VBR is terminated, the VBR enters the **terminated** state.
        >  Only the owner of an Express Connect circuit can call this operation.
        
        @param request: TerminateVirtualBorderRouterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TerminateVirtualBorderRouterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TerminateVirtualBorderRouter',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.TerminateVirtualBorderRouterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def terminate_virtual_border_router(
        self,
        request: vpc_20160428_models.TerminateVirtualBorderRouterRequest,
    ) -> vpc_20160428_models.TerminateVirtualBorderRouterResponse:
        """
        @summary Terminates a virtual border router (VBR).
        
        @description After you call this operation, the VBR enters the *terminating** state from the **active** state. After the VBR is terminated, the VBR enters the **terminated** state.
        >  Only the owner of an Express Connect circuit can call this operation.
        
        @param request: TerminateVirtualBorderRouterRequest
        @return: TerminateVirtualBorderRouterResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.terminate_virtual_border_router_with_options(request, runtime)

    async def terminate_virtual_border_router_async(
        self,
        request: vpc_20160428_models.TerminateVirtualBorderRouterRequest,
    ) -> vpc_20160428_models.TerminateVirtualBorderRouterResponse:
        """
        @summary Terminates a virtual border router (VBR).
        
        @description After you call this operation, the VBR enters the *terminating** state from the **active** state. After the VBR is terminated, the VBR enters the **terminated** state.
        >  Only the owner of an Express Connect circuit can call this operation.
        
        @param request: TerminateVirtualBorderRouterRequest
        @return: TerminateVirtualBorderRouterResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.terminate_virtual_border_router_with_options_async(request, runtime)

    def un_tag_resources_with_options(
        self,
        request: vpc_20160428_models.UnTagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UnTagResourcesResponse:
        """
        @summary Removes tags from resources.
        
        @param request: UnTagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnTagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.all):
            query['All'] = request.all
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag_key):
            query['TagKey'] = request.tag_key
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnTagResources',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UnTagResourcesResponse(),
            self.call_api(params, req, runtime)
        )

    async def un_tag_resources_with_options_async(
        self,
        request: vpc_20160428_models.UnTagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UnTagResourcesResponse:
        """
        @summary Removes tags from resources.
        
        @param request: UnTagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnTagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.all):
            query['All'] = request.all
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag_key):
            query['TagKey'] = request.tag_key
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnTagResources',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UnTagResourcesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def un_tag_resources(
        self,
        request: vpc_20160428_models.UnTagResourcesRequest,
    ) -> vpc_20160428_models.UnTagResourcesResponse:
        """
        @summary Removes tags from resources.
        
        @param request: UnTagResourcesRequest
        @return: UnTagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.un_tag_resources_with_options(request, runtime)

    async def un_tag_resources_async(
        self,
        request: vpc_20160428_models.UnTagResourcesRequest,
    ) -> vpc_20160428_models.UnTagResourcesResponse:
        """
        @summary Removes tags from resources.
        
        @param request: UnTagResourcesRequest
        @return: UnTagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.un_tag_resources_with_options_async(request, runtime)

    def unassociate_eip_address_with_options(
        self,
        request: vpc_20160428_models.UnassociateEipAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UnassociateEipAddressResponse:
        """
        @summary Disassociates an elastic IP address (EIP) from a cloud resource.
        
        @description    **UnassociateEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
        If the EIP is in the **Unassociating** state, the EIP is being disassociated. In this state, you can only query the EIP and cannot perform other operations.
        If the EIP is in the **Available** state, the EIP is disassociated.
        You cannot repeatedly call the **UnassociateEipAddress** operation within the specified period of time.
        
        @param request: UnassociateEipAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassociateEipAddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassociateEipAddress',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UnassociateEipAddressResponse(),
            self.call_api(params, req, runtime)
        )

    async def unassociate_eip_address_with_options_async(
        self,
        request: vpc_20160428_models.UnassociateEipAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UnassociateEipAddressResponse:
        """
        @summary Disassociates an elastic IP address (EIP) from a cloud resource.
        
        @description    **UnassociateEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
        If the EIP is in the **Unassociating** state, the EIP is being disassociated. In this state, you can only query the EIP and cannot perform other operations.
        If the EIP is in the **Available** state, the EIP is disassociated.
        You cannot repeatedly call the **UnassociateEipAddress** operation within the specified period of time.
        
        @param request: UnassociateEipAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassociateEipAddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allocation_id):
            query['AllocationId'] = request.allocation_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.private_ip_address):
            query['PrivateIpAddress'] = request.private_ip_address
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassociateEipAddress',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UnassociateEipAddressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def unassociate_eip_address(
        self,
        request: vpc_20160428_models.UnassociateEipAddressRequest,
    ) -> vpc_20160428_models.UnassociateEipAddressResponse:
        """
        @summary Disassociates an elastic IP address (EIP) from a cloud resource.
        
        @description    **UnassociateEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
        If the EIP is in the **Unassociating** state, the EIP is being disassociated. In this state, you can only query the EIP and cannot perform other operations.
        If the EIP is in the **Available** state, the EIP is disassociated.
        You cannot repeatedly call the **UnassociateEipAddress** operation within the specified period of time.
        
        @param request: UnassociateEipAddressRequest
        @return: UnassociateEipAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.unassociate_eip_address_with_options(request, runtime)

    async def unassociate_eip_address_async(
        self,
        request: vpc_20160428_models.UnassociateEipAddressRequest,
    ) -> vpc_20160428_models.UnassociateEipAddressResponse:
        """
        @summary Disassociates an elastic IP address (EIP) from a cloud resource.
        
        @description    **UnassociateEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
        If the EIP is in the **Unassociating** state, the EIP is being disassociated. In this state, you can only query the EIP and cannot perform other operations.
        If the EIP is in the **Available** state, the EIP is disassociated.
        You cannot repeatedly call the **UnassociateEipAddress** operation within the specified period of time.
        
        @param request: UnassociateEipAddressRequest
        @return: UnassociateEipAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.unassociate_eip_address_with_options_async(request, runtime)

    def unassociate_global_acceleration_instance_with_options(
        self,
        request: vpc_20160428_models.UnassociateGlobalAccelerationInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UnassociateGlobalAccelerationInstanceResponse:
        """
        @summary Disassociates a Global Accelerator (GA) instance from a backend server.
        
        @param request: UnassociateGlobalAccelerationInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassociateGlobalAccelerationInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.global_acceleration_instance_id):
            query['GlobalAccelerationInstanceId'] = request.global_acceleration_instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassociateGlobalAccelerationInstance',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UnassociateGlobalAccelerationInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def unassociate_global_acceleration_instance_with_options_async(
        self,
        request: vpc_20160428_models.UnassociateGlobalAccelerationInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UnassociateGlobalAccelerationInstanceResponse:
        """
        @summary Disassociates a Global Accelerator (GA) instance from a backend server.
        
        @param request: UnassociateGlobalAccelerationInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassociateGlobalAccelerationInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.global_acceleration_instance_id):
            query['GlobalAccelerationInstanceId'] = request.global_acceleration_instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassociateGlobalAccelerationInstance',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UnassociateGlobalAccelerationInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def unassociate_global_acceleration_instance(
        self,
        request: vpc_20160428_models.UnassociateGlobalAccelerationInstanceRequest,
    ) -> vpc_20160428_models.UnassociateGlobalAccelerationInstanceResponse:
        """
        @summary Disassociates a Global Accelerator (GA) instance from a backend server.
        
        @param request: UnassociateGlobalAccelerationInstanceRequest
        @return: UnassociateGlobalAccelerationInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.unassociate_global_acceleration_instance_with_options(request, runtime)

    async def unassociate_global_acceleration_instance_async(
        self,
        request: vpc_20160428_models.UnassociateGlobalAccelerationInstanceRequest,
    ) -> vpc_20160428_models.UnassociateGlobalAccelerationInstanceResponse:
        """
        @summary Disassociates a Global Accelerator (GA) instance from a backend server.
        
        @param request: UnassociateGlobalAccelerationInstanceRequest
        @return: UnassociateGlobalAccelerationInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.unassociate_global_acceleration_instance_with_options_async(request, runtime)

    def unassociate_ha_vip_with_options(
        self,
        request: vpc_20160428_models.UnassociateHaVipRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UnassociateHaVipResponse:
        """
        @summary Disassociates a high-availability virtual IP address (HAVIP) from an Elastic Compute Service (ECS) in a virtual private cloud (VPC) or from an elastic network interface (ENI).
        
        @description ## [](#)
        When you call this operation, take note of the following limits:
        The ECS instance must be in the **Running** or **Stopped** state.
        The HAVIP must be in the **Available** or **InUse** state.
        **UnassociateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and an instance ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HAVIP:
        If the HAVIP is in the **Unassociating** state, the HAVIP is being disassociated.
        If the HAVIP is in the **Inuse** or **Available** state, the HAVIP is disassociated.
        You cannot repeatedly call the **UnassociateHaVip** operation to disassociate an HAVIP within the specified period of time.
        
        @param request: UnassociateHaVipRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassociateHaVipResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.ha_vip_id):
            query['HaVipId'] = request.ha_vip_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassociateHaVip',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UnassociateHaVipResponse(),
            self.call_api(params, req, runtime)
        )

    async def unassociate_ha_vip_with_options_async(
        self,
        request: vpc_20160428_models.UnassociateHaVipRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UnassociateHaVipResponse:
        """
        @summary Disassociates a high-availability virtual IP address (HAVIP) from an Elastic Compute Service (ECS) in a virtual private cloud (VPC) or from an elastic network interface (ENI).
        
        @description ## [](#)
        When you call this operation, take note of the following limits:
        The ECS instance must be in the **Running** or **Stopped** state.
        The HAVIP must be in the **Available** or **InUse** state.
        **UnassociateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and an instance ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HAVIP:
        If the HAVIP is in the **Unassociating** state, the HAVIP is being disassociated.
        If the HAVIP is in the **Inuse** or **Available** state, the HAVIP is disassociated.
        You cannot repeatedly call the **UnassociateHaVip** operation to disassociate an HAVIP within the specified period of time.
        
        @param request: UnassociateHaVipRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassociateHaVipResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.ha_vip_id):
            query['HaVipId'] = request.ha_vip_id
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassociateHaVip',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UnassociateHaVipResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def unassociate_ha_vip(
        self,
        request: vpc_20160428_models.UnassociateHaVipRequest,
    ) -> vpc_20160428_models.UnassociateHaVipResponse:
        """
        @summary Disassociates a high-availability virtual IP address (HAVIP) from an Elastic Compute Service (ECS) in a virtual private cloud (VPC) or from an elastic network interface (ENI).
        
        @description ## [](#)
        When you call this operation, take note of the following limits:
        The ECS instance must be in the **Running** or **Stopped** state.
        The HAVIP must be in the **Available** or **InUse** state.
        **UnassociateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and an instance ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HAVIP:
        If the HAVIP is in the **Unassociating** state, the HAVIP is being disassociated.
        If the HAVIP is in the **Inuse** or **Available** state, the HAVIP is disassociated.
        You cannot repeatedly call the **UnassociateHaVip** operation to disassociate an HAVIP within the specified period of time.
        
        @param request: UnassociateHaVipRequest
        @return: UnassociateHaVipResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.unassociate_ha_vip_with_options(request, runtime)

    async def unassociate_ha_vip_async(
        self,
        request: vpc_20160428_models.UnassociateHaVipRequest,
    ) -> vpc_20160428_models.UnassociateHaVipResponse:
        """
        @summary Disassociates a high-availability virtual IP address (HAVIP) from an Elastic Compute Service (ECS) in a virtual private cloud (VPC) or from an elastic network interface (ENI).
        
        @description ## [](#)
        When you call this operation, take note of the following limits:
        The ECS instance must be in the **Running** or **Stopped** state.
        The HAVIP must be in the **Available** or **InUse** state.
        **UnassociateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and an instance ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HAVIP:
        If the HAVIP is in the **Unassociating** state, the HAVIP is being disassociated.
        If the HAVIP is in the **Inuse** or **Available** state, the HAVIP is disassociated.
        You cannot repeatedly call the **UnassociateHaVip** operation to disassociate an HAVIP within the specified period of time.
        
        @param request: UnassociateHaVipRequest
        @return: UnassociateHaVipResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.unassociate_ha_vip_with_options_async(request, runtime)

    def unassociate_network_acl_with_options(
        self,
        request: vpc_20160428_models.UnassociateNetworkAclRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UnassociateNetworkAclResponse:
        """
        @summary Disassociates a network access control list (ACL) from a vSwitch.
        
        @description ## [](#)Description
        **UnassociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
        If the network ACL is in the **UNBINDING** state, the network ACL is being disassociated from the vSwitch.
        If the network ACL is in the **UNBINDED** state, the network ACL is disassociated from the vSwitch.
        You cannot repeatedly call the **UnassociateNetworkAcl** operation to disassociate a network ACL from a vSwitch within the specified period of time.
        
        @param request: UnassociateNetworkAclRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassociateNetworkAclResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.network_acl_id):
            query['NetworkAclId'] = request.network_acl_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource):
            query['Resource'] = request.resource
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassociateNetworkAcl',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UnassociateNetworkAclResponse(),
            self.call_api(params, req, runtime)
        )

    async def unassociate_network_acl_with_options_async(
        self,
        request: vpc_20160428_models.UnassociateNetworkAclRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UnassociateNetworkAclResponse:
        """
        @summary Disassociates a network access control list (ACL) from a vSwitch.
        
        @description ## [](#)Description
        **UnassociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
        If the network ACL is in the **UNBINDING** state, the network ACL is being disassociated from the vSwitch.
        If the network ACL is in the **UNBINDED** state, the network ACL is disassociated from the vSwitch.
        You cannot repeatedly call the **UnassociateNetworkAcl** operation to disassociate a network ACL from a vSwitch within the specified period of time.
        
        @param request: UnassociateNetworkAclRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassociateNetworkAclResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.network_acl_id):
            query['NetworkAclId'] = request.network_acl_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource):
            query['Resource'] = request.resource
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassociateNetworkAcl',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UnassociateNetworkAclResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def unassociate_network_acl(
        self,
        request: vpc_20160428_models.UnassociateNetworkAclRequest,
    ) -> vpc_20160428_models.UnassociateNetworkAclResponse:
        """
        @summary Disassociates a network access control list (ACL) from a vSwitch.
        
        @description ## [](#)Description
        **UnassociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
        If the network ACL is in the **UNBINDING** state, the network ACL is being disassociated from the vSwitch.
        If the network ACL is in the **UNBINDED** state, the network ACL is disassociated from the vSwitch.
        You cannot repeatedly call the **UnassociateNetworkAcl** operation to disassociate a network ACL from a vSwitch within the specified period of time.
        
        @param request: UnassociateNetworkAclRequest
        @return: UnassociateNetworkAclResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.unassociate_network_acl_with_options(request, runtime)

    async def unassociate_network_acl_async(
        self,
        request: vpc_20160428_models.UnassociateNetworkAclRequest,
    ) -> vpc_20160428_models.UnassociateNetworkAclResponse:
        """
        @summary Disassociates a network access control list (ACL) from a vSwitch.
        
        @description ## [](#)Description
        **UnassociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
        If the network ACL is in the **UNBINDING** state, the network ACL is being disassociated from the vSwitch.
        If the network ACL is in the **UNBINDED** state, the network ACL is disassociated from the vSwitch.
        You cannot repeatedly call the **UnassociateNetworkAcl** operation to disassociate a network ACL from a vSwitch within the specified period of time.
        
        @param request: UnassociateNetworkAclRequest
        @return: UnassociateNetworkAclResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.unassociate_network_acl_with_options_async(request, runtime)

    def unassociate_physical_connection_from_virtual_border_router_with_options(
        self,
        request: vpc_20160428_models.UnassociatePhysicalConnectionFromVirtualBorderRouterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UnassociatePhysicalConnectionFromVirtualBorderRouterResponse:
        """
        @summary Disassociates a virtual border router (VBR) from an Express Connect circuit.
        
        @param request: UnassociatePhysicalConnectionFromVirtualBorderRouterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassociatePhysicalConnectionFromVirtualBorderRouterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassociatePhysicalConnectionFromVirtualBorderRouter',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UnassociatePhysicalConnectionFromVirtualBorderRouterResponse(),
            self.call_api(params, req, runtime)
        )

    async def unassociate_physical_connection_from_virtual_border_router_with_options_async(
        self,
        request: vpc_20160428_models.UnassociatePhysicalConnectionFromVirtualBorderRouterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UnassociatePhysicalConnectionFromVirtualBorderRouterResponse:
        """
        @summary Disassociates a virtual border router (VBR) from an Express Connect circuit.
        
        @param request: UnassociatePhysicalConnectionFromVirtualBorderRouterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassociatePhysicalConnectionFromVirtualBorderRouterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.physical_connection_id):
            query['PhysicalConnectionId'] = request.physical_connection_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vbr_id):
            query['VbrId'] = request.vbr_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassociatePhysicalConnectionFromVirtualBorderRouter',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UnassociatePhysicalConnectionFromVirtualBorderRouterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def unassociate_physical_connection_from_virtual_border_router(
        self,
        request: vpc_20160428_models.UnassociatePhysicalConnectionFromVirtualBorderRouterRequest,
    ) -> vpc_20160428_models.UnassociatePhysicalConnectionFromVirtualBorderRouterResponse:
        """
        @summary Disassociates a virtual border router (VBR) from an Express Connect circuit.
        
        @param request: UnassociatePhysicalConnectionFromVirtualBorderRouterRequest
        @return: UnassociatePhysicalConnectionFromVirtualBorderRouterResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.unassociate_physical_connection_from_virtual_border_router_with_options(request, runtime)

    async def unassociate_physical_connection_from_virtual_border_router_async(
        self,
        request: vpc_20160428_models.UnassociatePhysicalConnectionFromVirtualBorderRouterRequest,
    ) -> vpc_20160428_models.UnassociatePhysicalConnectionFromVirtualBorderRouterResponse:
        """
        @summary Disassociates a virtual border router (VBR) from an Express Connect circuit.
        
        @param request: UnassociatePhysicalConnectionFromVirtualBorderRouterRequest
        @return: UnassociatePhysicalConnectionFromVirtualBorderRouterResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.unassociate_physical_connection_from_virtual_border_router_with_options_async(request, runtime)

    def unassociate_route_table_with_options(
        self,
        request: vpc_20160428_models.UnassociateRouteTableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UnassociateRouteTableResponse:
        """
        @summary Disassociates a route table from a vSwitch.
        
        @description ## [](#)References
        **UnassociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task.
        If the vSwitch is in the **Pending** state, the route table is being disassociated.
        If the vSwitch is in the **Available** state, the route table is disassociated.
        You cannot repeatedly call the **UnassociateRouteTable** operation to disassociate a route table from a vSwitch within the specified period of time.
        
        @param request: UnassociateRouteTableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassociateRouteTableResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassociateRouteTable',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UnassociateRouteTableResponse(),
            self.call_api(params, req, runtime)
        )

    async def unassociate_route_table_with_options_async(
        self,
        request: vpc_20160428_models.UnassociateRouteTableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UnassociateRouteTableResponse:
        """
        @summary Disassociates a route table from a vSwitch.
        
        @description ## [](#)References
        **UnassociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task.
        If the vSwitch is in the **Pending** state, the route table is being disassociated.
        If the vSwitch is in the **Available** state, the route table is disassociated.
        You cannot repeatedly call the **UnassociateRouteTable** operation to disassociate a route table from a vSwitch within the specified period of time.
        
        @param request: UnassociateRouteTableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassociateRouteTableResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.route_table_id):
            query['RouteTableId'] = request.route_table_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassociateRouteTable',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UnassociateRouteTableResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def unassociate_route_table(
        self,
        request: vpc_20160428_models.UnassociateRouteTableRequest,
    ) -> vpc_20160428_models.UnassociateRouteTableResponse:
        """
        @summary Disassociates a route table from a vSwitch.
        
        @description ## [](#)References
        **UnassociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task.
        If the vSwitch is in the **Pending** state, the route table is being disassociated.
        If the vSwitch is in the **Available** state, the route table is disassociated.
        You cannot repeatedly call the **UnassociateRouteTable** operation to disassociate a route table from a vSwitch within the specified period of time.
        
        @param request: UnassociateRouteTableRequest
        @return: UnassociateRouteTableResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.unassociate_route_table_with_options(request, runtime)

    async def unassociate_route_table_async(
        self,
        request: vpc_20160428_models.UnassociateRouteTableRequest,
    ) -> vpc_20160428_models.UnassociateRouteTableResponse:
        """
        @summary Disassociates a route table from a vSwitch.
        
        @description ## [](#)References
        **UnassociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task.
        If the vSwitch is in the **Pending** state, the route table is being disassociated.
        If the vSwitch is in the **Available** state, the route table is disassociated.
        You cannot repeatedly call the **UnassociateRouteTable** operation to disassociate a route table from a vSwitch within the specified period of time.
        
        @param request: UnassociateRouteTableRequest
        @return: UnassociateRouteTableResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.unassociate_route_table_with_options_async(request, runtime)

    def unassociate_vpc_cidr_block_with_options(
        self,
        request: vpc_20160428_models.UnassociateVpcCidrBlockRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UnassociateVpcCidrBlockResponse:
        """
        @summary Removes a secondary CIDR block from a virtual private cloud (VPC).
        
        @description    Before you delete a secondary CIDR block from a VPC, delete the vSwitch which is created with the CIDR block. For more information, see [DeleteVSwitch](https://help.aliyun.com/document_detail/35746.html).
        You cannot repeatedly call the **UnassociateVpcCidrBlock** operation to delete a secondary CIDR block from a VPC within the specified period of time.
        
        @param request: UnassociateVpcCidrBlockRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassociateVpcCidrBlockResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipv_6cidr_block):
            query['IPv6CidrBlock'] = request.ipv_6cidr_block
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.secondary_cidr_block):
            query['SecondaryCidrBlock'] = request.secondary_cidr_block
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassociateVpcCidrBlock',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UnassociateVpcCidrBlockResponse(),
            self.call_api(params, req, runtime)
        )

    async def unassociate_vpc_cidr_block_with_options_async(
        self,
        request: vpc_20160428_models.UnassociateVpcCidrBlockRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UnassociateVpcCidrBlockResponse:
        """
        @summary Removes a secondary CIDR block from a virtual private cloud (VPC).
        
        @description    Before you delete a secondary CIDR block from a VPC, delete the vSwitch which is created with the CIDR block. For more information, see [DeleteVSwitch](https://help.aliyun.com/document_detail/35746.html).
        You cannot repeatedly call the **UnassociateVpcCidrBlock** operation to delete a secondary CIDR block from a VPC within the specified period of time.
        
        @param request: UnassociateVpcCidrBlockRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnassociateVpcCidrBlockResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ipv_6cidr_block):
            query['IPv6CidrBlock'] = request.ipv_6cidr_block
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.secondary_cidr_block):
            query['SecondaryCidrBlock'] = request.secondary_cidr_block
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnassociateVpcCidrBlock',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UnassociateVpcCidrBlockResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def unassociate_vpc_cidr_block(
        self,
        request: vpc_20160428_models.UnassociateVpcCidrBlockRequest,
    ) -> vpc_20160428_models.UnassociateVpcCidrBlockResponse:
        """
        @summary Removes a secondary CIDR block from a virtual private cloud (VPC).
        
        @description    Before you delete a secondary CIDR block from a VPC, delete the vSwitch which is created with the CIDR block. For more information, see [DeleteVSwitch](https://help.aliyun.com/document_detail/35746.html).
        You cannot repeatedly call the **UnassociateVpcCidrBlock** operation to delete a secondary CIDR block from a VPC within the specified period of time.
        
        @param request: UnassociateVpcCidrBlockRequest
        @return: UnassociateVpcCidrBlockResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.unassociate_vpc_cidr_block_with_options(request, runtime)

    async def unassociate_vpc_cidr_block_async(
        self,
        request: vpc_20160428_models.UnassociateVpcCidrBlockRequest,
    ) -> vpc_20160428_models.UnassociateVpcCidrBlockResponse:
        """
        @summary Removes a secondary CIDR block from a virtual private cloud (VPC).
        
        @description    Before you delete a secondary CIDR block from a VPC, delete the vSwitch which is created with the CIDR block. For more information, see [DeleteVSwitch](https://help.aliyun.com/document_detail/35746.html).
        You cannot repeatedly call the **UnassociateVpcCidrBlock** operation to delete a secondary CIDR block from a VPC within the specified period of time.
        
        @param request: UnassociateVpcCidrBlockRequest
        @return: UnassociateVpcCidrBlockResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.unassociate_vpc_cidr_block_with_options_async(request, runtime)

    def untag_resources_for_express_connect_with_options(
        self,
        request: vpc_20160428_models.UntagResourcesForExpressConnectRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UntagResourcesForExpressConnectResponse:
        """
        @summary Removes tags from an Express Connect circuit at a time.
        
        @param request: UntagResourcesForExpressConnectRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UntagResourcesForExpressConnectResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.all):
            query['All'] = request.all
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag_key):
            query['TagKey'] = request.tag_key
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UntagResourcesForExpressConnect',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UntagResourcesForExpressConnectResponse(),
            self.call_api(params, req, runtime)
        )

    async def untag_resources_for_express_connect_with_options_async(
        self,
        request: vpc_20160428_models.UntagResourcesForExpressConnectRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UntagResourcesForExpressConnectResponse:
        """
        @summary Removes tags from an Express Connect circuit at a time.
        
        @param request: UntagResourcesForExpressConnectRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UntagResourcesForExpressConnectResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.all):
            query['All'] = request.all
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag_key):
            query['TagKey'] = request.tag_key
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UntagResourcesForExpressConnect',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UntagResourcesForExpressConnectResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def untag_resources_for_express_connect(
        self,
        request: vpc_20160428_models.UntagResourcesForExpressConnectRequest,
    ) -> vpc_20160428_models.UntagResourcesForExpressConnectResponse:
        """
        @summary Removes tags from an Express Connect circuit at a time.
        
        @param request: UntagResourcesForExpressConnectRequest
        @return: UntagResourcesForExpressConnectResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.untag_resources_for_express_connect_with_options(request, runtime)

    async def untag_resources_for_express_connect_async(
        self,
        request: vpc_20160428_models.UntagResourcesForExpressConnectRequest,
    ) -> vpc_20160428_models.UntagResourcesForExpressConnectResponse:
        """
        @summary Removes tags from an Express Connect circuit at a time.
        
        @param request: UntagResourcesForExpressConnectRequest
        @return: UntagResourcesForExpressConnectResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.untag_resources_for_express_connect_with_options_async(request, runtime)

    def update_dhcp_options_set_attribute_with_options(
        self,
        request: vpc_20160428_models.UpdateDhcpOptionsSetAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateDhcpOptionsSetAttributeResponse:
        """
        @summary Dhcp
        
        @param request: UpdateDhcpOptionsSetAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateDhcpOptionsSetAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dhcp_options_set_description):
            query['DhcpOptionsSetDescription'] = request.dhcp_options_set_description
        if not UtilClient.is_unset(request.dhcp_options_set_id):
            query['DhcpOptionsSetId'] = request.dhcp_options_set_id
        if not UtilClient.is_unset(request.dhcp_options_set_name):
            query['DhcpOptionsSetName'] = request.dhcp_options_set_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.domain_name_servers):
            query['DomainNameServers'] = request.domain_name_servers
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.ipv_6lease_time):
            query['Ipv6LeaseTime'] = request.ipv_6lease_time
        if not UtilClient.is_unset(request.lease_time):
            query['LeaseTime'] = request.lease_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateDhcpOptionsSetAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateDhcpOptionsSetAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_dhcp_options_set_attribute_with_options_async(
        self,
        request: vpc_20160428_models.UpdateDhcpOptionsSetAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateDhcpOptionsSetAttributeResponse:
        """
        @summary Dhcp
        
        @param request: UpdateDhcpOptionsSetAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateDhcpOptionsSetAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dhcp_options_set_description):
            query['DhcpOptionsSetDescription'] = request.dhcp_options_set_description
        if not UtilClient.is_unset(request.dhcp_options_set_id):
            query['DhcpOptionsSetId'] = request.dhcp_options_set_id
        if not UtilClient.is_unset(request.dhcp_options_set_name):
            query['DhcpOptionsSetName'] = request.dhcp_options_set_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.domain_name_servers):
            query['DomainNameServers'] = request.domain_name_servers
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.ipv_6lease_time):
            query['Ipv6LeaseTime'] = request.ipv_6lease_time
        if not UtilClient.is_unset(request.lease_time):
            query['LeaseTime'] = request.lease_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateDhcpOptionsSetAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateDhcpOptionsSetAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_dhcp_options_set_attribute(
        self,
        request: vpc_20160428_models.UpdateDhcpOptionsSetAttributeRequest,
    ) -> vpc_20160428_models.UpdateDhcpOptionsSetAttributeResponse:
        """
        @summary Dhcp
        
        @param request: UpdateDhcpOptionsSetAttributeRequest
        @return: UpdateDhcpOptionsSetAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_dhcp_options_set_attribute_with_options(request, runtime)

    async def update_dhcp_options_set_attribute_async(
        self,
        request: vpc_20160428_models.UpdateDhcpOptionsSetAttributeRequest,
    ) -> vpc_20160428_models.UpdateDhcpOptionsSetAttributeResponse:
        """
        @summary Dhcp
        
        @param request: UpdateDhcpOptionsSetAttributeRequest
        @return: UpdateDhcpOptionsSetAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_dhcp_options_set_attribute_with_options_async(request, runtime)

    def update_failover_test_job_with_options(
        self,
        request: vpc_20160428_models.UpdateFailoverTestJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateFailoverTestJobResponse:
        """
        @summary 
        
        @param request: UpdateFailoverTestJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateFailoverTestJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.job_duration):
            query['JobDuration'] = request.job_duration
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateFailoverTestJob',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateFailoverTestJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_failover_test_job_with_options_async(
        self,
        request: vpc_20160428_models.UpdateFailoverTestJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateFailoverTestJobResponse:
        """
        @summary 
        
        @param request: UpdateFailoverTestJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateFailoverTestJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.job_duration):
            query['JobDuration'] = request.job_duration
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateFailoverTestJob',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateFailoverTestJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_failover_test_job(
        self,
        request: vpc_20160428_models.UpdateFailoverTestJobRequest,
    ) -> vpc_20160428_models.UpdateFailoverTestJobResponse:
        """
        @summary 
        
        @param request: UpdateFailoverTestJobRequest
        @return: UpdateFailoverTestJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_failover_test_job_with_options(request, runtime)

    async def update_failover_test_job_async(
        self,
        request: vpc_20160428_models.UpdateFailoverTestJobRequest,
    ) -> vpc_20160428_models.UpdateFailoverTestJobResponse:
        """
        @summary 
        
        @param request: UpdateFailoverTestJobRequest
        @return: UpdateFailoverTestJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_failover_test_job_with_options_async(request, runtime)

    def update_gateway_route_table_entry_attribute_with_options(
        self,
        request: vpc_20160428_models.UpdateGatewayRouteTableEntryAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateGatewayRouteTableEntryAttributeResponse:
        """
        @summary Modifies the next hop type and next hop of the route entry in a gateway route table.
        
        @param request: UpdateGatewayRouteTableEntryAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateGatewayRouteTableEntryAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.destination_cidr_block):
            query['DestinationCidrBlock'] = request.destination_cidr_block
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.gateway_route_table_id):
            query['GatewayRouteTableId'] = request.gateway_route_table_id
        if not UtilClient.is_unset(request.ipv_4gateway_route_table_id):
            query['IPv4GatewayRouteTableId'] = request.ipv_4gateway_route_table_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.next_hop_id):
            query['NextHopId'] = request.next_hop_id
        if not UtilClient.is_unset(request.next_hop_type):
            query['NextHopType'] = request.next_hop_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateGatewayRouteTableEntryAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateGatewayRouteTableEntryAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_gateway_route_table_entry_attribute_with_options_async(
        self,
        request: vpc_20160428_models.UpdateGatewayRouteTableEntryAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateGatewayRouteTableEntryAttributeResponse:
        """
        @summary Modifies the next hop type and next hop of the route entry in a gateway route table.
        
        @param request: UpdateGatewayRouteTableEntryAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateGatewayRouteTableEntryAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.destination_cidr_block):
            query['DestinationCidrBlock'] = request.destination_cidr_block
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.gateway_route_table_id):
            query['GatewayRouteTableId'] = request.gateway_route_table_id
        if not UtilClient.is_unset(request.ipv_4gateway_route_table_id):
            query['IPv4GatewayRouteTableId'] = request.ipv_4gateway_route_table_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.next_hop_id):
            query['NextHopId'] = request.next_hop_id
        if not UtilClient.is_unset(request.next_hop_type):
            query['NextHopType'] = request.next_hop_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateGatewayRouteTableEntryAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateGatewayRouteTableEntryAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_gateway_route_table_entry_attribute(
        self,
        request: vpc_20160428_models.UpdateGatewayRouteTableEntryAttributeRequest,
    ) -> vpc_20160428_models.UpdateGatewayRouteTableEntryAttributeResponse:
        """
        @summary Modifies the next hop type and next hop of the route entry in a gateway route table.
        
        @param request: UpdateGatewayRouteTableEntryAttributeRequest
        @return: UpdateGatewayRouteTableEntryAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_gateway_route_table_entry_attribute_with_options(request, runtime)

    async def update_gateway_route_table_entry_attribute_async(
        self,
        request: vpc_20160428_models.UpdateGatewayRouteTableEntryAttributeRequest,
    ) -> vpc_20160428_models.UpdateGatewayRouteTableEntryAttributeResponse:
        """
        @summary Modifies the next hop type and next hop of the route entry in a gateway route table.
        
        @param request: UpdateGatewayRouteTableEntryAttributeRequest
        @return: UpdateGatewayRouteTableEntryAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_gateway_route_table_entry_attribute_with_options_async(request, runtime)

    def update_ipsec_server_with_options(
        self,
        request: vpc_20160428_models.UpdateIpsecServerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateIpsecServerResponse:
        """
        @summary Modifies the configuration of an IPsec server.
        
        @description    If you modify only the **IpsecServerName** parameter, this operation is synchronous. If you modify parameters other than **IpsecServerName**, this operation is asynchronous.
        When the **UpdateIpsecServer** operation is asynchronous, the system returns a request ID after you send a request to call this operation and the IPsec server is being modified in the backend. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of a VPN gateway.
        If the VPN gateway is in the **updating** state, the configuration of the IPsec server is being modified.
        If the VPN gateway is in the **active** state, the configuration of the IPsec server is modified.
        You cannot repeatedly call the **UpdateIpsecServer** operation for the same VPN gateway within the specified period of time.
        
        @param request: UpdateIpsecServerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateIpsecServerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_ip_pool):
            query['ClientIpPool'] = request.client_ip_pool
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.effect_immediately):
            query['EffectImmediately'] = request.effect_immediately
        if not UtilClient.is_unset(request.ike_config):
            query['IkeConfig'] = request.ike_config
        if not UtilClient.is_unset(request.ipsec_config):
            query['IpsecConfig'] = request.ipsec_config
        if not UtilClient.is_unset(request.ipsec_server_id):
            query['IpsecServerId'] = request.ipsec_server_id
        if not UtilClient.is_unset(request.ipsec_server_name):
            query['IpsecServerName'] = request.ipsec_server_name
        if not UtilClient.is_unset(request.local_subnet):
            query['LocalSubnet'] = request.local_subnet
        if not UtilClient.is_unset(request.psk):
            query['Psk'] = request.psk
        if not UtilClient.is_unset(request.psk_enabled):
            query['PskEnabled'] = request.psk_enabled
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateIpsecServer',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateIpsecServerResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_ipsec_server_with_options_async(
        self,
        request: vpc_20160428_models.UpdateIpsecServerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateIpsecServerResponse:
        """
        @summary Modifies the configuration of an IPsec server.
        
        @description    If you modify only the **IpsecServerName** parameter, this operation is synchronous. If you modify parameters other than **IpsecServerName**, this operation is asynchronous.
        When the **UpdateIpsecServer** operation is asynchronous, the system returns a request ID after you send a request to call this operation and the IPsec server is being modified in the backend. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of a VPN gateway.
        If the VPN gateway is in the **updating** state, the configuration of the IPsec server is being modified.
        If the VPN gateway is in the **active** state, the configuration of the IPsec server is modified.
        You cannot repeatedly call the **UpdateIpsecServer** operation for the same VPN gateway within the specified period of time.
        
        @param request: UpdateIpsecServerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateIpsecServerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_ip_pool):
            query['ClientIpPool'] = request.client_ip_pool
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.effect_immediately):
            query['EffectImmediately'] = request.effect_immediately
        if not UtilClient.is_unset(request.ike_config):
            query['IkeConfig'] = request.ike_config
        if not UtilClient.is_unset(request.ipsec_config):
            query['IpsecConfig'] = request.ipsec_config
        if not UtilClient.is_unset(request.ipsec_server_id):
            query['IpsecServerId'] = request.ipsec_server_id
        if not UtilClient.is_unset(request.ipsec_server_name):
            query['IpsecServerName'] = request.ipsec_server_name
        if not UtilClient.is_unset(request.local_subnet):
            query['LocalSubnet'] = request.local_subnet
        if not UtilClient.is_unset(request.psk):
            query['Psk'] = request.psk
        if not UtilClient.is_unset(request.psk_enabled):
            query['PskEnabled'] = request.psk_enabled
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateIpsecServer',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateIpsecServerResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_ipsec_server(
        self,
        request: vpc_20160428_models.UpdateIpsecServerRequest,
    ) -> vpc_20160428_models.UpdateIpsecServerResponse:
        """
        @summary Modifies the configuration of an IPsec server.
        
        @description    If you modify only the **IpsecServerName** parameter, this operation is synchronous. If you modify parameters other than **IpsecServerName**, this operation is asynchronous.
        When the **UpdateIpsecServer** operation is asynchronous, the system returns a request ID after you send a request to call this operation and the IPsec server is being modified in the backend. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of a VPN gateway.
        If the VPN gateway is in the **updating** state, the configuration of the IPsec server is being modified.
        If the VPN gateway is in the **active** state, the configuration of the IPsec server is modified.
        You cannot repeatedly call the **UpdateIpsecServer** operation for the same VPN gateway within the specified period of time.
        
        @param request: UpdateIpsecServerRequest
        @return: UpdateIpsecServerResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_ipsec_server_with_options(request, runtime)

    async def update_ipsec_server_async(
        self,
        request: vpc_20160428_models.UpdateIpsecServerRequest,
    ) -> vpc_20160428_models.UpdateIpsecServerResponse:
        """
        @summary Modifies the configuration of an IPsec server.
        
        @description    If you modify only the **IpsecServerName** parameter, this operation is synchronous. If you modify parameters other than **IpsecServerName**, this operation is asynchronous.
        When the **UpdateIpsecServer** operation is asynchronous, the system returns a request ID after you send a request to call this operation and the IPsec server is being modified in the backend. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of a VPN gateway.
        If the VPN gateway is in the **updating** state, the configuration of the IPsec server is being modified.
        If the VPN gateway is in the **active** state, the configuration of the IPsec server is modified.
        You cannot repeatedly call the **UpdateIpsecServer** operation for the same VPN gateway within the specified period of time.
        
        @param request: UpdateIpsecServerRequest
        @return: UpdateIpsecServerResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_ipsec_server_with_options_async(request, runtime)

    def update_ipv_4gateway_attribute_with_options(
        self,
        request: vpc_20160428_models.UpdateIpv4GatewayAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateIpv4GatewayAttributeResponse:
        """
        @summary Modifies the description or name of an IPv4 gateway.
        
        @description You cannot repeatedly call the *UpdateIpv4GatewayAttribute** operation to modify the name or description of an IPv4 gateway within the specified period of time.
        
        @param request: UpdateIpv4GatewayAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateIpv4GatewayAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.ipv_4gateway_description):
            query['Ipv4GatewayDescription'] = request.ipv_4gateway_description
        if not UtilClient.is_unset(request.ipv_4gateway_id):
            query['Ipv4GatewayId'] = request.ipv_4gateway_id
        if not UtilClient.is_unset(request.ipv_4gateway_name):
            query['Ipv4GatewayName'] = request.ipv_4gateway_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateIpv4GatewayAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateIpv4GatewayAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_ipv_4gateway_attribute_with_options_async(
        self,
        request: vpc_20160428_models.UpdateIpv4GatewayAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateIpv4GatewayAttributeResponse:
        """
        @summary Modifies the description or name of an IPv4 gateway.
        
        @description You cannot repeatedly call the *UpdateIpv4GatewayAttribute** operation to modify the name or description of an IPv4 gateway within the specified period of time.
        
        @param request: UpdateIpv4GatewayAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateIpv4GatewayAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.ipv_4gateway_description):
            query['Ipv4GatewayDescription'] = request.ipv_4gateway_description
        if not UtilClient.is_unset(request.ipv_4gateway_id):
            query['Ipv4GatewayId'] = request.ipv_4gateway_id
        if not UtilClient.is_unset(request.ipv_4gateway_name):
            query['Ipv4GatewayName'] = request.ipv_4gateway_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateIpv4GatewayAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateIpv4GatewayAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_ipv_4gateway_attribute(
        self,
        request: vpc_20160428_models.UpdateIpv4GatewayAttributeRequest,
    ) -> vpc_20160428_models.UpdateIpv4GatewayAttributeResponse:
        """
        @summary Modifies the description or name of an IPv4 gateway.
        
        @description You cannot repeatedly call the *UpdateIpv4GatewayAttribute** operation to modify the name or description of an IPv4 gateway within the specified period of time.
        
        @param request: UpdateIpv4GatewayAttributeRequest
        @return: UpdateIpv4GatewayAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_ipv_4gateway_attribute_with_options(request, runtime)

    async def update_ipv_4gateway_attribute_async(
        self,
        request: vpc_20160428_models.UpdateIpv4GatewayAttributeRequest,
    ) -> vpc_20160428_models.UpdateIpv4GatewayAttributeResponse:
        """
        @summary Modifies the description or name of an IPv4 gateway.
        
        @description You cannot repeatedly call the *UpdateIpv4GatewayAttribute** operation to modify the name or description of an IPv4 gateway within the specified period of time.
        
        @param request: UpdateIpv4GatewayAttributeRequest
        @return: UpdateIpv4GatewayAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_ipv_4gateway_attribute_with_options_async(request, runtime)

    def update_nat_gateway_nat_type_with_options(
        self,
        request: vpc_20160428_models.UpdateNatGatewayNatTypeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateNatGatewayNatTypeResponse:
        """
        @summary Upgrades a standard NAT gateway to an enhanced NAT gateway.
        
        @description Before you call this operation, take note of the following limits:
        **UpdateNatGatewayNatType** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the NAT gateway is still being upgraded in the backend. You can call the GetNatGatewayConvertStatus operation to query the upgrade progress of a NAT gateway. For more information, see [GetNatGatewayConvertStatus](https://help.aliyun.com/document_detail/184744.html).
        If the NAT gateway is in the **processing** state, the NAT gateway is being upgraded. You can only query the status of the NAT gateway but cannot perform other operations.
        If the NAT gateway is in the **successful** state, the NAT gateway is upgraded.
        If the NAT gateway is in the **failed** state, the system failed to upgrade the NAT gateway.
        You cannot repeatedly call the **UpdateNatGatewayNatType** operation for the same VPN gateway within the specified period of time.
        The billing method and billable items remain the same after the upgrade.
        It takes about five minutes to upgrade a standard NAT gateway to an enhanced NAT gateway. During the upgrade, transient connection errors may occur once or twice. The service can be recovered by reconnection. You can determine whether to enable automatic reconnection or use manual reconnection based on your business requirements.
        You can only upgrade standard NAT gateways to enhanced NAT gateways. You are not allowed to downgrade enhanced NAT gateways to standard NAT gateways.
        
        @param request: UpdateNatGatewayNatTypeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateNatGatewayNatTypeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.nat_type):
            query['NatType'] = request.nat_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateNatGatewayNatType',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateNatGatewayNatTypeResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_nat_gateway_nat_type_with_options_async(
        self,
        request: vpc_20160428_models.UpdateNatGatewayNatTypeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateNatGatewayNatTypeResponse:
        """
        @summary Upgrades a standard NAT gateway to an enhanced NAT gateway.
        
        @description Before you call this operation, take note of the following limits:
        **UpdateNatGatewayNatType** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the NAT gateway is still being upgraded in the backend. You can call the GetNatGatewayConvertStatus operation to query the upgrade progress of a NAT gateway. For more information, see [GetNatGatewayConvertStatus](https://help.aliyun.com/document_detail/184744.html).
        If the NAT gateway is in the **processing** state, the NAT gateway is being upgraded. You can only query the status of the NAT gateway but cannot perform other operations.
        If the NAT gateway is in the **successful** state, the NAT gateway is upgraded.
        If the NAT gateway is in the **failed** state, the system failed to upgrade the NAT gateway.
        You cannot repeatedly call the **UpdateNatGatewayNatType** operation for the same VPN gateway within the specified period of time.
        The billing method and billable items remain the same after the upgrade.
        It takes about five minutes to upgrade a standard NAT gateway to an enhanced NAT gateway. During the upgrade, transient connection errors may occur once or twice. The service can be recovered by reconnection. You can determine whether to enable automatic reconnection or use manual reconnection based on your business requirements.
        You can only upgrade standard NAT gateways to enhanced NAT gateways. You are not allowed to downgrade enhanced NAT gateways to standard NAT gateways.
        
        @param request: UpdateNatGatewayNatTypeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateNatGatewayNatTypeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.nat_type):
            query['NatType'] = request.nat_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateNatGatewayNatType',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateNatGatewayNatTypeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_nat_gateway_nat_type(
        self,
        request: vpc_20160428_models.UpdateNatGatewayNatTypeRequest,
    ) -> vpc_20160428_models.UpdateNatGatewayNatTypeResponse:
        """
        @summary Upgrades a standard NAT gateway to an enhanced NAT gateway.
        
        @description Before you call this operation, take note of the following limits:
        **UpdateNatGatewayNatType** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the NAT gateway is still being upgraded in the backend. You can call the GetNatGatewayConvertStatus operation to query the upgrade progress of a NAT gateway. For more information, see [GetNatGatewayConvertStatus](https://help.aliyun.com/document_detail/184744.html).
        If the NAT gateway is in the **processing** state, the NAT gateway is being upgraded. You can only query the status of the NAT gateway but cannot perform other operations.
        If the NAT gateway is in the **successful** state, the NAT gateway is upgraded.
        If the NAT gateway is in the **failed** state, the system failed to upgrade the NAT gateway.
        You cannot repeatedly call the **UpdateNatGatewayNatType** operation for the same VPN gateway within the specified period of time.
        The billing method and billable items remain the same after the upgrade.
        It takes about five minutes to upgrade a standard NAT gateway to an enhanced NAT gateway. During the upgrade, transient connection errors may occur once or twice. The service can be recovered by reconnection. You can determine whether to enable automatic reconnection or use manual reconnection based on your business requirements.
        You can only upgrade standard NAT gateways to enhanced NAT gateways. You are not allowed to downgrade enhanced NAT gateways to standard NAT gateways.
        
        @param request: UpdateNatGatewayNatTypeRequest
        @return: UpdateNatGatewayNatTypeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_nat_gateway_nat_type_with_options(request, runtime)

    async def update_nat_gateway_nat_type_async(
        self,
        request: vpc_20160428_models.UpdateNatGatewayNatTypeRequest,
    ) -> vpc_20160428_models.UpdateNatGatewayNatTypeResponse:
        """
        @summary Upgrades a standard NAT gateway to an enhanced NAT gateway.
        
        @description Before you call this operation, take note of the following limits:
        **UpdateNatGatewayNatType** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the NAT gateway is still being upgraded in the backend. You can call the GetNatGatewayConvertStatus operation to query the upgrade progress of a NAT gateway. For more information, see [GetNatGatewayConvertStatus](https://help.aliyun.com/document_detail/184744.html).
        If the NAT gateway is in the **processing** state, the NAT gateway is being upgraded. You can only query the status of the NAT gateway but cannot perform other operations.
        If the NAT gateway is in the **successful** state, the NAT gateway is upgraded.
        If the NAT gateway is in the **failed** state, the system failed to upgrade the NAT gateway.
        You cannot repeatedly call the **UpdateNatGatewayNatType** operation for the same VPN gateway within the specified period of time.
        The billing method and billable items remain the same after the upgrade.
        It takes about five minutes to upgrade a standard NAT gateway to an enhanced NAT gateway. During the upgrade, transient connection errors may occur once or twice. The service can be recovered by reconnection. You can determine whether to enable automatic reconnection or use manual reconnection based on your business requirements.
        You can only upgrade standard NAT gateways to enhanced NAT gateways. You are not allowed to downgrade enhanced NAT gateways to standard NAT gateways.
        
        @param request: UpdateNatGatewayNatTypeRequest
        @return: UpdateNatGatewayNatTypeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_nat_gateway_nat_type_with_options_async(request, runtime)

    def update_network_acl_entries_with_options(
        self,
        request: vpc_20160428_models.UpdateNetworkAclEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateNetworkAclEntriesResponse:
        """
        @summary Updates the rules of a network access control list (ACL).
        
        @description    **UpdateNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of a network ACL:
        If the network ACL is in the **Modifying** state, the rules of the network ACL are being updated.
        If the network ACL is in the **Available** state, the rules of the network ACL are updated.
        You cannot repeatedly call the **UpdateNetworkAclEntries** operation to update the rules of a network ACL within the specified period of time.
        
        @param request: UpdateNetworkAclEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateNetworkAclEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.egress_acl_entries):
            query['EgressAclEntries'] = request.egress_acl_entries
        if not UtilClient.is_unset(request.ingress_acl_entries):
            query['IngressAclEntries'] = request.ingress_acl_entries
        if not UtilClient.is_unset(request.network_acl_id):
            query['NetworkAclId'] = request.network_acl_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.update_egress_acl_entries):
            query['UpdateEgressAclEntries'] = request.update_egress_acl_entries
        if not UtilClient.is_unset(request.update_ingress_acl_entries):
            query['UpdateIngressAclEntries'] = request.update_ingress_acl_entries
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateNetworkAclEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateNetworkAclEntriesResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_network_acl_entries_with_options_async(
        self,
        request: vpc_20160428_models.UpdateNetworkAclEntriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateNetworkAclEntriesResponse:
        """
        @summary Updates the rules of a network access control list (ACL).
        
        @description    **UpdateNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of a network ACL:
        If the network ACL is in the **Modifying** state, the rules of the network ACL are being updated.
        If the network ACL is in the **Available** state, the rules of the network ACL are updated.
        You cannot repeatedly call the **UpdateNetworkAclEntries** operation to update the rules of a network ACL within the specified period of time.
        
        @param request: UpdateNetworkAclEntriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateNetworkAclEntriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.egress_acl_entries):
            query['EgressAclEntries'] = request.egress_acl_entries
        if not UtilClient.is_unset(request.ingress_acl_entries):
            query['IngressAclEntries'] = request.ingress_acl_entries
        if not UtilClient.is_unset(request.network_acl_id):
            query['NetworkAclId'] = request.network_acl_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.update_egress_acl_entries):
            query['UpdateEgressAclEntries'] = request.update_egress_acl_entries
        if not UtilClient.is_unset(request.update_ingress_acl_entries):
            query['UpdateIngressAclEntries'] = request.update_ingress_acl_entries
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateNetworkAclEntries',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateNetworkAclEntriesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_network_acl_entries(
        self,
        request: vpc_20160428_models.UpdateNetworkAclEntriesRequest,
    ) -> vpc_20160428_models.UpdateNetworkAclEntriesResponse:
        """
        @summary Updates the rules of a network access control list (ACL).
        
        @description    **UpdateNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of a network ACL:
        If the network ACL is in the **Modifying** state, the rules of the network ACL are being updated.
        If the network ACL is in the **Available** state, the rules of the network ACL are updated.
        You cannot repeatedly call the **UpdateNetworkAclEntries** operation to update the rules of a network ACL within the specified period of time.
        
        @param request: UpdateNetworkAclEntriesRequest
        @return: UpdateNetworkAclEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_network_acl_entries_with_options(request, runtime)

    async def update_network_acl_entries_async(
        self,
        request: vpc_20160428_models.UpdateNetworkAclEntriesRequest,
    ) -> vpc_20160428_models.UpdateNetworkAclEntriesResponse:
        """
        @summary Updates the rules of a network access control list (ACL).
        
        @description    **UpdateNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of a network ACL:
        If the network ACL is in the **Modifying** state, the rules of the network ACL are being updated.
        If the network ACL is in the **Available** state, the rules of the network ACL are updated.
        You cannot repeatedly call the **UpdateNetworkAclEntries** operation to update the rules of a network ACL within the specified period of time.
        
        @param request: UpdateNetworkAclEntriesRequest
        @return: UpdateNetworkAclEntriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_network_acl_entries_with_options_async(request, runtime)

    def update_public_ip_address_pool_attribute_with_options(
        self,
        request: vpc_20160428_models.UpdatePublicIpAddressPoolAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdatePublicIpAddressPoolAttributeResponse:
        """
        @summary Modifies the attributes of an IP address pool.
        
        @description You cannot repeatedly call the *UpdatePublicIpAddressPoolAttribute** operation to modify the attributes of an IP address pool within the specified period of time.
        
        @param request: UpdatePublicIpAddressPoolAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdatePublicIpAddressPoolAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.public_ip_address_pool_id):
            query['PublicIpAddressPoolId'] = request.public_ip_address_pool_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdatePublicIpAddressPoolAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdatePublicIpAddressPoolAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_public_ip_address_pool_attribute_with_options_async(
        self,
        request: vpc_20160428_models.UpdatePublicIpAddressPoolAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdatePublicIpAddressPoolAttributeResponse:
        """
        @summary Modifies the attributes of an IP address pool.
        
        @description You cannot repeatedly call the *UpdatePublicIpAddressPoolAttribute** operation to modify the attributes of an IP address pool within the specified period of time.
        
        @param request: UpdatePublicIpAddressPoolAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdatePublicIpAddressPoolAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.public_ip_address_pool_id):
            query['PublicIpAddressPoolId'] = request.public_ip_address_pool_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdatePublicIpAddressPoolAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdatePublicIpAddressPoolAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_public_ip_address_pool_attribute(
        self,
        request: vpc_20160428_models.UpdatePublicIpAddressPoolAttributeRequest,
    ) -> vpc_20160428_models.UpdatePublicIpAddressPoolAttributeResponse:
        """
        @summary Modifies the attributes of an IP address pool.
        
        @description You cannot repeatedly call the *UpdatePublicIpAddressPoolAttribute** operation to modify the attributes of an IP address pool within the specified period of time.
        
        @param request: UpdatePublicIpAddressPoolAttributeRequest
        @return: UpdatePublicIpAddressPoolAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_public_ip_address_pool_attribute_with_options(request, runtime)

    async def update_public_ip_address_pool_attribute_async(
        self,
        request: vpc_20160428_models.UpdatePublicIpAddressPoolAttributeRequest,
    ) -> vpc_20160428_models.UpdatePublicIpAddressPoolAttributeResponse:
        """
        @summary Modifies the attributes of an IP address pool.
        
        @description You cannot repeatedly call the *UpdatePublicIpAddressPoolAttribute** operation to modify the attributes of an IP address pool within the specified period of time.
        
        @param request: UpdatePublicIpAddressPoolAttributeRequest
        @return: UpdatePublicIpAddressPoolAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_public_ip_address_pool_attribute_with_options_async(request, runtime)

    def update_traffic_mirror_filter_attribute_with_options(
        self,
        request: vpc_20160428_models.UpdateTrafficMirrorFilterAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateTrafficMirrorFilterAttributeResponse:
        """
        @summary Modifies the configuration of a filter for traffic mirroring.
        
        @description You cannot repeatedly call the *UpdateTrafficMirrorFilterAttribute** operation to modify the configuration of a filter for traffic mirroring within the specified period of time.
        
        @param request: UpdateTrafficMirrorFilterAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTrafficMirrorFilterAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.traffic_mirror_filter_description):
            query['TrafficMirrorFilterDescription'] = request.traffic_mirror_filter_description
        if not UtilClient.is_unset(request.traffic_mirror_filter_id):
            query['TrafficMirrorFilterId'] = request.traffic_mirror_filter_id
        if not UtilClient.is_unset(request.traffic_mirror_filter_name):
            query['TrafficMirrorFilterName'] = request.traffic_mirror_filter_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTrafficMirrorFilterAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateTrafficMirrorFilterAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_traffic_mirror_filter_attribute_with_options_async(
        self,
        request: vpc_20160428_models.UpdateTrafficMirrorFilterAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateTrafficMirrorFilterAttributeResponse:
        """
        @summary Modifies the configuration of a filter for traffic mirroring.
        
        @description You cannot repeatedly call the *UpdateTrafficMirrorFilterAttribute** operation to modify the configuration of a filter for traffic mirroring within the specified period of time.
        
        @param request: UpdateTrafficMirrorFilterAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTrafficMirrorFilterAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.traffic_mirror_filter_description):
            query['TrafficMirrorFilterDescription'] = request.traffic_mirror_filter_description
        if not UtilClient.is_unset(request.traffic_mirror_filter_id):
            query['TrafficMirrorFilterId'] = request.traffic_mirror_filter_id
        if not UtilClient.is_unset(request.traffic_mirror_filter_name):
            query['TrafficMirrorFilterName'] = request.traffic_mirror_filter_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTrafficMirrorFilterAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateTrafficMirrorFilterAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_traffic_mirror_filter_attribute(
        self,
        request: vpc_20160428_models.UpdateTrafficMirrorFilterAttributeRequest,
    ) -> vpc_20160428_models.UpdateTrafficMirrorFilterAttributeResponse:
        """
        @summary Modifies the configuration of a filter for traffic mirroring.
        
        @description You cannot repeatedly call the *UpdateTrafficMirrorFilterAttribute** operation to modify the configuration of a filter for traffic mirroring within the specified period of time.
        
        @param request: UpdateTrafficMirrorFilterAttributeRequest
        @return: UpdateTrafficMirrorFilterAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_traffic_mirror_filter_attribute_with_options(request, runtime)

    async def update_traffic_mirror_filter_attribute_async(
        self,
        request: vpc_20160428_models.UpdateTrafficMirrorFilterAttributeRequest,
    ) -> vpc_20160428_models.UpdateTrafficMirrorFilterAttributeResponse:
        """
        @summary Modifies the configuration of a filter for traffic mirroring.
        
        @description You cannot repeatedly call the *UpdateTrafficMirrorFilterAttribute** operation to modify the configuration of a filter for traffic mirroring within the specified period of time.
        
        @param request: UpdateTrafficMirrorFilterAttributeRequest
        @return: UpdateTrafficMirrorFilterAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_traffic_mirror_filter_attribute_with_options_async(request, runtime)

    def update_traffic_mirror_filter_rule_attribute_with_options(
        self,
        request: vpc_20160428_models.UpdateTrafficMirrorFilterRuleAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateTrafficMirrorFilterRuleAttributeResponse:
        """
        @summary Modifies the configuration of an inbound or outbound rule for traffic mirroring.
        
        @description    The **UpdateTrafficMirrorFilterRuleAttribute** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of an inbound or outbound rule:
        If the rule is in the **Modifying** state, the rule is being modified.
        If the rule is in the **Created** state, the rule is modified.
        You cannot repeatedly call the **UpdateTrafficMirrorFilterRuleAttribute** operation to modify an inbound or outbound rule within the specified period of time.
        
        @param request: UpdateTrafficMirrorFilterRuleAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTrafficMirrorFilterRuleAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.destination_cidr_block):
            query['DestinationCidrBlock'] = request.destination_cidr_block
        if not UtilClient.is_unset(request.destination_port_range):
            query['DestinationPortRange'] = request.destination_port_range
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.protocol):
            query['Protocol'] = request.protocol
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.rule_action):
            query['RuleAction'] = request.rule_action
        if not UtilClient.is_unset(request.source_cidr_block):
            query['SourceCidrBlock'] = request.source_cidr_block
        if not UtilClient.is_unset(request.source_port_range):
            query['SourcePortRange'] = request.source_port_range
        if not UtilClient.is_unset(request.traffic_mirror_filter_rule_id):
            query['TrafficMirrorFilterRuleId'] = request.traffic_mirror_filter_rule_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTrafficMirrorFilterRuleAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateTrafficMirrorFilterRuleAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_traffic_mirror_filter_rule_attribute_with_options_async(
        self,
        request: vpc_20160428_models.UpdateTrafficMirrorFilterRuleAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateTrafficMirrorFilterRuleAttributeResponse:
        """
        @summary Modifies the configuration of an inbound or outbound rule for traffic mirroring.
        
        @description    The **UpdateTrafficMirrorFilterRuleAttribute** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of an inbound or outbound rule:
        If the rule is in the **Modifying** state, the rule is being modified.
        If the rule is in the **Created** state, the rule is modified.
        You cannot repeatedly call the **UpdateTrafficMirrorFilterRuleAttribute** operation to modify an inbound or outbound rule within the specified period of time.
        
        @param request: UpdateTrafficMirrorFilterRuleAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTrafficMirrorFilterRuleAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.destination_cidr_block):
            query['DestinationCidrBlock'] = request.destination_cidr_block
        if not UtilClient.is_unset(request.destination_port_range):
            query['DestinationPortRange'] = request.destination_port_range
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.protocol):
            query['Protocol'] = request.protocol
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.rule_action):
            query['RuleAction'] = request.rule_action
        if not UtilClient.is_unset(request.source_cidr_block):
            query['SourceCidrBlock'] = request.source_cidr_block
        if not UtilClient.is_unset(request.source_port_range):
            query['SourcePortRange'] = request.source_port_range
        if not UtilClient.is_unset(request.traffic_mirror_filter_rule_id):
            query['TrafficMirrorFilterRuleId'] = request.traffic_mirror_filter_rule_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTrafficMirrorFilterRuleAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateTrafficMirrorFilterRuleAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_traffic_mirror_filter_rule_attribute(
        self,
        request: vpc_20160428_models.UpdateTrafficMirrorFilterRuleAttributeRequest,
    ) -> vpc_20160428_models.UpdateTrafficMirrorFilterRuleAttributeResponse:
        """
        @summary Modifies the configuration of an inbound or outbound rule for traffic mirroring.
        
        @description    The **UpdateTrafficMirrorFilterRuleAttribute** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of an inbound or outbound rule:
        If the rule is in the **Modifying** state, the rule is being modified.
        If the rule is in the **Created** state, the rule is modified.
        You cannot repeatedly call the **UpdateTrafficMirrorFilterRuleAttribute** operation to modify an inbound or outbound rule within the specified period of time.
        
        @param request: UpdateTrafficMirrorFilterRuleAttributeRequest
        @return: UpdateTrafficMirrorFilterRuleAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_traffic_mirror_filter_rule_attribute_with_options(request, runtime)

    async def update_traffic_mirror_filter_rule_attribute_async(
        self,
        request: vpc_20160428_models.UpdateTrafficMirrorFilterRuleAttributeRequest,
    ) -> vpc_20160428_models.UpdateTrafficMirrorFilterRuleAttributeResponse:
        """
        @summary Modifies the configuration of an inbound or outbound rule for traffic mirroring.
        
        @description    The **UpdateTrafficMirrorFilterRuleAttribute** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of an inbound or outbound rule:
        If the rule is in the **Modifying** state, the rule is being modified.
        If the rule is in the **Created** state, the rule is modified.
        You cannot repeatedly call the **UpdateTrafficMirrorFilterRuleAttribute** operation to modify an inbound or outbound rule within the specified period of time.
        
        @param request: UpdateTrafficMirrorFilterRuleAttributeRequest
        @return: UpdateTrafficMirrorFilterRuleAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_traffic_mirror_filter_rule_attribute_with_options_async(request, runtime)

    def update_traffic_mirror_session_attribute_with_options(
        self,
        request: vpc_20160428_models.UpdateTrafficMirrorSessionAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateTrafficMirrorSessionAttributeResponse:
        """
        @summary Modifies the configuration of a traffic mirror session.
        
        @description ## Usage notes
        **UpdateTrafficMirrorSessionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
        If the traffic mirror session is in the **Modifying** state, the configuration of the traffic mirror session is being modified.
        If the traffic mirror session is in the **Created** state, the configuration of the traffic mirror session is modified.
        You cannot repeatedly call the **UpdateTrafficMirrorSessionAttribute** operation within a specific period of time.
        
        @param request: UpdateTrafficMirrorSessionAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTrafficMirrorSessionAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.enabled):
            query['Enabled'] = request.enabled
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.packet_length):
            query['PacketLength'] = request.packet_length
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.traffic_mirror_filter_id):
            query['TrafficMirrorFilterId'] = request.traffic_mirror_filter_id
        if not UtilClient.is_unset(request.traffic_mirror_session_description):
            query['TrafficMirrorSessionDescription'] = request.traffic_mirror_session_description
        if not UtilClient.is_unset(request.traffic_mirror_session_id):
            query['TrafficMirrorSessionId'] = request.traffic_mirror_session_id
        if not UtilClient.is_unset(request.traffic_mirror_session_name):
            query['TrafficMirrorSessionName'] = request.traffic_mirror_session_name
        if not UtilClient.is_unset(request.traffic_mirror_target_id):
            query['TrafficMirrorTargetId'] = request.traffic_mirror_target_id
        if not UtilClient.is_unset(request.traffic_mirror_target_type):
            query['TrafficMirrorTargetType'] = request.traffic_mirror_target_type
        if not UtilClient.is_unset(request.virtual_network_id):
            query['VirtualNetworkId'] = request.virtual_network_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTrafficMirrorSessionAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateTrafficMirrorSessionAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_traffic_mirror_session_attribute_with_options_async(
        self,
        request: vpc_20160428_models.UpdateTrafficMirrorSessionAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateTrafficMirrorSessionAttributeResponse:
        """
        @summary Modifies the configuration of a traffic mirror session.
        
        @description ## Usage notes
        **UpdateTrafficMirrorSessionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
        If the traffic mirror session is in the **Modifying** state, the configuration of the traffic mirror session is being modified.
        If the traffic mirror session is in the **Created** state, the configuration of the traffic mirror session is modified.
        You cannot repeatedly call the **UpdateTrafficMirrorSessionAttribute** operation within a specific period of time.
        
        @param request: UpdateTrafficMirrorSessionAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTrafficMirrorSessionAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.enabled):
            query['Enabled'] = request.enabled
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.packet_length):
            query['PacketLength'] = request.packet_length
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.traffic_mirror_filter_id):
            query['TrafficMirrorFilterId'] = request.traffic_mirror_filter_id
        if not UtilClient.is_unset(request.traffic_mirror_session_description):
            query['TrafficMirrorSessionDescription'] = request.traffic_mirror_session_description
        if not UtilClient.is_unset(request.traffic_mirror_session_id):
            query['TrafficMirrorSessionId'] = request.traffic_mirror_session_id
        if not UtilClient.is_unset(request.traffic_mirror_session_name):
            query['TrafficMirrorSessionName'] = request.traffic_mirror_session_name
        if not UtilClient.is_unset(request.traffic_mirror_target_id):
            query['TrafficMirrorTargetId'] = request.traffic_mirror_target_id
        if not UtilClient.is_unset(request.traffic_mirror_target_type):
            query['TrafficMirrorTargetType'] = request.traffic_mirror_target_type
        if not UtilClient.is_unset(request.virtual_network_id):
            query['VirtualNetworkId'] = request.virtual_network_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTrafficMirrorSessionAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateTrafficMirrorSessionAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_traffic_mirror_session_attribute(
        self,
        request: vpc_20160428_models.UpdateTrafficMirrorSessionAttributeRequest,
    ) -> vpc_20160428_models.UpdateTrafficMirrorSessionAttributeResponse:
        """
        @summary Modifies the configuration of a traffic mirror session.
        
        @description ## Usage notes
        **UpdateTrafficMirrorSessionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
        If the traffic mirror session is in the **Modifying** state, the configuration of the traffic mirror session is being modified.
        If the traffic mirror session is in the **Created** state, the configuration of the traffic mirror session is modified.
        You cannot repeatedly call the **UpdateTrafficMirrorSessionAttribute** operation within a specific period of time.
        
        @param request: UpdateTrafficMirrorSessionAttributeRequest
        @return: UpdateTrafficMirrorSessionAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_traffic_mirror_session_attribute_with_options(request, runtime)

    async def update_traffic_mirror_session_attribute_async(
        self,
        request: vpc_20160428_models.UpdateTrafficMirrorSessionAttributeRequest,
    ) -> vpc_20160428_models.UpdateTrafficMirrorSessionAttributeResponse:
        """
        @summary Modifies the configuration of a traffic mirror session.
        
        @description ## Usage notes
        **UpdateTrafficMirrorSessionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
        If the traffic mirror session is in the **Modifying** state, the configuration of the traffic mirror session is being modified.
        If the traffic mirror session is in the **Created** state, the configuration of the traffic mirror session is modified.
        You cannot repeatedly call the **UpdateTrafficMirrorSessionAttribute** operation within a specific period of time.
        
        @param request: UpdateTrafficMirrorSessionAttributeRequest
        @return: UpdateTrafficMirrorSessionAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_traffic_mirror_session_attribute_with_options_async(request, runtime)

    def update_virtual_border_bandwidth_with_options(
        self,
        request: vpc_20160428_models.UpdateVirtualBorderBandwidthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateVirtualBorderBandwidthResponse:
        """
        @summary Updates the maximum bandwidth value of outbound data transfer for a virtual border router (VBR).
        
        @param request: UpdateVirtualBorderBandwidthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateVirtualBorderBandwidthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.virtual_border_router_id):
            query['VirtualBorderRouterId'] = request.virtual_border_router_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateVirtualBorderBandwidth',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateVirtualBorderBandwidthResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_virtual_border_bandwidth_with_options_async(
        self,
        request: vpc_20160428_models.UpdateVirtualBorderBandwidthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateVirtualBorderBandwidthResponse:
        """
        @summary Updates the maximum bandwidth value of outbound data transfer for a virtual border router (VBR).
        
        @param request: UpdateVirtualBorderBandwidthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateVirtualBorderBandwidthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bandwidth):
            query['Bandwidth'] = request.bandwidth
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.virtual_border_router_id):
            query['VirtualBorderRouterId'] = request.virtual_border_router_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateVirtualBorderBandwidth',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateVirtualBorderBandwidthResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_virtual_border_bandwidth(
        self,
        request: vpc_20160428_models.UpdateVirtualBorderBandwidthRequest,
    ) -> vpc_20160428_models.UpdateVirtualBorderBandwidthResponse:
        """
        @summary Updates the maximum bandwidth value of outbound data transfer for a virtual border router (VBR).
        
        @param request: UpdateVirtualBorderBandwidthRequest
        @return: UpdateVirtualBorderBandwidthResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_virtual_border_bandwidth_with_options(request, runtime)

    async def update_virtual_border_bandwidth_async(
        self,
        request: vpc_20160428_models.UpdateVirtualBorderBandwidthRequest,
    ) -> vpc_20160428_models.UpdateVirtualBorderBandwidthResponse:
        """
        @summary Updates the maximum bandwidth value of outbound data transfer for a virtual border router (VBR).
        
        @param request: UpdateVirtualBorderBandwidthRequest
        @return: UpdateVirtualBorderBandwidthResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_virtual_border_bandwidth_with_options_async(request, runtime)

    def update_virtual_physical_connection_with_options(
        self,
        request: vpc_20160428_models.UpdateVirtualPhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateVirtualPhysicalConnectionResponse:
        """
        @summary Changes the virtual local area network (VLAN) ID of a hosted connection over Express Connect circuit.
        
        @param request: UpdateVirtualPhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateVirtualPhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.expect_spec):
            query['ExpectSpec'] = request.expect_spec
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.token):
            query['Token'] = request.token
        if not UtilClient.is_unset(request.vlan_id):
            query['VlanId'] = request.vlan_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateVirtualPhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateVirtualPhysicalConnectionResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_virtual_physical_connection_with_options_async(
        self,
        request: vpc_20160428_models.UpdateVirtualPhysicalConnectionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateVirtualPhysicalConnectionResponse:
        """
        @summary Changes the virtual local area network (VLAN) ID of a hosted connection over Express Connect circuit.
        
        @param request: UpdateVirtualPhysicalConnectionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateVirtualPhysicalConnectionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.expect_spec):
            query['ExpectSpec'] = request.expect_spec
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.token):
            query['Token'] = request.token
        if not UtilClient.is_unset(request.vlan_id):
            query['VlanId'] = request.vlan_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateVirtualPhysicalConnection',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateVirtualPhysicalConnectionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_virtual_physical_connection(
        self,
        request: vpc_20160428_models.UpdateVirtualPhysicalConnectionRequest,
    ) -> vpc_20160428_models.UpdateVirtualPhysicalConnectionResponse:
        """
        @summary Changes the virtual local area network (VLAN) ID of a hosted connection over Express Connect circuit.
        
        @param request: UpdateVirtualPhysicalConnectionRequest
        @return: UpdateVirtualPhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_virtual_physical_connection_with_options(request, runtime)

    async def update_virtual_physical_connection_async(
        self,
        request: vpc_20160428_models.UpdateVirtualPhysicalConnectionRequest,
    ) -> vpc_20160428_models.UpdateVirtualPhysicalConnectionResponse:
        """
        @summary Changes the virtual local area network (VLAN) ID of a hosted connection over Express Connect circuit.
        
        @param request: UpdateVirtualPhysicalConnectionRequest
        @return: UpdateVirtualPhysicalConnectionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_virtual_physical_connection_with_options_async(request, runtime)

    def update_vpc_gateway_endpoint_attribute_with_options(
        self,
        request: vpc_20160428_models.UpdateVpcGatewayEndpointAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateVpcGatewayEndpointAttributeResponse:
        """
        @summary Modifies the configuration of a gateway endpoint.
        
        @description    **UpdateVpcGatewayEndpointAttribute** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query the status of the task.
        If the gateway endpoint is in the **Updating** state, it is being modified.
        If the gateway endpoint is in the **Created** state, it is modified.
        You cannot call the **UpdateVpcGatewayEndpointAttribute** operation within a specific period of time.
        
        @param request: UpdateVpcGatewayEndpointAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateVpcGatewayEndpointAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.endpoint_description):
            query['EndpointDescription'] = request.endpoint_description
        if not UtilClient.is_unset(request.endpoint_id):
            query['EndpointId'] = request.endpoint_id
        if not UtilClient.is_unset(request.endpoint_name):
            query['EndpointName'] = request.endpoint_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.policy_document):
            query['PolicyDocument'] = request.policy_document
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateVpcGatewayEndpointAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateVpcGatewayEndpointAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_vpc_gateway_endpoint_attribute_with_options_async(
        self,
        request: vpc_20160428_models.UpdateVpcGatewayEndpointAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.UpdateVpcGatewayEndpointAttributeResponse:
        """
        @summary Modifies the configuration of a gateway endpoint.
        
        @description    **UpdateVpcGatewayEndpointAttribute** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query the status of the task.
        If the gateway endpoint is in the **Updating** state, it is being modified.
        If the gateway endpoint is in the **Created** state, it is modified.
        You cannot call the **UpdateVpcGatewayEndpointAttribute** operation within a specific period of time.
        
        @param request: UpdateVpcGatewayEndpointAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateVpcGatewayEndpointAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.endpoint_description):
            query['EndpointDescription'] = request.endpoint_description
        if not UtilClient.is_unset(request.endpoint_id):
            query['EndpointId'] = request.endpoint_id
        if not UtilClient.is_unset(request.endpoint_name):
            query['EndpointName'] = request.endpoint_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.policy_document):
            query['PolicyDocument'] = request.policy_document
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateVpcGatewayEndpointAttribute',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.UpdateVpcGatewayEndpointAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_vpc_gateway_endpoint_attribute(
        self,
        request: vpc_20160428_models.UpdateVpcGatewayEndpointAttributeRequest,
    ) -> vpc_20160428_models.UpdateVpcGatewayEndpointAttributeResponse:
        """
        @summary Modifies the configuration of a gateway endpoint.
        
        @description    **UpdateVpcGatewayEndpointAttribute** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query the status of the task.
        If the gateway endpoint is in the **Updating** state, it is being modified.
        If the gateway endpoint is in the **Created** state, it is modified.
        You cannot call the **UpdateVpcGatewayEndpointAttribute** operation within a specific period of time.
        
        @param request: UpdateVpcGatewayEndpointAttributeRequest
        @return: UpdateVpcGatewayEndpointAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_vpc_gateway_endpoint_attribute_with_options(request, runtime)

    async def update_vpc_gateway_endpoint_attribute_async(
        self,
        request: vpc_20160428_models.UpdateVpcGatewayEndpointAttributeRequest,
    ) -> vpc_20160428_models.UpdateVpcGatewayEndpointAttributeResponse:
        """
        @summary Modifies the configuration of a gateway endpoint.
        
        @description    **UpdateVpcGatewayEndpointAttribute** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query the status of the task.
        If the gateway endpoint is in the **Updating** state, it is being modified.
        If the gateway endpoint is in the **Created** state, it is modified.
        You cannot call the **UpdateVpcGatewayEndpointAttribute** operation within a specific period of time.
        
        @param request: UpdateVpcGatewayEndpointAttributeRequest
        @return: UpdateVpcGatewayEndpointAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_vpc_gateway_endpoint_attribute_with_options_async(request, runtime)

    def vpc_describe_vpc_nat_gateway_network_interface_quota_with_options(
        self,
        request: vpc_20160428_models.VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse:
        """
        @summary eni quota
        
        @description Before you call this operation, make sure that a VPC NAT gateway is created. For more information, see [CreateNatGateway](https://help.aliyun.com/document_detail/120219.html).
        
        @param request: VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_uid):
            query['ResourceUid'] = request.resource_uid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='VpcDescribeVpcNatGatewayNetworkInterfaceQuota',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse(),
            self.call_api(params, req, runtime)
        )

    async def vpc_describe_vpc_nat_gateway_network_interface_quota_with_options_async(
        self,
        request: vpc_20160428_models.VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vpc_20160428_models.VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse:
        """
        @summary eni quota
        
        @description Before you call this operation, make sure that a VPC NAT gateway is created. For more information, see [CreateNatGateway](https://help.aliyun.com/document_detail/120219.html).
        
        @param request: VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.nat_gateway_id):
            query['NatGatewayId'] = request.nat_gateway_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_uid):
            query['ResourceUid'] = request.resource_uid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='VpcDescribeVpcNatGatewayNetworkInterfaceQuota',
            version='2016-04-28',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vpc_20160428_models.VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def vpc_describe_vpc_nat_gateway_network_interface_quota(
        self,
        request: vpc_20160428_models.VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest,
    ) -> vpc_20160428_models.VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse:
        """
        @summary eni quota
        
        @description Before you call this operation, make sure that a VPC NAT gateway is created. For more information, see [CreateNatGateway](https://help.aliyun.com/document_detail/120219.html).
        
        @param request: VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest
        @return: VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.vpc_describe_vpc_nat_gateway_network_interface_quota_with_options(request, runtime)

    async def vpc_describe_vpc_nat_gateway_network_interface_quota_async(
        self,
        request: vpc_20160428_models.VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest,
    ) -> vpc_20160428_models.VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse:
        """
        @summary eni quota
        
        @description Before you call this operation, make sure that a VPC NAT gateway is created. For more information, see [CreateNatGateway](https://help.aliyun.com/document_detail/120219.html).
        
        @param request: VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest
        @return: VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.vpc_describe_vpc_nat_gateway_network_interface_quota_with_options_async(request, runtime)
