# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import List, Dict


class BucketInfo(TeaModel):
    def __init__(
        self,
        bucket_acl: str = None,
        bucket_name: str = None,
        comment: str = None,
        create_time: str = None,
        data_redundancy_type: str = None,
        dispatcher_type: str = None,
        endpoint: str = None,
        ens_region_id: str = None,
        modify_time: str = None,
        resource_type: str = None,
        storage_class: str = None,
    ):
        self.bucket_acl = bucket_acl
        # This parameter is required.
        self.bucket_name = bucket_name
        self.comment = comment
        self.create_time = create_time
        self.data_redundancy_type = data_redundancy_type
        self.dispatcher_type = dispatcher_type
        self.endpoint = endpoint
        self.ens_region_id = ens_region_id
        self.modify_time = modify_time
        self.resource_type = resource_type
        self.storage_class = storage_class

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_acl is not None:
            result['BucketAcl'] = self.bucket_acl
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.data_redundancy_type is not None:
            result['DataRedundancyType'] = self.data_redundancy_type
        if self.dispatcher_type is not None:
            result['DispatcherType'] = self.dispatcher_type
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.storage_class is not None:
            result['StorageClass'] = self.storage_class
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketAcl') is not None:
            self.bucket_acl = m.get('BucketAcl')
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DataRedundancyType') is not None:
            self.data_redundancy_type = m.get('DataRedundancyType')
        if m.get('DispatcherType') is not None:
            self.dispatcher_type = m.get('DispatcherType')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('StorageClass') is not None:
            self.storage_class = m.get('StorageClass')
        return self


class DataDisk(TeaModel):
    def __init__(
        self,
        size: int = None,
    ):
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class HealthCheck(TeaModel):
    def __init__(
        self,
        health_check: str = None,
        health_check_connect_port: int = None,
        health_check_connect_timeout: int = None,
        health_check_domain: str = None,
        health_check_http_code: str = None,
        health_check_interval: int = None,
        health_check_method: str = None,
        health_check_timeout: int = None,
        health_check_type: str = None,
        health_check_uri: str = None,
        healthy_threshold: int = None,
        unhealthy_threshold: int = None,
    ):
        self.health_check = health_check
        self.health_check_connect_port = health_check_connect_port
        self.health_check_connect_timeout = health_check_connect_timeout
        self.health_check_domain = health_check_domain
        self.health_check_http_code = health_check_http_code
        self.health_check_interval = health_check_interval
        self.health_check_method = health_check_method
        self.health_check_timeout = health_check_timeout
        self.health_check_type = health_check_type
        self.health_check_uri = health_check_uri
        self.healthy_threshold = healthy_threshold
        self.unhealthy_threshold = unhealthy_threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.health_check is not None:
            result['HealthCheck'] = self.health_check
        if self.health_check_connect_port is not None:
            result['HealthCheckConnectPort'] = self.health_check_connect_port
        if self.health_check_connect_timeout is not None:
            result['HealthCheckConnectTimeout'] = self.health_check_connect_timeout
        if self.health_check_domain is not None:
            result['HealthCheckDomain'] = self.health_check_domain
        if self.health_check_http_code is not None:
            result['HealthCheckHttpCode'] = self.health_check_http_code
        if self.health_check_interval is not None:
            result['HealthCheckInterval'] = self.health_check_interval
        if self.health_check_method is not None:
            result['HealthCheckMethod'] = self.health_check_method
        if self.health_check_timeout is not None:
            result['HealthCheckTimeout'] = self.health_check_timeout
        if self.health_check_type is not None:
            result['HealthCheckType'] = self.health_check_type
        if self.health_check_uri is not None:
            result['HealthCheckURI'] = self.health_check_uri
        if self.healthy_threshold is not None:
            result['HealthyThreshold'] = self.healthy_threshold
        if self.unhealthy_threshold is not None:
            result['UnhealthyThreshold'] = self.unhealthy_threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HealthCheck') is not None:
            self.health_check = m.get('HealthCheck')
        if m.get('HealthCheckConnectPort') is not None:
            self.health_check_connect_port = m.get('HealthCheckConnectPort')
        if m.get('HealthCheckConnectTimeout') is not None:
            self.health_check_connect_timeout = m.get('HealthCheckConnectTimeout')
        if m.get('HealthCheckDomain') is not None:
            self.health_check_domain = m.get('HealthCheckDomain')
        if m.get('HealthCheckHttpCode') is not None:
            self.health_check_http_code = m.get('HealthCheckHttpCode')
        if m.get('HealthCheckInterval') is not None:
            self.health_check_interval = m.get('HealthCheckInterval')
        if m.get('HealthCheckMethod') is not None:
            self.health_check_method = m.get('HealthCheckMethod')
        if m.get('HealthCheckTimeout') is not None:
            self.health_check_timeout = m.get('HealthCheckTimeout')
        if m.get('HealthCheckType') is not None:
            self.health_check_type = m.get('HealthCheckType')
        if m.get('HealthCheckURI') is not None:
            self.health_check_uri = m.get('HealthCheckURI')
        if m.get('HealthyThreshold') is not None:
            self.healthy_threshold = m.get('HealthyThreshold')
        if m.get('UnhealthyThreshold') is not None:
            self.unhealthy_threshold = m.get('UnhealthyThreshold')
        return self


class HttpConfig(TeaModel):
    def __init__(
        self,
        cookie: str = None,
        cookie_timeout: int = None,
        idle_timeout: int = None,
        request_timeout: int = None,
        scheduler: str = None,
        server_certificate_id: str = None,
        sticky_session: str = None,
        sticky_session_type: str = None,
        xforwarded_for: str = None,
    ):
        self.cookie = cookie
        self.cookie_timeout = cookie_timeout
        self.idle_timeout = idle_timeout
        self.request_timeout = request_timeout
        self.scheduler = scheduler
        self.server_certificate_id = server_certificate_id
        self.sticky_session = sticky_session
        self.sticky_session_type = sticky_session_type
        self.xforwarded_for = xforwarded_for

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cookie is not None:
            result['Cookie'] = self.cookie
        if self.cookie_timeout is not None:
            result['CookieTimeout'] = self.cookie_timeout
        if self.idle_timeout is not None:
            result['IdleTimeout'] = self.idle_timeout
        if self.request_timeout is not None:
            result['RequestTimeout'] = self.request_timeout
        if self.scheduler is not None:
            result['Scheduler'] = self.scheduler
        if self.server_certificate_id is not None:
            result['ServerCertificateId'] = self.server_certificate_id
        if self.sticky_session is not None:
            result['StickySession'] = self.sticky_session
        if self.sticky_session_type is not None:
            result['StickySessionType'] = self.sticky_session_type
        if self.xforwarded_for is not None:
            result['XForwardedFor'] = self.xforwarded_for
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cookie') is not None:
            self.cookie = m.get('Cookie')
        if m.get('CookieTimeout') is not None:
            self.cookie_timeout = m.get('CookieTimeout')
        if m.get('IdleTimeout') is not None:
            self.idle_timeout = m.get('IdleTimeout')
        if m.get('RequestTimeout') is not None:
            self.request_timeout = m.get('RequestTimeout')
        if m.get('Scheduler') is not None:
            self.scheduler = m.get('Scheduler')
        if m.get('ServerCertificateId') is not None:
            self.server_certificate_id = m.get('ServerCertificateId')
        if m.get('StickySession') is not None:
            self.sticky_session = m.get('StickySession')
        if m.get('StickySessionType') is not None:
            self.sticky_session_type = m.get('StickySessionType')
        if m.get('XForwardedFor') is not None:
            self.xforwarded_for = m.get('XForwardedFor')
        return self


class InstanceActiveOpsGroup(TeaModel):
    def __init__(
        self,
        instance_ids: List[str] = None,
    ):
        self.instance_ids = instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        return self


class InstanceActiveOpsTask(TeaModel):
    def __init__(
        self,
        instance_active_ops_task_id: str = None,
        instance_active_ops_task_status: str = None,
    ):
        self.instance_active_ops_task_id = instance_active_ops_task_id
        self.instance_active_ops_task_status = instance_active_ops_task_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_active_ops_task_id is not None:
            result['InstanceActiveOpsTaskId'] = self.instance_active_ops_task_id
        if self.instance_active_ops_task_status is not None:
            result['InstanceActiveOpsTaskStatus'] = self.instance_active_ops_task_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceActiveOpsTaskId') is not None:
            self.instance_active_ops_task_id = m.get('InstanceActiveOpsTaskId')
        if m.get('InstanceActiveOpsTaskStatus') is not None:
            self.instance_active_ops_task_status = m.get('InstanceActiveOpsTaskStatus')
        return self


class InstanceOperateResponse(TeaModel):
    def __init__(
        self,
        code: int = None,
        instance_id: str = None,
        message: str = None,
    ):
        self.code = code
        self.instance_id = instance_id
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class SecurityGroupRule(TeaModel):
    def __init__(
        self,
        description: str = None,
        dest_cidr_ip: str = None,
        direction: str = None,
        ip_protocol: str = None,
        policy: str = None,
        port_range: str = None,
        source_cidr_ip: str = None,
        source_port_range: str = None,
        priority: int = None,
    ):
        self.description = description
        self.dest_cidr_ip = dest_cidr_ip
        self.direction = direction
        self.ip_protocol = ip_protocol
        self.policy = policy
        self.port_range = port_range
        self.source_cidr_ip = source_cidr_ip
        self.source_port_range = source_port_range
        self.priority = priority

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.dest_cidr_ip is not None:
            result['DestCidrIp'] = self.dest_cidr_ip
        if self.direction is not None:
            result['Direction'] = self.direction
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.source_cidr_ip is not None:
            result['SourceCidrIp'] = self.source_cidr_ip
        if self.source_port_range is not None:
            result['SourcePortRange'] = self.source_port_range
        if self.priority is not None:
            result['priority'] = self.priority
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestCidrIp') is not None:
            self.dest_cidr_ip = m.get('DestCidrIp')
        if m.get('Direction') is not None:
            self.direction = m.get('Direction')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('SourceCidrIp') is not None:
            self.source_cidr_ip = m.get('SourceCidrIp')
        if m.get('SourcePortRange') is not None:
            self.source_port_range = m.get('SourcePortRange')
        if m.get('priority') is not None:
            self.priority = m.get('priority')
        return self


class TagsInParamsTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # This parameter is required.
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class TagsInParams(TeaModel):
    def __init__(
        self,
        tag: List[TagsInParamsTag] = None,
    ):
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = TagsInParamsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class TcpConfig(TeaModel):
    def __init__(
        self,
        established_timeout: int = None,
        persistence_timeout: int = None,
        scheduler: str = None,
    ):
        self.established_timeout = established_timeout
        self.persistence_timeout = persistence_timeout
        self.scheduler = scheduler

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.established_timeout is not None:
            result['EstablishedTimeout'] = self.established_timeout
        if self.persistence_timeout is not None:
            result['PersistenceTimeout'] = self.persistence_timeout
        if self.scheduler is not None:
            result['Scheduler'] = self.scheduler
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EstablishedTimeout') is not None:
            self.established_timeout = m.get('EstablishedTimeout')
        if m.get('PersistenceTimeout') is not None:
            self.persistence_timeout = m.get('PersistenceTimeout')
        if m.get('Scheduler') is not None:
            self.scheduler = m.get('Scheduler')
        return self


class UdpCheck(TeaModel):
    def __init__(
        self,
        health_check_connect_port: int = None,
        health_check_connect_timeout: int = None,
        health_check_interval: int = None,
        healthy_threshold: int = None,
        unhealthy_threshold: int = None,
    ):
        self.health_check_connect_port = health_check_connect_port
        self.health_check_connect_timeout = health_check_connect_timeout
        self.health_check_interval = health_check_interval
        self.healthy_threshold = healthy_threshold
        self.unhealthy_threshold = unhealthy_threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.health_check_connect_port is not None:
            result['HealthCheckConnectPort'] = self.health_check_connect_port
        if self.health_check_connect_timeout is not None:
            result['HealthCheckConnectTimeout'] = self.health_check_connect_timeout
        if self.health_check_interval is not None:
            result['HealthCheckInterval'] = self.health_check_interval
        if self.healthy_threshold is not None:
            result['HealthyThreshold'] = self.healthy_threshold
        if self.unhealthy_threshold is not None:
            result['UnhealthyThreshold'] = self.unhealthy_threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HealthCheckConnectPort') is not None:
            self.health_check_connect_port = m.get('HealthCheckConnectPort')
        if m.get('HealthCheckConnectTimeout') is not None:
            self.health_check_connect_timeout = m.get('HealthCheckConnectTimeout')
        if m.get('HealthCheckInterval') is not None:
            self.health_check_interval = m.get('HealthCheckInterval')
        if m.get('HealthyThreshold') is not None:
            self.healthy_threshold = m.get('HealthyThreshold')
        if m.get('UnhealthyThreshold') is not None:
            self.unhealthy_threshold = m.get('UnhealthyThreshold')
        return self


class UdpConfig(TeaModel):
    def __init__(
        self,
        hash_key: str = None,
        scheduler: str = None,
    ):
        self.hash_key = hash_key
        self.scheduler = scheduler

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hash_key is not None:
            result['HashKey'] = self.hash_key
        if self.scheduler is not None:
            result['Scheduler'] = self.scheduler
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HashKey') is not None:
            self.hash_key = m.get('HashKey')
        if m.get('Scheduler') is not None:
            self.scheduler = m.get('Scheduler')
        return self


class AccosicateNetworkAclRequestResource(TeaModel):
    def __init__(
        self,
        resource_id: str = None,
        resource_type: str = None,
    ):
        # The ID of the associated resource.
        # 
        # This parameter is required.
        self.resource_id = resource_id
        # The type of the associated resource. Set the value to **Network**.
        # 
        # Valid values of **N**: 0 to 29. You can associate a network ACL with at most 30 resources.
        # 
        # This parameter is required.
        self.resource_type = resource_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class AccosicateNetworkAclRequest(TeaModel):
    def __init__(
        self,
        network_acl_id: str = None,
        resource: List[AccosicateNetworkAclRequestResource] = None,
    ):
        # The ID of the network ACL.
        # 
        # This parameter is required.
        self.network_acl_id = network_acl_id
        # The type of resource with which you want to associate the network ACL.
        # 
        # This parameter is required.
        self.resource = resource

    def validate(self):
        if self.resource:
            for k in self.resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_acl_id is not None:
            result['NetworkAclId'] = self.network_acl_id
        result['Resource'] = []
        if self.resource is not None:
            for k in self.resource:
                result['Resource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkAclId') is not None:
            self.network_acl_id = m.get('NetworkAclId')
        self.resource = []
        if m.get('Resource') is not None:
            for k in m.get('Resource'):
                temp_model = AccosicateNetworkAclRequestResource()
                self.resource.append(temp_model.from_map(k))
        return self


class AccosicateNetworkAclResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AccosicateNetworkAclResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AccosicateNetworkAclResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AccosicateNetworkAclResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddBackendServersRequestBackendServers(TeaModel):
    def __init__(
        self,
        ip: str = None,
        port: int = None,
        server_id: str = None,
        type: str = None,
        weight: int = None,
    ):
        # The IP address of the backend server.
        self.ip = ip
        # The backend port that is used by the ELB instance.
        self.port = port
        # The ID of the ENS instance.
        # 
        # This parameter is required.
        self.server_id = server_id
        # The type of the backend server. Valid values:
        # 
        # *   **ens**: ENS instance
        # *   **eni**: elastic network interface (ENI)
        self.type = type
        # The weight of the backend server. Default value: 100. Valid values: **0** to **100**.
        # 
        # >  The value 0 indicates that requests are not forwarded to the backend server.
        self.weight = weight

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.port is not None:
            result['Port'] = self.port
        if self.server_id is not None:
            result['ServerId'] = self.server_id
        if self.type is not None:
            result['Type'] = self.type
        if self.weight is not None:
            result['Weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('ServerId') is not None:
            self.server_id = m.get('ServerId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        return self


class AddBackendServersRequest(TeaModel):
    def __init__(
        self,
        backend_servers: List[AddBackendServersRequestBackendServers] = None,
        load_balancer_id: str = None,
    ):
        # The list of backend servers that you want to add to the Edge Load Balancer (ELB) instance. You can add up to 20 backend servers at a time.
        # 
        # >  Only Edge Node Service (ENS) instances that are in the running state can be added to the ELB instance as backend servers.
        # 
        # This parameter is required.
        self.backend_servers = backend_servers
        # The frontend port that is used by the Edge Load Balance (ELB) instance. Valid values: **1** to **65535**.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id

    def validate(self):
        if self.backend_servers:
            for k in self.backend_servers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BackendServers'] = []
        if self.backend_servers is not None:
            for k in self.backend_servers:
                result['BackendServers'].append(k.to_map() if k else None)
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.backend_servers = []
        if m.get('BackendServers') is not None:
            for k in m.get('BackendServers'):
                temp_model = AddBackendServersRequestBackendServers()
                self.backend_servers.append(temp_model.from_map(k))
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        return self


class AddBackendServersShrinkRequest(TeaModel):
    def __init__(
        self,
        backend_servers_shrink: str = None,
        load_balancer_id: str = None,
    ):
        # The list of backend servers that you want to add to the Edge Load Balancer (ELB) instance. You can add up to 20 backend servers at a time.
        # 
        # >  Only Edge Node Service (ENS) instances that are in the running state can be added to the ELB instance as backend servers.
        # 
        # This parameter is required.
        self.backend_servers_shrink = backend_servers_shrink
        # The frontend port that is used by the Edge Load Balance (ELB) instance. Valid values: **1** to **65535**.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backend_servers_shrink is not None:
            result['BackendServers'] = self.backend_servers_shrink
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackendServers') is not None:
            self.backend_servers_shrink = m.get('BackendServers')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        return self


class AddBackendServersResponseBodyBackendServersBackendServer(TeaModel):
    def __init__(
        self,
        ip: str = None,
        port: int = None,
        server_id: str = None,
        type: str = None,
        weight: int = None,
    ):
        # The IP address of the backend server.
        self.ip = ip
        # The backend port that is used by the ELB instance.
        self.port = port
        # The ID of the instance that is used as the backend server.
        self.server_id = server_id
        # The type of the backend server. Valid values:
        # 
        # *   **ens**: ENS instance.
        # *   **eni**: ENI.
        self.type = type
        # The weight of the backend server. Default value: 100. Valid values: **0** to **100**.
        # 
        # >  The value 0 indicates that requests are not forwarded to the backend server.
        self.weight = weight

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.port is not None:
            result['Port'] = self.port
        if self.server_id is not None:
            result['ServerId'] = self.server_id
        if self.type is not None:
            result['Type'] = self.type
        if self.weight is not None:
            result['Weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('ServerId') is not None:
            self.server_id = m.get('ServerId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        return self


class AddBackendServersResponseBodyBackendServers(TeaModel):
    def __init__(
        self,
        backend_server: List[AddBackendServersResponseBodyBackendServersBackendServer] = None,
    ):
        self.backend_server = backend_server

    def validate(self):
        if self.backend_server:
            for k in self.backend_server:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BackendServer'] = []
        if self.backend_server is not None:
            for k in self.backend_server:
                result['BackendServer'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.backend_server = []
        if m.get('BackendServer') is not None:
            for k in m.get('BackendServer'):
                temp_model = AddBackendServersResponseBodyBackendServersBackendServer()
                self.backend_server.append(temp_model.from_map(k))
        return self


class AddBackendServersResponseBody(TeaModel):
    def __init__(
        self,
        backend_servers: AddBackendServersResponseBodyBackendServers = None,
        request_id: str = None,
    ):
        # The list of backend servers that you want to add. You can add at most 20 backend servers.
        # 
        # >  Only ENS instances that are in the running state can be attached to the ELB instance as backend servers.
        self.backend_servers = backend_servers
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.backend_servers:
            self.backend_servers.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backend_servers is not None:
            result['BackendServers'] = self.backend_servers.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackendServers') is not None:
            temp_model = AddBackendServersResponseBodyBackendServers()
            self.backend_servers = temp_model.from_map(m['BackendServers'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddBackendServersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddBackendServersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddBackendServersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddNetworkInterfaceToInstanceRequest(TeaModel):
    def __init__(
        self,
        auto_start: bool = None,
        instance_id: str = None,
        networks: str = None,
    ):
        # Specifies whether to automatically restart the instance.
        self.auto_start = auto_start
        # The ID of the instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The network. The value is a JSON string. Only IPv6 is supported. Sample code of an IPv6 network: [{ "ipType": "public", "ipAddressType": "ipv6" }]
        # 
        # This parameter is required.
        self.networks = networks

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_start is not None:
            result['AutoStart'] = self.auto_start
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.networks is not None:
            result['Networks'] = self.networks
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoStart') is not None:
            self.auto_start = m.get('AutoStart')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Networks') is not None:
            self.networks = m.get('Networks')
        return self


class AddNetworkInterfaceToInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddNetworkInterfaceToInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddNetworkInterfaceToInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddNetworkInterfaceToInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddSnatIpForSnatEntryRequest(TeaModel):
    def __init__(
        self,
        snat_entry_id: str = None,
        snat_ip: str = None,
    ):
        # The ID of the SNAT entry.
        # 
        # This parameter is required.
        self.snat_entry_id = snat_entry_id
        # The EIP specified in the SNAT entry.
        # 
        # This parameter is required.
        self.snat_ip = snat_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.snat_entry_id is not None:
            result['SnatEntryId'] = self.snat_entry_id
        if self.snat_ip is not None:
            result['SnatIp'] = self.snat_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SnatEntryId') is not None:
            self.snat_entry_id = m.get('SnatEntryId')
        if m.get('SnatIp') is not None:
            self.snat_ip = m.get('SnatIp')
        return self


class AddSnatIpForSnatEntryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddSnatIpForSnatEntryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddSnatIpForSnatEntryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddSnatIpForSnatEntryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AssignPrivateIpAddressesRequest(TeaModel):
    def __init__(
        self,
        network_interface_id: str = None,
        v_switch_id: str = None,
    ):
        # The ID of the ENI.
        # 
        # This parameter is required.
        self.network_interface_id = network_interface_id
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet(TeaModel):
    def __init__(
        self,
        network_interface_id: str = None,
        private_ip_set: List[str] = None,
    ):
        # The ID of the ENI.
        self.network_interface_id = network_interface_id
        # The assigned private IP addresses.
        self.private_ip_set = private_ip_set

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.private_ip_set is not None:
            result['PrivateIpSet'] = self.private_ip_set
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('PrivateIpSet') is not None:
            self.private_ip_set = m.get('PrivateIpSet')
        return self


class AssignPrivateIpAddressesResponseBody(TeaModel):
    def __init__(
        self,
        assigned_private_ip_addresses_set: AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet = None,
        request_id: str = None,
    ):
        # Details about the ENI and the secondary private IP addresses that are assigned to the ENI.
        self.assigned_private_ip_addresses_set = assigned_private_ip_addresses_set
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.assigned_private_ip_addresses_set:
            self.assigned_private_ip_addresses_set.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assigned_private_ip_addresses_set is not None:
            result['AssignedPrivateIpAddressesSet'] = self.assigned_private_ip_addresses_set.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssignedPrivateIpAddressesSet') is not None:
            temp_model = AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet()
            self.assigned_private_ip_addresses_set = temp_model.from_map(m['AssignedPrivateIpAddressesSet'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AssignPrivateIpAddressesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AssignPrivateIpAddressesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AssignPrivateIpAddressesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AssociateEnsEipAddressRequest(TeaModel):
    def __init__(
        self,
        allocation_id: str = None,
        instance_id: str = None,
        instance_type: str = None,
        standby: bool = None,
    ):
        # The ID of the EIP that you want to associate.
        # 
        # This parameter is required.
        self.allocation_id = allocation_id
        # The ID of the cloud service with which the EIP is associated.
        # 
        # >  You can specify the ID of an Edge Load Balancer (ELB) instance ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The type of instance with which you want to associate the EIP. Valid values:
        # 
        # *   **Nat**: NAT gateway.
        # *   **SlbInstance**: Edge Load Balancer (ELB) instance.
        # *   **NetworkInterface**: secondary elastic network interface (ENI).
        # *   **NatSlbInstance**: If you want to associate multiple EIPs with an ELB instance, you need to set the parameter to this value.
        # *   **EnsInstance** (default): ENS instance.
        self.instance_type = instance_type
        # Specifies whether the EIP is a secondary EIP. Valid values:
        # 
        # *   true
        # *   false
        self.standby = standby

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.standby is not None:
            result['Standby'] = self.standby
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('Standby') is not None:
            self.standby = m.get('Standby')
        return self


class AssociateEnsEipAddressResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AssociateEnsEipAddressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AssociateEnsEipAddressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AssociateEnsEipAddressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AssociateHaVipRequest(TeaModel):
    def __init__(
        self,
        ha_vip_id: str = None,
        instance_id: str = None,
        instance_type: str = None,
    ):
        # The ID of the HAVIP.
        # 
        # This parameter is required.
        self.ha_vip_id = ha_vip_id
        # The ID of the instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The type of the instance to be associated with the HAVIP. Valid values:
        # 
        # *   EnsInstance (default): ENS instance
        # *   NetworkInterface: elastic network interface (ENI)
        self.instance_type = instance_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ha_vip_id is not None:
            result['HaVipId'] = self.ha_vip_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HaVipId') is not None:
            self.ha_vip_id = m.get('HaVipId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        return self


class AssociateHaVipResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AssociateHaVipResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AssociateHaVipResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AssociateHaVipResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AttachDiskRequest(TeaModel):
    def __init__(
        self,
        delete_with_instance: str = None,
        disk_id: str = None,
        instance_id: str = None,
    ):
        # Specifies whether the disk to be attached is released with the instance. Valid values:
        # 
        # *   true: The disk will be released when the ECS instance is released.
        # *   false: The disk will be retained when the ECS instance is released.
        # *   If you leave this parameter empty, the default value is used.
        self.delete_with_instance = delete_with_instance
        # The ID of the disk to be attached. The cloud disk and the instance must belong to the same node.
        # 
        # This parameter is required.
        self.disk_id = disk_id
        # The ID of the instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delete_with_instance is not None:
            result['DeleteWithInstance'] = self.delete_with_instance
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeleteWithInstance') is not None:
            self.delete_with_instance = m.get('DeleteWithInstance')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class AttachDiskResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        request_id: str = None,
    ):
        # The returned service code. 0 indicates that the request was successful.
        self.code = code
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AttachDiskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AttachDiskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AttachDiskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AttachEnsInstancesRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        scripts: str = None,
    ):
        # The ID of the instance. You can specify only one instance ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The command that you want to execute on the instance. The command must be encoded in Base64 or UTF-8.
        # 
        # This parameter is required.
        self.scripts = scripts

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.scripts is not None:
            result['Scripts'] = self.scripts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Scripts') is not None:
            self.scripts = m.get('Scripts')
        return self


class AttachEnsInstancesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AttachEnsInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AttachEnsInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AttachEnsInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AttachInstanceSDGRequestLoadOpt(TeaModel):
    def __init__(
        self,
        block_rw_split: bool = None,
        block_rw_split_size: int = None,
        cache: bool = None,
        cache_size: int = None,
    ):
        self.block_rw_split = block_rw_split
        self.block_rw_split_size = block_rw_split_size
        self.cache = cache
        self.cache_size = cache_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_rw_split is not None:
            result['BlockRwSplit'] = self.block_rw_split
        if self.block_rw_split_size is not None:
            result['BlockRwSplitSize'] = self.block_rw_split_size
        if self.cache is not None:
            result['Cache'] = self.cache
        if self.cache_size is not None:
            result['CacheSize'] = self.cache_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BlockRwSplit') is not None:
            self.block_rw_split = m.get('BlockRwSplit')
        if m.get('BlockRwSplitSize') is not None:
            self.block_rw_split_size = m.get('BlockRwSplitSize')
        if m.get('Cache') is not None:
            self.cache = m.get('Cache')
        if m.get('CacheSize') is not None:
            self.cache_size = m.get('CacheSize')
        return self


class AttachInstanceSDGRequest(TeaModel):
    def __init__(
        self,
        disk_access_protocol: str = None,
        disk_type: str = None,
        instance_ids: List[str] = None,
        load_opt: AttachInstanceSDGRequestLoadOpt = None,
        sdgid: str = None,
    ):
        self.disk_access_protocol = disk_access_protocol
        self.disk_type = disk_type
        # The IDs of the instances.
        # 
        # This parameter is required.
        self.instance_ids = instance_ids
        self.load_opt = load_opt
        # The ID of the SDG.
        # 
        # This parameter is required.
        self.sdgid = sdgid

    def validate(self):
        if self.load_opt:
            self.load_opt.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_access_protocol is not None:
            result['DiskAccessProtocol'] = self.disk_access_protocol
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.load_opt is not None:
            result['LoadOpt'] = self.load_opt.to_map()
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DiskAccessProtocol') is not None:
            self.disk_access_protocol = m.get('DiskAccessProtocol')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('LoadOpt') is not None:
            temp_model = AttachInstanceSDGRequestLoadOpt()
            self.load_opt = temp_model.from_map(m['LoadOpt'])
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class AttachInstanceSDGShrinkRequest(TeaModel):
    def __init__(
        self,
        disk_access_protocol: str = None,
        disk_type: str = None,
        instance_ids_shrink: str = None,
        load_opt_shrink: str = None,
        sdgid: str = None,
    ):
        self.disk_access_protocol = disk_access_protocol
        self.disk_type = disk_type
        # The IDs of the instances.
        # 
        # This parameter is required.
        self.instance_ids_shrink = instance_ids_shrink
        self.load_opt_shrink = load_opt_shrink
        # The ID of the SDG.
        # 
        # This parameter is required.
        self.sdgid = sdgid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_access_protocol is not None:
            result['DiskAccessProtocol'] = self.disk_access_protocol
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.instance_ids_shrink is not None:
            result['InstanceIds'] = self.instance_ids_shrink
        if self.load_opt_shrink is not None:
            result['LoadOpt'] = self.load_opt_shrink
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DiskAccessProtocol') is not None:
            self.disk_access_protocol = m.get('DiskAccessProtocol')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('InstanceIds') is not None:
            self.instance_ids_shrink = m.get('InstanceIds')
        if m.get('LoadOpt') is not None:
            self.load_opt_shrink = m.get('LoadOpt')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class AttachInstanceSDGResponseBodyDataResultFailedItems(TeaModel):
    def __init__(
        self,
        err_message: str = None,
        instance_id: str = None,
    ):
        # The error message.
        self.err_message = err_message
        # The ID of the instance.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.err_message is not None:
            result['ErrMessage'] = self.err_message
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrMessage') is not None:
            self.err_message = m.get('ErrMessage')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class AttachInstanceSDGResponseBodyDataResult(TeaModel):
    def __init__(
        self,
        failed_count: int = None,
        failed_items: List[AttachInstanceSDGResponseBodyDataResultFailedItems] = None,
        success_count: int = None,
    ):
        # The number of failed tasks.
        self.failed_count = failed_count
        # Details about failed tasks.
        self.failed_items = failed_items
        # The number of successful tasks.
        self.success_count = success_count

    def validate(self):
        if self.failed_items:
            for k in self.failed_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failed_count is not None:
            result['FailedCount'] = self.failed_count
        result['FailedItems'] = []
        if self.failed_items is not None:
            for k in self.failed_items:
                result['FailedItems'].append(k.to_map() if k else None)
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailedCount') is not None:
            self.failed_count = m.get('FailedCount')
        self.failed_items = []
        if m.get('FailedItems') is not None:
            for k in m.get('FailedItems'):
                temp_model = AttachInstanceSDGResponseBodyDataResultFailedItems()
                self.failed_items.append(temp_model.from_map(k))
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        return self


class AttachInstanceSDGResponseBodyData(TeaModel):
    def __init__(
        self,
        message: str = None,
        result: AttachInstanceSDGResponseBodyDataResult = None,
        success: bool = None,
    ):
        # The response message. Success is returned for a successful request.
        self.message = message
        # The execution result of the synchronization request.
        self.result = result
        # Indicates whether all tasks are successful. Valid values:
        # 
        # *   **true**: All tasks are successful.
        # *   **false**: Failed tasks exist.
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.result is not None:
            result['Result'] = self.result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Result') is not None:
            temp_model = AttachInstanceSDGResponseBodyDataResult()
            self.result = temp_model.from_map(m['Result'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AttachInstanceSDGResponseBody(TeaModel):
    def __init__(
        self,
        data: AttachInstanceSDGResponseBodyData = None,
        request_id: str = None,
    ):
        # The returned data object.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = AttachInstanceSDGResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AttachInstanceSDGResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AttachInstanceSDGResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AttachInstanceSDGResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AttachNetworkInterfaceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        network_interface_id: str = None,
    ):
        # The ID of the instance
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The ID of the ENI.
        # 
        # This parameter is required.
        self.network_interface_id = network_interface_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        return self


class AttachNetworkInterfaceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AttachNetworkInterfaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AttachNetworkInterfaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AttachNetworkInterfaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AuthorizeSecurityGroupRequest(TeaModel):
    def __init__(
        self,
        ip_protocol: str = None,
        policy: str = None,
        port_range: str = None,
        priority: int = None,
        security_group_id: str = None,
        source_cidr_ip: str = None,
        source_port_range: str = None,
    ):
        # The transport layer protocol. The values of this parameter are case-sensitive. Valid values:
        # 
        # *   tcp
        # *   udp
        # *   icmp
        # *   gre
        # *   all: All protocols are supported.
        # 
        # This parameter is required.
        self.ip_protocol = ip_protocol
        # The action of security group rule N that determines whether to allow inbound access. Valid values:
        # 
        # *   accept: allows access.
        # *   drop: denies access and returns no responses.
        # 
        # Default value: accept.
        self.policy = policy
        # The range of destination ports that correspond to the transport layer protocol for security group rule N. Valid values:
        # 
        # *   When the IpProtocol parameter is set to tcp or udp, the port number range is **1** to **65535**. The start port number and the end port number are separated by a forward slash (/). Correct example: **1/200**. Incorrect example: **200/1**.
        # *   When the IpProtocol parameter is set to icmp, the port number range is **-1/-1**, which indicates all ports.
        # *   When the IpProtocol parameter is set to gre, the port number range is **-1/-1**, which indicates all ports.
        # *   When the IpProtocol parameter is set to all, the port number range is **-1/-1**, which indicates all ports.
        # 
        # This parameter is required.
        self.port_range = port_range
        # The priority of security group rule N. Valid values: **1** to **100**.
        # 
        # Default value: **1**.
        self.priority = priority
        # The ID of the security group.
        # 
        # This parameter is required.
        self.security_group_id = security_group_id
        # The source IPv4 CIDR block. CIDR blocks and IPv4 addresses are supported.
        # 
        # This parameter is empty by default.
        # 
        # This parameter is required.
        self.source_cidr_ip = source_cidr_ip
        # The range of port numbers that correspond to the transport layer protocol for the source security group. Valid values:
        # 
        # *   When the IpProtocol parameter is set to tcp or udp, the port number range is **1 to 65535**. The start port number and the end port number are separated by a forward slash (/). Correct example: **1/200**. Incorrect example: **200/1**.
        # *   When the IpProtocol parameter is set to icmp, the port number range is **-1/-1**, which indicates all ports.
        # *   When the IpProtocol parameter is set to gre, the port number range is **-1/-1**, which indicates all ports.
        # *   When the IpProtocol parameter is set to all, the port number range is **-1/-1**, which indicates all ports.
        self.source_port_range = source_port_range

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.source_cidr_ip is not None:
            result['SourceCidrIp'] = self.source_cidr_ip
        if self.source_port_range is not None:
            result['SourcePortRange'] = self.source_port_range
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SourceCidrIp') is not None:
            self.source_cidr_ip = m.get('SourceCidrIp')
        if m.get('SourcePortRange') is not None:
            self.source_port_range = m.get('SourcePortRange')
        return self


class AuthorizeSecurityGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AuthorizeSecurityGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AuthorizeSecurityGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AuthorizeSecurityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AuthorizeSecurityGroupEgressRequest(TeaModel):
    def __init__(
        self,
        dest_cidr_ip: str = None,
        ip_protocol: str = None,
        policy: str = None,
        port_range: str = None,
        priority: int = None,
        security_group_id: str = None,
        source_port_range: str = None,
    ):
        # The destination IP addresses. CIDR blocks and IPv4 addresses are supported.
        # 
        # This parameter is empty by default.
        # 
        # This parameter is required.
        self.dest_cidr_ip = dest_cidr_ip
        # The transport layer protocol. The value of this parameter is case-sensitive. Valid values:
        # 
        # *   tcp
        # *   udp
        # *   icmp
        # *   gre
        # *   all: All protocols are supported.
        # 
        # This parameter is required.
        self.ip_protocol = ip_protocol
        # The action of the security group rule. Valid values:
        # 
        # *   accept: allows access. This is the default value.
        # *   drop: denies access and does not return responses.
        self.policy = policy
        # The range of destination ports that correspond to the transport layer protocol for security group rule N. Valid values:
        # 
        # *   When the IpProtocol parameter is set to tcp or udp, the port number range is **1** to **65535**. The start port number and the end port number are separated by a forward slash (/). Correct example: **1/200**. Incorrect example: **200/1**.
        # *   When the IpProtocol parameter is set to icmp, the port number range is **-1/-1**, which indicates all ports.
        # *   When the IpProtocol parameter is set to gre, the port number range is **-1/-1**, which indicates all ports.
        # *   When the IpProtocol parameter is set to all, the port number range is **-1/-1**, which indicates all ports.
        # 
        # This parameter is required.
        self.port_range = port_range
        # The priority of security group rule N. Valid values: **1 to 100**. Default value: **1**.
        self.priority = priority
        # The ID of the security group.
        # 
        # This parameter is required.
        self.security_group_id = security_group_id
        # The range of port numbers that correspond to the transport layer protocol for the source security group. Valid values:
        # 
        # *   When the IpProtocol parameter is set to tcp or udp, the port number range is **1** to **65535**. The start port number and the end port number are separated by a forward slash (/). Correct example: **1/200**. Incorrect example: **200/1**.
        # *   When the IpProtocol parameter is set to icmp, the port number range is **-1/-1**, which indicates all ports.
        # *   When the IpProtocol parameter is set to gre, the port number range is **-1/-1**, which indicates all ports.
        # *   When the IpProtocol parameter is set to all, the port number range is **-1/-1**, which indicates all ports.
        self.source_port_range = source_port_range

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dest_cidr_ip is not None:
            result['DestCidrIp'] = self.dest_cidr_ip
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.source_port_range is not None:
            result['SourcePortRange'] = self.source_port_range
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestCidrIp') is not None:
            self.dest_cidr_ip = m.get('DestCidrIp')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SourcePortRange') is not None:
            self.source_port_range = m.get('SourcePortRange')
        return self


class AuthorizeSecurityGroupEgressResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AuthorizeSecurityGroupEgressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AuthorizeSecurityGroupEgressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AuthorizeSecurityGroupEgressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CleanDistDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_name: str = None,
        data_version: str = None,
        ens_region_id: str = None,
    ):
        self.app_id = app_id
        self.data_name = data_name
        self.data_version = data_version
        self.ens_region_id = ens_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_name is not None:
            result['DataName'] = self.data_name
        if self.data_version is not None:
            result['DataVersion'] = self.data_version
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataName') is not None:
            self.data_name = m.get('DataName')
        if m.get('DataVersion') is not None:
            self.data_version = m.get('DataVersion')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        return self


class CleanDistDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CleanDistDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CleanDistDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CleanDistDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CopySDGRequest(TeaModel):
    def __init__(
        self,
        destination_region_ids: List[str] = None,
        sdgid: str = None,
    ):
        # The destination nodes.
        # 
        # This parameter is required.
        self.destination_region_ids = destination_region_ids
        # The ID of the SDG that you want to copy.
        # 
        # This parameter is required.
        self.sdgid = sdgid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_region_ids is not None:
            result['DestinationRegionIds'] = self.destination_region_ids
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationRegionIds') is not None:
            self.destination_region_ids = m.get('DestinationRegionIds')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class CopySDGShrinkRequest(TeaModel):
    def __init__(
        self,
        destination_region_ids_shrink: str = None,
        sdgid: str = None,
    ):
        # The destination nodes.
        # 
        # This parameter is required.
        self.destination_region_ids_shrink = destination_region_ids_shrink
        # The ID of the SDG that you want to copy.
        # 
        # This parameter is required.
        self.sdgid = sdgid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_region_ids_shrink is not None:
            result['DestinationRegionIds'] = self.destination_region_ids_shrink
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationRegionIds') is not None:
            self.destination_region_ids_shrink = m.get('DestinationRegionIds')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class CopySDGResponseBodyDataResultFailedItems(TeaModel):
    def __init__(
        self,
        destination_region_id: str = None,
        error_message: str = None,
    ):
        # The ID of the destination node.
        self.destination_region_id = destination_region_id
        # The error message.
        self.error_message = error_message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_region_id is not None:
            result['DestinationRegionId'] = self.destination_region_id
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationRegionId') is not None:
            self.destination_region_id = m.get('DestinationRegionId')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        return self


class CopySDGResponseBodyDataResult(TeaModel):
    def __init__(
        self,
        failed_count: int = None,
        failed_items: List[CopySDGResponseBodyDataResultFailedItems] = None,
        success_count: int = None,
    ):
        # The number of failed nodes.
        self.failed_count = failed_count
        # Details of failed nodes.
        self.failed_items = failed_items
        # The number of successful nodes.
        self.success_count = success_count

    def validate(self):
        if self.failed_items:
            for k in self.failed_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failed_count is not None:
            result['FailedCount'] = self.failed_count
        result['FailedItems'] = []
        if self.failed_items is not None:
            for k in self.failed_items:
                result['FailedItems'].append(k.to_map() if k else None)
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailedCount') is not None:
            self.failed_count = m.get('FailedCount')
        self.failed_items = []
        if m.get('FailedItems') is not None:
            for k in m.get('FailedItems'):
                temp_model = CopySDGResponseBodyDataResultFailedItems()
                self.failed_items.append(temp_model.from_map(k))
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        return self


class CopySDGResponseBodyData(TeaModel):
    def __init__(
        self,
        message: str = None,
        result: CopySDGResponseBodyDataResult = None,
        success: bool = None,
    ):
        # The response message. Success is returned for a successful request.
        self.message = message
        # The execution result of the synchronization request.
        self.result = result
        # Indicates whether all tasks are successful. Valid values:
        # 
        # *   **true**: All tasks are successful.
        # *   **false**: Failed tasks exist.
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.result is not None:
            result['Result'] = self.result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Result') is not None:
            temp_model = CopySDGResponseBodyDataResult()
            self.result = temp_model.from_map(m['Result'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CopySDGResponseBody(TeaModel):
    def __init__(
        self,
        data: CopySDGResponseBodyData = None,
        request_id: str = None,
    ):
        # The returned data object.
        self.data = data
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = CopySDGResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CopySDGResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CopySDGResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CopySDGResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CopySnapshotRequest(TeaModel):
    def __init__(
        self,
        destination_region_ids: List[str] = None,
        destination_snapshot_description: str = None,
        destination_snapshot_name: str = None,
        instance_billing_cycle: str = None,
        snapshot_id: str = None,
    ):
        # The IDs of destination nodes.
        # 
        # This parameter is required.
        self.destination_region_ids = destination_region_ids
        # The description of the snapshot. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.destination_snapshot_description = destination_snapshot_description
        # The name of the snapshot. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (_), and hyphens (-).
        self.destination_snapshot_name = destination_snapshot_name
        self.instance_billing_cycle = instance_billing_cycle
        # The ID of the source snapshot.
        # 
        # This parameter is required.
        self.snapshot_id = snapshot_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_region_ids is not None:
            result['DestinationRegionIds'] = self.destination_region_ids
        if self.destination_snapshot_description is not None:
            result['DestinationSnapshotDescription'] = self.destination_snapshot_description
        if self.destination_snapshot_name is not None:
            result['DestinationSnapshotName'] = self.destination_snapshot_name
        if self.instance_billing_cycle is not None:
            result['InstanceBillingCycle'] = self.instance_billing_cycle
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationRegionIds') is not None:
            self.destination_region_ids = m.get('DestinationRegionIds')
        if m.get('DestinationSnapshotDescription') is not None:
            self.destination_snapshot_description = m.get('DestinationSnapshotDescription')
        if m.get('DestinationSnapshotName') is not None:
            self.destination_snapshot_name = m.get('DestinationSnapshotName')
        if m.get('InstanceBillingCycle') is not None:
            self.instance_billing_cycle = m.get('InstanceBillingCycle')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        return self


class CopySnapshotShrinkRequest(TeaModel):
    def __init__(
        self,
        destination_region_ids_shrink: str = None,
        destination_snapshot_description: str = None,
        destination_snapshot_name: str = None,
        instance_billing_cycle: str = None,
        snapshot_id: str = None,
    ):
        # The IDs of destination nodes.
        # 
        # This parameter is required.
        self.destination_region_ids_shrink = destination_region_ids_shrink
        # The description of the snapshot. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.destination_snapshot_description = destination_snapshot_description
        # The name of the snapshot. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (_), and hyphens (-).
        self.destination_snapshot_name = destination_snapshot_name
        self.instance_billing_cycle = instance_billing_cycle
        # The ID of the source snapshot.
        # 
        # This parameter is required.
        self.snapshot_id = snapshot_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_region_ids_shrink is not None:
            result['DestinationRegionIds'] = self.destination_region_ids_shrink
        if self.destination_snapshot_description is not None:
            result['DestinationSnapshotDescription'] = self.destination_snapshot_description
        if self.destination_snapshot_name is not None:
            result['DestinationSnapshotName'] = self.destination_snapshot_name
        if self.instance_billing_cycle is not None:
            result['InstanceBillingCycle'] = self.instance_billing_cycle
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationRegionIds') is not None:
            self.destination_region_ids_shrink = m.get('DestinationRegionIds')
        if m.get('DestinationSnapshotDescription') is not None:
            self.destination_snapshot_description = m.get('DestinationSnapshotDescription')
        if m.get('DestinationSnapshotName') is not None:
            self.destination_snapshot_name = m.get('DestinationSnapshotName')
        if m.get('InstanceBillingCycle') is not None:
            self.instance_billing_cycle = m.get('InstanceBillingCycle')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        return self


class CopySnapshotResponseBodyAllocationId(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        instance_id: List[str] = None,
    ):
        # The ID of the node.
        self.ens_region_id = ens_region_id
        # The IDs of the instances.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class CopySnapshotResponseBodyUnAllocationId(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
    ):
        # The ID of the node.
        self.ens_region_id = ens_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        return self


class CopySnapshotResponseBody(TeaModel):
    def __init__(
        self,
        allocation_id: List[CopySnapshotResponseBodyAllocationId] = None,
        biz_status_code: str = None,
        request_id: str = None,
        un_allocation_id: List[CopySnapshotResponseBodyUnAllocationId] = None,
    ):
        # The list of created snapshots.
        self.allocation_id = allocation_id
        # The success status code.
        # 
        # *   **PartSuccess**: partially succeeded.
        # *   **AllSuccess**: all succeeded.
        self.biz_status_code = biz_status_code
        # The request ID.
        self.request_id = request_id
        # The list of nodes that are not created.
        self.un_allocation_id = un_allocation_id

    def validate(self):
        if self.allocation_id:
            for k in self.allocation_id:
                if k:
                    k.validate()
        if self.un_allocation_id:
            for k in self.un_allocation_id:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AllocationId'] = []
        if self.allocation_id is not None:
            for k in self.allocation_id:
                result['AllocationId'].append(k.to_map() if k else None)
        if self.biz_status_code is not None:
            result['BizStatusCode'] = self.biz_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['UnAllocationId'] = []
        if self.un_allocation_id is not None:
            for k in self.un_allocation_id:
                result['UnAllocationId'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.allocation_id = []
        if m.get('AllocationId') is not None:
            for k in m.get('AllocationId'):
                temp_model = CopySnapshotResponseBodyAllocationId()
                self.allocation_id.append(temp_model.from_map(k))
        if m.get('BizStatusCode') is not None:
            self.biz_status_code = m.get('BizStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.un_allocation_id = []
        if m.get('UnAllocationId') is not None:
            for k in m.get('UnAllocationId'):
                temp_model = CopySnapshotResponseBodyUnAllocationId()
                self.un_allocation_id.append(temp_model.from_map(k))
        return self


class CopySnapshotResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CopySnapshotResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CopySnapshotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateARMServerInstancesRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateARMServerInstancesRequest(TeaModel):
    def __init__(
        self,
        amount: int = None,
        auto_renew: bool = None,
        auto_use_coupon: bool = None,
        cidr: str = None,
        ens_region_id: str = None,
        environment_var: str = None,
        frequency: int = None,
        image_id: str = None,
        instance_billing_cycle: str = None,
        instance_type: str = None,
        key_pair_name: str = None,
        name_space: str = None,
        pay_type: str = None,
        period: int = None,
        period_unit: str = None,
        resolution: str = None,
        server_name: str = None,
        server_type: str = None,
        tag: List[CreateARMServerInstancesRequestTag] = None,
    ):
        # The number of instances to create. Valid values: **1** to **100**.
        # 
        # This parameter is required.
        self.amount = amount
        # Specifies whether to enable auto-renewal for the subscription. Valid values:
        # 
        # *   true
        # *   false (default)
        self.auto_renew = auto_renew
        # Specifies whether to use coupons. Valid values:
        # 
        # *   true
        # *   false (default)
        self.auto_use_coupon = auto_use_coupon
        self.cidr = cidr
        # The ID of the Edge Node Service (ENS) node.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        # Set one or more environment variables during EAIS instance initialization.
        self.environment_var = environment_var
        # The refresh rate. Unit: Hz. Valid values: 30 and 60.
        self.frequency = frequency
        # The ID of the image.
        # 
        # This parameter is required.
        self.image_id = image_id
        self.instance_billing_cycle = instance_billing_cycle
        # The specification of the Android in Container (AIC) instance. Examples:
        # 
        # *   aic.cf52r.c1.np
        # *   aic.cf52r.c2.np
        # *   aic.cf53r.c2.np
        # *   aic.cf52r.c4.np
        # *   aic.cf53r.c3.np
        # *   aic.cf52r.c3.np
        # *   aic.cf53r.c1.np
        # *   aic.cf53r.c5.np
        # *   aic.cf53r.c6
        # *   aic.cf53r.c4.np
        # *   aic.cf53r.c6.np
        # *   aic.cf53r.c7.np
        # *   aic.cf52m1r.c5.np
        # *   aic.cf53r.c8.np
        # *   aic.cf53r.c7
        # *   aic.cf52m1r.c2.np
        # *   aic.cf52m1r.c1.np
        # *   aic.cf52m1r.c3.np
        # *   aic.cf52m1r.c4.np
        # *   aic.cf52m1r.c6
        # *   ens.a6c2
        # 
        # This parameter is required.
        self.instance_type = instance_type
        # The name of the key pair.
        self.key_pair_name = key_pair_name
        # The namespace.
        self.name_space = name_space
        # The billing method. Set the value to **PrePaid**. PrePaid specifies the subscription billing method.
        # 
        # >  Only PrePaid is supported.
        # 
        # This parameter is required.
        self.pay_type = pay_type
        # The subscription duration of the instance.
        # 
        # *   If you leave PeriodUnit empty, the instance is purchased on a monthly basis. Valid values: Day and Month.
        # *   If you set PeriodUnit to Day, you can set Period only to 3.
        # *   If you set PeriodUnit to Month, you can set Period to a value within the range of [1,9], or set the value to 12.
        self.period = period
        # The unit of the subscription duration.
        # 
        # *   If you leave PeriodUnit empty, the instance is purchased on a monthly basis. Valid values: Day and Month.
        # *   If you set PeriodUnit to Day, you can set Period only to 3.
        # *   If you set PeriodUnit to Month, you can set Period to a value within the range of [1,9], or set the value to 12.
        self.period_unit = period_unit
        # The resolution. Examples:
        # 
        # *   1920\\*864
        # *   1080\\*1920
        # *   1920\\*1080
        # *   720\\*1280
        # *   2400\\*1080
        # *   1080\\*2400
        # *   1280\\*720
        # *   864\\*1920
        # 
        # This parameter is required.
        self.resolution = resolution
        # The name of the service.
        self.server_name = server_name
        # The specification of the ARM server. Examples:
        # 
        # *   cas.cf53r
        # *   cas.cf52r
        # *   cas.cf52m1r
        # *   cas.tg52g2
        # *   ens.afq-c2m3i.medium
        # 
        # This parameter is required.
        self.server_type = server_type
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amount is not None:
            result['Amount'] = self.amount
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.auto_use_coupon is not None:
            result['AutoUseCoupon'] = self.auto_use_coupon
        if self.cidr is not None:
            result['Cidr'] = self.cidr
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.environment_var is not None:
            result['EnvironmentVar'] = self.environment_var
        if self.frequency is not None:
            result['Frequency'] = self.frequency
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.instance_billing_cycle is not None:
            result['InstanceBillingCycle'] = self.instance_billing_cycle
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.name_space is not None:
            result['NameSpace'] = self.name_space
        if self.pay_type is not None:
            result['PayType'] = self.pay_type
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.resolution is not None:
            result['Resolution'] = self.resolution
        if self.server_name is not None:
            result['ServerName'] = self.server_name
        if self.server_type is not None:
            result['ServerType'] = self.server_type
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Amount') is not None:
            self.amount = m.get('Amount')
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('AutoUseCoupon') is not None:
            self.auto_use_coupon = m.get('AutoUseCoupon')
        if m.get('Cidr') is not None:
            self.cidr = m.get('Cidr')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('EnvironmentVar') is not None:
            self.environment_var = m.get('EnvironmentVar')
        if m.get('Frequency') is not None:
            self.frequency = m.get('Frequency')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InstanceBillingCycle') is not None:
            self.instance_billing_cycle = m.get('InstanceBillingCycle')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('NameSpace') is not None:
            self.name_space = m.get('NameSpace')
        if m.get('PayType') is not None:
            self.pay_type = m.get('PayType')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('Resolution') is not None:
            self.resolution = m.get('Resolution')
        if m.get('ServerName') is not None:
            self.server_name = m.get('ServerName')
        if m.get('ServerType') is not None:
            self.server_type = m.get('ServerType')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateARMServerInstancesRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class CreateARMServerInstancesResponseBody(TeaModel):
    def __init__(
        self,
        instance_ids: List[str] = None,
        order_id: str = None,
        request_id: str = None,
    ):
        # The IDs of instances.
        self.instance_ids = instance_ids
        # The ID of the order.
        self.order_id = order_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateARMServerInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateARMServerInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateARMServerInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateApplicationRequest(TeaModel):
    def __init__(
        self,
        template: str = None,
        timeout: int = None,
    ):
        # The edge application template. The value must be a JSON string that contains the following information:
        # 
        # *   Basic information such as the name of the application
        # *   Information such as resource specifications and network security configurations
        # *   Service specifications
        # *   Required resources
        # 
        # This parameter is required.
        self.template = template
        # The timeout period for asynchronous processing. Unit: seconds. Default value: 1800.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template is not None:
            result['Template'] = self.template
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Template') is not None:
            self.template = m.get('Template')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class CreateApplicationResponseBody(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        request_id: str = None,
    ):
        # The ID of the application. This is the unique identifier of the edge application.
        self.app_id = app_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateClassicNetworkRequest(TeaModel):
    def __init__(
        self,
        cidr_block: str = None,
        description: str = None,
        ens_region_id: str = None,
        network_name: str = None,
    ):
        # The CIDR block of the network. You can use one of the following CIDR blocks or their subnets as the CIDR block of the network:
        # 
        # *   10.0.0.0/8 (default)
        # *   172.16.0.0/12
        # *   192.168.0.0/16
        # 
        # This parameter is required.
        self.cidr_block = cidr_block
        # The description of the network. The name must be 2 to 256 characters in length. It must start with a letter but cannot start with http:// or https://.
        self.description = description
        # The ID of the edge node.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        # The name of the network. The name must meet the following requirements:
        # 
        # *   The name must be 2 to 128 characters in length.
        # *   The name must start with a letter but cannot start with http:// or https://.
        # *   The name can contain letters, digits, colons (:), underscores (_), and hyphens (-).
        self.network_name = network_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.description is not None:
            result['Description'] = self.description
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.network_name is not None:
            result['NetworkName'] = self.network_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('NetworkName') is not None:
            self.network_name = m.get('NetworkName')
        return self


class CreateClassicNetworkResponseBody(TeaModel):
    def __init__(
        self,
        network_id: str = None,
        request_id: str = None,
    ):
        # The ID of the network.
        self.network_id = network_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateClassicNetworkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateClassicNetworkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateClassicNetworkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateClusterRequest(TeaModel):
    def __init__(
        self,
        cluster_version: str = None,
        name: str = None,
    ):
        # The version of the cluster.
        self.cluster_version = cluster_version
        # The name of the cluster.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_version is not None:
            result['ClusterVersion'] = self.cluster_version
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterVersion') is not None:
            self.cluster_version = m.get('ClusterVersion')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class CreateClusterResponseBody(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        request_id: str = None,
    ):
        # The ID of the instance.
        self.cluster_id = cluster_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateClusterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateClusterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDiskRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag. Valid values of N: **1** to **20**.
        # 
        # *   The key cannot start with `aliyun`, `acs:`, `http://`, or `https://`.
        # *   The key must be up to 64 characters in length.
        # *   The tag key cannot be an empty string.
        self.key = key
        # The value of a tag that is attached to the topics you want to query. This parameter is not required. If you configure this parameter, you must also configure the **Key** parameter.**** If you include the Key and Value parameters in a request, this operation queries only the topics that use the specified tags. If you do not include these parameters in a request, this operation queries all topics that you can access.
        # 
        # *   Valid values: 1 to 20.
        # *   The value of this parameter can be an empty string.
        # *   The tag value can be up to 128 characters in length. It cannot start with aliyun or acs: and cannot contain http:// or https://.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateDiskRequest(TeaModel):
    def __init__(
        self,
        category: str = None,
        disk_name: str = None,
        encrypted: bool = None,
        ens_region_id: str = None,
        instance_billing_cycle: str = None,
        instance_charge_type: str = None,
        kmskey_id: str = None,
        size: str = None,
        snapshot_id: str = None,
        tag: List[CreateDiskRequestTag] = None,
    ):
        # The category of the disk. Valid values:
        # 
        # *   cloud_efficiency: ultra disk.
        # *   cloud_ssd: all-flash disk.
        # 
        # This parameter is required.
        self.category = category
        # The name of the disk.
        self.disk_name = disk_name
        # Specifies whether to encrypt the new system disk. Valid values:
        # 
        # *   **true**\
        # *   **false** (default): no
        self.encrypted = encrypted
        # The ID of the edge node.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        self.instance_billing_cycle = instance_billing_cycle
        # The billing method of the instance. Set the value to **PostPaid**.
        # 
        # This parameter is required.
        self.instance_charge_type = instance_charge_type
        # The ID of the Key Management Service (KMS) key that is used by the cloud disk.
        # 
        # >  If you set the **Encrypted** parameter to **true**, the default service key is used when the **KMSKeyId** parameter is empty.
        self.kmskey_id = kmskey_id
        # The size of the disk. Unit: GiB.
        self.size = size
        # The ID of the snapshot that you want to use to create the disk.
        # 
        # The following limits apply to the **SnapshotId** and **Size** parameters:
        # 
        # *   If the size of the snapshot specified by **SnapshotId** is greater than the specified **Size** value, the size of the created disk is equal to the specified snapshot size.
        # *   If the size of the snapshot specified by **SnapshotId** is smaller than the specified **Size** value, the size of the created disk is equal to the specified **Size** value.
        self.snapshot_id = snapshot_id
        # The tags of the instance. You can specify at most 20 tags in each call.
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_billing_cycle is not None:
            result['InstanceBillingCycle'] = self.instance_billing_cycle
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.kmskey_id is not None:
            result['KMSKeyId'] = self.kmskey_id
        if self.size is not None:
            result['Size'] = self.size
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceBillingCycle') is not None:
            self.instance_billing_cycle = m.get('InstanceBillingCycle')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('KMSKeyId') is not None:
            self.kmskey_id = m.get('KMSKeyId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateDiskRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class CreateDiskResponseBody(TeaModel):
    def __init__(
        self,
        instance_ids: List[str] = None,
        order_id: str = None,
        request_id: str = None,
    ):
        # The IDs of the instances.
        self.instance_ids = instance_ids
        # The ID of the order. Multiple IDs are separated by commas (,).
        # 
        # >  This parameter is not returned for the pay-as-you-go billing method.
        self.order_id = order_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDiskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDiskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDiskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEipInstanceRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of tag N of the instance. Valid values of N: **1** to **20**.
        # 
        # *   The key cannot start with `aliyun`, `acs:`, `http://`, or `https://`.
        # *   The key must be up to 64 characters in length.
        # *   The tag key cannot be an empty string.
        self.key = key
        # The value of tag N that is added to the resource. Valid values of N: 1 to 20. The tag value can be an empty string. The tag value can be up to 128 characters in length. It cannot start with acs: or contain http:// or https://.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateEipInstanceRequest(TeaModel):
    def __init__(
        self,
        bandwidth: int = None,
        client_token: str = None,
        description: str = None,
        ens_region_id: str = None,
        instance_charge_type: str = None,
        internet_charge_type: str = None,
        isp: str = None,
        name: str = None,
        tag: List[CreateEipInstanceRequestTag] = None,
    ):
        # The maximum bandwidth of the EIP. Default value: 5. Valid values: 5 to 10000. Unit: Mbit/s.
        self.bandwidth = bandwidth
        # The client token that is used to ensure the idempotence of the request. This prevents repeated operations caused by multiple retries.
        # 
        # *   You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
        # *   If you use a ClientToken that has been used and other request parameters remain unchanged in a repeated request, the client will receive the same result as the first request. This does not affect the status of your server.
        # *   You can initiate a retry when the operation times out or the error code is PROCESSING. The idempotence is valid. If HTTP status code 200 is returned, the client receives the same result as the last request. However, your server status is not affected. If HTTP status code 4xx is returned and error code is not PROCESSING, the idempotence is invalid.
        # *   A client token is valid for 10 minutes.
        self.client_token = client_token
        # The description of the EIP.
        self.description = description
        # The ID of the Edge Node Service (ENS) node.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        # The billing method of the EIP. Set the value to **PostPaid**.
        # 
        # This parameter is required.
        self.instance_charge_type = instance_charge_type
        # The metering method of the EIP. Set the value to **95BandwidthByMonth**.
        # 
        # This parameter is required.
        self.internet_charge_type = internet_charge_type
        # The Internet service provider. Valid values:
        # 
        # *   **cmcc**: China Mobile.
        # *   **unicom**: China Unicom.
        # *   **telecom**: China Telecom.
        self.isp = isp
        # The name of the EIP.
        self.name = name
        # The tags.
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.name is not None:
            result['Name'] = self.name
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateEipInstanceRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class CreateEipInstanceResponseBody(TeaModel):
    def __init__(
        self,
        allocation_id: str = None,
        request_id: str = None,
    ):
        # The ID of the EIP.
        self.allocation_id = allocation_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateEipInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEipInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEipInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEnsRouteEntryRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        destination_cidr_block: str = None,
        next_hop_id: str = None,
        next_hop_type: str = None,
        route_entry_name: str = None,
        route_table_id: str = None,
        source_cidr_block: str = None,
    ):
        # The description of the custom route entry.
        self.description = description
        # The destination CIDR block of the custom route entry. Make sure that the following requirements are met:
        # 
        # *   The destination CIDR block cannot point or belong to 100.64.0.0/10.
        # *   The destination CIDR blocks of the custom route entries in the same route table cannot overlap.
        # *   0.0.0.0/0 indicates the default CIDR block.
        # 
        # This parameter is required.
        self.destination_cidr_block = destination_cidr_block
        # The ID of the next hop of the custom route entry.
        # 
        # This parameter is required.
        self.next_hop_id = next_hop_id
        # The next hop type of the custom route. Valid values:
        # 
        # *   Instance: an ENS instance.
        # *   HaVip: a high-availability virtual IP address (HAVIP).
        # *   NetworkPeer: VPC peering connection.
        self.next_hop_type = next_hop_type
        # The name of the custom route entry that you want to add. The name must be 1 to 128 characters in length. It cannot start with http:// or https://.
        self.route_entry_name = route_entry_name
        # The ID of the route table to which you want to add a custom route entry.
        # 
        # This parameter is required.
        self.route_table_id = route_table_id
        # The source CIDR block is available when you configure a route entry in the gateway route table, but is not unavailable when you configure a route entry in the vSwitch route table.
        self.source_cidr_block = source_cidr_block

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.destination_cidr_block is not None:
            result['DestinationCidrBlock'] = self.destination_cidr_block
        if self.next_hop_id is not None:
            result['NextHopId'] = self.next_hop_id
        if self.next_hop_type is not None:
            result['NextHopType'] = self.next_hop_type
        if self.route_entry_name is not None:
            result['RouteEntryName'] = self.route_entry_name
        if self.route_table_id is not None:
            result['RouteTableId'] = self.route_table_id
        if self.source_cidr_block is not None:
            result['SourceCidrBlock'] = self.source_cidr_block
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestinationCidrBlock') is not None:
            self.destination_cidr_block = m.get('DestinationCidrBlock')
        if m.get('NextHopId') is not None:
            self.next_hop_id = m.get('NextHopId')
        if m.get('NextHopType') is not None:
            self.next_hop_type = m.get('NextHopType')
        if m.get('RouteEntryName') is not None:
            self.route_entry_name = m.get('RouteEntryName')
        if m.get('RouteTableId') is not None:
            self.route_table_id = m.get('RouteTableId')
        if m.get('SourceCidrBlock') is not None:
            self.source_cidr_block = m.get('SourceCidrBlock')
        return self


class CreateEnsRouteEntryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        route_entry_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The ID of the route.
        self.route_entry_id = route_entry_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.route_entry_id is not None:
            result['RouteEntryId'] = self.route_entry_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RouteEntryId') is not None:
            self.route_entry_id = m.get('RouteEntryId')
        return self


class CreateEnsRouteEntryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEnsRouteEntryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEnsRouteEntryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEnsSaleControlRequestSaleControlsConditionControls(TeaModel):
    def __init__(
        self,
        condition_control_module_code: str = None,
        condition_control_module_value: str = None,
    ):
        self.condition_control_module_code = condition_control_module_code
        self.condition_control_module_value = condition_control_module_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition_control_module_code is not None:
            result['ConditionControlModuleCode'] = self.condition_control_module_code
        if self.condition_control_module_value is not None:
            result['ConditionControlModuleValue'] = self.condition_control_module_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConditionControlModuleCode') is not None:
            self.condition_control_module_code = m.get('ConditionControlModuleCode')
        if m.get('ConditionControlModuleValue') is not None:
            self.condition_control_module_value = m.get('ConditionControlModuleValue')
        return self


class CreateEnsSaleControlRequestSaleControlsModuleValue(TeaModel):
    def __init__(
        self,
        module_max_value: str = None,
        module_min_value: str = None,
        module_value: List[str] = None,
    ):
        self.module_max_value = module_max_value
        self.module_min_value = module_min_value
        self.module_value = module_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.module_max_value is not None:
            result['ModuleMaxValue'] = self.module_max_value
        if self.module_min_value is not None:
            result['ModuleMinValue'] = self.module_min_value
        if self.module_value is not None:
            result['ModuleValue'] = self.module_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ModuleMaxValue') is not None:
            self.module_max_value = m.get('ModuleMaxValue')
        if m.get('ModuleMinValue') is not None:
            self.module_min_value = m.get('ModuleMinValue')
        if m.get('ModuleValue') is not None:
            self.module_value = m.get('ModuleValue')
        return self


class CreateEnsSaleControlRequestSaleControls(TeaModel):
    def __init__(
        self,
        condition_controls: List[CreateEnsSaleControlRequestSaleControlsConditionControls] = None,
        description: str = None,
        module_code: str = None,
        module_value: CreateEnsSaleControlRequestSaleControlsModuleValue = None,
        operator: str = None,
        order_type: str = None,
    ):
        self.condition_controls = condition_controls
        self.description = description
        # This parameter is required.
        self.module_code = module_code
        # This parameter is required.
        self.module_value = module_value
        # This parameter is required.
        self.operator = operator
        # This parameter is required.
        self.order_type = order_type

    def validate(self):
        if self.condition_controls:
            for k in self.condition_controls:
                if k:
                    k.validate()
        if self.module_value:
            self.module_value.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConditionControls'] = []
        if self.condition_controls is not None:
            for k in self.condition_controls:
                result['ConditionControls'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.module_code is not None:
            result['ModuleCode'] = self.module_code
        if self.module_value is not None:
            result['ModuleValue'] = self.module_value.to_map()
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.condition_controls = []
        if m.get('ConditionControls') is not None:
            for k in m.get('ConditionControls'):
                temp_model = CreateEnsSaleControlRequestSaleControlsConditionControls()
                self.condition_controls.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ModuleCode') is not None:
            self.module_code = m.get('ModuleCode')
        if m.get('ModuleValue') is not None:
            temp_model = CreateEnsSaleControlRequestSaleControlsModuleValue()
            self.module_value = temp_model.from_map(m['ModuleValue'])
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        return self


class CreateEnsSaleControlRequest(TeaModel):
    def __init__(
        self,
        ali_uid_account: str = None,
        commodity_code: str = None,
        custom_account: str = None,
        sale_controls: List[CreateEnsSaleControlRequestSaleControls] = None,
    ):
        self.ali_uid_account = ali_uid_account
        # This parameter is required.
        self.commodity_code = commodity_code
        self.custom_account = custom_account
        # This parameter is required.
        self.sale_controls = sale_controls

    def validate(self):
        if self.sale_controls:
            for k in self.sale_controls:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uid_account is not None:
            result['AliUidAccount'] = self.ali_uid_account
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.custom_account is not None:
            result['CustomAccount'] = self.custom_account
        result['SaleControls'] = []
        if self.sale_controls is not None:
            for k in self.sale_controls:
                result['SaleControls'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliUidAccount') is not None:
            self.ali_uid_account = m.get('AliUidAccount')
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('CustomAccount') is not None:
            self.custom_account = m.get('CustomAccount')
        self.sale_controls = []
        if m.get('SaleControls') is not None:
            for k in m.get('SaleControls'):
                temp_model = CreateEnsSaleControlRequestSaleControls()
                self.sale_controls.append(temp_model.from_map(k))
        return self


class CreateEnsSaleControlShrinkRequest(TeaModel):
    def __init__(
        self,
        ali_uid_account: str = None,
        commodity_code: str = None,
        custom_account: str = None,
        sale_controls_shrink: str = None,
    ):
        self.ali_uid_account = ali_uid_account
        # This parameter is required.
        self.commodity_code = commodity_code
        self.custom_account = custom_account
        # This parameter is required.
        self.sale_controls_shrink = sale_controls_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uid_account is not None:
            result['AliUidAccount'] = self.ali_uid_account
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.custom_account is not None:
            result['CustomAccount'] = self.custom_account
        if self.sale_controls_shrink is not None:
            result['SaleControls'] = self.sale_controls_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliUidAccount') is not None:
            self.ali_uid_account = m.get('AliUidAccount')
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('CustomAccount') is not None:
            self.custom_account = m.get('CustomAccount')
        if m.get('SaleControls') is not None:
            self.sale_controls_shrink = m.get('SaleControls')
        return self


class CreateEnsSaleControlResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateEnsSaleControlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEnsSaleControlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEnsSaleControlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEnsServiceRequest(TeaModel):
    def __init__(
        self,
        ens_service_id: str = None,
        order_type: str = None,
    ):
        # The ID of the resource that you want to obtain. You can specify only one ID in a request.
        # 
        # This parameter is required.
        self.ens_service_id = ens_service_id
        # The operation to perform after you preview the created edge service. Valid values:
        # 
        # *   **Buy**: create
        # *   **Upgrade**: change
        # 
        # This parameter is required.
        self.order_type = order_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_service_id is not None:
            result['EnsServiceId'] = self.ens_service_id
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsServiceId') is not None:
            self.ens_service_id = m.get('EnsServiceId')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        return self


class CreateEnsServiceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        request_id: str = None,
    ):
        # The service code. 0 is returned for a successful request. An error code is returned for a failed request.
        self.code = code
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateEnsServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEnsServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEnsServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEpnInstanceRequest(TeaModel):
    def __init__(
        self,
        epninstance_name: str = None,
        epninstance_type: str = None,
        internet_charge_type: str = None,
        internet_max_bandwidth_out: int = None,
        networking_model: str = None,
    ):
        # The name of the EPN instance.
        self.epninstance_name = epninstance_name
        # The type of the EPN instance. Set the value to **EdgeToEdge**.
        # 
        # This parameter is required.
        self.epninstance_type = epninstance_type
        # The billing method for network usage. Valid values:
        # 
        # *   **BandwidthByDay**: Pay by daily peak bandwidth.
        # *   **95BandwidthByMonth**: Pay by monthly 95th percentile bandwidth.
        # *   **PayByBandwidth4thMonth**: Pay by monthly fourth peak bandwidth.
        # *   **PayByBandwidth**: Pay by fixed bandwidth.
        # 
        # You can specify only one metering method for network usage and cannot overwrite the existing metering method.
        # 
        # This parameter is required.
        self.internet_charge_type = internet_charge_type
        # The maximum outbound public bandwidth. Unit: Mbit/s. Valid values: 1 to 100.
        # 
        # This parameter is required.
        self.internet_max_bandwidth_out = internet_max_bandwidth_out
        # The networking mode. Valid values:
        # 
        # *   **SpeedUp**: intelligent acceleration network (Internet)
        # *   **Connection**: internal network
        # *   **SpeedUpAndConnection**: intelligent acceleration network and internal network
        # 
        # This parameter is required.
        self.networking_model = networking_model

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.epninstance_name is not None:
            result['EPNInstanceName'] = self.epninstance_name
        if self.epninstance_type is not None:
            result['EPNInstanceType'] = self.epninstance_type
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.internet_max_bandwidth_out is not None:
            result['InternetMaxBandwidthOut'] = self.internet_max_bandwidth_out
        if self.networking_model is not None:
            result['NetworkingModel'] = self.networking_model
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EPNInstanceName') is not None:
            self.epninstance_name = m.get('EPNInstanceName')
        if m.get('EPNInstanceType') is not None:
            self.epninstance_type = m.get('EPNInstanceType')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('InternetMaxBandwidthOut') is not None:
            self.internet_max_bandwidth_out = m.get('InternetMaxBandwidthOut')
        if m.get('NetworkingModel') is not None:
            self.networking_model = m.get('NetworkingModel')
        return self


class CreateEpnInstanceResponseBody(TeaModel):
    def __init__(
        self,
        epninstance_id: str = None,
        request_id: str = None,
    ):
        # The ID of the EPN instance.
        self.epninstance_id = epninstance_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.epninstance_id is not None:
            result['EPNInstanceId'] = self.epninstance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EPNInstanceId') is not None:
            self.epninstance_id = m.get('EPNInstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateEpnInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEpnInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEpnInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateFileSystemRequestOrderDetails(TeaModel):
    def __init__(
        self,
        charge_type: str = None,
        ens_region_id: str = None,
        file_system_name: str = None,
        mount_target_domain: str = None,
        network_id: str = None,
        order_type: str = None,
        protocol_type: str = None,
        storge_type: str = None,
    ):
        # The billing method of the NAS file system. Valid values:
        # 
        # *   PrePaid: subscription. This billing method is not supported.
        # *   PostPaid: pay-as-you-go.
        # 
        # This parameter is required.
        self.charge_type = charge_type
        # The ID of the edge node.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        # The name of the file system. The name must be 1 to 80 characters in length and can contain letters, digits, hyphens (-), and underscores (_).
        # 
        # This parameter is required.
        self.file_system_name = file_system_name
        # The name of the mount target. The name must be 1 to 80 characters in length and can contain letters, digits, hyphens (-), and underscores (_).
        # 
        # This parameter is required.
        self.mount_target_domain = mount_target_domain
        # The ID of the VPC.
        # 
        # This parameter is required.
        self.network_id = network_id
        # The type of the order. Set the value to BUY.
        # 
        # This parameter is required.
        self.order_type = order_type
        # The storage protocol. Set the value to nfs.
        # 
        # This parameter is required.
        self.protocol_type = protocol_type
        # The storage type. Valid values:
        # 
        # *   Capacity.
        # *   Performance.
        # 
        # This parameter is required.
        self.storge_type = storge_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.charge_type is not None:
            result['ChargeType'] = self.charge_type
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.file_system_name is not None:
            result['FileSystemName'] = self.file_system_name
        if self.mount_target_domain is not None:
            result['MountTargetDomain'] = self.mount_target_domain
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.storge_type is not None:
            result['StorgeType'] = self.storge_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChargeType') is not None:
            self.charge_type = m.get('ChargeType')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('FileSystemName') is not None:
            self.file_system_name = m.get('FileSystemName')
        if m.get('MountTargetDomain') is not None:
            self.mount_target_domain = m.get('MountTargetDomain')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('StorgeType') is not None:
            self.storge_type = m.get('StorgeType')
        return self


class CreateFileSystemRequest(TeaModel):
    def __init__(
        self,
        order_details: List[CreateFileSystemRequestOrderDetails] = None,
    ):
        # The information about the orders.
        # 
        # This parameter is required.
        self.order_details = order_details

    def validate(self):
        if self.order_details:
            for k in self.order_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OrderDetails'] = []
        if self.order_details is not None:
            for k in self.order_details:
                result['OrderDetails'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.order_details = []
        if m.get('OrderDetails') is not None:
            for k in m.get('OrderDetails'):
                temp_model = CreateFileSystemRequestOrderDetails()
                self.order_details.append(temp_model.from_map(k))
        return self


class CreateFileSystemShrinkRequest(TeaModel):
    def __init__(
        self,
        order_details_shrink: str = None,
    ):
        # The information about the orders.
        # 
        # This parameter is required.
        self.order_details_shrink = order_details_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_details_shrink is not None:
            result['OrderDetails'] = self.order_details_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderDetails') is not None:
            self.order_details_shrink = m.get('OrderDetails')
        return self


class CreateFileSystemResponseBody(TeaModel):
    def __init__(
        self,
        allocation_id: List[str] = None,
        biz_status_code: str = None,
        request_id: str = None,
        un_allocation_id: List[str] = None,
    ):
        # The information about the file system that was created.
        self.allocation_id = allocation_id
        # The status code for successful operations. Valid values:
        # 
        # *   PartSuccess: The operation is partially successful.
        # *   AllSuccess: The operation is successful.
        self.biz_status_code = biz_status_code
        # The ID of the request.
        self.request_id = request_id
        # The information about the file system that failed to be created.
        self.un_allocation_id = un_allocation_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.biz_status_code is not None:
            result['BizStatusCode'] = self.biz_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.un_allocation_id is not None:
            result['UnAllocationId'] = self.un_allocation_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('BizStatusCode') is not None:
            self.biz_status_code = m.get('BizStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UnAllocationId') is not None:
            self.un_allocation_id = m.get('UnAllocationId')
        return self


class CreateFileSystemResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateFileSystemResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateFileSystemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateForwardEntryRequest(TeaModel):
    def __init__(
        self,
        external_ip: str = None,
        external_port: str = None,
        forward_entry_name: str = None,
        health_check_port: int = None,
        internal_ip: str = None,
        internal_port: str = None,
        ip_protocol: str = None,
        nat_gateway_id: str = None,
        standby_external_ip: str = None,
    ):
        # The elastic IP address (EIP) that is used to access the Internet.
        # 
        # This parameter is required.
        self.external_ip = external_ip
        # The external port or port range that is used for port forwarding.
        # 
        # *   Valid values: 1 to 65535.
        # *   To specify a port range, separate the first port and the last port with a forward slash (/), such as 10/20.
        # *   If you set ExternalPort to a port range, you must also set InternalPort to a port range. The number of ports in the port ranges must be the same. For example, if you set ExternalPort to 10/20, you can set InternalPort to 80/90.
        # 
        # This parameter is required.
        self.external_port = external_port
        # The name of the DNAT entry. The name must be 2 to 128 characters in length. The name cannot start with `http://` or `https://`.
        self.forward_entry_name = forward_entry_name
        # The probe port. The port must be within the internal port range. By default, this parameter is left empty.
        self.health_check_port = health_check_port
        # The private IP address of the instance that uses the DNAT entry for Internet communication.
        # 
        # This parameter is required.
        self.internal_ip = internal_ip
        # The internal port or port range that is used for port forwarding.
        # 
        # *   Valid values: 1 to 65535.
        # *   To specify a port range, separate the first port and the last port with a forward slash (/), such as 10/20.
        # 
        # This parameter is required.
        self.internal_port = internal_port
        # The protocol. Valid values:
        # 
        # *   **TCP**: forwards TCP packets.
        # *   **UDP**: forwards UDP packets.
        # *   **Any** (default): forwards all packets.
        self.ip_protocol = ip_protocol
        # The ID of the Network Address Translation (NAT) gateway.
        # 
        # This parameter is required.
        self.nat_gateway_id = nat_gateway_id
        # The secondary EIP that is used to access the Internet. You need to select a secondary EIP that is bound to NAT. After the DNAT entry is created, the secondary EIP takes effect.
        self.standby_external_ip = standby_external_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.external_ip is not None:
            result['ExternalIp'] = self.external_ip
        if self.external_port is not None:
            result['ExternalPort'] = self.external_port
        if self.forward_entry_name is not None:
            result['ForwardEntryName'] = self.forward_entry_name
        if self.health_check_port is not None:
            result['HealthCheckPort'] = self.health_check_port
        if self.internal_ip is not None:
            result['InternalIp'] = self.internal_ip
        if self.internal_port is not None:
            result['InternalPort'] = self.internal_port
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.nat_gateway_id is not None:
            result['NatGatewayId'] = self.nat_gateway_id
        if self.standby_external_ip is not None:
            result['StandbyExternalIp'] = self.standby_external_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExternalIp') is not None:
            self.external_ip = m.get('ExternalIp')
        if m.get('ExternalPort') is not None:
            self.external_port = m.get('ExternalPort')
        if m.get('ForwardEntryName') is not None:
            self.forward_entry_name = m.get('ForwardEntryName')
        if m.get('HealthCheckPort') is not None:
            self.health_check_port = m.get('HealthCheckPort')
        if m.get('InternalIp') is not None:
            self.internal_ip = m.get('InternalIp')
        if m.get('InternalPort') is not None:
            self.internal_port = m.get('InternalPort')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('NatGatewayId') is not None:
            self.nat_gateway_id = m.get('NatGatewayId')
        if m.get('StandbyExternalIp') is not None:
            self.standby_external_ip = m.get('StandbyExternalIp')
        return self


class CreateForwardEntryResponseBody(TeaModel):
    def __init__(
        self,
        forward_entry_id: str = None,
        request_id: str = None,
    ):
        # The ID of the DNAT entry.
        self.forward_entry_id = forward_entry_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.forward_entry_id is not None:
            result['ForwardEntryId'] = self.forward_entry_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ForwardEntryId') is not None:
            self.forward_entry_id = m.get('ForwardEntryId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateForwardEntryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateForwardEntryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateForwardEntryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateHaVipRequest(TeaModel):
    def __init__(
        self,
        amount: int = None,
        description: str = None,
        ip_address: str = None,
        name: str = None,
        v_switch_id: str = None,
    ):
        # The number of HAVIPs that you want to create. Valid values: 1 to 10. The value can be only 1 if you specify an IP address.
        # 
        # Default value: 1.
        self.amount = amount
        self.description = description
        self.ip_address = ip_address
        self.name = name
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amount is not None:
            result['Amount'] = self.amount
        if self.description is not None:
            result['Description'] = self.description
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        if self.name is not None:
            result['Name'] = self.name
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Amount') is not None:
            self.amount = m.get('Amount')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class CreateHaVipResponseBody(TeaModel):
    def __init__(
        self,
        ha_vip_ids: List[str] = None,
        request_id: str = None,
    ):
        self.ha_vip_ids = ha_vip_ids
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ha_vip_ids is not None:
            result['HaVipIds'] = self.ha_vip_ids
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HaVipIds') is not None:
            self.ha_vip_ids = m.get('HaVipIds')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateHaVipResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateHaVipResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateHaVipResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateImageRequest(TeaModel):
    def __init__(
        self,
        delete_after_image_upload: str = None,
        image_name: str = None,
        instance_id: str = None,
        snapshot_id: str = None,
        target_ossregion_id: str = None,
        with_data_disks: bool = None,
    ):
        # Specifies whether to automatically release the instance after the image is packaged and uploaded. Only image builders are supported. Default value: false. Valid values:
        # 
        # *   true: The image is released when the instance is released.
        # *   false: The image is retained when the instance is released.
        # *   If you leave this property empty, false is used by default.
        self.delete_after_image_upload = delete_after_image_upload
        # The name of the image. The name must be 2 to 128 characters in length. The name can contain letters, digits, colons (:), underscores (_), and hyphens (-). It must start with a letter but cannot start with `http://` or `https://`. The name can contain letters, digits, colons (:), underscores (_), and hyphens (-).
        # 
        # This parameter is required.
        self.image_name = image_name
        # The ID of the instance.
        self.instance_id = instance_id
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id
        # The region of the destination OSS bucket where the image is to be stored.
        self.target_ossregion_id = target_ossregion_id
        # Specifies whether to include data disk snapshots in the custom image.
        self.with_data_disks = with_data_disks

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delete_after_image_upload is not None:
            result['DeleteAfterImageUpload'] = self.delete_after_image_upload
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.target_ossregion_id is not None:
            result['TargetOSSRegionId'] = self.target_ossregion_id
        if self.with_data_disks is not None:
            result['WithDataDisks'] = self.with_data_disks
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeleteAfterImageUpload') is not None:
            self.delete_after_image_upload = m.get('DeleteAfterImageUpload')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('TargetOSSRegionId') is not None:
            self.target_ossregion_id = m.get('TargetOSSRegionId')
        if m.get('WithDataDisks') is not None:
            self.with_data_disks = m.get('WithDataDisks')
        return self


class CreateImageResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        image_id: str = None,
        request_id: str = None,
    ):
        # The returned service code. 0 indicates that the request was successful.
        self.code = code
        # The ID of the image.
        self.image_id = image_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateImageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateImageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateInstanceRequestDataDisk(TeaModel):
    def __init__(
        self,
        size: str = None,
    ):
        # The capacity of the first data disk. Unit: GiB. The capacity is at least 20 GiB and is a multiple of 10 GiB.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class CreateInstanceRequestSystemDisk(TeaModel):
    def __init__(
        self,
        size: str = None,
    ):
        # The size of the system disk. Unit: GiB. Valid values: **20** and **40**. The value cannot be smaller than the size of the image and must be a multiple of 10 GiB.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class CreateInstanceRequest(TeaModel):
    def __init__(
        self,
        data_disk: List[CreateInstanceRequestDataDisk] = None,
        system_disk: CreateInstanceRequestSystemDisk = None,
        auto_renew: str = None,
        auto_renew_period: str = None,
        ens_region_id: str = None,
        host_name: str = None,
        image_id: str = None,
        instance_name: str = None,
        instance_type: str = None,
        internet_charge_type: str = None,
        ip_type: str = None,
        key_pair_name: str = None,
        owner_id: int = None,
        password: str = None,
        password_inherit: bool = None,
        payment_type: str = None,
        period: str = None,
        private_ip_address: str = None,
        public_ip_identification: bool = None,
        quantity: str = None,
        unique_suffix: bool = None,
        user_data: str = None,
        v_switch_id: str = None,
    ):
        self.data_disk = data_disk
        self.system_disk = system_disk
        # Specifies whether to enable the auto-renewal feature. Valid values: **True** and **False**. Default value: False.
        self.auto_renew = auto_renew
        # The auto-renewal period for the instance. This parameter is required when the **AutoRenew** parameter is set to **True**. Valid values: **1** to **12**. Unit: months.
        self.auto_renew_period = auto_renew_period
        # The region ID.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        # The hostname of the Elastic Compute Service (ECS) instance. General naming rules: The hostname cannot start or end with a period (.) or hyphen (-). It cannot contain consecutive periods (.) or hyphens (-).
        # 
        # Naming rules for specific instances:
        # 
        # *   For Windows instances, the hostname must be **2** to **15** characters in length and cannot contain periods (.) or contain only digits. The hostname cannot contain periods (.) or contain only digits.
        # *   For instances that run one of other operating systems such as Linux, the hostname must be **2** to **64** characters in length. You can use periods (.) to separate the hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).
        self.host_name = host_name
        # The ID of the image file that you select when creating the instance.
        self.image_id = image_id
        # The name of the instance. The name must conform to the following naming conventions:
        # 
        # *   The name must be **2** to **128** characters in length.
        # *   It must start with a letter but cannot start with http:// or https://.
        # *   The name can contain letters, digits, colons (:), underscores (_), periods (.), and hyphens (-).
        # 
        # If you do not specify this parameter, the instance ID is used as the instance name by default.
        self.instance_name = instance_name
        # The type of the instance.
        # 
        # For more information, see [](~~66124~~).
        # 
        # This parameter is required.
        self.instance_type = instance_type
        # This parameter is required if you create the instance for the first time. The existing billing method is used by default if you have created an instance. Valid values:
        # 
        # *   **BandwidthByDay**: Pay by daily peak bandwidth.
        # *   **95BandwidthByMonth**: Pay by monthly 95th percentile bandwidth.
        self.internet_charge_type = internet_charge_type
        # The type of the IP address. Valid values:
        # 
        # *   **ipv4** (default)
        # *   **ipv6**\
        # *   **ipv4Andipv6**\
        self.ip_type = ip_type
        # The name of the key pair. You can specify only one name.
        self.key_pair_name = key_pair_name
        self.owner_id = owner_id
        # The password of the instance.
        # 
        # The password must be 8 to 30 characters in length and contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. Special characters include: ``()`~!@#$%^&*-_+=|{}[]:;\\"<>,.?/``
        self.password = password
        # Specifies whether to use the preset password of the image. Valid values:
        # 
        # - **true**: The password preset in the image is used, and the **Password** parameter must be null. For secure access, make sure that the selected image has a password configured.
        # 
        # - **false**: does not use the password preset in the image.
        self.password_inherit = password_inherit
        # The billing method of the instance. Set the value to Subscription.
        self.payment_type = payment_type
        # The subscription period of the instance. Valid values: **1** to **9** and **12**. Unit: months.
        # 
        # This parameter is required.
        self.period = period
        # The internal IP address. If this parameter is specified, you must specify the vSwitch ID. The vSwitch must be created first. Otherwise, an error is returned.
        self.private_ip_address = private_ip_address
        # Specifies whether a public IP address can be assigned to the specified instance. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.public_ip_identification = public_ip_identification
        # The number of instances.
        # 
        # This parameter is required.
        self.quantity = quantity
        # Specifies whether to automatically append sequential suffixes to the hostnames specified by the **HostName** parameter and instance names specified by the **InstanceName** parameter. The sequential suffixes range from **001** to **999**.
        # 
        # Examples: **LocalHost001** and **LocalHost002**, and **MyInstance001** and **MyInstance002**.
        # 
        # Default value: **false**.
        self.unique_suffix = unique_suffix
        # Custom data. The data starts with `#!`. The data can be at most 256 characters in length and 16 KB in size. Only custom scripts are supported and cannot be rendered by InstanceMetaData.
        # 
        # You can specify custom data. The data is encoded in Base64. The system does not encrypt your custom data when API requests are initiated. We recommend that you do not pass in confidential information such as passwords and private keys in plaintext. If you want to provide sensitive data such as passwords and private keys, encrypt the data and then encode it in Base64. The data is decrypted on the instance in the way it is encrypted.
        # 
        # For more information, see [User data formats](https://cloudinit.readthedocs.io/en/latest/topics/format.html).
        self.user_data = user_data
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id

    def validate(self):
        if self.data_disk:
            for k in self.data_disk:
                if k:
                    k.validate()
        if self.system_disk:
            self.system_disk.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataDisk'] = []
        if self.data_disk is not None:
            for k in self.data_disk:
                result['DataDisk'].append(k.to_map() if k else None)
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.auto_renew_period is not None:
            result['AutoRenewPeriod'] = self.auto_renew_period
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.ip_type is not None:
            result['IpType'] = self.ip_type
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.password is not None:
            result['Password'] = self.password
        if self.password_inherit is not None:
            result['PasswordInherit'] = self.password_inherit
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.period is not None:
            result['Period'] = self.period
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        if self.public_ip_identification is not None:
            result['PublicIpIdentification'] = self.public_ip_identification
        if self.quantity is not None:
            result['Quantity'] = self.quantity
        if self.unique_suffix is not None:
            result['UniqueSuffix'] = self.unique_suffix
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_disk = []
        if m.get('DataDisk') is not None:
            for k in m.get('DataDisk'):
                temp_model = CreateInstanceRequestDataDisk()
                self.data_disk.append(temp_model.from_map(k))
        if m.get('SystemDisk') is not None:
            temp_model = CreateInstanceRequestSystemDisk()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('AutoRenewPeriod') is not None:
            self.auto_renew_period = m.get('AutoRenewPeriod')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('IpType') is not None:
            self.ip_type = m.get('IpType')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('PasswordInherit') is not None:
            self.password_inherit = m.get('PasswordInherit')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        if m.get('PublicIpIdentification') is not None:
            self.public_ip_identification = m.get('PublicIpIdentification')
        if m.get('Quantity') is not None:
            self.quantity = m.get('Quantity')
        if m.get('UniqueSuffix') is not None:
            self.unique_suffix = m.get('UniqueSuffix')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class CreateInstanceResponseBodyInstanceIds(TeaModel):
    def __init__(
        self,
        instance_id: List[str] = None,
    ):
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class CreateInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        instance_ids: CreateInstanceResponseBodyInstanceIds = None,
        request_id: str = None,
    ):
        # The return code. A value of 0 indicates that the request is successful.
        # 
        # >  If you call this operation by using SDKs, the return value is of the integer type. If you call this operation by using common methods or HTTP requests, the return value is of the string type.
        self.code = code
        # The IDs of instances.
        self.instance_ids = instance_ids
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.instance_ids:
            self.instance_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('InstanceIds') is not None:
            temp_model = CreateInstanceResponseBodyInstanceIds()
            self.instance_ids = temp_model.from_map(m['InstanceIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateInstanceActiveOpsTaskRequest(TeaModel):
    def __init__(
        self,
        instance_ids: List[str] = None,
    ):
        self.instance_ids = instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        return self


class CreateInstanceActiveOpsTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        instance_ids_shrink: str = None,
    ):
        self.instance_ids_shrink = instance_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids_shrink is not None:
            result['InstanceIds'] = self.instance_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids_shrink = m.get('InstanceIds')
        return self


class CreateInstanceActiveOpsTaskResponseBody(TeaModel):
    def __init__(
        self,
        instance_active_ops_task: InstanceActiveOpsTask = None,
        request_id: str = None,
    ):
        self.instance_active_ops_task = instance_active_ops_task
        self.request_id = request_id

    def validate(self):
        if self.instance_active_ops_task:
            self.instance_active_ops_task.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_active_ops_task is not None:
            result['InstanceActiveOpsTask'] = self.instance_active_ops_task.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceActiveOpsTask') is not None:
            temp_model = InstanceActiveOpsTask()
            self.instance_active_ops_task = temp_model.from_map(m['InstanceActiveOpsTask'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateInstanceActiveOpsTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateInstanceActiveOpsTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateInstanceActiveOpsTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateKeyPairRequest(TeaModel):
    def __init__(
        self,
        key_pair_name: str = None,
    ):
        # The name of the key pair. The name must conform to the following naming conventions:
        # 
        # *   The name must be 2 to 128 characters in length, and can contain letters, digits, colons (:), underscores (_), and hyphens (-).
        # *   It must start with a letter but cannot start with `http://` or `https://`.
        # 
        # This parameter is required.
        self.key_pair_name = key_pair_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        return self


class CreateKeyPairResponseBody(TeaModel):
    def __init__(
        self,
        key_pair_finger_print: str = None,
        key_pair_id: str = None,
        key_pair_name: str = None,
        private_key_body: str = None,
        request_id: str = None,
    ):
        # The fingerprint of the key pair. The message-digest algorithm 5 (MD5) is used based on the public key fingerprint format defined in RFC 4716. For more information, see [RFC 4716](https://tools.ietf.org/html/rfc4716).
        self.key_pair_finger_print = key_pair_finger_print
        # The ID of the SSH key pair.
        self.key_pair_id = key_pair_id
        # The name of the key pair.
        self.key_pair_name = key_pair_name
        # The private key of the key pair. The private key is encoded with PEM in the PKCS#8 format.
        self.private_key_body = private_key_body
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_pair_finger_print is not None:
            result['KeyPairFingerPrint'] = self.key_pair_finger_print
        if self.key_pair_id is not None:
            result['KeyPairId'] = self.key_pair_id
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.private_key_body is not None:
            result['PrivateKeyBody'] = self.private_key_body
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('KeyPairFingerPrint') is not None:
            self.key_pair_finger_print = m.get('KeyPairFingerPrint')
        if m.get('KeyPairId') is not None:
            self.key_pair_id = m.get('KeyPairId')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('PrivateKeyBody') is not None:
            self.private_key_body = m.get('PrivateKeyBody')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateKeyPairResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateKeyPairResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateKeyPairResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLoadBalancerRequest(TeaModel):
    def __init__(
        self,
        billing_cycle: str = None,
        client_token: str = None,
        ens_region_id: str = None,
        load_balancer_name: str = None,
        load_balancer_spec: str = None,
        load_balancer_type: str = None,
        network_id: str = None,
        pay_type: str = None,
        v_switch_id: str = None,
    ):
        self.billing_cycle = billing_cycle
        # The client token that is used to ensure the idempotence of the request. This prevents repeated operations caused by multiple retries.
        # 
        # *   You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
        # *   If you retry an API request with the same client token and request parameters after it has completed successfully, the result of the original request is returned. The server status does not change.
        # *   You can initiate a retry when the operation times out or the error code is PROCESSING. The idempotence is valid. If HTTP status code 200 is returned, the client receives the same result as the last request. However, your server status is not affected. If HTTP status code 4xx is returned and error code is not PROCESSING, the idempotence is invalid.
        # *   A client token is valid for 10 minutes.
        self.client_token = client_token
        # The ID of the Edge Node Service (ENS) node.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        # The name of the ELB instance. The name must be 1 to 80 characters in length. If you leave this parameter empty, the system randomly allocates a name as the value of this parameter.
        # 
        # >  The value cannot start with `http://` or `https://`.
        self.load_balancer_name = load_balancer_name
        # The specification of the ELB instance.
        # 
        # This parameter is required.
        self.load_balancer_spec = load_balancer_spec
        self.load_balancer_type = load_balancer_type
        # The network ID of the created ELB instance.
        # 
        # This parameter is required.
        self.network_id = network_id
        # The billing method of the cluster. Valid value: PostPaid. PostPaid specifies the pay-as-you-go billing method.
        # 
        # This parameter is required.
        self.pay_type = pay_type
        # The ID of the vSwitch to which the internal-facing ELB instance belongs.
        # 
        # This parameter is required.
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.billing_cycle is not None:
            result['BillingCycle'] = self.billing_cycle
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.load_balancer_name is not None:
            result['LoadBalancerName'] = self.load_balancer_name
        if self.load_balancer_spec is not None:
            result['LoadBalancerSpec'] = self.load_balancer_spec
        if self.load_balancer_type is not None:
            result['LoadBalancerType'] = self.load_balancer_type
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.pay_type is not None:
            result['PayType'] = self.pay_type
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BillingCycle') is not None:
            self.billing_cycle = m.get('BillingCycle')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('LoadBalancerName') is not None:
            self.load_balancer_name = m.get('LoadBalancerName')
        if m.get('LoadBalancerSpec') is not None:
            self.load_balancer_spec = m.get('LoadBalancerSpec')
        if m.get('LoadBalancerType') is not None:
            self.load_balancer_type = m.get('LoadBalancerType')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('PayType') is not None:
            self.pay_type = m.get('PayType')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class CreateLoadBalancerResponseBody(TeaModel):
    def __init__(
        self,
        load_balancer_id: str = None,
        load_balancer_name: str = None,
        network_id: str = None,
        request_id: str = None,
        v_switch_id: str = None,
    ):
        # The ID of the ELB instance.
        self.load_balancer_id = load_balancer_id
        # The name of the ELB instance.
        self.load_balancer_name = load_balancer_name
        # The ID of the network.
        self.network_id = network_id
        # The ID of the request.
        self.request_id = request_id
        # The ID of the vSwitch to which the ELB instance belongs.
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.load_balancer_name is not None:
            result['LoadBalancerName'] = self.load_balancer_name
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('LoadBalancerName') is not None:
            self.load_balancer_name = m.get('LoadBalancerName')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class CreateLoadBalancerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLoadBalancerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLoadBalancerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLoadBalancerHTTPListenerRequest(TeaModel):
    def __init__(
        self,
        backend_server_port: int = None,
        description: str = None,
        forward_port: int = None,
        health_check: str = None,
        health_check_connect_port: int = None,
        health_check_domain: str = None,
        health_check_http_code: str = None,
        health_check_interval: int = None,
        health_check_method: str = None,
        health_check_timeout: int = None,
        health_check_uri: str = None,
        healthy_threshold: int = None,
        idle_timeout: int = None,
        listener_forward: str = None,
        listener_port: int = None,
        load_balancer_id: str = None,
        request_timeout: int = None,
        scheduler: str = None,
        unhealthy_threshold: int = None,
        xforwarded_for: str = None,
    ):
        # The port used by the backend server of the ELB instance. Valid values: **1** to **65535**.
        self.backend_server_port = backend_server_port
        # The name of the listener. The value must be **1** to **80** characters in length.
        # 
        # >  The value cannot start with `http://` or `https://`.
        self.description = description
        # The listener port that is used to redirect HTTP requests to HTTPS.
        self.forward_port = forward_port
        # Specifies whether to enable the health check feature. Valid values:
        # 
        # *   **on**\
        # *   **off** (default)
        # 
        # This parameter is required.
        self.health_check = health_check
        # The backend port that is used for health checks. Valid values: **1** to **65535**.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.health_check_connect_port = health_check_connect_port
        # The domain name that you want to use for health checks.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.health_check_domain = health_check_domain
        # The HTTP status code for a successful health check. Valid values:
        # 
        # *   **http_2xx** (default)
        # *   **http_3xx**\
        # *   **http_4xx**\
        # *   **http_5xx**\
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.health_check_http_code = health_check_http_code
        # The interval at which health checks are performed. Valid values: **1** to **50**. Default value: **2**. Unit: seconds.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.health_check_interval = health_check_interval
        # The HTTP request method for health checks. Valid values:
        # 
        # *   **head** (default)
        # *   **get**\
        # 
        # >  This parameter takes effect only if the HealthCheck parameter is set to on.
        self.health_check_method = health_check_method
        # The timeout period of a health check response. If a backend server does not respond within the specified timeout period, the server fails the health check.
        # 
        # *   Default value: 5.
        # *   Valid values: **1** to **300**.
        # *   Unit: seconds.
        # 
        # > 
        # 
        # *   This parameter takes effect only if the HealthCheck parameter is set to on.
        # 
        # *   If the value of HealthCheckTimeout is smaller than the value of HealthCheckInterval, the timeout period specified by HealthCheckTimeout becomes invalid, and the value of HealthCheckInterval is used as the timeout period.
        self.health_check_timeout = health_check_timeout
        # The URI used for health checks. The URI must be **1** to **80** characters in length.
        # 
        # > 
        # 
        # *   A URL must start with a forward slash (`/`) but cannot contain only forward slashes (`/`).
        # 
        # *   This parameter takes effect only if the HealthCheck parameter is set to on.
        self.health_check_uri = health_check_uri
        # The number of consecutive successful health checks that must occur before an unhealthy and inaccessible backend server is declared healthy and accessible. Valid values: **2** to **10**. Default value: **3**.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.healthy_threshold = healthy_threshold
        # The timeout period for idle connections. Default value: 15. Valid values: **1** to **60**. Unit: seconds.
        # 
        # >  If no request is received within the specified timeout period, ELB closes the connection. When a request is received, ELB creates a new connection.
        self.idle_timeout = idle_timeout
        # Specifies whether to enable redirection from HTTP to HTTPS. Valid values:
        # 
        # *   **on**\
        # *   **off** (default)
        self.listener_forward = listener_forward
        # The listener port that is used by Edge Load Balancer (ELB) to receive requests and forward the requests to backend servers. Valid values: **1** to **65535**.
        # 
        # >  We recommend that you use port 80 for HTTP.
        # 
        # This parameter is required.
        self.listener_port = listener_port
        # The ID of the Edge Load Balancer (ELB) instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id
        # The timeout period of a request. Default value: 60. Valid values: **1** to **180**. Unit: seconds.
        # 
        # >  If no response is received from the backend server within the specified timeout period, ALB returns an HTTP 504 error code to the client.
        self.request_timeout = request_timeout
        # The scheduling algorithm. Valid values:
        # 
        # *   **wrr** (default): Backend servers with higher weights receive more requests than backend servers with lower weights.
        # *   **wlc**: Requests are distributed based on the weights and number of connections to backend servers. If two backend servers have the same weight, the backend server that has fewer connections receives more requests.
        # *   **rr**: Requests are distributed to backend servers in sequence.
        # *   **sch**: consistent hashing based on source IP addresses. Requests from the same source IP address are distributed to the same backend server.
        # *   **qch**: consistent hashing based on QUIC connection IDs (CIDs). Requests that contain the same QUIC CID are distributed to the same backend server.
        # *   **iqch**: consistent hashing based on three specific bytes of iQUIC CIDs. Requests with the same second, third, and fourth bytes are distributed to the same backend server.
        self.scheduler = scheduler
        # The number of consecutive failed health checks that must occur before a healthy and accessible backend server is declared unhealthy and inaccessible. Valid values: **2** to **10**. Default value: **3**.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.unhealthy_threshold = unhealthy_threshold
        # Specifies whether to use the X-Forwarded-For header to obtain the real IP address of the client. Valid values:
        # 
        # *   **on**\
        # *   **off** (default)
        self.xforwarded_for = xforwarded_for

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backend_server_port is not None:
            result['BackendServerPort'] = self.backend_server_port
        if self.description is not None:
            result['Description'] = self.description
        if self.forward_port is not None:
            result['ForwardPort'] = self.forward_port
        if self.health_check is not None:
            result['HealthCheck'] = self.health_check
        if self.health_check_connect_port is not None:
            result['HealthCheckConnectPort'] = self.health_check_connect_port
        if self.health_check_domain is not None:
            result['HealthCheckDomain'] = self.health_check_domain
        if self.health_check_http_code is not None:
            result['HealthCheckHttpCode'] = self.health_check_http_code
        if self.health_check_interval is not None:
            result['HealthCheckInterval'] = self.health_check_interval
        if self.health_check_method is not None:
            result['HealthCheckMethod'] = self.health_check_method
        if self.health_check_timeout is not None:
            result['HealthCheckTimeout'] = self.health_check_timeout
        if self.health_check_uri is not None:
            result['HealthCheckURI'] = self.health_check_uri
        if self.healthy_threshold is not None:
            result['HealthyThreshold'] = self.healthy_threshold
        if self.idle_timeout is not None:
            result['IdleTimeout'] = self.idle_timeout
        if self.listener_forward is not None:
            result['ListenerForward'] = self.listener_forward
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.request_timeout is not None:
            result['RequestTimeout'] = self.request_timeout
        if self.scheduler is not None:
            result['Scheduler'] = self.scheduler
        if self.unhealthy_threshold is not None:
            result['UnhealthyThreshold'] = self.unhealthy_threshold
        if self.xforwarded_for is not None:
            result['XForwardedFor'] = self.xforwarded_for
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackendServerPort') is not None:
            self.backend_server_port = m.get('BackendServerPort')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ForwardPort') is not None:
            self.forward_port = m.get('ForwardPort')
        if m.get('HealthCheck') is not None:
            self.health_check = m.get('HealthCheck')
        if m.get('HealthCheckConnectPort') is not None:
            self.health_check_connect_port = m.get('HealthCheckConnectPort')
        if m.get('HealthCheckDomain') is not None:
            self.health_check_domain = m.get('HealthCheckDomain')
        if m.get('HealthCheckHttpCode') is not None:
            self.health_check_http_code = m.get('HealthCheckHttpCode')
        if m.get('HealthCheckInterval') is not None:
            self.health_check_interval = m.get('HealthCheckInterval')
        if m.get('HealthCheckMethod') is not None:
            self.health_check_method = m.get('HealthCheckMethod')
        if m.get('HealthCheckTimeout') is not None:
            self.health_check_timeout = m.get('HealthCheckTimeout')
        if m.get('HealthCheckURI') is not None:
            self.health_check_uri = m.get('HealthCheckURI')
        if m.get('HealthyThreshold') is not None:
            self.healthy_threshold = m.get('HealthyThreshold')
        if m.get('IdleTimeout') is not None:
            self.idle_timeout = m.get('IdleTimeout')
        if m.get('ListenerForward') is not None:
            self.listener_forward = m.get('ListenerForward')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('RequestTimeout') is not None:
            self.request_timeout = m.get('RequestTimeout')
        if m.get('Scheduler') is not None:
            self.scheduler = m.get('Scheduler')
        if m.get('UnhealthyThreshold') is not None:
            self.unhealthy_threshold = m.get('UnhealthyThreshold')
        if m.get('XForwardedFor') is not None:
            self.xforwarded_for = m.get('XForwardedFor')
        return self


class CreateLoadBalancerHTTPListenerResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateLoadBalancerHTTPListenerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLoadBalancerHTTPListenerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLoadBalancerHTTPListenerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLoadBalancerHTTPSListenerRequest(TeaModel):
    def __init__(
        self,
        backend_server_port: int = None,
        cookie: str = None,
        cookie_timeout: int = None,
        description: str = None,
        forward_port: int = None,
        health_check: str = None,
        health_check_connect_port: int = None,
        health_check_domain: str = None,
        health_check_http_code: str = None,
        health_check_interval: int = None,
        health_check_method: str = None,
        health_check_timeout: int = None,
        health_check_uri: str = None,
        healthy_threshold: int = None,
        idle_timeout: int = None,
        listener_forward: str = None,
        listener_port: int = None,
        load_balancer_id: str = None,
        request_timeout: int = None,
        scheduler: str = None,
        server_certificate_id: str = None,
        sticky_session_type: str = None,
        unhealthy_threshold: int = None,
    ):
        # The backend port that is used by the ELB instance. Valid values: **1** to **65535**.
        self.backend_server_port = backend_server_port
        # The cookie that is configured on the server. The cookie must be **1** to **200** characters in length and contain only ASCII characters and digits.
        # 
        # >  This parameter is required if you set StickySession to on and StickySessionType to server.
        self.cookie = cookie
        # The timeout period of a cookie. Valid values: **1** to **86400**. Unit: seconds.
        # 
        # >  This parameter is required if you set StickySession to on and StickySessionType to insert.
        self.cookie_timeout = cookie_timeout
        # The description of the listener. The description must be **1** to **80** characters in length.
        # 
        # >  The value cannot start with `http://` or `https://`.
        self.description = description
        # The listener port that is used to redirect HTTP requests to HTTPS.
        self.forward_port = forward_port
        # Indicates whether the health check feature is enabled. Valid values:
        # 
        # *   **on**\
        # *   **off**\
        # 
        # This parameter is required.
        self.health_check = health_check
        # The port that is used for health checks. Valid values: **1** to **65535**. If you leave this parameter empty, the port specified by BackendServerPort is used for health checks.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.health_check_connect_port = health_check_connect_port
        # The domain name that you want to use for health checks.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.health_check_domain = health_check_domain
        # The HTTP status code for a successful health check. Valid values:
        # 
        # *   **http_2xx** (default)
        # *   **http_3xx**\
        # *   **http_4xx**\
        # *   **http_5xx**\
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.health_check_http_code = health_check_http_code
        # The interval at which health checks are performed. Valid values: **1** to **50**. Default value: **2**. Unit: seconds.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.health_check_interval = health_check_interval
        # The HTTP request method for health checks. Valid values:
        # 
        # *   **head** (default): requests the head of the page.
        # *   **get**: requests the specified part of the page and returns the entity body.
        # 
        # >  This parameter takes effect only if the HealthCheck parameter is set to on.
        self.health_check_method = health_check_method
        # The timeout period of a health check response. If a backend server does not respond within the specified timeout period, the server fails to pass the health check.
        # 
        # *   Default value: 5.
        # *   Valid values: **1** to **300**.
        # *   Unit: seconds.
        # 
        # > 
        # 
        # *   This parameter takes effect only if the HealthCheck parameter is set to on.
        # 
        # *   If the value of HealthCheckTimeout is smaller than the value of HealthCheckInterval, the timeout period specified by HealthCheckTimeout becomes invalid, and the value of HealthCheckInterval is used as the timeout period.
        self.health_check_timeout = health_check_timeout
        # The URI used for health checks. The URI must be **1** to **80** characters in length.
        # 
        # >  A URL must start with a forward slash (`/`) but cannot contain only forward slashes (`/`).
        self.health_check_uri = health_check_uri
        # The number of consecutive successful health checks that must occur before an unhealthy and inaccessible backend server is declared healthy and accessible. Valid values: **2** to **10**. Default value: **3**.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.healthy_threshold = healthy_threshold
        # The timeout period for idle connections. Default value: 15. Valid values: **1** to **60**. Unit: seconds.
        # 
        # >  If no request is received within the specified timeout period, ELB closes the connection. When another request is received, ELB establishes a new connection.
        self.idle_timeout = idle_timeout
        # Specifies whether to enable redirection from HTTP to HTTPS. Valid values:
        # 
        # *   **on**\
        # *   **off** (default)
        self.listener_forward = listener_forward
        # The listening port that is used by Edge Load Balancer (ELB) to receive requests and forward the requests to backend servers. Valid values: **1** to **65535**.
        # 
        # >  We recommend that you use port 443 for HTTPS.
        # 
        # This parameter is required.
        self.listener_port = listener_port
        # The ID of the Edge Load Balancer (ELB) instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id
        # The timeout period of requests. Default value: 60. Valid values: **1** to **180**. Unit: seconds.
        # 
        # >  If no response is received from the backend server within the specified timeout period, ELB returns an HTTP 504 error code to the client.
        self.request_timeout = request_timeout
        # The scheduling algorithm. Valid values:
        # 
        # *   **wrr** (default): Backend servers with higher weights receive more requests than backend servers with lower weights.
        # *   **wlc**: Requests are distributed based on the weight and load of each backend server. The load refers to the number of connections on a backend server. If two backend servers have the same weight, the backend server that has fewer connections receives more requests.
        # *   **rr**: Requests are distributed to backend servers in sequence.
        # *   **sch**: consistent hashing based on source IP addresses. Requests from the same source IP address are distributed to the same backend server.
        # *   **qch**: consistent hashing based on QUIC connection IDs (CIDs). Requests that contain the same QUIC CID are distributed to the same backend server.
        # *   **iqch**: consistent hashing based on three specific bytes of iQUIC CIDs. Requests with the same second, third, and fourth bytes are distributed to the same backend server.
        self.scheduler = scheduler
        # The ID of the server certificate.
        # 
        # This parameter is required.
        self.server_certificate_id = server_certificate_id
        # The method that is used to handle cookies. Valid values:
        # 
        # *   **insert**: inserts a cookie. ELB inserts a session cookie (SERVERID) into the first HTTP or HTTPS response that is sent to a client. Subsequent requests to ELB carry this cookie, and ELB determines the destination servers of the requests based on the cookies.
        # *   **server**: rewrites the original cookie. SLB rewrites the custom cookies in requests from a client. Subsequent requests from the client that carry the new cookie are forwarded to the same backend server as the first request.
        # 
        # >  This parameter is required when the StickySession parameter is set to on.
        self.sticky_session_type = sticky_session_type
        # The number of consecutive failed health checks that must occur before a healthy and accessible backend server is declared unhealthy and inaccessible. Valid values: **2** to **10**. Default value: **3**.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.unhealthy_threshold = unhealthy_threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backend_server_port is not None:
            result['BackendServerPort'] = self.backend_server_port
        if self.cookie is not None:
            result['Cookie'] = self.cookie
        if self.cookie_timeout is not None:
            result['CookieTimeout'] = self.cookie_timeout
        if self.description is not None:
            result['Description'] = self.description
        if self.forward_port is not None:
            result['ForwardPort'] = self.forward_port
        if self.health_check is not None:
            result['HealthCheck'] = self.health_check
        if self.health_check_connect_port is not None:
            result['HealthCheckConnectPort'] = self.health_check_connect_port
        if self.health_check_domain is not None:
            result['HealthCheckDomain'] = self.health_check_domain
        if self.health_check_http_code is not None:
            result['HealthCheckHttpCode'] = self.health_check_http_code
        if self.health_check_interval is not None:
            result['HealthCheckInterval'] = self.health_check_interval
        if self.health_check_method is not None:
            result['HealthCheckMethod'] = self.health_check_method
        if self.health_check_timeout is not None:
            result['HealthCheckTimeout'] = self.health_check_timeout
        if self.health_check_uri is not None:
            result['HealthCheckURI'] = self.health_check_uri
        if self.healthy_threshold is not None:
            result['HealthyThreshold'] = self.healthy_threshold
        if self.idle_timeout is not None:
            result['IdleTimeout'] = self.idle_timeout
        if self.listener_forward is not None:
            result['ListenerForward'] = self.listener_forward
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.request_timeout is not None:
            result['RequestTimeout'] = self.request_timeout
        if self.scheduler is not None:
            result['Scheduler'] = self.scheduler
        if self.server_certificate_id is not None:
            result['ServerCertificateId'] = self.server_certificate_id
        if self.sticky_session_type is not None:
            result['StickySessionType'] = self.sticky_session_type
        if self.unhealthy_threshold is not None:
            result['UnhealthyThreshold'] = self.unhealthy_threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackendServerPort') is not None:
            self.backend_server_port = m.get('BackendServerPort')
        if m.get('Cookie') is not None:
            self.cookie = m.get('Cookie')
        if m.get('CookieTimeout') is not None:
            self.cookie_timeout = m.get('CookieTimeout')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ForwardPort') is not None:
            self.forward_port = m.get('ForwardPort')
        if m.get('HealthCheck') is not None:
            self.health_check = m.get('HealthCheck')
        if m.get('HealthCheckConnectPort') is not None:
            self.health_check_connect_port = m.get('HealthCheckConnectPort')
        if m.get('HealthCheckDomain') is not None:
            self.health_check_domain = m.get('HealthCheckDomain')
        if m.get('HealthCheckHttpCode') is not None:
            self.health_check_http_code = m.get('HealthCheckHttpCode')
        if m.get('HealthCheckInterval') is not None:
            self.health_check_interval = m.get('HealthCheckInterval')
        if m.get('HealthCheckMethod') is not None:
            self.health_check_method = m.get('HealthCheckMethod')
        if m.get('HealthCheckTimeout') is not None:
            self.health_check_timeout = m.get('HealthCheckTimeout')
        if m.get('HealthCheckURI') is not None:
            self.health_check_uri = m.get('HealthCheckURI')
        if m.get('HealthyThreshold') is not None:
            self.healthy_threshold = m.get('HealthyThreshold')
        if m.get('IdleTimeout') is not None:
            self.idle_timeout = m.get('IdleTimeout')
        if m.get('ListenerForward') is not None:
            self.listener_forward = m.get('ListenerForward')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('RequestTimeout') is not None:
            self.request_timeout = m.get('RequestTimeout')
        if m.get('Scheduler') is not None:
            self.scheduler = m.get('Scheduler')
        if m.get('ServerCertificateId') is not None:
            self.server_certificate_id = m.get('ServerCertificateId')
        if m.get('StickySessionType') is not None:
            self.sticky_session_type = m.get('StickySessionType')
        if m.get('UnhealthyThreshold') is not None:
            self.unhealthy_threshold = m.get('UnhealthyThreshold')
        return self


class CreateLoadBalancerHTTPSListenerResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateLoadBalancerHTTPSListenerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLoadBalancerHTTPSListenerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLoadBalancerHTTPSListenerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLoadBalancerTCPListenerRequest(TeaModel):
    def __init__(
        self,
        backend_server_port: int = None,
        description: str = None,
        eip_transmit: str = None,
        established_timeout: int = None,
        health_check_connect_port: int = None,
        health_check_connect_timeout: int = None,
        health_check_domain: str = None,
        health_check_http_code: str = None,
        health_check_interval: int = None,
        health_check_type: str = None,
        health_check_uri: str = None,
        healthy_threshold: int = None,
        listener_port: int = None,
        load_balancer_id: str = None,
        persistence_timeout: int = None,
        scheduler: str = None,
        unhealthy_threshold: int = None,
    ):
        # The port used by the backend ELB server of the ELB instance. Valid values: **1** to **65535**.
        self.backend_server_port = backend_server_port
        # The name of the listener. The value must be **1** to **80** characters in length.
        # 
        # >  The value cannot start with `http://` or `https://`.
        self.description = description
        # Specifies whether to enable elastic IP address (EIP) pass-through. Valid values:
        # 
        # *   **on**\
        # *   **off** (default)
        self.eip_transmit = eip_transmit
        # The timeout period of a connection. Valid values: **10** to **900**. Default value: **900**. Unit: seconds.
        self.established_timeout = established_timeout
        # The port that is used for health checks. Valid values: **1** to **65535**. If you leave this parameter empty, the port specified for BackendServerPort is used for health checks.
        self.health_check_connect_port = health_check_connect_port
        # The timeout period of a health check response. If a backend server does not respond within the specified timeout period, the server fails the health check.
        # 
        # *   Default value: 5.
        # *   Valid values: **1** to **300**.
        # *   Unit: seconds.
        # 
        # >  If the value of the HealthCheckConnectTimeout parameter is smaller than that of the HealthCheckInterval parameter, the timeout period specified by the HealthCheckConnectTimeout parameter is ignored and the period of time specified by the HealthCheckInterval parameter is used as the timeout period.
        self.health_check_connect_timeout = health_check_connect_timeout
        # The domain name that you want to use for health checks.
        self.health_check_domain = health_check_domain
        # The HTTP status codes for a successful health check. Valid values:
        # 
        # *   **http_2xx** (default)
        # *   **http_3xx**.
        # *   **http_4xx**\
        # *   **http_5xx**\
        self.health_check_http_code = health_check_http_code
        # The interval at which health checks are performed. Valid values: **1** to **50**. Default value: **2**. Unit: seconds.
        self.health_check_interval = health_check_interval
        # The type of health checks. Valid values:
        # 
        # *   **tcp** (default)
        # *   **http**\
        self.health_check_type = health_check_type
        # The Uniform Resource Identifier (URI) that you want to use for health checks. The URI must be **1** to **80** characters in length.
        # 
        # >  The URL must start with `/` and contain characters other than `/`.
        self.health_check_uri = health_check_uri
        # The number of consecutive successful health checks that must occur before an unhealthy and inaccessible backend server is declared healthy and accessible. Valid values: **2** to **10**. Default value: **3**.
        self.healthy_threshold = healthy_threshold
        # The listener port that is used by Edge Load Balancer (ELB) to receive requests and forward the requests to backend servers. Valid values: **1** to **65535**.
        # 
        # This parameter is required.
        self.listener_port = listener_port
        # The ID of the Edge Load Balancer (ELB) instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id
        # The timeout period of session persistence.
        # 
        # *   Default value: 0. If the default value is used, the system disables session persistence.
        # *   Valid values: **0** to **3600**.
        # *   Unit: seconds.
        self.persistence_timeout = persistence_timeout
        # The scheduling algorithm. Valid values:
        # 
        # *   **wrr** (default): Backend servers with higher weights receive more requests than backend servers with lower weights.
        # *   **wlc**: Requests are distributed based on the weights and number of connections to backend servers. If two backend servers have the same weight, the backend server that has fewer connections receives more requests.
        # *   **rr**: Requests are distributed to backend servers in sequence.
        # *   **sch**: consistent hashing based on source IP addresses. Requests from the same source IP address are distributed to the same backend server.
        # *   **qch**: consistent hashing based on QUIC connection IDs (CIDs). Requests that contain the same QUIC CID are distributed to the same backend server.
        # *   **iqch**: consistent hashing based on three specific bytes of iQUIC CIDs. Requests with the same second, third, and fourth bytes are distributed to the same backend server.
        self.scheduler = scheduler
        # The number of consecutive failed health checks that must occur before a healthy and accessible backend server is declared unhealthy and inaccessible. Valid values: **2** to **10**. Default value: **3**.
        self.unhealthy_threshold = unhealthy_threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backend_server_port is not None:
            result['BackendServerPort'] = self.backend_server_port
        if self.description is not None:
            result['Description'] = self.description
        if self.eip_transmit is not None:
            result['EipTransmit'] = self.eip_transmit
        if self.established_timeout is not None:
            result['EstablishedTimeout'] = self.established_timeout
        if self.health_check_connect_port is not None:
            result['HealthCheckConnectPort'] = self.health_check_connect_port
        if self.health_check_connect_timeout is not None:
            result['HealthCheckConnectTimeout'] = self.health_check_connect_timeout
        if self.health_check_domain is not None:
            result['HealthCheckDomain'] = self.health_check_domain
        if self.health_check_http_code is not None:
            result['HealthCheckHttpCode'] = self.health_check_http_code
        if self.health_check_interval is not None:
            result['HealthCheckInterval'] = self.health_check_interval
        if self.health_check_type is not None:
            result['HealthCheckType'] = self.health_check_type
        if self.health_check_uri is not None:
            result['HealthCheckURI'] = self.health_check_uri
        if self.healthy_threshold is not None:
            result['HealthyThreshold'] = self.healthy_threshold
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.persistence_timeout is not None:
            result['PersistenceTimeout'] = self.persistence_timeout
        if self.scheduler is not None:
            result['Scheduler'] = self.scheduler
        if self.unhealthy_threshold is not None:
            result['UnhealthyThreshold'] = self.unhealthy_threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackendServerPort') is not None:
            self.backend_server_port = m.get('BackendServerPort')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EipTransmit') is not None:
            self.eip_transmit = m.get('EipTransmit')
        if m.get('EstablishedTimeout') is not None:
            self.established_timeout = m.get('EstablishedTimeout')
        if m.get('HealthCheckConnectPort') is not None:
            self.health_check_connect_port = m.get('HealthCheckConnectPort')
        if m.get('HealthCheckConnectTimeout') is not None:
            self.health_check_connect_timeout = m.get('HealthCheckConnectTimeout')
        if m.get('HealthCheckDomain') is not None:
            self.health_check_domain = m.get('HealthCheckDomain')
        if m.get('HealthCheckHttpCode') is not None:
            self.health_check_http_code = m.get('HealthCheckHttpCode')
        if m.get('HealthCheckInterval') is not None:
            self.health_check_interval = m.get('HealthCheckInterval')
        if m.get('HealthCheckType') is not None:
            self.health_check_type = m.get('HealthCheckType')
        if m.get('HealthCheckURI') is not None:
            self.health_check_uri = m.get('HealthCheckURI')
        if m.get('HealthyThreshold') is not None:
            self.healthy_threshold = m.get('HealthyThreshold')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('PersistenceTimeout') is not None:
            self.persistence_timeout = m.get('PersistenceTimeout')
        if m.get('Scheduler') is not None:
            self.scheduler = m.get('Scheduler')
        if m.get('UnhealthyThreshold') is not None:
            self.unhealthy_threshold = m.get('UnhealthyThreshold')
        return self


class CreateLoadBalancerTCPListenerResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateLoadBalancerTCPListenerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLoadBalancerTCPListenerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLoadBalancerTCPListenerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLoadBalancerUDPListenerRequest(TeaModel):
    def __init__(
        self,
        backend_server_port: int = None,
        description: str = None,
        eip_transmit: str = None,
        established_timeout: int = None,
        health_check_connect_port: int = None,
        health_check_connect_timeout: int = None,
        health_check_exp: str = None,
        health_check_interval: int = None,
        health_check_req: str = None,
        healthy_threshold: int = None,
        listener_port: int = None,
        load_balancer_id: str = None,
        scheduler: str = None,
        unhealthy_threshold: int = None,
    ):
        # The port used by the backend ELB server of the ELB instance. Valid values: **1** to **65535**.
        self.backend_server_port = backend_server_port
        # The name of the listener. The value must be **1** to **80** characters in length.
        # 
        # >  The value cannot start with `http://` or `https://`.
        self.description = description
        # Specifies whether to enable Elastic IP address (EIP) pass-through. Valid values:
        # 
        # *   **on**\
        # *   **off** (default)
        self.eip_transmit = eip_transmit
        # The timeout period of a connection. Valid values: **10** to **900**. Default value: **900**. Unit: seconds.
        self.established_timeout = established_timeout
        # The port that is used for health checks. Valid values: **1** to **65535**. If you leave this parameter empty, the port specified by BackendServerPort is used for health checks.
        self.health_check_connect_port = health_check_connect_port
        # The timeout period for a health check response. If a backend server does not respond within the specified timeout period, the server fails the health check.
        # 
        # *   Default value: 5.
        # *   Valid values: **1** to **300**.
        # *   Unit: seconds.
        # 
        # >  If the value of the HealthCheckConnectTimeout parameter is smaller than that of the HealthCheckInterval parameter, the timeout period specified by the HealthCheckConnectTimeout parameter becomes invalid and the value of the HealthCheckInterval parameter is used as the timeout period.
        self.health_check_connect_timeout = health_check_connect_timeout
        # The response string for UDP listener health checks. The string can be up to 64 characters in length and can contain only letters and digits.
        self.health_check_exp = health_check_exp
        # The interval at which health checks are performed. Valid values: **1** to **50**. Default value: **2**. Unit: seconds.
        self.health_check_interval = health_check_interval
        # The request string for UDP listener health checks. The string can be up to 64 characters in length and can contain only letters and digits.
        self.health_check_req = health_check_req
        # The number of consecutive successful health checks that must occur before an unhealthy and inaccessible backend server is declared healthy and accessible. Valid values: **2** to **10**. Default value: **3**.
        self.healthy_threshold = healthy_threshold
        # The listener port that is used by Edge Load Balancer (ELB) to receive requests and forward the requests to backend servers. Valid values: **1** to **65535**.
        # 
        # >  You cannot specify ports 250, 4789, or 4790 for UDP listeners. They are system reserved ports.
        # 
        # This parameter is required.
        self.listener_port = listener_port
        # The ID of the Edge Load Balancer (ELB) instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id
        # The scheduling algorithm. Valid values:
        # 
        # *   **wrr**: Backend servers with higher weights receive more requests than backend servers with lower weights. This is the default value.
        # *   **wlc**: Requests are distributed based on the weight and load of each backend server. The load refers to the number of connections on a backend server. If two backend servers have the same weight, the backend server that has fewer connections receives more requests.
        # *   **rr**: Requests are distributed to backend servers in sequence.
        # *   **sch**: Consistent hashing that is based on source IP addresses. Requests from the same source IP address are distributed to the same backend server.
        # *   **qch**: Consistent hashing based on Quick UDP Internet Connection (QUIC) IDs. Requests that contain the same QUIC ID are scheduled to the same backend server.
        # *   **iqch**: Consistent hashing based on three specific bytes of iQUIC CID. Requests with the same second, third, and forth bytes are scheduled to the same backend server.
        self.scheduler = scheduler
        # The number of consecutive failed health checks that must occur before a healthy and accessible backend server is declared unhealthy and inaccessible. Valid values: **2** to **10**. Default value: **3**.
        self.unhealthy_threshold = unhealthy_threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backend_server_port is not None:
            result['BackendServerPort'] = self.backend_server_port
        if self.description is not None:
            result['Description'] = self.description
        if self.eip_transmit is not None:
            result['EipTransmit'] = self.eip_transmit
        if self.established_timeout is not None:
            result['EstablishedTimeout'] = self.established_timeout
        if self.health_check_connect_port is not None:
            result['HealthCheckConnectPort'] = self.health_check_connect_port
        if self.health_check_connect_timeout is not None:
            result['HealthCheckConnectTimeout'] = self.health_check_connect_timeout
        if self.health_check_exp is not None:
            result['HealthCheckExp'] = self.health_check_exp
        if self.health_check_interval is not None:
            result['HealthCheckInterval'] = self.health_check_interval
        if self.health_check_req is not None:
            result['HealthCheckReq'] = self.health_check_req
        if self.healthy_threshold is not None:
            result['HealthyThreshold'] = self.healthy_threshold
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.scheduler is not None:
            result['Scheduler'] = self.scheduler
        if self.unhealthy_threshold is not None:
            result['UnhealthyThreshold'] = self.unhealthy_threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackendServerPort') is not None:
            self.backend_server_port = m.get('BackendServerPort')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EipTransmit') is not None:
            self.eip_transmit = m.get('EipTransmit')
        if m.get('EstablishedTimeout') is not None:
            self.established_timeout = m.get('EstablishedTimeout')
        if m.get('HealthCheckConnectPort') is not None:
            self.health_check_connect_port = m.get('HealthCheckConnectPort')
        if m.get('HealthCheckConnectTimeout') is not None:
            self.health_check_connect_timeout = m.get('HealthCheckConnectTimeout')
        if m.get('HealthCheckExp') is not None:
            self.health_check_exp = m.get('HealthCheckExp')
        if m.get('HealthCheckInterval') is not None:
            self.health_check_interval = m.get('HealthCheckInterval')
        if m.get('HealthCheckReq') is not None:
            self.health_check_req = m.get('HealthCheckReq')
        if m.get('HealthyThreshold') is not None:
            self.healthy_threshold = m.get('HealthyThreshold')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('Scheduler') is not None:
            self.scheduler = m.get('Scheduler')
        if m.get('UnhealthyThreshold') is not None:
            self.unhealthy_threshold = m.get('UnhealthyThreshold')
        return self


class CreateLoadBalancerUDPListenerResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateLoadBalancerUDPListenerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLoadBalancerUDPListenerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLoadBalancerUDPListenerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMountTargetRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        file_system_id: str = None,
        mount_target_name: str = None,
        net_work_id: str = None,
    ):
        # The ID of the region.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        # The ID of the file system.
        # 
        # This parameter is required.
        self.file_system_id = file_system_id
        # The name of the mount target.
        # 
        # This parameter is required.
        self.mount_target_name = mount_target_name
        # The ID of the network.
        # 
        # This parameter is required.
        self.net_work_id = net_work_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.file_system_id is not None:
            result['FileSystemId'] = self.file_system_id
        if self.mount_target_name is not None:
            result['MountTargetName'] = self.mount_target_name
        if self.net_work_id is not None:
            result['NetWorkId'] = self.net_work_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('FileSystemId') is not None:
            self.file_system_id = m.get('FileSystemId')
        if m.get('MountTargetName') is not None:
            self.mount_target_name = m.get('MountTargetName')
        if m.get('NetWorkId') is not None:
            self.net_work_id = m.get('NetWorkId')
        return self


class CreateMountTargetResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        status: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The state of the mount target. Valid values:
        # 
        # *   active
        # *   inactive
        # *   pending
        # *   deleting
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class CreateMountTargetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateMountTargetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMountTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateNatGatewayRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of tag N of the instance. Valid values of N: **1** to **20**.
        # 
        # *   The key cannot start with `aliyun`, `acs:`, `http://`, or `https://`.
        # *   The key must be up to 64 characters in length.
        # *   The tag key cannot be an empty string.
        self.key = key
        # The value of tag N that is added to the resource. Valid values of N: 1 to 20. The tag value can be an empty string. The tag value can be up to 128 characters in length. It cannot start with acs: or contain http:// or https://.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateNatGatewayRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        instance_billing_cycle: str = None,
        instance_type: str = None,
        name: str = None,
        network_id: str = None,
        tag: List[CreateNatGatewayRequestTag] = None,
        v_switch_id: str = None,
    ):
        # The ID of the Edge Node Service (ENS) node.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        self.instance_billing_cycle = instance_billing_cycle
        # The instance type of the NAT gateway. Set the value to **enat.default**.
        self.instance_type = instance_type
        # The name of the NAT gateway. The name must be 1 to 128 characters in length. The name cannot start with `http://` or `https://`.
        self.name = name
        # The ID of the network.
        # 
        # This parameter is required.
        self.network_id = network_id
        # The tags.
        self.tag = tag
        # The ID of the new vSwitch.
        self.v_switch_id = v_switch_id

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_billing_cycle is not None:
            result['InstanceBillingCycle'] = self.instance_billing_cycle
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.name is not None:
            result['Name'] = self.name
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceBillingCycle') is not None:
            self.instance_billing_cycle = m.get('InstanceBillingCycle')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateNatGatewayRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class CreateNatGatewayResponseBody(TeaModel):
    def __init__(
        self,
        nat_gateway_id: str = None,
        request_id: str = None,
    ):
        # The ID of the NAT gateway.
        self.nat_gateway_id = nat_gateway_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nat_gateway_id is not None:
            result['NatGatewayId'] = self.nat_gateway_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NatGatewayId') is not None:
            self.nat_gateway_id = m.get('NatGatewayId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateNatGatewayResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateNatGatewayResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateNatGatewayResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateNetworkRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag that are to add to the instance. Valid values of N: **1** to **20**.
        # 
        # *   The key cannot start with `aliyun`, `acs:`, `http://`, or `https://`.
        # *   The key must be up to 64 characters in length.
        # *   The tag key cannot be an empty string.
        self.key = key
        # The value of tag N that is added to the resource. You can specify up to 20 tag values. The tag value can be an empty string. The tag value can be up to 128 characters in length. It cannot start with acs: or contain http:// or https://.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateNetworkRequest(TeaModel):
    def __init__(
        self,
        cidr_block: str = None,
        description: str = None,
        ens_region_id: str = None,
        network_name: str = None,
        tag: List[CreateNetworkRequestTag] = None,
    ):
        # The CIDR block of the network. You can use one of the following CIDR blocks or their subnets as the CIDR block of the network:
        # 
        # *   10.0.0.0/8 (default)
        # *   172.16.0.0/12
        # *   192.168.0.0/16
        # 
        # This parameter is required.
        self.cidr_block = cidr_block
        # The description of the network.
        # 
        # The description must be 2 to 256 characters in length. It must start with a letter but cannot start with http:// or https://.
        self.description = description
        # The ID of the edge node.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        # The name of the network. The name must meet the following requirements:
        # 
        # *   The name must be 2 to 128 characters in length.
        # *   The name must start with a letter but cannot start with http:// or https://.
        # *   The name can contain letters, digits, colons (:), underscores (_), and hyphens (-).
        self.network_name = network_name
        # The resource tags.
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.description is not None:
            result['Description'] = self.description
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.network_name is not None:
            result['NetworkName'] = self.network_name
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('NetworkName') is not None:
            self.network_name = m.get('NetworkName')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateNetworkRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class CreateNetworkResponseBody(TeaModel):
    def __init__(
        self,
        network_id: str = None,
        request_id: str = None,
    ):
        # The ID of the network.
        self.network_id = network_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateNetworkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateNetworkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateNetworkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateNetworkAclRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        network_acl_name: str = None,
    ):
        # The description of the network ACL.
        # 
        # The description must be 1 to 256 characters in length and cannot start with http:// or https://.
        self.description = description
        # Enter a name for the network ACL.
        # 
        # The name must be 1 to 128 characters in length and cannot start with http:// or https://.
        self.network_acl_name = network_acl_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.network_acl_name is not None:
            result['NetworkAclName'] = self.network_acl_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('NetworkAclName') is not None:
            self.network_acl_name = m.get('NetworkAclName')
        return self


class CreateNetworkAclResponseBody(TeaModel):
    def __init__(
        self,
        network_acl_id: str = None,
        request_id: str = None,
    ):
        # The ID of the network ACL.
        self.network_acl_id = network_acl_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_acl_id is not None:
            result['NetworkAclId'] = self.network_acl_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkAclId') is not None:
            self.network_acl_id = m.get('NetworkAclId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateNetworkAclResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateNetworkAclResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateNetworkAclResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateNetworkAclEntryRequest(TeaModel):
    def __init__(
        self,
        cidr_block: str = None,
        description: str = None,
        destination_cidr_block: str = None,
        direction: str = None,
        network_acl_entry_name: str = None,
        network_acl_id: str = None,
        policy: str = None,
        port_range: str = None,
        priority: int = None,
        protocol: str = None,
    ):
        # The source CIDR block.
        # 
        # This parameter is required.
        self.cidr_block = cidr_block
        # The description of the network ACL.
        # 
        # The description must be 1 to 256 characters in length and cannot start with http:// or https://.
        self.description = description
        self.destination_cidr_block = destination_cidr_block
        # The direction in which the rule is applied. Valid values:
        # 
        # *   **ingress**\
        # *   **egress**\
        # 
        # This parameter is required.
        self.direction = direction
        # The name of the rule.
        # 
        # The name must be 1 to 128 characters in length and cannot start with http:// or https://.
        self.network_acl_entry_name = network_acl_entry_name
        # The ID of the network ACL.
        # 
        # This parameter is required.
        self.network_acl_id = network_acl_id
        # The action that is performed on network traffic that matches the rule. Valid values:
        # 
        # *   **accept**: allows network traffic.
        # *   **drop**: blocks network traffic.
        # 
        # This parameter is required.
        self.policy = policy
        # The port range.
        # 
        # *   If you set **Protocol** to **all** or **icmp**, set this parameter to -1/-1, which specifies all ports.
        # *   If you set **Protocol** to **tcp** or **udp**, the port can be **1 to 65535**. You can set this parameter to **1/200** or **80/80**, which specifies ports 1 to 200 or port 80.
        # 
        # This parameter is required.
        self.port_range = port_range
        # The priority of the rule. Valid values: **1 to 100**. Default value: **1**.
        # 
        # This parameter is required.
        self.priority = priority
        # The type of the protocol. Valid values:
        # 
        # *   **icmp**: ICMP
        # *   **tcp**: TCP
        # *   **udp**: UDP
        # *   **all**: all protocols
        # 
        # This parameter is required.
        self.protocol = protocol

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.description is not None:
            result['Description'] = self.description
        if self.destination_cidr_block is not None:
            result['DestinationCidrBlock'] = self.destination_cidr_block
        if self.direction is not None:
            result['Direction'] = self.direction
        if self.network_acl_entry_name is not None:
            result['NetworkAclEntryName'] = self.network_acl_entry_name
        if self.network_acl_id is not None:
            result['NetworkAclId'] = self.network_acl_id
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestinationCidrBlock') is not None:
            self.destination_cidr_block = m.get('DestinationCidrBlock')
        if m.get('Direction') is not None:
            self.direction = m.get('Direction')
        if m.get('NetworkAclEntryName') is not None:
            self.network_acl_entry_name = m.get('NetworkAclEntryName')
        if m.get('NetworkAclId') is not None:
            self.network_acl_id = m.get('NetworkAclId')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        return self


class CreateNetworkAclEntryResponseBody(TeaModel):
    def __init__(
        self,
        network_acl_entry_id: str = None,
        request_id: str = None,
    ):
        # The ID of the network ACL.
        self.network_acl_entry_id = network_acl_entry_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_acl_entry_id is not None:
            result['NetworkAclEntryId'] = self.network_acl_entry_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkAclEntryId') is not None:
            self.network_acl_entry_id = m.get('NetworkAclEntryId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateNetworkAclEntryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateNetworkAclEntryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateNetworkAclEntryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateNetworkInterfaceRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        security_group_ids: List[str] = None,
        v_switch_id: str = None,
    ):
        self.description = description
        self.name = name
        # This parameter is required.
        self.security_group_ids = security_group_ids
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SecurityGroupIds') is not None:
            self.security_group_ids = m.get('SecurityGroupIds')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class CreateNetworkInterfaceShrinkRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        security_group_ids_shrink: str = None,
        v_switch_id: str = None,
    ):
        self.description = description
        self.name = name
        # This parameter is required.
        self.security_group_ids_shrink = security_group_ids_shrink
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.security_group_ids_shrink is not None:
            result['SecurityGroupIds'] = self.security_group_ids_shrink
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SecurityGroupIds') is not None:
            self.security_group_ids_shrink = m.get('SecurityGroupIds')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class CreateNetworkInterfaceResponseBody(TeaModel):
    def __init__(
        self,
        network_interface_ids: List[str] = None,
        request_id: str = None,
    ):
        self.network_interface_ids = network_interface_ids
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_interface_ids is not None:
            result['NetworkInterfaceIds'] = self.network_interface_ids
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkInterfaceIds') is not None:
            self.network_interface_ids = m.get('NetworkInterfaceIds')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateNetworkInterfaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateNetworkInterfaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateNetworkInterfaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSDGRequest(TeaModel):
    def __init__(
        self,
        billing_cycle: str = None,
        description: str = None,
        disk_type: str = None,
        from_sdgid: str = None,
        instance_id: str = None,
        size: str = None,
    ):
        self.billing_cycle = billing_cycle
        # The description of the SDG.
        # 
        # >  We recommend that you specify this parameter in details for subsequent queries.
        self.description = description
        self.disk_type = disk_type
        # The ID of the SDG from which you want to create an SDG.
        # 
        # > 
        # 
        # *   The first time you create an SDG, the **FromSDGId** parameter is empty.
        # 
        # *   If the value of the **FromSDGId** parameter is invalid or does not correspond to an original disk, an error is reported.
        # 
        # *   If the value of the **FromSDGId** parameter is not empty, you have created an SDG, and the operation is performed on the existing SDG.
        self.from_sdgid = from_sdgid
        # The ID of the AIC instance. You can call the [DescribeARMServerInstances](~~DescribeARMServerInstances~~) operation to query the ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The maximum capacity of the SDG. Unit: GB.
        # 
        # > 
        # 
        # *   To save costs, we recommend that you specify this parameter based on your business requirements.
        # 
        # *   The first time that you create an SDG, the **Size** parameter is required.
        # 
        # *   When the amount of data increases, you can pass a new **Size** parameter for resizing. If the value of the new **Size** parameter is greater than the value of the old **Size** parameter, the disk size of the SDG is increased to the size that is specified by the new **Size** parameter. If the value of the new **Size** parameter is empty or smaller than that of the old **Size** parameter, no operation is performed.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.billing_cycle is not None:
            result['BillingCycle'] = self.billing_cycle
        if self.description is not None:
            result['Description'] = self.description
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.from_sdgid is not None:
            result['FromSDGId'] = self.from_sdgid
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BillingCycle') is not None:
            self.billing_cycle = m.get('BillingCycle')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('FromSDGId') is not None:
            self.from_sdgid = m.get('FromSDGId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class CreateSDGResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        sdgid: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The ID of the generated SDG.
        self.sdgid = sdgid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class CreateSDGResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSDGResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSDGResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSecurityGroupRequestPermissions(TeaModel):
    def __init__(
        self,
        description: str = None,
        dest_cidr_ip: str = None,
        direction: str = None,
        ip_protocol: str = None,
        policy: str = None,
        port_range: str = None,
        priority: int = None,
        source_cidr_ip: str = None,
        source_port_range: str = None,
    ):
        # The description. It must be 2 to 256 characters in length and cannot start with http:// or https://.
        self.description = description
        # The destination IPv4 CIDR block. IPv4 CIDR blocks and IPv4 addresses are supported.
        self.dest_cidr_ip = dest_cidr_ip
        # The direction in which the security group rule is applied.
        # 
        # *   egress
        # *   ingress
        # 
        # This parameter is required.
        self.direction = direction
        # The protocol type. Valid values:
        # 
        # *   TCP
        # *   UDP
        # *   ICMP
        # *   ALL: All protocols are supported.
        # 
        # This parameter is required.
        self.ip_protocol = ip_protocol
        # The action of the security group rule. Valid values:
        # 
        # *   Accept
        # *   Drop
        # 
        # This parameter is required.
        self.policy = policy
        # The range of destination port numbers for the protocols specified in the security group rule. Valid values:
        # 
        # *   If you set IpProtocol to TCP or UDP, the port number range is 1 to 65535. Specify a port range in the format of \\<Start port number>/\\<End port number>. Example: 1/200.
        # *   If you set IpProtocol to ICMP, the port number range is -1/-1.
        # *   If you set IpProtocol to ALL, the port number range is -1/-1.
        # 
        # This parameter is required.
        self.port_range = port_range
        # The priority of the security group rule. A smaller value specifies a higher priority. Valid values: 1 to 100.
        # 
        # This parameter is required.
        self.priority = priority
        # The source IPv4 CIDR block. IPv4 CIDR blocks and IPv4 addresses are supported.
        self.source_cidr_ip = source_cidr_ip
        # The range of source port numbers for the protocols specified in the security group rule. Valid values:
        # 
        # *   If you set IpProtocol to TCP or UDP, the port number range is 1 to 65535. Specify a port range in the format of \\<Start port number>/\\<End port number>. Example: 1/200.
        # *   If you set IpProtocol to ICMP, the port number range is -1/-1.
        # *   If you set IpProtocol to ALL, the port number range is -1/-1, which indicates all port numbers.
        self.source_port_range = source_port_range

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.dest_cidr_ip is not None:
            result['DestCidrIp'] = self.dest_cidr_ip
        if self.direction is not None:
            result['Direction'] = self.direction
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.source_cidr_ip is not None:
            result['SourceCidrIp'] = self.source_cidr_ip
        if self.source_port_range is not None:
            result['SourcePortRange'] = self.source_port_range
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestCidrIp') is not None:
            self.dest_cidr_ip = m.get('DestCidrIp')
        if m.get('Direction') is not None:
            self.direction = m.get('Direction')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('SourceCidrIp') is not None:
            self.source_cidr_ip = m.get('SourceCidrIp')
        if m.get('SourcePortRange') is not None:
            self.source_port_range = m.get('SourcePortRange')
        return self


class CreateSecurityGroupRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        permissions: List[CreateSecurityGroupRequestPermissions] = None,
        security_group_name: str = None,
    ):
        # The description. The description must be 2 to 256 characters in length. It must start with a letter but cannot start with http:// or https://.
        self.description = description
        # An array of security group rules. You can specify up to 200 IDs of security group rules.
        self.permissions = permissions
        # The name of the security group. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (_), and hyphens (-). It must start with a letter but cannot start with http:// or https://. It can contain letters, digits, colons (:), underscores (_), and hyphens (-). By default, this parameter is empty.
        self.security_group_name = security_group_name

    def validate(self):
        if self.permissions:
            for k in self.permissions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        result['Permissions'] = []
        if self.permissions is not None:
            for k in self.permissions:
                result['Permissions'].append(k.to_map() if k else None)
        if self.security_group_name is not None:
            result['SecurityGroupName'] = self.security_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.permissions = []
        if m.get('Permissions') is not None:
            for k in m.get('Permissions'):
                temp_model = CreateSecurityGroupRequestPermissions()
                self.permissions.append(temp_model.from_map(k))
        if m.get('SecurityGroupName') is not None:
            self.security_group_name = m.get('SecurityGroupName')
        return self


class CreateSecurityGroupShrinkRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        permissions_shrink: str = None,
        security_group_name: str = None,
    ):
        # The description. The description must be 2 to 256 characters in length. It must start with a letter but cannot start with http:// or https://.
        self.description = description
        # An array of security group rules. You can specify up to 200 IDs of security group rules.
        self.permissions_shrink = permissions_shrink
        # The name of the security group. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (_), and hyphens (-). It must start with a letter but cannot start with http:// or https://. It can contain letters, digits, colons (:), underscores (_), and hyphens (-). By default, this parameter is empty.
        self.security_group_name = security_group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.permissions_shrink is not None:
            result['Permissions'] = self.permissions_shrink
        if self.security_group_name is not None:
            result['SecurityGroupName'] = self.security_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Permissions') is not None:
            self.permissions_shrink = m.get('Permissions')
        if m.get('SecurityGroupName') is not None:
            self.security_group_name = m.get('SecurityGroupName')
        return self


class CreateSecurityGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        security_group_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The ID of the security group.
        self.security_group_id = security_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class CreateSecurityGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSecurityGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSecurityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSnapshotRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        disk_id: str = None,
        ens_region_id: str = None,
        instance_billing_cycle: str = None,
        snapshot_name: str = None,
    ):
        # The description of the snapshot. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        # 
        # By default, this parameter is left empty.
        self.description = description
        # The ID of the cloud disk.
        # 
        # This parameter is required.
        self.disk_id = disk_id
        # The ID of the edge node.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        self.instance_billing_cycle = instance_billing_cycle
        # The name of the snapshot. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (_), and hyphens (-).
        self.snapshot_name = snapshot_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_billing_cycle is not None:
            result['InstanceBillingCycle'] = self.instance_billing_cycle
        if self.snapshot_name is not None:
            result['SnapshotName'] = self.snapshot_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceBillingCycle') is not None:
            self.instance_billing_cycle = m.get('InstanceBillingCycle')
        if m.get('SnapshotName') is not None:
            self.snapshot_name = m.get('SnapshotName')
        return self


class CreateSnapshotResponseBody(TeaModel):
    def __init__(
        self,
        order_id: str = None,
        request_id: str = None,
        snap_shot_id: List[str] = None,
    ):
        # The ID of the order.
        self.order_id = order_id
        # The request ID.
        self.request_id = request_id
        # The IDs of the snapshots.
        self.snap_shot_id = snap_shot_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snap_shot_id is not None:
            result['SnapShotId'] = self.snap_shot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnapShotId') is not None:
            self.snap_shot_id = m.get('SnapShotId')
        return self


class CreateSnapshotResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSnapshotResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSnapshotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSnatEntryRequest(TeaModel):
    def __init__(
        self,
        eip_affinity: bool = None,
        idle_timeout: int = None,
        isp_affinity: bool = None,
        nat_gateway_id: str = None,
        snat_entry_name: str = None,
        snat_ip: str = None,
        source_cidr: str = None,
        source_network_id: str = None,
        source_vswitch_id: str = None,
        standby_snat_ip: str = None,
    ):
        # Specifies whether to enable IP affinity. If you do not specify this parameter, IP affinity is enabled by default. Valid values:
        # 
        # *   **false**\
        # *   **true**\
        # 
        # >  After you enable IP affinity, if multiple EIPs are associated with an SNAT entry, one client uses the same EIP to for communication. If IP affinity is disabled, the client uses a random EIP for communication.
        self.eip_affinity = eip_affinity
        # The timeout period for idle connections. Valid values: **1** to **86400**. Unit: seconds.
        self.idle_timeout = idle_timeout
        # Whether to enable operator affinity. Value taking:
        # 
        # - false:Do not open.
        # - true:Open.
        self.isp_affinity = isp_affinity
        # The ID of the Network Address Translation (NAT) gateway.
        # 
        # This parameter is required.
        self.nat_gateway_id = nat_gateway_id
        # The name of the SNAT entry. The name must be 1 to 128 characters in length. The name cannot start with `http://` or `https://`.
        self.snat_entry_name = snat_entry_name
        # The elastic IP address (EIP) in the SNAT entry. Separate multiple EIPs with commas (,).
        # 
        # This parameter is required.
        self.snat_ip = snat_ip
        # The CIDR block. You can specify the CIDR block of a network, a vSwitch, or an instance. You can also specify a custom CIDR block. All instances within the CIDR block can access the Internet or external networks by using SNAT.
        # 
        # >  If you specify **SourceVSwitchId** and **SourceCIDR**, **SourceVSwitchId** does not take effect. The value that you specified for **SourceCIDR** takes precedence.
        self.source_cidr = source_cidr
        # The ID of the network. This parameter specifies that all ENS instances in the network can use the SNAT entry to access the Internet.
        # 
        # >  If you specify **SourceNetworkId** and **SourceVSwitchId** or **SourceCIDR**, **SourceNetworkId** does not take effect. The value that you specified for **SourceCIDR** takes precedence. Priority: **SourceCIDR** > **SourceVSwitchId** > **SourceNetworkId**.
        self.source_network_id = source_network_id
        # The ID of the vSwitch that you need to access over the Internet. This parameter specifies that Edge Node Service (ENS) instances in the vSwitch can use the SNAT entry to access the Internet.
        # 
        # >  If you specify **SourceVSwitchId** and **SourceCIDR**, **SourceVSwitchId** does not take effect. The value that you specified for **SourceCIDR** takes precedence.
        self.source_vswitch_id = source_vswitch_id
        # The secondary EIP in the SNAT entry. Separate multiple secondary EIPs with commas (,).
        self.standby_snat_ip = standby_snat_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.eip_affinity is not None:
            result['EipAffinity'] = self.eip_affinity
        if self.idle_timeout is not None:
            result['IdleTimeout'] = self.idle_timeout
        if self.isp_affinity is not None:
            result['IspAffinity'] = self.isp_affinity
        if self.nat_gateway_id is not None:
            result['NatGatewayId'] = self.nat_gateway_id
        if self.snat_entry_name is not None:
            result['SnatEntryName'] = self.snat_entry_name
        if self.snat_ip is not None:
            result['SnatIp'] = self.snat_ip
        if self.source_cidr is not None:
            result['SourceCIDR'] = self.source_cidr
        if self.source_network_id is not None:
            result['SourceNetworkId'] = self.source_network_id
        if self.source_vswitch_id is not None:
            result['SourceVSwitchId'] = self.source_vswitch_id
        if self.standby_snat_ip is not None:
            result['StandbySnatIp'] = self.standby_snat_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EipAffinity') is not None:
            self.eip_affinity = m.get('EipAffinity')
        if m.get('IdleTimeout') is not None:
            self.idle_timeout = m.get('IdleTimeout')
        if m.get('IspAffinity') is not None:
            self.isp_affinity = m.get('IspAffinity')
        if m.get('NatGatewayId') is not None:
            self.nat_gateway_id = m.get('NatGatewayId')
        if m.get('SnatEntryName') is not None:
            self.snat_entry_name = m.get('SnatEntryName')
        if m.get('SnatIp') is not None:
            self.snat_ip = m.get('SnatIp')
        if m.get('SourceCIDR') is not None:
            self.source_cidr = m.get('SourceCIDR')
        if m.get('SourceNetworkId') is not None:
            self.source_network_id = m.get('SourceNetworkId')
        if m.get('SourceVSwitchId') is not None:
            self.source_vswitch_id = m.get('SourceVSwitchId')
        if m.get('StandbySnatIp') is not None:
            self.standby_snat_ip = m.get('StandbySnatIp')
        return self


class CreateSnatEntryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        snat_entry_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The ID of the SNAT entry.
        self.snat_entry_id = snat_entry_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snat_entry_id is not None:
            result['SnatEntryId'] = self.snat_entry_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnatEntryId') is not None:
            self.snat_entry_id = m.get('SnatEntryId')
        return self


class CreateSnatEntryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSnatEntryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSnatEntryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateStorageGatewayRequestOrderDetails(TeaModel):
    def __init__(
        self,
        description: str = None,
        ens_region_id: str = None,
        gateway_name: str = None,
        gateway_type: str = None,
        vpc_id: str = None,
    ):
        # The description of the gateway. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.description = description
        # The ID of the node.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        # The name of the gateway. The name must be 2 to 128 characters in length. The name must start with a letter and cannot start with `http://` or `https://`. The name can contain letters, digits, colons (.), underscores (_), and hyphens (-).
        self.gateway_name = gateway_name
        # The type of the gateway. Set this parameter to **1**. **1** indicates iSCSI.
        # 
        # This parameter is required.
        self.gateway_type = gateway_type
        # The ID of the VPC.
        # 
        # This parameter is required.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.gateway_name is not None:
            result['GatewayName'] = self.gateway_name
        if self.gateway_type is not None:
            result['GatewayType'] = self.gateway_type
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('GatewayName') is not None:
            self.gateway_name = m.get('GatewayName')
        if m.get('GatewayType') is not None:
            self.gateway_type = m.get('GatewayType')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class CreateStorageGatewayRequest(TeaModel):
    def __init__(
        self,
        order_details: List[CreateStorageGatewayRequestOrderDetails] = None,
    ):
        # The array of orders.
        # 
        # This parameter is required.
        self.order_details = order_details

    def validate(self):
        if self.order_details:
            for k in self.order_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OrderDetails'] = []
        if self.order_details is not None:
            for k in self.order_details:
                result['OrderDetails'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.order_details = []
        if m.get('OrderDetails') is not None:
            for k in m.get('OrderDetails'):
                temp_model = CreateStorageGatewayRequestOrderDetails()
                self.order_details.append(temp_model.from_map(k))
        return self


class CreateStorageGatewayShrinkRequest(TeaModel):
    def __init__(
        self,
        order_details_shrink: str = None,
    ):
        # The array of orders.
        # 
        # This parameter is required.
        self.order_details_shrink = order_details_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_details_shrink is not None:
            result['OrderDetails'] = self.order_details_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderDetails') is not None:
            self.order_details_shrink = m.get('OrderDetails')
        return self


class CreateStorageGatewayResponseBodyAllocationId(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        instance_id: str = None,
    ):
        # The ID of the node.
        self.ens_region_id = ens_region_id
        # The ID of the instance.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class CreateStorageGatewayResponseBodyUnAllocationId(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        instance_id: str = None,
    ):
        # The ID of the node.
        self.ens_region_id = ens_region_id
        # The ID of the instance.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class CreateStorageGatewayResponseBody(TeaModel):
    def __init__(
        self,
        allocation_id: List[CreateStorageGatewayResponseBodyAllocationId] = None,
        biz_status_code: str = None,
        request_id: str = None,
        un_allocation_id: List[CreateStorageGatewayResponseBodyUnAllocationId] = None,
    ):
        # The list of created nodes.
        self.allocation_id = allocation_id
        # The success status code.
        # 
        # *   **PartSuccess**: partially succeeded.
        # *   **AllSuccess**: all succeeded.
        self.biz_status_code = biz_status_code
        # The request ID.
        self.request_id = request_id
        # The list of nodes that are not created.
        self.un_allocation_id = un_allocation_id

    def validate(self):
        if self.allocation_id:
            for k in self.allocation_id:
                if k:
                    k.validate()
        if self.un_allocation_id:
            for k in self.un_allocation_id:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AllocationId'] = []
        if self.allocation_id is not None:
            for k in self.allocation_id:
                result['AllocationId'].append(k.to_map() if k else None)
        if self.biz_status_code is not None:
            result['BizStatusCode'] = self.biz_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['UnAllocationId'] = []
        if self.un_allocation_id is not None:
            for k in self.un_allocation_id:
                result['UnAllocationId'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.allocation_id = []
        if m.get('AllocationId') is not None:
            for k in m.get('AllocationId'):
                temp_model = CreateStorageGatewayResponseBodyAllocationId()
                self.allocation_id.append(temp_model.from_map(k))
        if m.get('BizStatusCode') is not None:
            self.biz_status_code = m.get('BizStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.un_allocation_id = []
        if m.get('UnAllocationId') is not None:
            for k in m.get('UnAllocationId'):
                temp_model = CreateStorageGatewayResponseBodyUnAllocationId()
                self.un_allocation_id.append(temp_model.from_map(k))
        return self


class CreateStorageGatewayResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateStorageGatewayResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateStorageGatewayResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateStorageVolumeRequest(TeaModel):
    def __init__(
        self,
        auth_password: str = None,
        auth_protocol: str = None,
        auth_user: str = None,
        description: str = None,
        ens_region_id: str = None,
        gateway_id: str = None,
        is_auth: str = None,
        is_enable: str = None,
        storage_id: str = None,
        volume_name: str = None,
    ):
        # The password of the CHAP protocol.
        self.auth_password = auth_password
        # The authentication protocol. Set the value to **CHAP**.
        self.auth_protocol = auth_protocol
        # The username of the CHAP protocol.
        self.auth_user = auth_user
        # The description of the volume. The description must be 2 to 128 characters in length. The description cannot start with `http://` or `https://`.
        self.description = description
        # The ID of the node.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        # The ID of the gateway.
        # 
        # This parameter is required.
        self.gateway_id = gateway_id
        # Specifies whether to enable authentication. Valid values:
        # 
        # *   **1**: Authentication is enabled.
        # *   **0** (default): Authentication is disabled.
        self.is_auth = is_auth
        # Indicates whether the volume is enabled. Valid values:
        # 
        # *   **1** (default): The volume is enabled.
        # *   **0**: The volume is disabled.
        self.is_enable = is_enable
        # The ID of the storage medium.
        # 
        # This parameter is required.
        self.storage_id = storage_id
        # The name of the volume. The name must be 2 to 128 characters in length. The name cannot start with `http://` or `https://`. The name can contain letters, digits, colons (:), underscores (_), and hyphens (-).
        self.volume_name = volume_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_password is not None:
            result['AuthPassword'] = self.auth_password
        if self.auth_protocol is not None:
            result['AuthProtocol'] = self.auth_protocol
        if self.auth_user is not None:
            result['AuthUser'] = self.auth_user
        if self.description is not None:
            result['Description'] = self.description
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.gateway_id is not None:
            result['GatewayId'] = self.gateway_id
        if self.is_auth is not None:
            result['IsAuth'] = self.is_auth
        if self.is_enable is not None:
            result['IsEnable'] = self.is_enable
        if self.storage_id is not None:
            result['StorageId'] = self.storage_id
        if self.volume_name is not None:
            result['VolumeName'] = self.volume_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthPassword') is not None:
            self.auth_password = m.get('AuthPassword')
        if m.get('AuthProtocol') is not None:
            self.auth_protocol = m.get('AuthProtocol')
        if m.get('AuthUser') is not None:
            self.auth_user = m.get('AuthUser')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('GatewayId') is not None:
            self.gateway_id = m.get('GatewayId')
        if m.get('IsAuth') is not None:
            self.is_auth = m.get('IsAuth')
        if m.get('IsEnable') is not None:
            self.is_enable = m.get('IsEnable')
        if m.get('StorageId') is not None:
            self.storage_id = m.get('StorageId')
        if m.get('VolumeName') is not None:
            self.volume_name = m.get('VolumeName')
        return self


class CreateStorageVolumeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        volume_id: List[str] = None,
    ):
        # The request ID.
        self.request_id = request_id
        # An array of volume IDs.
        self.volume_id = volume_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.volume_id is not None:
            result['VolumeId'] = self.volume_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VolumeId') is not None:
            self.volume_id = m.get('VolumeId')
        return self


class CreateStorageVolumeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateStorageVolumeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateStorageVolumeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateVSwitchRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag that are to add to the instance. Valid values of N: **1** to **20**.
        # 
        # *   The key cannot start with `aliyun`, `acs:`, `http://`, or `https://`.
        # *   The key must be up to 64 characters in length.
        # *   The tag key cannot be an empty string.
        self.key = key
        # The value of tag N that is added to the resource. Valid values of N: 1 to 20. The tag value can be an empty string. The tag value can be up to 128 characters in length. It cannot start with acs: or contain http:// or https://.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateVSwitchRequest(TeaModel):
    def __init__(
        self,
        cidr_block: str = None,
        description: str = None,
        ens_region_id: str = None,
        network_id: str = None,
        tag: List[CreateVSwitchRequestTag] = None,
        v_switch_name: str = None,
    ):
        # The CIDR block of the vSwitch. Take note of the following limits:
        # 
        # *   The subnet mask must be 16 to 29 bits in length.
        # *   The CIDR block of the vSwitch must fall within the CIDR block of the VPC to which the vSwitch belongs.
        # *   The CIDR block of the vSwitch cannot be the same as the destination CIDR block in a route entry of the VPC. However, it can be a subset of the destination CIDR block.
        # 
        # This parameter is required.
        self.cidr_block = cidr_block
        # The description of the vSwitch.
        # 
        # The description must be 2 to 256 characters in length. It must start with a letter but cannot start with http:// or https://.
        self.description = description
        # The ID of the edge node.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        # The ID of the network to which the vSwitch that you want to create belongs.
        self.network_id = network_id
        # The tags.
        self.tag = tag
        # The name of the vSwitch. The name must meet the following requirements:
        # 
        # *   The name must be 2 to 128 characters in length.
        # *   The name must start with a letter and cannot start with http:// or https://. It can contain letters, digits, colons (:), underscores (_), and hyphens (-).
        # 
        # Default value: null.
        self.v_switch_name = v_switch_name

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.description is not None:
            result['Description'] = self.description
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.v_switch_name is not None:
            result['VSwitchName'] = self.v_switch_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateVSwitchRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('VSwitchName') is not None:
            self.v_switch_name = m.get('VSwitchName')
        return self


class CreateVSwitchResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        v_switch_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class CreateVSwitchResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateVSwitchResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateVSwitchResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        timeout: int = None,
    ):
        # The ID of the application. To obtain the application ID, call the ListApplication operation.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The timeout period for the asynchronous release. Unit: seconds. Default value: 300.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class DeleteApplicationResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteBucketRequest(TeaModel):
    def __init__(
        self,
        bucket_name: str = None,
    ):
        # The name of the bucket that you want to delete. You can delete only one bucket at a time.
        # 
        # This parameter is required.
        self.bucket_name = bucket_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        return self


class DeleteBucketResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteBucketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteBucketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteBucketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteBucketLifecycleRequest(TeaModel):
    def __init__(
        self,
        bucket_name: str = None,
        rule_id: str = None,
    ):
        # The name of the bucket.
        # 
        # This parameter is required.
        self.bucket_name = bucket_name
        # The ID of the rule. If this parameter is not specified, all rules are removed.
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class DeleteBucketLifecycleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteBucketLifecycleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteBucketLifecycleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteBucketLifecycleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDiskRequest(TeaModel):
    def __init__(
        self,
        disk_id: str = None,
    ):
        # The ID of the disk.
        # 
        # This parameter is required.
        self.disk_id = disk_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        return self


class DeleteDiskResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        request_id: str = None,
    ):
        # The returned service code. 0 indicates that the request was successful.
        self.code = code
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDiskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDiskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDiskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEipRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DeleteEipResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteEipResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEipResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEipResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEnsRouteEntryRequest(TeaModel):
    def __init__(
        self,
        route_entry_id: str = None,
    ):
        # The ID of the route that you want to delete.
        # 
        # This parameter is required.
        self.route_entry_id = route_entry_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.route_entry_id is not None:
            result['RouteEntryId'] = self.route_entry_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RouteEntryId') is not None:
            self.route_entry_id = m.get('RouteEntryId')
        return self


class DeleteEnsRouteEntryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteEnsRouteEntryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEnsRouteEntryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEnsRouteEntryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEnsSaleConditionControlRequestSaleControlsConditionControls(TeaModel):
    def __init__(
        self,
        condition_control_module_code: str = None,
        condition_control_module_value: str = None,
    ):
        # This parameter is required.
        self.condition_control_module_code = condition_control_module_code
        # This parameter is required.
        self.condition_control_module_value = condition_control_module_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition_control_module_code is not None:
            result['ConditionControlModuleCode'] = self.condition_control_module_code
        if self.condition_control_module_value is not None:
            result['ConditionControlModuleValue'] = self.condition_control_module_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConditionControlModuleCode') is not None:
            self.condition_control_module_code = m.get('ConditionControlModuleCode')
        if m.get('ConditionControlModuleValue') is not None:
            self.condition_control_module_value = m.get('ConditionControlModuleValue')
        return self


class DeleteEnsSaleConditionControlRequestSaleControls(TeaModel):
    def __init__(
        self,
        condition_controls: List[DeleteEnsSaleConditionControlRequestSaleControlsConditionControls] = None,
        module_code: str = None,
        order_type: str = None,
    ):
        # This parameter is required.
        self.condition_controls = condition_controls
        # This parameter is required.
        self.module_code = module_code
        # This parameter is required.
        self.order_type = order_type

    def validate(self):
        if self.condition_controls:
            for k in self.condition_controls:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConditionControls'] = []
        if self.condition_controls is not None:
            for k in self.condition_controls:
                result['ConditionControls'].append(k.to_map() if k else None)
        if self.module_code is not None:
            result['ModuleCode'] = self.module_code
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.condition_controls = []
        if m.get('ConditionControls') is not None:
            for k in m.get('ConditionControls'):
                temp_model = DeleteEnsSaleConditionControlRequestSaleControlsConditionControls()
                self.condition_controls.append(temp_model.from_map(k))
        if m.get('ModuleCode') is not None:
            self.module_code = m.get('ModuleCode')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        return self


class DeleteEnsSaleConditionControlRequest(TeaModel):
    def __init__(
        self,
        ali_uid_account: str = None,
        commodity_code: str = None,
        custom_account: str = None,
        sale_controls: List[DeleteEnsSaleConditionControlRequestSaleControls] = None,
    ):
        self.ali_uid_account = ali_uid_account
        # This parameter is required.
        self.commodity_code = commodity_code
        self.custom_account = custom_account
        # This parameter is required.
        self.sale_controls = sale_controls

    def validate(self):
        if self.sale_controls:
            for k in self.sale_controls:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uid_account is not None:
            result['AliUidAccount'] = self.ali_uid_account
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.custom_account is not None:
            result['CustomAccount'] = self.custom_account
        result['SaleControls'] = []
        if self.sale_controls is not None:
            for k in self.sale_controls:
                result['SaleControls'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliUidAccount') is not None:
            self.ali_uid_account = m.get('AliUidAccount')
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('CustomAccount') is not None:
            self.custom_account = m.get('CustomAccount')
        self.sale_controls = []
        if m.get('SaleControls') is not None:
            for k in m.get('SaleControls'):
                temp_model = DeleteEnsSaleConditionControlRequestSaleControls()
                self.sale_controls.append(temp_model.from_map(k))
        return self


class DeleteEnsSaleConditionControlShrinkRequest(TeaModel):
    def __init__(
        self,
        ali_uid_account: str = None,
        commodity_code: str = None,
        custom_account: str = None,
        sale_controls_shrink: str = None,
    ):
        self.ali_uid_account = ali_uid_account
        # This parameter is required.
        self.commodity_code = commodity_code
        self.custom_account = custom_account
        # This parameter is required.
        self.sale_controls_shrink = sale_controls_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uid_account is not None:
            result['AliUidAccount'] = self.ali_uid_account
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.custom_account is not None:
            result['CustomAccount'] = self.custom_account
        if self.sale_controls_shrink is not None:
            result['SaleControls'] = self.sale_controls_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliUidAccount') is not None:
            self.ali_uid_account = m.get('AliUidAccount')
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('CustomAccount') is not None:
            self.custom_account = m.get('CustomAccount')
        if m.get('SaleControls') is not None:
            self.sale_controls_shrink = m.get('SaleControls')
        return self


class DeleteEnsSaleConditionControlResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteEnsSaleConditionControlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEnsSaleConditionControlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEnsSaleConditionControlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEnsSaleControlRequestSaleControls(TeaModel):
    def __init__(
        self,
        module_code: str = None,
        order_type: str = None,
    ):
        # This parameter is required.
        self.module_code = module_code
        # This parameter is required.
        self.order_type = order_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.module_code is not None:
            result['ModuleCode'] = self.module_code
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ModuleCode') is not None:
            self.module_code = m.get('ModuleCode')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        return self


class DeleteEnsSaleControlRequest(TeaModel):
    def __init__(
        self,
        ali_uid_account: str = None,
        commodity_code: str = None,
        custom_account: str = None,
        sale_controls: List[DeleteEnsSaleControlRequestSaleControls] = None,
    ):
        self.ali_uid_account = ali_uid_account
        # This parameter is required.
        self.commodity_code = commodity_code
        self.custom_account = custom_account
        # This parameter is required.
        self.sale_controls = sale_controls

    def validate(self):
        if self.sale_controls:
            for k in self.sale_controls:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uid_account is not None:
            result['AliUidAccount'] = self.ali_uid_account
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.custom_account is not None:
            result['CustomAccount'] = self.custom_account
        result['SaleControls'] = []
        if self.sale_controls is not None:
            for k in self.sale_controls:
                result['SaleControls'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliUidAccount') is not None:
            self.ali_uid_account = m.get('AliUidAccount')
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('CustomAccount') is not None:
            self.custom_account = m.get('CustomAccount')
        self.sale_controls = []
        if m.get('SaleControls') is not None:
            for k in m.get('SaleControls'):
                temp_model = DeleteEnsSaleControlRequestSaleControls()
                self.sale_controls.append(temp_model.from_map(k))
        return self


class DeleteEnsSaleControlShrinkRequest(TeaModel):
    def __init__(
        self,
        ali_uid_account: str = None,
        commodity_code: str = None,
        custom_account: str = None,
        sale_controls_shrink: str = None,
    ):
        self.ali_uid_account = ali_uid_account
        # This parameter is required.
        self.commodity_code = commodity_code
        self.custom_account = custom_account
        # This parameter is required.
        self.sale_controls_shrink = sale_controls_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uid_account is not None:
            result['AliUidAccount'] = self.ali_uid_account
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.custom_account is not None:
            result['CustomAccount'] = self.custom_account
        if self.sale_controls_shrink is not None:
            result['SaleControls'] = self.sale_controls_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliUidAccount') is not None:
            self.ali_uid_account = m.get('AliUidAccount')
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('CustomAccount') is not None:
            self.custom_account = m.get('CustomAccount')
        if m.get('SaleControls') is not None:
            self.sale_controls_shrink = m.get('SaleControls')
        return self


class DeleteEnsSaleControlResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteEnsSaleControlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEnsSaleControlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEnsSaleControlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEpnInstanceRequest(TeaModel):
    def __init__(
        self,
        epninstance_id: str = None,
    ):
        # The ID of the EPN instance.
        # 
        # This parameter is required.
        self.epninstance_id = epninstance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.epninstance_id is not None:
            result['EPNInstanceId'] = self.epninstance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EPNInstanceId') is not None:
            self.epninstance_id = m.get('EPNInstanceId')
        return self


class DeleteEpnInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteEpnInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEpnInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEpnInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteFileSystemRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        file_system_id: str = None,
    ):
        # The ID of the edge node.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        # The ID of the file system that you want to delete.
        # 
        # This parameter is required.
        self.file_system_id = file_system_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.file_system_id is not None:
            result['FileSystemId'] = self.file_system_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('FileSystemId') is not None:
            self.file_system_id = m.get('FileSystemId')
        return self


class DeleteFileSystemResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteFileSystemResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteFileSystemResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteFileSystemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteForwardEntryRequest(TeaModel):
    def __init__(
        self,
        forward_entry_id: str = None,
    ):
        # The ID of the DNAT entry that you want to delete.
        # 
        # This parameter is required.
        self.forward_entry_id = forward_entry_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.forward_entry_id is not None:
            result['ForwardEntryId'] = self.forward_entry_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ForwardEntryId') is not None:
            self.forward_entry_id = m.get('ForwardEntryId')
        return self


class DeleteForwardEntryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteForwardEntryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteForwardEntryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteForwardEntryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteHaVipsRequest(TeaModel):
    def __init__(
        self,
        ha_vip_ids: List[str] = None,
    ):
        # This parameter is required.
        self.ha_vip_ids = ha_vip_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ha_vip_ids is not None:
            result['HaVipIds'] = self.ha_vip_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HaVipIds') is not None:
            self.ha_vip_ids = m.get('HaVipIds')
        return self


class DeleteHaVipsShrinkRequest(TeaModel):
    def __init__(
        self,
        ha_vip_ids_shrink: str = None,
    ):
        # This parameter is required.
        self.ha_vip_ids_shrink = ha_vip_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ha_vip_ids_shrink is not None:
            result['HaVipIds'] = self.ha_vip_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HaVipIds') is not None:
            self.ha_vip_ids_shrink = m.get('HaVipIds')
        return self


class DeleteHaVipsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteHaVipsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteHaVipsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteHaVipsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteImageRequest(TeaModel):
    def __init__(
        self,
        image_id: str = None,
    ):
        # The ID of the image. You can specify only one image ID.
        # 
        # You can delete only custom images that you created.
        # 
        # This parameter is required.
        self.image_id = image_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        return self


class DeleteImageResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        request_id: str = None,
    ):
        # The returned service code. A value of 0 indicates that the operation was successful.
        self.code = code
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteImageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteImageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteKeyPairsRequest(TeaModel):
    def __init__(
        self,
        key_pair_id: str = None,
        key_pair_name: str = None,
    ):
        # The ID of the SSH key pair.
        self.key_pair_id = key_pair_id
        # The name of the key pair. The name must conform to the following naming conventions:
        # 
        # *   The name must be 2 to 128 characters in length.
        # *   The name must start with a letter and cannot start with `http://` or `https://`.
        # *   The name can contain letters, digits, colons (:), underscores (_), and hyphens (-).
        # 
        # Before you delete a key pair, you can call the DescribeKeyPairs operation to query existing key pairs.
        self.key_pair_name = key_pair_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_pair_id is not None:
            result['KeyPairId'] = self.key_pair_id
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('KeyPairId') is not None:
            self.key_pair_id = m.get('KeyPairId')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        return self


class DeleteKeyPairsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteKeyPairsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteKeyPairsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteKeyPairsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLoadBalancerListenerRequest(TeaModel):
    def __init__(
        self,
        listener_port: int = None,
        listener_protocol: str = None,
        load_balancer_id: str = None,
    ):
        # The frontend port that is used by the Edge Load Balance (ELB) instance. Valid values: **1** to **65535**.
        # 
        # This parameter is required.
        self.listener_port = listener_port
        # The frontend protocol that is used by the ELB instance.
        # 
        # >  This parameter is required if the same port is used by listeners that use different protocols.
        self.listener_protocol = listener_protocol
        # The ID of the ELB instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.listener_protocol is not None:
            result['ListenerProtocol'] = self.listener_protocol
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('ListenerProtocol') is not None:
            self.listener_protocol = m.get('ListenerProtocol')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        return self


class DeleteLoadBalancerListenerResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLoadBalancerListenerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLoadBalancerListenerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLoadBalancerListenerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMountTargetRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        file_system_id: str = None,
        mount_target_name: str = None,
    ):
        # The ID of the edge node.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        # The ID of the file system.
        # 
        # This parameter is required.
        self.file_system_id = file_system_id
        # The name of the mount target.
        # 
        # This parameter is required.
        self.mount_target_name = mount_target_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.file_system_id is not None:
            result['FileSystemId'] = self.file_system_id
        if self.mount_target_name is not None:
            result['MountTargetName'] = self.mount_target_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('FileSystemId') is not None:
            self.file_system_id = m.get('FileSystemId')
        if m.get('MountTargetName') is not None:
            self.mount_target_name = m.get('MountTargetName')
        return self


class DeleteMountTargetResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteMountTargetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMountTargetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMountTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteNatGatewayRequest(TeaModel):
    def __init__(
        self,
        force_delete: bool = None,
        nat_gateway_id: str = None,
    ):
        # Specifies whether to forcefully delete the NAT instance.
        self.force_delete = force_delete
        # The ID of the NAT gateway that you want to delete.
        # 
        # This parameter is required.
        self.nat_gateway_id = nat_gateway_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.force_delete is not None:
            result['ForceDelete'] = self.force_delete
        if self.nat_gateway_id is not None:
            result['NatGatewayId'] = self.nat_gateway_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ForceDelete') is not None:
            self.force_delete = m.get('ForceDelete')
        if m.get('NatGatewayId') is not None:
            self.nat_gateway_id = m.get('NatGatewayId')
        return self


class DeleteNatGatewayResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteNatGatewayResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteNatGatewayResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteNatGatewayResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteNetworkRequest(TeaModel):
    def __init__(
        self,
        network_id: str = None,
    ):
        # The ID of the network.
        # 
        # This parameter is required.
        self.network_id = network_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        return self


class DeleteNetworkResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteNetworkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteNetworkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteNetworkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteNetworkAclRequest(TeaModel):
    def __init__(
        self,
        network_acl_id: str = None,
    ):
        # The ID of the network ACL.
        # 
        # This parameter is required.
        self.network_acl_id = network_acl_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_acl_id is not None:
            result['NetworkAclId'] = self.network_acl_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkAclId') is not None:
            self.network_acl_id = m.get('NetworkAclId')
        return self


class DeleteNetworkAclResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteNetworkAclResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteNetworkAclResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteNetworkAclResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteNetworkAclEntryRequest(TeaModel):
    def __init__(
        self,
        network_acl_entry_id: str = None,
    ):
        # The ID of the network ACL for which you want to delete a rule.
        self.network_acl_entry_id = network_acl_entry_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_acl_entry_id is not None:
            result['NetworkAclEntryId'] = self.network_acl_entry_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkAclEntryId') is not None:
            self.network_acl_entry_id = m.get('NetworkAclEntryId')
        return self


class DeleteNetworkAclEntryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteNetworkAclEntryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteNetworkAclEntryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteNetworkAclEntryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteNetworkInterfacesRequest(TeaModel):
    def __init__(
        self,
        network_interface_ids: List[str] = None,
    ):
        # This parameter is required.
        self.network_interface_ids = network_interface_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_interface_ids is not None:
            result['NetworkInterfaceIds'] = self.network_interface_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkInterfaceIds') is not None:
            self.network_interface_ids = m.get('NetworkInterfaceIds')
        return self


class DeleteNetworkInterfacesShrinkRequest(TeaModel):
    def __init__(
        self,
        network_interface_ids_shrink: str = None,
    ):
        # This parameter is required.
        self.network_interface_ids_shrink = network_interface_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_interface_ids_shrink is not None:
            result['NetworkInterfaceIds'] = self.network_interface_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkInterfaceIds') is not None:
            self.network_interface_ids_shrink = m.get('NetworkInterfaceIds')
        return self


class DeleteNetworkInterfacesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteNetworkInterfacesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteNetworkInterfacesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteNetworkInterfacesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteObjectRequest(TeaModel):
    def __init__(
        self,
        bucket_name: str = None,
        object_key: str = None,
    ):
        # The name of the bucket.
        # 
        # This parameter is required.
        self.bucket_name = bucket_name
        # The name of the file.
        # 
        # This parameter is required.
        self.object_key = object_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        if self.object_key is not None:
            result['ObjectKey'] = self.object_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        if m.get('ObjectKey') is not None:
            self.object_key = m.get('ObjectKey')
        return self


class DeleteObjectResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteObjectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteObjectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteObjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSDGRequest(TeaModel):
    def __init__(
        self,
        sdgid: List[str] = None,
    ):
        # The IDs of the SDGs that you want to delete.
        # 
        # This parameter is required.
        self.sdgid = sdgid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class DeleteSDGShrinkRequest(TeaModel):
    def __init__(
        self,
        sdgid_shrink: str = None,
    ):
        # The IDs of the SDGs that you want to delete.
        # 
        # This parameter is required.
        self.sdgid_shrink = sdgid_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sdgid_shrink is not None:
            result['SDGId'] = self.sdgid_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SDGId') is not None:
            self.sdgid_shrink = m.get('SDGId')
        return self


class DeleteSDGResponseBodyDataResultFailedItemsItem(TeaModel):
    def __init__(
        self,
        sdg_id: str = None,
    ):
        # The ID of the shared data group (SDG).
        self.sdg_id = sdg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sdg_id is not None:
            result['SdgId'] = self.sdg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SdgId') is not None:
            self.sdg_id = m.get('SdgId')
        return self


class DeleteSDGResponseBodyDataResultFailedItems(TeaModel):
    def __init__(
        self,
        err_message: str = None,
        item: DeleteSDGResponseBodyDataResultFailedItemsItem = None,
    ):
        # The error message.
        self.err_message = err_message
        # Description
        self.item = item

    def validate(self):
        if self.item:
            self.item.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.err_message is not None:
            result['ErrMessage'] = self.err_message
        if self.item is not None:
            result['Item'] = self.item.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrMessage') is not None:
            self.err_message = m.get('ErrMessage')
        if m.get('Item') is not None:
            temp_model = DeleteSDGResponseBodyDataResultFailedItemsItem()
            self.item = temp_model.from_map(m['Item'])
        return self


class DeleteSDGResponseBodyDataResult(TeaModel):
    def __init__(
        self,
        failed_count: int = None,
        failed_items: List[DeleteSDGResponseBodyDataResultFailedItems] = None,
        success_count: int = None,
    ):
        # The number of failed tasks.
        self.failed_count = failed_count
        # Details about the failed tasks.
        self.failed_items = failed_items
        # The number of successful tasks.
        self.success_count = success_count

    def validate(self):
        if self.failed_items:
            for k in self.failed_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failed_count is not None:
            result['FailedCount'] = self.failed_count
        result['FailedItems'] = []
        if self.failed_items is not None:
            for k in self.failed_items:
                result['FailedItems'].append(k.to_map() if k else None)
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailedCount') is not None:
            self.failed_count = m.get('FailedCount')
        self.failed_items = []
        if m.get('FailedItems') is not None:
            for k in m.get('FailedItems'):
                temp_model = DeleteSDGResponseBodyDataResultFailedItems()
                self.failed_items.append(temp_model.from_map(k))
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        return self


class DeleteSDGResponseBodyData(TeaModel):
    def __init__(
        self,
        message: str = None,
        result: DeleteSDGResponseBodyDataResult = None,
        success: bool = None,
    ):
        # The response message. Success is returned for a successful request.
        self.message = message
        # The execution result of the synchronization request.
        self.result = result
        # Indicates whether all tasks are successful. Valid values:
        # 
        # *   true: All tasks are successful.
        # *   false: Failed tasks exist.
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.result is not None:
            result['Result'] = self.result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Result') is not None:
            temp_model = DeleteSDGResponseBodyDataResult()
            self.result = temp_model.from_map(m['Result'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteSDGResponseBody(TeaModel):
    def __init__(
        self,
        data: DeleteSDGResponseBodyData = None,
        request_id: str = None,
    ):
        # The returned data object.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = DeleteSDGResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSDGResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSDGResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSDGResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSecurityGroupRequest(TeaModel):
    def __init__(
        self,
        security_group_id: str = None,
    ):
        # The security group ID of the instance.
        # 
        # This parameter is required.
        self.security_group_id = security_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class DeleteSecurityGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSecurityGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSecurityGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSecurityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSnapshotRequest(TeaModel):
    def __init__(
        self,
        snapshot_id: str = None,
    ):
        # The ID of the snapshot.
        # 
        # This parameter is required.
        self.snapshot_id = snapshot_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        return self


class DeleteSnapshotResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSnapshotResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSnapshotResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSnapshotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSnatEntryRequest(TeaModel):
    def __init__(
        self,
        snat_entry_id: str = None,
    ):
        # The ID of the SNAT entry that you want to delete.
        # 
        # This parameter is required.
        self.snat_entry_id = snat_entry_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.snat_entry_id is not None:
            result['SnatEntryId'] = self.snat_entry_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SnatEntryId') is not None:
            self.snat_entry_id = m.get('SnatEntryId')
        return self


class DeleteSnatEntryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSnatEntryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSnatEntryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSnatEntryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSnatIpForSnatEntryRequest(TeaModel):
    def __init__(
        self,
        snat_entry_id: str = None,
        snat_ip: str = None,
    ):
        # The ID of the SNAT entry.
        # 
        # This parameter is required.
        self.snat_entry_id = snat_entry_id
        # The EIP that you want to delete from the SNAT entry.
        # 
        # This parameter is required.
        self.snat_ip = snat_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.snat_entry_id is not None:
            result['SnatEntryId'] = self.snat_entry_id
        if self.snat_ip is not None:
            result['SnatIp'] = self.snat_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SnatEntryId') is not None:
            self.snat_entry_id = m.get('SnatEntryId')
        if m.get('SnatIp') is not None:
            self.snat_ip = m.get('SnatIp')
        return self


class DeleteSnatIpForSnatEntryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSnatIpForSnatEntryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSnatIpForSnatEntryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSnatIpForSnatEntryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteStorageGatewayRequest(TeaModel):
    def __init__(
        self,
        gateway_id: str = None,
    ):
        # The ID of the gateway.
        # 
        # This parameter is required.
        self.gateway_id = gateway_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gateway_id is not None:
            result['GatewayId'] = self.gateway_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GatewayId') is not None:
            self.gateway_id = m.get('GatewayId')
        return self


class DeleteStorageGatewayResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteStorageGatewayResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteStorageGatewayResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteStorageGatewayResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteStorageVolumeRequest(TeaModel):
    def __init__(
        self,
        volume_id: str = None,
    ):
        # The ID of the volume.
        # 
        # This parameter is required.
        self.volume_id = volume_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.volume_id is not None:
            result['VolumeId'] = self.volume_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VolumeId') is not None:
            self.volume_id = m.get('VolumeId')
        return self


class DeleteStorageVolumeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteStorageVolumeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteStorageVolumeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteStorageVolumeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteVSwitchRequest(TeaModel):
    def __init__(
        self,
        v_switch_id: str = None,
    ):
        # The ID of the vSwitch.
        # 
        # This parameter is required.
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DeleteVSwitchResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteVSwitchResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteVSwitchResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteVSwitchResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeployInstanceSDGRequest(TeaModel):
    def __init__(
        self,
        deployment_type: str = None,
        disk_access_protocol: str = None,
        disk_type: str = None,
        instance_ids: List[str] = None,
        sdgid: str = None,
    ):
        # The deployment type of the SDG. shared: shared read/write splitting deployment. The content of the SDG is read-only, and data updates are written to the local storage of the instance.
        self.deployment_type = deployment_type
        self.disk_access_protocol = disk_access_protocol
        self.disk_type = disk_type
        # The IDs of the instances. The value is a JSON array that consists of up to 100 IDs.
        # 
        # This parameter is required.
        self.instance_ids = instance_ids
        # The ID of the SDG.
        # 
        # This parameter is required.
        self.sdgid = sdgid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deployment_type is not None:
            result['DeploymentType'] = self.deployment_type
        if self.disk_access_protocol is not None:
            result['DiskAccessProtocol'] = self.disk_access_protocol
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeploymentType') is not None:
            self.deployment_type = m.get('DeploymentType')
        if m.get('DiskAccessProtocol') is not None:
            self.disk_access_protocol = m.get('DiskAccessProtocol')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class DeployInstanceSDGShrinkRequest(TeaModel):
    def __init__(
        self,
        deployment_type: str = None,
        disk_access_protocol: str = None,
        disk_type: str = None,
        instance_ids_shrink: str = None,
        sdgid: str = None,
    ):
        # The deployment type of the SDG. shared: shared read/write splitting deployment. The content of the SDG is read-only, and data updates are written to the local storage of the instance.
        self.deployment_type = deployment_type
        self.disk_access_protocol = disk_access_protocol
        self.disk_type = disk_type
        # The IDs of the instances. The value is a JSON array that consists of up to 100 IDs.
        # 
        # This parameter is required.
        self.instance_ids_shrink = instance_ids_shrink
        # The ID of the SDG.
        # 
        # This parameter is required.
        self.sdgid = sdgid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deployment_type is not None:
            result['DeploymentType'] = self.deployment_type
        if self.disk_access_protocol is not None:
            result['DiskAccessProtocol'] = self.disk_access_protocol
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.instance_ids_shrink is not None:
            result['InstanceIds'] = self.instance_ids_shrink
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeploymentType') is not None:
            self.deployment_type = m.get('DeploymentType')
        if m.get('DiskAccessProtocol') is not None:
            self.disk_access_protocol = m.get('DiskAccessProtocol')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('InstanceIds') is not None:
            self.instance_ids_shrink = m.get('InstanceIds')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class DeployInstanceSDGResponseBodyDataResultFailedItems(TeaModel):
    def __init__(
        self,
        err_message: str = None,
        instance_id: str = None,
    ):
        # The error message that is returned.
        self.err_message = err_message
        # The ID of the instance.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.err_message is not None:
            result['ErrMessage'] = self.err_message
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrMessage') is not None:
            self.err_message = m.get('ErrMessage')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DeployInstanceSDGResponseBodyDataResult(TeaModel):
    def __init__(
        self,
        failed_count: int = None,
        failed_items: List[DeployInstanceSDGResponseBodyDataResultFailedItems] = None,
        success_count: int = None,
    ):
        # The number of failed tasks.
        self.failed_count = failed_count
        # Details about the failed tasks.
        self.failed_items = failed_items
        # The number of successful tasks.
        self.success_count = success_count

    def validate(self):
        if self.failed_items:
            for k in self.failed_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failed_count is not None:
            result['FailedCount'] = self.failed_count
        result['FailedItems'] = []
        if self.failed_items is not None:
            for k in self.failed_items:
                result['FailedItems'].append(k.to_map() if k else None)
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailedCount') is not None:
            self.failed_count = m.get('FailedCount')
        self.failed_items = []
        if m.get('FailedItems') is not None:
            for k in m.get('FailedItems'):
                temp_model = DeployInstanceSDGResponseBodyDataResultFailedItems()
                self.failed_items.append(temp_model.from_map(k))
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        return self


class DeployInstanceSDGResponseBodyData(TeaModel):
    def __init__(
        self,
        message: str = None,
        result: DeployInstanceSDGResponseBodyDataResult = None,
        success: bool = None,
    ):
        # The response message. Success is returned for a successful request.
        self.message = message
        # The execution result of the synchronization request.
        self.result = result
        # Indicates whether all tasks are successful. Valid values:
        # 
        # *   true: All tasks are successful.
        # *   false: Failed tasks exist.
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.result is not None:
            result['Result'] = self.result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Result') is not None:
            temp_model = DeployInstanceSDGResponseBodyDataResult()
            self.result = temp_model.from_map(m['Result'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeployInstanceSDGResponseBody(TeaModel):
    def __init__(
        self,
        data: DeployInstanceSDGResponseBodyData = None,
        request_id: str = None,
    ):
        # The returned data object.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = DeployInstanceSDGResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeployInstanceSDGResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeployInstanceSDGResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeployInstanceSDGResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeploySDGRequest(TeaModel):
    def __init__(
        self,
        deployment_type: str = None,
        instance_ids: List[str] = None,
        sdgid: str = None,
    ):
        # The SDG deployment type. Valid values:
        # 
        # *   common (default): read/write deployment. Data updates are written to disks.
        # *   overlay: read/write splitting deployment. Content in SDGs is read-only. Data updates are written to the local storage of the instance.
        self.deployment_type = deployment_type
        # The IDs of instances on which you want to deploy SDGs. You can deploy SDGs on a maximum of 100 instances at a time.
        # 
        # This parameter is required.
        self.instance_ids = instance_ids
        # The SDG ID. This parameter is used to create a disk, which is attached to an instance.
        # 
        # This parameter is required.
        self.sdgid = sdgid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deployment_type is not None:
            result['DeploymentType'] = self.deployment_type
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeploymentType') is not None:
            self.deployment_type = m.get('DeploymentType')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class DeploySDGShrinkRequest(TeaModel):
    def __init__(
        self,
        deployment_type: str = None,
        instance_ids_shrink: str = None,
        sdgid: str = None,
    ):
        # The SDG deployment type. Valid values:
        # 
        # *   common (default): read/write deployment. Data updates are written to disks.
        # *   overlay: read/write splitting deployment. Content in SDGs is read-only. Data updates are written to the local storage of the instance.
        self.deployment_type = deployment_type
        # The IDs of instances on which you want to deploy SDGs. You can deploy SDGs on a maximum of 100 instances at a time.
        # 
        # This parameter is required.
        self.instance_ids_shrink = instance_ids_shrink
        # The SDG ID. This parameter is used to create a disk, which is attached to an instance.
        # 
        # This parameter is required.
        self.sdgid = sdgid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deployment_type is not None:
            result['DeploymentType'] = self.deployment_type
        if self.instance_ids_shrink is not None:
            result['InstanceIds'] = self.instance_ids_shrink
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeploymentType') is not None:
            self.deployment_type = m.get('DeploymentType')
        if m.get('InstanceIds') is not None:
            self.instance_ids_shrink = m.get('InstanceIds')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class DeploySDGResponseBodyDataResultFailedItems(TeaModel):
    def __init__(
        self,
        err_message: str = None,
        instance_id: str = None,
    ):
        # The error message.
        self.err_message = err_message
        # The ID of the instance.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.err_message is not None:
            result['ErrMessage'] = self.err_message
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrMessage') is not None:
            self.err_message = m.get('ErrMessage')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DeploySDGResponseBodyDataResult(TeaModel):
    def __init__(
        self,
        failed_count: int = None,
        failed_items: List[DeploySDGResponseBodyDataResultFailedItems] = None,
        success_count: int = None,
    ):
        # The number of failed tasks.
        self.failed_count = failed_count
        # Details of failed tasks.
        self.failed_items = failed_items
        # The number of successful tasks.
        self.success_count = success_count

    def validate(self):
        if self.failed_items:
            for k in self.failed_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failed_count is not None:
            result['FailedCount'] = self.failed_count
        result['FailedItems'] = []
        if self.failed_items is not None:
            for k in self.failed_items:
                result['FailedItems'].append(k.to_map() if k else None)
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailedCount') is not None:
            self.failed_count = m.get('FailedCount')
        self.failed_items = []
        if m.get('FailedItems') is not None:
            for k in m.get('FailedItems'):
                temp_model = DeploySDGResponseBodyDataResultFailedItems()
                self.failed_items.append(temp_model.from_map(k))
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        return self


class DeploySDGResponseBodyData(TeaModel):
    def __init__(
        self,
        message: str = None,
        result: DeploySDGResponseBodyDataResult = None,
        success: bool = None,
    ):
        # The response message. Success is returned for a successful request.
        self.message = message
        # The task result.
        self.result = result
        # Indicates whether all tasks are successful. Valid values:
        # 
        # *   true: All tasks are successful.
        # *   false: Failed tasks exist.
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.result is not None:
            result['Result'] = self.result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Result') is not None:
            temp_model = DeploySDGResponseBodyDataResult()
            self.result = temp_model.from_map(m['Result'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeploySDGResponseBody(TeaModel):
    def __init__(
        self,
        data: DeploySDGResponseBodyData = None,
        request_id: str = None,
    ):
        # The returned data object.
        self.data = data
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = DeploySDGResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeploySDGResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeploySDGResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeploySDGResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAICImagesRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        image_id: str = None,
        image_type: str = None,
        image_url: str = None,
        max_date: str = None,
        min_date: str = None,
        page_number: str = None,
        page_size: str = None,
        status: str = None,
    ):
        # The description of the image.
        self.description = description
        # The image ID of the AIC instance.
        self.image_id = image_id
        # The type of the image. Valid values:
        # 
        # *   **public**: public image
        # *   **private**: custom image
        self.image_type = image_type
        # The URL of the AIC image repository.
        self.image_url = image_url
        # The end of the time range to query. Specify the time in the 2006-01-02 format. By default, the time range to query is not restricted.
        self.max_date = max_date
        # The beginning of the time range to query. Specify the time in the 2006-01-02 format. By default, the time range to query is not restricted.
        self.min_date = min_date
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. The maximum value is **100**. Default value: **10**.
        self.page_size = page_size
        # The status of the image. Valid values:
        # 
        # *   **verifying**\
        # *   **disable**\
        # *   **available**\
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_type is not None:
            result['ImageType'] = self.image_type
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.max_date is not None:
            result['MaxDate'] = self.max_date
        if self.min_date is not None:
            result['MinDate'] = self.min_date
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageType') is not None:
            self.image_type = m.get('ImageType')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('MaxDate') is not None:
            self.max_date = m.get('MaxDate')
        if m.get('MinDate') is not None:
            self.min_date = m.get('MinDate')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeAICImagesResponseBodyImages(TeaModel):
    def __init__(
        self,
        android_version: str = None,
        creation_time: str = None,
        description: str = None,
        image_id: str = None,
        image_url: str = None,
        status: str = None,
        user: str = None,
    ):
        self.android_version = android_version
        # The time when the image was created.
        self.creation_time = creation_time
        # The description of the image.
        self.description = description
        # The image ID of the AIC instance.
        self.image_id = image_id
        # The URL of the AIC image repository.
        self.image_url = image_url
        # The status of the image. **Available** is returned for this parameter. Available indicates that the image is available.
        self.status = status
        # The username of the image repository.
        self.user = user

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.android_version is not None:
            result['AndroidVersion'] = self.android_version
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.status is not None:
            result['Status'] = self.status
        if self.user is not None:
            result['User'] = self.user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AndroidVersion') is not None:
            self.android_version = m.get('AndroidVersion')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('User') is not None:
            self.user = m.get('User')
        return self


class DescribeAICImagesResponseBody(TeaModel):
    def __init__(
        self,
        images: List[DescribeAICImagesResponseBodyImages] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The information about the images.
        self.images = images
        # The page number. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page.
        # 
        # Default value: 10.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.images:
            for k in self.images:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = DescribeAICImagesResponseBodyImages()
                self.images.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeAICImagesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAICImagesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAICImagesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeARMServerInstancesRequest(TeaModel):
    def __init__(
        self,
        aicspecs: List[str] = None,
        describe_aicinstances: bool = None,
        ens_region_ids: List[str] = None,
        max_date: str = None,
        min_date: str = None,
        name: str = None,
        namespace: str = None,
        order_by_params: str = None,
        page_number: int = None,
        page_size: int = None,
        server_ids: List[str] = None,
        server_specs: List[str] = None,
        states: List[str] = None,
    ):
        # The container specifications.
        self.aicspecs = aicspecs
        # Spcifies whether the result contains the container information. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.describe_aicinstances = describe_aicinstances
        # The IDs of the Edge Node Service (ENS) nodes.
        self.ens_region_ids = ens_region_ids
        # The end of the time range to query. Specify the time in the 2006-01-02 format. By default, the time range to query is not restricted.
        self.max_date = max_date
        # The beginning of the time range to query. Specify the time in the 2006-01-02 format. By default, the time range to query is not restricted.
        self.min_date = min_date
        # The name of the server.
        self.name = name
        # The namespace.
        self.namespace = namespace
        # The sorting order of the results to return. Valid values: ServerIdSort, ServerNameSort, ExpireTimeSort, CreationTimeSort, and EnsRegionIdSort.
        # 
        # asc: ascending order. desc: descending order.
        self.order_by_params = order_by_params
        # The page number. Pages start from page **1**.
        # 
        # Default value: **1**.
        self.page_number = page_number
        # The number of entries to return on each page. Maximum value: **100**.
        # 
        # Default value: **10**.
        self.page_size = page_size
        # The IDs of the ARM servers.
        self.server_ids = server_ids
        # The server specifications.
        self.server_specs = server_specs
        # The operation statuses.
        self.states = states

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aicspecs is not None:
            result['AICSpecs'] = self.aicspecs
        if self.describe_aicinstances is not None:
            result['DescribeAICInstances'] = self.describe_aicinstances
        if self.ens_region_ids is not None:
            result['EnsRegionIds'] = self.ens_region_ids
        if self.max_date is not None:
            result['MaxDate'] = self.max_date
        if self.min_date is not None:
            result['MinDate'] = self.min_date
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.order_by_params is not None:
            result['OrderByParams'] = self.order_by_params
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.server_ids is not None:
            result['ServerIds'] = self.server_ids
        if self.server_specs is not None:
            result['ServerSpecs'] = self.server_specs
        if self.states is not None:
            result['States'] = self.states
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AICSpecs') is not None:
            self.aicspecs = m.get('AICSpecs')
        if m.get('DescribeAICInstances') is not None:
            self.describe_aicinstances = m.get('DescribeAICInstances')
        if m.get('EnsRegionIds') is not None:
            self.ens_region_ids = m.get('EnsRegionIds')
        if m.get('MaxDate') is not None:
            self.max_date = m.get('MaxDate')
        if m.get('MinDate') is not None:
            self.min_date = m.get('MinDate')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('OrderByParams') is not None:
            self.order_by_params = m.get('OrderByParams')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ServerIds') is not None:
            self.server_ids = m.get('ServerIds')
        if m.get('ServerSpecs') is not None:
            self.server_specs = m.get('ServerSpecs')
        if m.get('States') is not None:
            self.states = m.get('States')
        return self


class DescribeARMServerInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        aicspecs_shrink: str = None,
        describe_aicinstances: bool = None,
        ens_region_ids_shrink: str = None,
        max_date: str = None,
        min_date: str = None,
        name: str = None,
        namespace: str = None,
        order_by_params: str = None,
        page_number: int = None,
        page_size: int = None,
        server_ids_shrink: str = None,
        server_specs_shrink: str = None,
        states_shrink: str = None,
    ):
        # The container specifications.
        self.aicspecs_shrink = aicspecs_shrink
        # Spcifies whether the result contains the container information. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.describe_aicinstances = describe_aicinstances
        # The IDs of the Edge Node Service (ENS) nodes.
        self.ens_region_ids_shrink = ens_region_ids_shrink
        # The end of the time range to query. Specify the time in the 2006-01-02 format. By default, the time range to query is not restricted.
        self.max_date = max_date
        # The beginning of the time range to query. Specify the time in the 2006-01-02 format. By default, the time range to query is not restricted.
        self.min_date = min_date
        # The name of the server.
        self.name = name
        # The namespace.
        self.namespace = namespace
        # The sorting order of the results to return. Valid values: ServerIdSort, ServerNameSort, ExpireTimeSort, CreationTimeSort, and EnsRegionIdSort.
        # 
        # asc: ascending order. desc: descending order.
        self.order_by_params = order_by_params
        # The page number. Pages start from page **1**.
        # 
        # Default value: **1**.
        self.page_number = page_number
        # The number of entries to return on each page. Maximum value: **100**.
        # 
        # Default value: **10**.
        self.page_size = page_size
        # The IDs of the ARM servers.
        self.server_ids_shrink = server_ids_shrink
        # The server specifications.
        self.server_specs_shrink = server_specs_shrink
        # The operation statuses.
        self.states_shrink = states_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aicspecs_shrink is not None:
            result['AICSpecs'] = self.aicspecs_shrink
        if self.describe_aicinstances is not None:
            result['DescribeAICInstances'] = self.describe_aicinstances
        if self.ens_region_ids_shrink is not None:
            result['EnsRegionIds'] = self.ens_region_ids_shrink
        if self.max_date is not None:
            result['MaxDate'] = self.max_date
        if self.min_date is not None:
            result['MinDate'] = self.min_date
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.order_by_params is not None:
            result['OrderByParams'] = self.order_by_params
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.server_ids_shrink is not None:
            result['ServerIds'] = self.server_ids_shrink
        if self.server_specs_shrink is not None:
            result['ServerSpecs'] = self.server_specs_shrink
        if self.states_shrink is not None:
            result['States'] = self.states_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AICSpecs') is not None:
            self.aicspecs_shrink = m.get('AICSpecs')
        if m.get('DescribeAICInstances') is not None:
            self.describe_aicinstances = m.get('DescribeAICInstances')
        if m.get('EnsRegionIds') is not None:
            self.ens_region_ids_shrink = m.get('EnsRegionIds')
        if m.get('MaxDate') is not None:
            self.max_date = m.get('MaxDate')
        if m.get('MinDate') is not None:
            self.min_date = m.get('MinDate')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('OrderByParams') is not None:
            self.order_by_params = m.get('OrderByParams')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ServerIds') is not None:
            self.server_ids_shrink = m.get('ServerIds')
        if m.get('ServerSpecs') is not None:
            self.server_specs_shrink = m.get('ServerSpecs')
        if m.get('States') is not None:
            self.states_shrink = m.get('States')
        return self


class DescribeARMServerInstancesResponseBodyServersAICInstancesNetworkAttributes(TeaModel):
    def __init__(
        self,
        ip_address: str = None,
        network_id: str = None,
        v_switch_id: str = None,
    ):
        # The IP address of the AIC instance.
        self.ip_address = ip_address
        # The network ID of the AIC instance.
        self.network_id = network_id
        # The vSwitch ID of the AIC instance.
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeARMServerInstancesResponseBodyServersAICInstancesSdgDeployInfo(TeaModel):
    def __init__(
        self,
        sdgid: str = None,
        status: str = None,
    ):
        # The ID of the SDG.
        self.sdgid = sdgid
        # The deployment status of the SDG. Valid values:
        # 
        # *   **sdg_deploying**\
        # *   **failed**\
        # *   **success**\
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeARMServerInstancesResponseBodyServersAICInstances(TeaModel):
    def __init__(
        self,
        frequency: int = None,
        image_id: str = None,
        instance_id: str = None,
        latest_action: str = None,
        name: str = None,
        network_attributes: DescribeARMServerInstancesResponseBodyServersAICInstancesNetworkAttributes = None,
        resolution: str = None,
        sdg_deploy_info: DescribeARMServerInstancesResponseBodyServersAICInstancesSdgDeployInfo = None,
        spec: str = None,
        state: str = None,
        status: str = None,
    ):
        # The refresh rate of the AIC instance. Unit: Hz.
        self.frequency = frequency
        # The ID of the AIC image.
        self.image_id = image_id
        # The ID of the AIC instance.
        self.instance_id = instance_id
        # The operation that was most recently performed.
        self.latest_action = latest_action
        # The name of the container.
        self.name = name
        # The network attributes of the AIC instance.
        self.network_attributes = network_attributes
        # The resolution of the AIC instance.
        self.resolution = resolution
        # The information about the shared data group (SDG) that is deployed on the AIC instance.
        self.sdg_deploy_info = sdg_deploy_info
        # The specification of the AIC instance.
        self.spec = spec
        # The operation status of the AIC instance. Valid values:
        # 
        # *   **success**\
        # *   **failed**\
        # *   **creating**\
        # *   **releasing**\
        # *   **rebooting**\
        # *   **reseting**\
        self.state = state
        # The running status of the AIC instance. Valid values:
        # 
        # *   **running**\
        # *   **pending**\
        # *   **terminating**\
        self.status = status

    def validate(self):
        if self.network_attributes:
            self.network_attributes.validate()
        if self.sdg_deploy_info:
            self.sdg_deploy_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.frequency is not None:
            result['Frequency'] = self.frequency
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.latest_action is not None:
            result['LatestAction'] = self.latest_action
        if self.name is not None:
            result['Name'] = self.name
        if self.network_attributes is not None:
            result['NetworkAttributes'] = self.network_attributes.to_map()
        if self.resolution is not None:
            result['Resolution'] = self.resolution
        if self.sdg_deploy_info is not None:
            result['SdgDeployInfo'] = self.sdg_deploy_info.to_map()
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.state is not None:
            result['State'] = self.state
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Frequency') is not None:
            self.frequency = m.get('Frequency')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('LatestAction') is not None:
            self.latest_action = m.get('LatestAction')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NetworkAttributes') is not None:
            temp_model = DescribeARMServerInstancesResponseBodyServersAICInstancesNetworkAttributes()
            self.network_attributes = temp_model.from_map(m['NetworkAttributes'])
        if m.get('Resolution') is not None:
            self.resolution = m.get('Resolution')
        if m.get('SdgDeployInfo') is not None:
            temp_model = DescribeARMServerInstancesResponseBodyServersAICInstancesSdgDeployInfo()
            self.sdg_deploy_info = temp_model.from_map(m['SdgDeployInfo'])
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeARMServerInstancesResponseBodyServersTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeARMServerInstancesResponseBodyServers(TeaModel):
    def __init__(
        self,
        aicinstances: List[DescribeARMServerInstancesResponseBodyServersAICInstances] = None,
        creation_time: str = None,
        ens_region_id: str = None,
        expired_time: str = None,
        latest_action: str = None,
        name: str = None,
        namespace: str = None,
        pay_type: str = None,
        server_id: str = None,
        spec_name: str = None,
        state: str = None,
        status: str = None,
        tags: List[DescribeARMServerInstancesResponseBodyServersTags] = None,
    ):
        # The information about the AIC instances.
        self.aicinstances = aicinstances
        # The time when the instance was created.
        self.creation_time = creation_time
        # The ID of the ENS node.
        self.ens_region_id = ens_region_id
        # The time when the instance expires.
        self.expired_time = expired_time
        # The operation that was most recently performed.
        self.latest_action = latest_action
        # The name of the server.
        self.name = name
        # The namespace of the cluster to which the server belongs.
        self.namespace = namespace
        # The billing method.
        self.pay_type = pay_type
        # The ID of the server.
        self.server_id = server_id
        # The server specification.
        self.spec_name = spec_name
        # The operation status of the server. Valid values:
        # 
        # *   **success**\
        # *   **failed**\
        # *   **creating**\
        # *   **releasing**\
        # *   **rebooting**\
        # *   **upgrading**\
        self.state = state
        # The running status of the server. Valid values:
        # 
        # *   **running**\
        # *   **stopping**\
        # *   **down**\
        # *   **starting**\
        self.status = status
        self.tags = tags

    def validate(self):
        if self.aicinstances:
            for k in self.aicinstances:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AICInstances'] = []
        if self.aicinstances is not None:
            for k in self.aicinstances:
                result['AICInstances'].append(k.to_map() if k else None)
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.expired_time is not None:
            result['ExpiredTime'] = self.expired_time
        if self.latest_action is not None:
            result['LatestAction'] = self.latest_action
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.pay_type is not None:
            result['PayType'] = self.pay_type
        if self.server_id is not None:
            result['ServerId'] = self.server_id
        if self.spec_name is not None:
            result['SpecName'] = self.spec_name
        if self.state is not None:
            result['State'] = self.state
        if self.status is not None:
            result['Status'] = self.status
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.aicinstances = []
        if m.get('AICInstances') is not None:
            for k in m.get('AICInstances'):
                temp_model = DescribeARMServerInstancesResponseBodyServersAICInstances()
                self.aicinstances.append(temp_model.from_map(k))
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('ExpiredTime') is not None:
            self.expired_time = m.get('ExpiredTime')
        if m.get('LatestAction') is not None:
            self.latest_action = m.get('LatestAction')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PayType') is not None:
            self.pay_type = m.get('PayType')
        if m.get('ServerId') is not None:
            self.server_id = m.get('ServerId')
        if m.get('SpecName') is not None:
            self.spec_name = m.get('SpecName')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = DescribeARMServerInstancesResponseBodyServersTags()
                self.tags.append(temp_model.from_map(k))
        return self


class DescribeARMServerInstancesResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        servers: List[DescribeARMServerInstancesResponseBodyServers] = None,
        total_count: int = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The information about the servers and the AIC instances.
        self.servers = servers
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.servers:
            for k in self.servers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Servers'] = []
        if self.servers is not None:
            for k in self.servers:
                result['Servers'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.servers = []
        if m.get('Servers') is not None:
            for k in m.get('Servers'):
                temp_model = DescribeARMServerInstancesResponseBodyServers()
                self.servers.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeARMServerInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeARMServerInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeARMServerInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_versions: str = None,
        level: str = None,
        out_detail_stat_params: str = None,
        resource_selector: str = None,
    ):
        # The ID of the application. You can call the ListApplications operation to obtain the application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The version number of the application. Separate multiple version numbers with commas (,). If you want to query data of all versions of applications, specify All for this parameter. By default, only data of applications in the stable versions are queried.
        self.app_versions = app_versions
        # The region level by which edge resources of the application are collected. The value is of the enumeration type. Valid values:
        # 
        # *   National: Chinese mainland
        # *   Big: area
        # *   Middle: province
        # *   Small: city
        # *   RegionId: edge node
        # 
        # Default value: National.
        self.level = level
        # Specifies whether to return other information about the application, such as statistics on resource instances and pods. The value must be a JSON string. By default, all information is returned.
        self.out_detail_stat_params = out_detail_stat_params
        # The resource filtering condition.
        self.resource_selector = resource_selector

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_versions is not None:
            result['AppVersions'] = self.app_versions
        if self.level is not None:
            result['Level'] = self.level
        if self.out_detail_stat_params is not None:
            result['OutDetailStatParams'] = self.out_detail_stat_params
        if self.resource_selector is not None:
            result['ResourceSelector'] = self.resource_selector
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppVersions') is not None:
            self.app_versions = m.get('AppVersions')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('OutDetailStatParams') is not None:
            self.out_detail_stat_params = m.get('OutDetailStatParams')
        if m.get('ResourceSelector') is not None:
            self.resource_selector = m.get('ResourceSelector')
        return self


class DescribeApplicationResponseBody(TeaModel):
    def __init__(
        self,
        application: str = None,
        request_id: str = None,
    ):
        # The returned application information.
        self.application = application
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application is not None:
            result['Application'] = self.application
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Application') is not None:
            self.application = m.get('Application')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAvailableResourceResponseBodyImagesImage(TeaModel):
    def __init__(
        self,
        image_id: str = None,
        image_name: str = None,
    ):
        # The ID of the image.
        self.image_id = image_id
        # The name of the image.
        self.image_name = image_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        return self


class DescribeAvailableResourceResponseBodyImages(TeaModel):
    def __init__(
        self,
        image: List[DescribeAvailableResourceResponseBodyImagesImage] = None,
    ):
        self.image = image

    def validate(self):
        if self.image:
            for k in self.image:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Image'] = []
        if self.image is not None:
            for k in self.image:
                result['Image'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.image = []
        if m.get('Image') is not None:
            for k in m.get('Image'):
                temp_model = DescribeAvailableResourceResponseBodyImagesImage()
                self.image.append(temp_model.from_map(k))
        return self


class DescribeAvailableResourceResponseBodySupportResourcesSupportResource(TeaModel):
    def __init__(
        self,
        data_disk_size: str = None,
        ens_region_id: str = None,
        instance_spec: str = None,
        support_resources_count: str = None,
        system_disk_size: str = None,
    ):
        # The size of the data disk. Unit: GB.
        self.data_disk_size = data_disk_size
        # The ID of the edge node.
        self.ens_region_id = ens_region_id
        # The specifications of the resource plan.
        self.instance_spec = instance_spec
        # The number of resources that you can purchase.
        self.support_resources_count = support_resources_count
        # The size of the system disk. Unit: GiB.
        self.system_disk_size = system_disk_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_disk_size is not None:
            result['DataDiskSize'] = self.data_disk_size
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_spec is not None:
            result['InstanceSpec'] = self.instance_spec
        if self.support_resources_count is not None:
            result['SupportResourcesCount'] = self.support_resources_count
        if self.system_disk_size is not None:
            result['SystemDiskSize'] = self.system_disk_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataDiskSize') is not None:
            self.data_disk_size = m.get('DataDiskSize')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceSpec') is not None:
            self.instance_spec = m.get('InstanceSpec')
        if m.get('SupportResourcesCount') is not None:
            self.support_resources_count = m.get('SupportResourcesCount')
        if m.get('SystemDiskSize') is not None:
            self.system_disk_size = m.get('SystemDiskSize')
        return self


class DescribeAvailableResourceResponseBodySupportResources(TeaModel):
    def __init__(
        self,
        support_resource: List[DescribeAvailableResourceResponseBodySupportResourcesSupportResource] = None,
    ):
        self.support_resource = support_resource

    def validate(self):
        if self.support_resource:
            for k in self.support_resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SupportResource'] = []
        if self.support_resource is not None:
            for k in self.support_resource:
                result['SupportResource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.support_resource = []
        if m.get('SupportResource') is not None:
            for k in m.get('SupportResource'):
                temp_model = DescribeAvailableResourceResponseBodySupportResourcesSupportResource()
                self.support_resource.append(temp_model.from_map(k))
        return self


class DescribeAvailableResourceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        images: DescribeAvailableResourceResponseBodyImages = None,
        request_id: str = None,
        support_resources: DescribeAvailableResourceResponseBodySupportResources = None,
    ):
        # The returned service code. 0 indicates that the request was successful.
        self.code = code
        # The details of the images.
        self.images = images
        # The ID of the request. This is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.
        self.request_id = request_id
        # The specifications of resources that you can purchase.
        self.support_resources = support_resources

    def validate(self):
        if self.images:
            self.images.validate()
        if self.support_resources:
            self.support_resources.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.images is not None:
            result['Images'] = self.images.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.support_resources is not None:
            result['SupportResources'] = self.support_resources.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Images') is not None:
            temp_model = DescribeAvailableResourceResponseBodyImages()
            self.images = temp_model.from_map(m['Images'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SupportResources') is not None:
            temp_model = DescribeAvailableResourceResponseBodySupportResources()
            self.support_resources = temp_model.from_map(m['SupportResources'])
        return self


class DescribeAvailableResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAvailableResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAvailableResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAvailableResourceInfoResponseBodyImagesImage(TeaModel):
    def __init__(
        self,
        image_id: str = None,
        image_name: str = None,
        image_size: int = None,
    ):
        # The ID of the image.
        self.image_id = image_id
        # The name of the image.
        self.image_name = image_name
        # The size of the image. Unit: GB.
        self.image_size = image_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.image_size is not None:
            result['ImageSize'] = self.image_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('ImageSize') is not None:
            self.image_size = m.get('ImageSize')
        return self


class DescribeAvailableResourceInfoResponseBodyImages(TeaModel):
    def __init__(
        self,
        image: List[DescribeAvailableResourceInfoResponseBodyImagesImage] = None,
    ):
        self.image = image

    def validate(self):
        if self.image:
            for k in self.image:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Image'] = []
        if self.image is not None:
            for k in self.image:
                result['Image'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.image = []
        if m.get('Image') is not None:
            for k in m.get('Image'):
                temp_model = DescribeAvailableResourceInfoResponseBodyImagesImage()
                self.image.append(temp_model.from_map(k))
        return self


class DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceBandwidthTypes(TeaModel):
    def __init__(
        self,
        bandwidth_type: List[str] = None,
    ):
        self.bandwidth_type = bandwidth_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidth_type is not None:
            result['BandwidthType'] = self.bandwidth_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BandwidthType') is not None:
            self.bandwidth_type = m.get('BandwidthType')
        return self


class DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIds(TeaModel):
    def __init__(
        self,
        ens_region_id: List[str] = None,
    ):
        self.ens_region_id = ens_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        return self


class DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtendsEnsRegionId(TeaModel):
    def __init__(
        self,
        area: str = None,
        en_name: str = None,
        ens_region_id: str = None,
        isp: str = None,
        name: str = None,
        province: str = None,
    ):
        # The region.
        self.area = area
        # The name. This parameter is empty by default.
        self.en_name = en_name
        # The ID of the edge node.
        self.ens_region_id = ens_region_id
        # The information about the Internet service provider (ISP).
        self.isp = isp
        # The name of the edge node.
        self.name = name
        # The province.
        self.province = province

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.area is not None:
            result['Area'] = self.area
        if self.en_name is not None:
            result['EnName'] = self.en_name
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.name is not None:
            result['Name'] = self.name
        if self.province is not None:
            result['Province'] = self.province
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Area') is not None:
            self.area = m.get('Area')
        if m.get('EnName') is not None:
            self.en_name = m.get('EnName')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Province') is not None:
            self.province = m.get('Province')
        return self


class DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtends(TeaModel):
    def __init__(
        self,
        ens_region_id: List[DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtendsEnsRegionId] = None,
    ):
        self.ens_region_id = ens_region_id

    def validate(self):
        if self.ens_region_id:
            for k in self.ens_region_id:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EnsRegionId'] = []
        if self.ens_region_id is not None:
            for k in self.ens_region_id:
                result['EnsRegionId'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ens_region_id = []
        if m.get('EnsRegionId') is not None:
            for k in m.get('EnsRegionId'):
                temp_model = DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtendsEnsRegionId()
                self.ens_region_id.append(temp_model.from_map(k))
        return self


class DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceInstanceSpeces(TeaModel):
    def __init__(
        self,
        instance_spec: List[str] = None,
    ):
        self.instance_spec = instance_spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_spec is not None:
            result['InstanceSpec'] = self.instance_spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceSpec') is not None:
            self.instance_spec = m.get('InstanceSpec')
        return self


class DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceIsp(TeaModel):
    def __init__(
        self,
        isp: List[str] = None,
    ):
        self.isp = isp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.isp is not None:
            result['Isp'] = self.isp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        return self


class DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResource(TeaModel):
    def __init__(
        self,
        bandwidth_types: DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceBandwidthTypes = None,
        data_disk_max_size: int = None,
        data_disk_min_size: int = None,
        ens_region_ids: DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIds = None,
        ens_region_ids_extends: DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtends = None,
        instance_speces: DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceInstanceSpeces = None,
        isp: DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceIsp = None,
        system_disk_max_size: int = None,
        system_disk_min_size: int = None,
    ):
        # Bandwidth billing method.
        self.bandwidth_types = bandwidth_types
        # The maximum capacity of a data disk. Unit: GB.
        self.data_disk_max_size = data_disk_max_size
        # The minimum data disk size. Unit: GiB.
        self.data_disk_min_size = data_disk_min_size
        # node ID
        self.ens_region_ids = ens_region_ids
        # The supplementary information about the edge nodes.
        self.ens_region_ids_extends = ens_region_ids_extends
        self.instance_speces = instance_speces
        # Operator
        self.isp = isp
        # The maximum size of the system disk. Unit: GiB.
        self.system_disk_max_size = system_disk_max_size
        # The minimum capacity of a system disk. Unit: GB.
        self.system_disk_min_size = system_disk_min_size

    def validate(self):
        if self.bandwidth_types:
            self.bandwidth_types.validate()
        if self.ens_region_ids:
            self.ens_region_ids.validate()
        if self.ens_region_ids_extends:
            self.ens_region_ids_extends.validate()
        if self.instance_speces:
            self.instance_speces.validate()
        if self.isp:
            self.isp.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidth_types is not None:
            result['BandwidthTypes'] = self.bandwidth_types.to_map()
        if self.data_disk_max_size is not None:
            result['DataDiskMaxSize'] = self.data_disk_max_size
        if self.data_disk_min_size is not None:
            result['DataDiskMinSize'] = self.data_disk_min_size
        if self.ens_region_ids is not None:
            result['EnsRegionIds'] = self.ens_region_ids.to_map()
        if self.ens_region_ids_extends is not None:
            result['EnsRegionIdsExtends'] = self.ens_region_ids_extends.to_map()
        if self.instance_speces is not None:
            result['InstanceSpeces'] = self.instance_speces.to_map()
        if self.isp is not None:
            result['Isp'] = self.isp.to_map()
        if self.system_disk_max_size is not None:
            result['SystemDiskMaxSize'] = self.system_disk_max_size
        if self.system_disk_min_size is not None:
            result['SystemDiskMinSize'] = self.system_disk_min_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BandwidthTypes') is not None:
            temp_model = DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceBandwidthTypes()
            self.bandwidth_types = temp_model.from_map(m['BandwidthTypes'])
        if m.get('DataDiskMaxSize') is not None:
            self.data_disk_max_size = m.get('DataDiskMaxSize')
        if m.get('DataDiskMinSize') is not None:
            self.data_disk_min_size = m.get('DataDiskMinSize')
        if m.get('EnsRegionIds') is not None:
            temp_model = DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIds()
            self.ens_region_ids = temp_model.from_map(m['EnsRegionIds'])
        if m.get('EnsRegionIdsExtends') is not None:
            temp_model = DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtends()
            self.ens_region_ids_extends = temp_model.from_map(m['EnsRegionIdsExtends'])
        if m.get('InstanceSpeces') is not None:
            temp_model = DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceInstanceSpeces()
            self.instance_speces = temp_model.from_map(m['InstanceSpeces'])
        if m.get('Isp') is not None:
            temp_model = DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceIsp()
            self.isp = temp_model.from_map(m['Isp'])
        if m.get('SystemDiskMaxSize') is not None:
            self.system_disk_max_size = m.get('SystemDiskMaxSize')
        if m.get('SystemDiskMinSize') is not None:
            self.system_disk_min_size = m.get('SystemDiskMinSize')
        return self


class DescribeAvailableResourceInfoResponseBodySupportResources(TeaModel):
    def __init__(
        self,
        support_resource: List[DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResource] = None,
    ):
        self.support_resource = support_resource

    def validate(self):
        if self.support_resource:
            for k in self.support_resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SupportResource'] = []
        if self.support_resource is not None:
            for k in self.support_resource:
                result['SupportResource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.support_resource = []
        if m.get('SupportResource') is not None:
            for k in m.get('SupportResource'):
                temp_model = DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResource()
                self.support_resource.append(temp_model.from_map(k))
        return self


class DescribeAvailableResourceInfoResponseBody(TeaModel):
    def __init__(
        self,
        images: DescribeAvailableResourceInfoResponseBodyImages = None,
        request_id: str = None,
        support_resources: DescribeAvailableResourceInfoResponseBodySupportResources = None,
    ):
        # The information about the image.
        self.images = images
        # The request ID.
        self.request_id = request_id
        # The specifications of resources that you can purchase.
        self.support_resources = support_resources

    def validate(self):
        if self.images:
            self.images.validate()
        if self.support_resources:
            self.support_resources.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.images is not None:
            result['Images'] = self.images.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.support_resources is not None:
            result['SupportResources'] = self.support_resources.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Images') is not None:
            temp_model = DescribeAvailableResourceInfoResponseBodyImages()
            self.images = temp_model.from_map(m['Images'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SupportResources') is not None:
            temp_model = DescribeAvailableResourceInfoResponseBodySupportResources()
            self.support_resources = temp_model.from_map(m['SupportResources'])
        return self


class DescribeAvailableResourceInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAvailableResourceInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAvailableResourceInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBandWithdChargeTypeResponseBody(TeaModel):
    def __init__(
        self,
        band_with_type_info: str = None,
        charge_contract_type: str = None,
        charge_cycle_info: str = None,
        code: int = None,
        request_id: str = None,
    ):
        # The information about the metering method.
        self.band_with_type_info = band_with_type_info
        # The metering type.
        # 
        # *   ChargeByUnified: unified metering.
        # *   ChargeByGrade: differential metering.
        self.charge_contract_type = charge_contract_type
        # The metering cycle. Currently, this parameter is empty in the response.
        self.charge_cycle_info = charge_cycle_info
        # The returned service code. A value of 0 indicates that the operation was successful.
        self.code = code
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.band_with_type_info is not None:
            result['BandWithTypeInfo'] = self.band_with_type_info
        if self.charge_contract_type is not None:
            result['ChargeContractType'] = self.charge_contract_type
        if self.charge_cycle_info is not None:
            result['ChargeCycleInfo'] = self.charge_cycle_info
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BandWithTypeInfo') is not None:
            self.band_with_type_info = m.get('BandWithTypeInfo')
        if m.get('ChargeContractType') is not None:
            self.charge_contract_type = m.get('ChargeContractType')
        if m.get('ChargeCycleInfo') is not None:
            self.charge_cycle_info = m.get('ChargeCycleInfo')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBandWithdChargeTypeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeBandWithdChargeTypeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBandWithdChargeTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBandwitdhByInternetChargeTypeRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        ens_region_id: str = None,
        isp: str = None,
        start_time: str = None,
    ):
        # The end of the time range to query.
        # 
        # *   Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # *   If the value of the seconds place is not 00, the start time is automatically set to the next minute.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The region ID of the instance.
        self.ens_region_id = ens_region_id
        # The Internet service provider (ISP). Valid values:
        # 
        # *   cmcc: China Mobile
        # *   telecom: China Telecom
        # *   unicom: China Unicom
        # *   multiCarrier: multi-line ISP
        self.isp = isp
        # The beginning of the time range to query.
        # 
        # *   Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # *   If the value of the seconds place is not 00, the start time is automatically set to the next minute.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeBandwitdhByInternetChargeTypeResponseBody(TeaModel):
    def __init__(
        self,
        bandwidth_value: int = None,
        internet_charge_type: str = None,
        request_id: str = None,
        time_stamp: str = None,
    ):
        # The bandwidth. Unit: bit/s.
        self.bandwidth_value = bandwidth_value
        # The metering method. Valid values:
        # 
        # *   BandwidthByDay: Pay by daily peak bandwidth
        # *   95BandwidthByMonth: Pay by monthly 95th percentile bandwidth
        # *   PayByBandwidth4thMonth: Pay by monthly fourth peak bandwidth
        # *   PayByBandwidth: Pay by fixed bandwidth
        # 
        # You can specify only one metering method for network usage and cannot overwrite the existing metering method.
        self.internet_charge_type = internet_charge_type
        # The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use the ID to troubleshoot issues.
        self.request_id = request_id
        # The timestamp. The time follows the ISO 8601 standard. The time is displayed in UTC. Example: 2016-10-20T04:00:00Z.
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidth_value is not None:
            result['BandwidthValue'] = self.bandwidth_value
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BandwidthValue') is not None:
            self.bandwidth_value = m.get('BandwidthValue')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeBandwitdhByInternetChargeTypeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeBandwitdhByInternetChargeTypeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBandwitdhByInternetChargeTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResourceAbility(TeaModel):
    def __init__(
        self,
        ability: List[str] = None,
    ):
        self.ability = ability

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ability is not None:
            result['Ability'] = self.ability
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ability') is not None:
            self.ability = m.get('Ability')
        return self


class DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResource(TeaModel):
    def __init__(
        self,
        ability: DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResourceAbility = None,
        can_buy_count: int = None,
        category: str = None,
        default_disk_size: int = None,
        disk_max_size: int = None,
        disk_min_size: int = None,
        ens_region_id: str = None,
        ens_region_name: str = None,
    ):
        # Node product capability.
        self.ability = ability
        # The number of disks that you can purchase.
        self.can_buy_count = can_buy_count
        # The type of the disk.
        # 
        # *   cloud_efficiency:ultra disk.
        # *   cloud_ssd:all-flash disk.
        # *   local_hdd:local HDD.
        # *   local_ssd:local SSD.
        self.category = category
        # The default size of the disk. Unit: GiB.
        self.default_disk_size = default_disk_size
        # The maximum size of the disk. Unit: GiB.
        self.disk_max_size = disk_max_size
        # The minimum size of the disk size. Unit: GiB.
        self.disk_min_size = disk_min_size
        # The ID of the edge node.
        self.ens_region_id = ens_region_id
        # The name of the task node.
        self.ens_region_name = ens_region_name

    def validate(self):
        if self.ability:
            self.ability.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ability is not None:
            result['Ability'] = self.ability.to_map()
        if self.can_buy_count is not None:
            result['CanBuyCount'] = self.can_buy_count
        if self.category is not None:
            result['Category'] = self.category
        if self.default_disk_size is not None:
            result['DefaultDiskSize'] = self.default_disk_size
        if self.disk_max_size is not None:
            result['DiskMaxSize'] = self.disk_max_size
        if self.disk_min_size is not None:
            result['DiskMinSize'] = self.disk_min_size
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.ens_region_name is not None:
            result['EnsRegionName'] = self.ens_region_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ability') is not None:
            temp_model = DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResourceAbility()
            self.ability = temp_model.from_map(m['Ability'])
        if m.get('CanBuyCount') is not None:
            self.can_buy_count = m.get('CanBuyCount')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('DefaultDiskSize') is not None:
            self.default_disk_size = m.get('DefaultDiskSize')
        if m.get('DiskMaxSize') is not None:
            self.disk_max_size = m.get('DiskMaxSize')
        if m.get('DiskMinSize') is not None:
            self.disk_min_size = m.get('DiskMinSize')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('EnsRegionName') is not None:
            self.ens_region_name = m.get('EnsRegionName')
        return self


class DescribeCloudDiskAvailableResourceInfoResponseBodySupportResources(TeaModel):
    def __init__(
        self,
        support_resource: List[DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResource] = None,
    ):
        self.support_resource = support_resource

    def validate(self):
        if self.support_resource:
            for k in self.support_resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SupportResource'] = []
        if self.support_resource is not None:
            for k in self.support_resource:
                result['SupportResource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.support_resource = []
        if m.get('SupportResource') is not None:
            for k in m.get('SupportResource'):
                temp_model = DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResource()
                self.support_resource.append(temp_model.from_map(k))
        return self


class DescribeCloudDiskAvailableResourceInfoResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        support_resources: DescribeCloudDiskAvailableResourceInfoResponseBodySupportResources = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The specifications of resources that you can purchase.
        self.support_resources = support_resources

    def validate(self):
        if self.support_resources:
            self.support_resources.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.support_resources is not None:
            result['SupportResources'] = self.support_resources.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SupportResources') is not None:
            temp_model = DescribeCloudDiskAvailableResourceInfoResponseBodySupportResources()
            self.support_resources = temp_model.from_map(m['SupportResources'])
        return self


class DescribeCloudDiskAvailableResourceInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCloudDiskAvailableResourceInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudDiskAvailableResourceInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudDiskTypesRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        ens_region_ids: List[str] = None,
    ):
        # The ID of the edge node.
        self.ens_region_id = ens_region_id
        # The edge nodes.
        self.ens_region_ids = ens_region_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.ens_region_ids is not None:
            result['EnsRegionIds'] = self.ens_region_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('EnsRegionIds') is not None:
            self.ens_region_ids = m.get('EnsRegionIds')
        return self


class DescribeCloudDiskTypesShrinkRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        ens_region_ids_shrink: str = None,
    ):
        # The ID of the edge node.
        self.ens_region_id = ens_region_id
        # The edge nodes.
        self.ens_region_ids_shrink = ens_region_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.ens_region_ids_shrink is not None:
            result['EnsRegionIds'] = self.ens_region_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('EnsRegionIds') is not None:
            self.ens_region_ids_shrink = m.get('EnsRegionIds')
        return self


class DescribeCloudDiskTypesResponseBodySupportResourcesSupportResource(TeaModel):
    def __init__(
        self,
        category: str = None,
        ens_region_id: str = None,
    ):
        # The category of the disk.
        # 
        # *   cloud_efficiency: ultra disk.
        # *   cloud_ssd: all-flash disk.
        # *   local_hdd: local HDD.
        # *   local_ssd: local SSD.
        self.category = category
        # The ID of the edge node.
        self.ens_region_id = ens_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        return self


class DescribeCloudDiskTypesResponseBodySupportResources(TeaModel):
    def __init__(
        self,
        support_resource: List[DescribeCloudDiskTypesResponseBodySupportResourcesSupportResource] = None,
    ):
        self.support_resource = support_resource

    def validate(self):
        if self.support_resource:
            for k in self.support_resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SupportResource'] = []
        if self.support_resource is not None:
            for k in self.support_resource:
                result['SupportResource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.support_resource = []
        if m.get('SupportResource') is not None:
            for k in m.get('SupportResource'):
                temp_model = DescribeCloudDiskTypesResponseBodySupportResourcesSupportResource()
                self.support_resource.append(temp_model.from_map(k))
        return self


class DescribeCloudDiskTypesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        support_resources: DescribeCloudDiskTypesResponseBodySupportResources = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The specifications of resources that you can purchase.
        self.support_resources = support_resources

    def validate(self):
        if self.support_resources:
            self.support_resources.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.support_resources is not None:
            result['SupportResources'] = self.support_resources.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SupportResources') is not None:
            temp_model = DescribeCloudDiskTypesResponseBodySupportResources()
            self.support_resources = temp_model.from_map(m['SupportResources'])
        return self


class DescribeCloudDiskTypesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCloudDiskTypesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudDiskTypesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeClusterRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
    ):
        # The cluster ID.
        self.cluster_id = cluster_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        return self


class DescribeClusterResponseBodyClusters(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        current_version: str = None,
        name: str = None,
        next_version: str = None,
        status: str = None,
    ):
        # The cluster ID.
        self.cluster_id = cluster_id
        # The version of the cluster.
        self.current_version = current_version
        # The cluster name.
        self.name = name
        # The next version of the cluster.
        self.next_version = next_version
        # The health status of the instance.
        # 
        # Valid values:
        # 
        # *   healthy
        # *   unhealthy
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.current_version is not None:
            result['CurrentVersion'] = self.current_version
        if self.name is not None:
            result['Name'] = self.name
        if self.next_version is not None:
            result['NextVersion'] = self.next_version
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CurrentVersion') is not None:
            self.current_version = m.get('CurrentVersion')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NextVersion') is not None:
            self.next_version = m.get('NextVersion')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeClusterResponseBody(TeaModel):
    def __init__(
        self,
        clusters: List[DescribeClusterResponseBodyClusters] = None,
        request_id: str = None,
    ):
        # An array that consists of the information about clusters.
        self.clusters = clusters
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.clusters:
            for k in self.clusters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Clusters'] = []
        if self.clusters is not None:
            for k in self.clusters:
                result['Clusters'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.clusters = []
        if m.get('Clusters') is not None:
            for k in m.get('Clusters'):
                temp_model = DescribeClusterResponseBodyClusters()
                self.clusters.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeClusterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeClusterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeClusterKubeConfigRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
    ):
        # The cluster ID.
        self.cluster_id = cluster_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        return self


class DescribeClusterKubeConfigResponseBody(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        kubeconfig: str = None,
        request_id: str = None,
    ):
        # The cluster ID.
        self.cluster_id = cluster_id
        # The cluster certificate.
        self.kubeconfig = kubeconfig
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.kubeconfig is not None:
            result['Kubeconfig'] = self.kubeconfig
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Kubeconfig') is not None:
            self.kubeconfig = m.get('Kubeconfig')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeClusterKubeConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeClusterKubeConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeClusterKubeConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCreatePrePaidInstanceResultRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # The ID of the instance. You can call the CreateIntance operation to create an instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeCreatePrePaidInstanceResultResponseBodyInstanceCreateResult(TeaModel):
    def __init__(
        self,
        instance_create_status: str = None,
        instance_id: str = None,
    ):
        # The status of the instance creation.
        # 
        # *   Accepted
        # *   Creating
        # *   Failed
        # *   Successed
        self.instance_create_status = instance_create_status
        # The ID of the instance.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_create_status is not None:
            result['InstanceCreateStatus'] = self.instance_create_status
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceCreateStatus') is not None:
            self.instance_create_status = m.get('InstanceCreateStatus')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeCreatePrePaidInstanceResultResponseBody(TeaModel):
    def __init__(
        self,
        instance_create_result: DescribeCreatePrePaidInstanceResultResponseBodyInstanceCreateResult = None,
        request_id: str = None,
    ):
        # Returned results of creating an instance.
        self.instance_create_result = instance_create_result
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.instance_create_result:
            self.instance_create_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_create_result is not None:
            result['InstanceCreateResult'] = self.instance_create_result.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceCreateResult') is not None:
            temp_model = DescribeCreatePrePaidInstanceResultResponseBodyInstanceCreateResult()
            self.instance_create_result = temp_model.from_map(m['InstanceCreateResult'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCreatePrePaidInstanceResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCreatePrePaidInstanceResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCreatePrePaidInstanceResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDataDistResultRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_names: str = None,
        data_versions: str = None,
        ens_region_ids: List[str] = None,
        instance_ids: str = None,
        max_date: str = None,
        min_date: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The name of the data file. Separate multiple names with commas (,). By default, all data files are queried.
        self.data_names = data_names
        # The version number of the data file. Separate multiple numbers with commas (,). By default, all versions of data files are queried.
        self.data_versions = data_versions
        # The IDs of the ENS nodes.
        self.ens_region_ids = ens_region_ids
        # The IDs of ENS instances. Separate multiple IDs with commas (,). By default, all instances are queried.
        self.instance_ids = instance_ids
        # The end of the time range to query. Specify the time in the 2006-01-02 format. By default, the time range to query is not restricted.
        self.max_date = max_date
        # The beginning of the time range to query. Specify the time in the 2006-01-02 format. By default, the time range to query is not restricted.
        self.min_date = min_date
        # The page number. Pages start from page 1. This parameter is optional if you want to return the push status of all data files.
        self.page_number = page_number
        # The number of entries per page. This parameter is optional if you want to return the distribution status of all data files.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_names is not None:
            result['DataNames'] = self.data_names
        if self.data_versions is not None:
            result['DataVersions'] = self.data_versions
        if self.ens_region_ids is not None:
            result['EnsRegionIds'] = self.ens_region_ids
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.max_date is not None:
            result['MaxDate'] = self.max_date
        if self.min_date is not None:
            result['MinDate'] = self.min_date
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataNames') is not None:
            self.data_names = m.get('DataNames')
        if m.get('DataVersions') is not None:
            self.data_versions = m.get('DataVersions')
        if m.get('EnsRegionIds') is not None:
            self.ens_region_ids = m.get('EnsRegionIds')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('MaxDate') is not None:
            self.max_date = m.get('MaxDate')
        if m.get('MinDate') is not None:
            self.min_date = m.get('MinDate')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeDataDistResultShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_names: str = None,
        data_versions: str = None,
        ens_region_ids_shrink: str = None,
        instance_ids: str = None,
        max_date: str = None,
        min_date: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The name of the data file. Separate multiple names with commas (,). By default, all data files are queried.
        self.data_names = data_names
        # The version number of the data file. Separate multiple numbers with commas (,). By default, all versions of data files are queried.
        self.data_versions = data_versions
        # The IDs of the ENS nodes.
        self.ens_region_ids_shrink = ens_region_ids_shrink
        # The IDs of ENS instances. Separate multiple IDs with commas (,). By default, all instances are queried.
        self.instance_ids = instance_ids
        # The end of the time range to query. Specify the time in the 2006-01-02 format. By default, the time range to query is not restricted.
        self.max_date = max_date
        # The beginning of the time range to query. Specify the time in the 2006-01-02 format. By default, the time range to query is not restricted.
        self.min_date = min_date
        # The page number. Pages start from page 1. This parameter is optional if you want to return the push status of all data files.
        self.page_number = page_number
        # The number of entries per page. This parameter is optional if you want to return the distribution status of all data files.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_names is not None:
            result['DataNames'] = self.data_names
        if self.data_versions is not None:
            result['DataVersions'] = self.data_versions
        if self.ens_region_ids_shrink is not None:
            result['EnsRegionIds'] = self.ens_region_ids_shrink
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.max_date is not None:
            result['MaxDate'] = self.max_date
        if self.min_date is not None:
            result['MinDate'] = self.min_date
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataNames') is not None:
            self.data_names = m.get('DataNames')
        if m.get('DataVersions') is not None:
            self.data_versions = m.get('DataVersions')
        if m.get('EnsRegionIds') is not None:
            self.ens_region_ids_shrink = m.get('EnsRegionIds')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('MaxDate') is not None:
            self.max_date = m.get('MaxDate')
        if m.get('MinDate') is not None:
            self.min_date = m.get('MinDate')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstancesInstance(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        start_time: str = None,
        status_descrip: str = None,
        update_time: str = None,
    ):
        # The ID of the instance
        self.instance_id = instance_id
        # The start time of the distribution. The time is displayed in UTC.
        self.start_time = start_time
        # The description of the distribution status.
        self.status_descrip = status_descrip
        # The time when the distribution status was last updated. The time is displayed in UTC.
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status_descrip is not None:
            result['StatusDescrip'] = self.status_descrip
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StatusDescrip') is not None:
            self.status_descrip = m.get('StatusDescrip')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstances(TeaModel):
    def __init__(
        self,
        instance: List[DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstancesInstance] = None,
    ):
        self.instance = instance

    def validate(self):
        if self.instance:
            for k in self.instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instance'] = []
        if self.instance is not None:
            for k in self.instance:
                result['Instance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance = []
        if m.get('Instance') is not None:
            for k in m.get('Instance'):
                temp_model = DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstancesInstance()
                self.instance.append(temp_model.from_map(k))
        return self


class DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStat(TeaModel):
    def __init__(
        self,
        instance_count: str = None,
        instances: DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstances = None,
        status: str = None,
    ):
        # The number of associated edge instances.
        self.instance_count = instance_count
        # The distribution status of the edge instance.
        self.instances = instances
        # The distribution status. The value is of the enumeration type. Valid values:
        # 
        # *   SUCCESS: The distribution is successful.
        # *   FAILED: The distribution failed.
        # *   DISTING: The data is being distributed.
        # *   POD_RESTARTING: The idle pod is being restarted.
        # *   DELETED: The data is cleared or removed.
        self.status = status

    def validate(self):
        if self.instances:
            self.instances.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.instances is not None:
            result['Instances'] = self.instances.to_map()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('Instances') is not None:
            temp_model = DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstances()
            self.instances = temp_model.from_map(m['Instances'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeDataDistResultResponseBodyDistResultsDistResultStatusStats(TeaModel):
    def __init__(
        self,
        status_stat: List[DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStat] = None,
    ):
        self.status_stat = status_stat

    def validate(self):
        if self.status_stat:
            for k in self.status_stat:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StatusStat'] = []
        if self.status_stat is not None:
            for k in self.status_stat:
                result['StatusStat'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.status_stat = []
        if m.get('StatusStat') is not None:
            for k in m.get('StatusStat'):
                temp_model = DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStat()
                self.status_stat.append(temp_model.from_map(k))
        return self


class DescribeDataDistResultResponseBodyDistResultsDistResult(TeaModel):
    def __init__(
        self,
        name: str = None,
        status_stats: DescribeDataDistResultResponseBodyDistResultsDistResultStatusStats = None,
        version: str = None,
    ):
        # The name of the data file.
        self.name = name
        # The distribution status statistics.
        self.status_stats = status_stats
        # The version number of the data file.
        self.version = version

    def validate(self):
        if self.status_stats:
            self.status_stats.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.status_stats is not None:
            result['StatusStats'] = self.status_stats.to_map()
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('StatusStats') is not None:
            temp_model = DescribeDataDistResultResponseBodyDistResultsDistResultStatusStats()
            self.status_stats = temp_model.from_map(m['StatusStats'])
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DescribeDataDistResultResponseBodyDistResults(TeaModel):
    def __init__(
        self,
        dist_result: List[DescribeDataDistResultResponseBodyDistResultsDistResult] = None,
    ):
        self.dist_result = dist_result

    def validate(self):
        if self.dist_result:
            for k in self.dist_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DistResult'] = []
        if self.dist_result is not None:
            for k in self.dist_result:
                result['DistResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dist_result = []
        if m.get('DistResult') is not None:
            for k in m.get('DistResult'):
                temp_model = DescribeDataDistResultResponseBodyDistResultsDistResult()
                self.dist_result.append(temp_model.from_map(k))
        return self


class DescribeDataDistResultResponseBody(TeaModel):
    def __init__(
        self,
        dist_results: DescribeDataDistResultResponseBodyDistResults = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The distribution status of data files on edge instances.
        self.dist_results = dist_results
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.dist_results:
            self.dist_results.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dist_results is not None:
            result['DistResults'] = self.dist_results.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DistResults') is not None:
            temp_model = DescribeDataDistResultResponseBodyDistResults()
            self.dist_results = temp_model.from_map(m['DistResults'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDataDistResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDataDistResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDataDistResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDataDownloadURLRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_name: str = None,
        data_version: str = None,
        expire_timeout: int = None,
        server_filter_strategy: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The name of the data file.
        # 
        # This parameter is required.
        self.data_name = data_name
        # The version number of the data file.
        # 
        # This parameter is required.
        self.data_version = data_version
        # This parameter is reserved.
        self.expire_timeout = expire_timeout
        # The condition that you want to use to filter file servers. You can specify multiple canary release policies. By default, all resources are queried.
        self.server_filter_strategy = server_filter_strategy

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_name is not None:
            result['DataName'] = self.data_name
        if self.data_version is not None:
            result['DataVersion'] = self.data_version
        if self.expire_timeout is not None:
            result['ExpireTimeout'] = self.expire_timeout
        if self.server_filter_strategy is not None:
            result['ServerFilterStrategy'] = self.server_filter_strategy
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataName') is not None:
            self.data_name = m.get('DataName')
        if m.get('DataVersion') is not None:
            self.data_version = m.get('DataVersion')
        if m.get('ExpireTimeout') is not None:
            self.expire_timeout = m.get('ExpireTimeout')
        if m.get('ServerFilterStrategy') is not None:
            self.server_filter_strategy = m.get('ServerFilterStrategy')
        return self


class DescribeDataDownloadURLResponseBodyDataServerList(TeaModel):
    def __init__(
        self,
        host: str = None,
        region_id: str = None,
    ):
        # The host address of the file server.
        self.host = host
        # The ID of the Edge Node Service (ENS) node.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host is not None:
            result['Host'] = self.host
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeDataDownloadURLResponseBodyData(TeaModel):
    def __init__(
        self,
        expire_time: str = None,
        server_list: List[DescribeDataDownloadURLResponseBodyDataServerList] = None,
        url: str = None,
    ):
        # The time when the data file expires. The time is displayed in UTC.
        self.expire_time = expire_time
        # The file servers.
        self.server_list = server_list
        # The download URL of the data file.
        self.url = url

    def validate(self):
        if self.server_list:
            for k in self.server_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        result['ServerList'] = []
        if self.server_list is not None:
            for k in self.server_list:
                result['ServerList'].append(k.to_map() if k else None)
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        self.server_list = []
        if m.get('ServerList') is not None:
            for k in m.get('ServerList'):
                temp_model = DescribeDataDownloadURLResponseBodyDataServerList()
                self.server_list.append(temp_model.from_map(k))
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class DescribeDataDownloadURLResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: DescribeDataDownloadURLResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code.
        self.code = code
        # The download URLs of data files.
        self.data = data
        # The response message. Success is returned for a successful request.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeDataDownloadURLResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDataDownloadURLResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDataDownloadURLResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDataDownloadURLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDataPushResultRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_names: str = None,
        data_versions: str = None,
        max_date: str = None,
        min_date: str = None,
        page_number: int = None,
        page_size: int = None,
        region_ids: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The name of the data file. Separate multiple names with commas (,). By default, all data files are queried.
        self.data_names = data_names
        # The version number of the data file. Separate multiple numbers with commas (,). By default, all versions of data files are queried.
        self.data_versions = data_versions
        # The end of the time range to query. Specify the time in the 2006-01-02 format. By default, the time range to query is not restricted.
        self.max_date = max_date
        # The beginning of the time range to query. Specify the time in the 2006-01-02 format. By default, the time range to query is not restricted.
        self.min_date = min_date
        self.page_number = page_number
        # The number of entries per page. This parameter is optional if you want to return the push status of all data files.
        self.page_size = page_size
        # The IDs of ENS nodes. Separate multiple IDs with commas (,). By default, all ENS nodes are queried.
        self.region_ids = region_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_names is not None:
            result['DataNames'] = self.data_names
        if self.data_versions is not None:
            result['DataVersions'] = self.data_versions
        if self.max_date is not None:
            result['MaxDate'] = self.max_date
        if self.min_date is not None:
            result['MinDate'] = self.min_date
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_ids is not None:
            result['RegionIds'] = self.region_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataNames') is not None:
            self.data_names = m.get('DataNames')
        if m.get('DataVersions') is not None:
            self.data_versions = m.get('DataVersions')
        if m.get('MaxDate') is not None:
            self.max_date = m.get('MaxDate')
        if m.get('MinDate') is not None:
            self.min_date = m.get('MinDate')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionIds') is not None:
            self.region_ids = m.get('RegionIds')
        return self


class DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIdsRegionId(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        start_time: str = None,
        status_descrip: str = None,
        update_time: str = None,
    ):
        # The ID of the ENS node.
        self.region_id = region_id
        # The start time of the push operation. The time is displayed in UTC.
        self.start_time = start_time
        # The description of the status.
        self.status_descrip = status_descrip
        # The time when the status was last updated. The time is displayed in UTC.
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status_descrip is not None:
            result['StatusDescrip'] = self.status_descrip
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StatusDescrip') is not None:
            self.status_descrip = m.get('StatusDescrip')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIds(TeaModel):
    def __init__(
        self,
        region_id: List[DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIdsRegionId] = None,
    ):
        self.region_id = region_id

    def validate(self):
        if self.region_id:
            for k in self.region_id:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RegionId'] = []
        if self.region_id is not None:
            for k in self.region_id:
                result['RegionId'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.region_id = []
        if m.get('RegionId') is not None:
            for k in m.get('RegionId'):
                temp_model = DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIdsRegionId()
                self.region_id.append(temp_model.from_map(k))
        return self


class DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStat(TeaModel):
    def __init__(
        self,
        region_id_count: int = None,
        region_ids: DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIds = None,
        status: str = None,
    ):
        # The total number of ENS nodes.
        self.region_id_count = region_id_count
        # The push status of data files on the ENS node.
        self.region_ids = region_ids
        # The push status. The value is of the enumeration type. Valid values: SUCCESS FAILED PUSHING
        self.status = status

    def validate(self):
        if self.region_ids:
            self.region_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id_count is not None:
            result['RegionIdCount'] = self.region_id_count
        if self.region_ids is not None:
            result['RegionIds'] = self.region_ids.to_map()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionIdCount') is not None:
            self.region_id_count = m.get('RegionIdCount')
        if m.get('RegionIds') is not None:
            temp_model = DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIds()
            self.region_ids = temp_model.from_map(m['RegionIds'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatS(TeaModel):
    def __init__(
        self,
        status_stat: List[DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStat] = None,
    ):
        self.status_stat = status_stat

    def validate(self):
        if self.status_stat:
            for k in self.status_stat:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StatusStat'] = []
        if self.status_stat is not None:
            for k in self.status_stat:
                result['StatusStat'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.status_stat = []
        if m.get('StatusStat') is not None:
            for k in m.get('StatusStat'):
                temp_model = DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStat()
                self.status_stat.append(temp_model.from_map(k))
        return self


class DescribeDataPushResultResponseBodyPushResultsPushResult(TeaModel):
    def __init__(
        self,
        name: str = None,
        status_stat_s: DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatS = None,
        version: str = None,
    ):
        # The name of the data file.
        self.name = name
        # The push status of data files.
        self.status_stat_s = status_stat_s
        # The version number of the data file.
        self.version = version

    def validate(self):
        if self.status_stat_s:
            self.status_stat_s.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.status_stat_s is not None:
            result['StatusStatS'] = self.status_stat_s.to_map()
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('StatusStatS') is not None:
            temp_model = DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatS()
            self.status_stat_s = temp_model.from_map(m['StatusStatS'])
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DescribeDataPushResultResponseBodyPushResults(TeaModel):
    def __init__(
        self,
        push_result: List[DescribeDataPushResultResponseBodyPushResultsPushResult] = None,
    ):
        self.push_result = push_result

    def validate(self):
        if self.push_result:
            for k in self.push_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PushResult'] = []
        if self.push_result is not None:
            for k in self.push_result:
                result['PushResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.push_result = []
        if m.get('PushResult') is not None:
            for k in m.get('PushResult'):
                temp_model = DescribeDataPushResultResponseBodyPushResultsPushResult()
                self.push_result.append(temp_model.from_map(k))
        return self


class DescribeDataPushResultResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        push_results: DescribeDataPushResultResponseBodyPushResults = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The push results of data files.
        self.push_results = push_results
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.push_results:
            self.push_results.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.push_results is not None:
            result['PushResults'] = self.push_results.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PushResults') is not None:
            temp_model = DescribeDataPushResultResponseBodyPushResults()
            self.push_results = temp_model.from_map(m['PushResults'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDataPushResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDataPushResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDataPushResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDeviceServiceRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        ens_region_id: str = None,
        instance_id: str = None,
        order_id: str = None,
        region_id: str = None,
        service_id: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # This parameter does not take effect.
        self.ens_region_id = ens_region_id
        # The ID of the instance.
        self.instance_id = instance_id
        # The ID of the order.
        self.order_id = order_id
        # The ID of the Edge Node Service (ENS) node.
        self.region_id = region_id
        # Service ID
        self.service_id = service_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.service_id is not None:
            result['ServiceId'] = self.service_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ServiceId') is not None:
            self.service_id = m.get('ServiceId')
        return self


class DescribeDeviceServiceResponseBodyAppMetaData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        app_stable_version: str = None,
        app_type: str = None,
        cluster_name: str = None,
        create_time: str = None,
        description: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name
        # The stable version number of the application.
        self.app_stable_version = app_stable_version
        # The type of the application. The value is of the enumeration type. Valid values:
        # 
        # *   Common
        # *   Scheduler
        self.app_type = app_type
        # The name of the application cluster.
        self.cluster_name = cluster_name
        # The time when the application was created.
        self.create_time = create_time
        # The description of the application.
        self.description = description

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.app_stable_version is not None:
            result['AppStableVersion'] = self.app_stable_version
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AppStableVersion') is not None:
            self.app_stable_version = m.get('AppStableVersion')
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        return self


class DescribeDeviceServiceResponseBodyAppStatus(TeaModel):
    def __init__(
        self,
        phase: str = None,
        status_descrip: str = None,
        update_time: str = None,
    ):
        # The status of the application. The value is of the enumeration type. Valid values:
        # 
        # Three intermediate states:
        # 
        # *   CREATING
        # *   UPDATING
        # *   DELETING
        # 
        # Four final states:
        # 
        # *   CREATE_FAILED
        # *   UPDATE_FAILED
        # *   DELETE_FAILED
        # *   RUNNING
        self.phase = phase
        # The description of the application status.
        self.status_descrip = status_descrip
        # The time when the status was last updated.
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.phase is not None:
            result['Phase'] = self.phase
        if self.status_descrip is not None:
            result['StatusDescrip'] = self.status_descrip
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Phase') is not None:
            self.phase = m.get('Phase')
        if m.get('StatusDescrip') is not None:
            self.status_descrip = m.get('StatusDescrip')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeDeviceServiceResponseBodyResourceDetailInfos(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        id: str = None,
        ip: str = None,
        isp: str = None,
        image_id: str = None,
        mac: str = None,
        region_id: str = None,
        server: str = None,
        status: str = None,
        type: str = None,
    ):
        # The name of the device.
        self.device_name = device_name
        # The ID of the cloud device.
        self.id = id
        # The IP address.
        self.ip = ip
        # The Internet service provider (ISP).
        self.isp = isp
        # The ID of the image.
        self.image_id = image_id
        # The media access control (MAC) address of the device.
        self.mac = mac
        # The ID of the ENS node.
        self.region_id = region_id
        # The server name of the ENS node.
        self.server = server
        # The status of the device.
        self.status = status
        # The type of the device.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.id is not None:
            result['ID'] = self.id
        if self.ip is not None:
            result['IP'] = self.ip
        if self.isp is not None:
            result['ISP'] = self.isp
        if self.image_id is not None:
            result['ImageID'] = self.image_id
        if self.mac is not None:
            result['Mac'] = self.mac
        if self.region_id is not None:
            result['RegionID'] = self.region_id
        if self.server is not None:
            result['Server'] = self.server
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('ID') is not None:
            self.id = m.get('ID')
        if m.get('IP') is not None:
            self.ip = m.get('IP')
        if m.get('ISP') is not None:
            self.isp = m.get('ISP')
        if m.get('ImageID') is not None:
            self.image_id = m.get('ImageID')
        if m.get('Mac') is not None:
            self.mac = m.get('Mac')
        if m.get('RegionID') is not None:
            self.region_id = m.get('RegionID')
        if m.get('Server') is not None:
            self.server = m.get('Server')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeDeviceServiceResponseBodyResourceInfosDeviceInfosNetwork(TeaModel):
    def __init__(
        self,
        container_ports: str = None,
        external_ip: str = None,
        host_ports: str = None,
        protocol: str = None,
    ):
        # The port of the container.
        self.container_ports = container_ports
        # The public IP address.
        self.external_ip = external_ip
        # The port range.
        self.host_ports = host_ports
        # The protocol of the gateway. The value is of the enumeration type. Valid values:
        # 
        # *   TCP
        # *   UDP
        self.protocol = protocol

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_ports is not None:
            result['ContainerPorts'] = self.container_ports
        if self.external_ip is not None:
            result['ExternalIp'] = self.external_ip
        if self.host_ports is not None:
            result['HostPorts'] = self.host_ports
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContainerPorts') is not None:
            self.container_ports = m.get('ContainerPorts')
        if m.get('ExternalIp') is not None:
            self.external_ip = m.get('ExternalIp')
        if m.get('HostPorts') is not None:
            self.host_ports = m.get('HostPorts')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        return self


class DescribeDeviceServiceResponseBodyResourceInfosDeviceInfos(TeaModel):
    def __init__(
        self,
        name: str = None,
        network: List[DescribeDeviceServiceResponseBodyResourceInfosDeviceInfosNetwork] = None,
        status: str = None,
    ):
        # The name of the device.
        self.name = name
        # The network information.
        self.network = network
        # The status.
        self.status = status

    def validate(self):
        if self.network:
            for k in self.network:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        result['Network'] = []
        if self.network is not None:
            for k in self.network:
                result['Network'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.network = []
        if m.get('Network') is not None:
            for k in m.get('Network'):
                temp_model = DescribeDeviceServiceResponseBodyResourceInfosDeviceInfosNetwork()
                self.network.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeDeviceServiceResponseBodyResourceInfosInternalIps(TeaModel):
    def __init__(
        self,
        ip: str = None,
    ):
        # The internal IP address.
        self.ip = ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['Ip'] = self.ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        return self


class DescribeDeviceServiceResponseBodyResourceInfosPublicIps(TeaModel):
    def __init__(
        self,
        ip: str = None,
    ):
        # The public IP address.
        self.ip = ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['Ip'] = self.ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        return self


class DescribeDeviceServiceResponseBodyResourceInfos(TeaModel):
    def __init__(
        self,
        app_version: str = None,
        area_code: str = None,
        area_name: str = None,
        create_time: str = None,
        device_infos: List[DescribeDeviceServiceResponseBodyResourceInfosDeviceInfos] = None,
        instance_id: str = None,
        instance_status: str = None,
        internal_ips: List[DescribeDeviceServiceResponseBodyResourceInfosInternalIps] = None,
        public_ips: List[DescribeDeviceServiceResponseBodyResourceInfosPublicIps] = None,
        region_code: str = None,
        region_id: str = None,
        region_name: str = None,
    ):
        # The version of the application.
        self.app_version = app_version
        # The area code.
        self.area_code = area_code
        # The region name.
        self.area_name = area_name
        # The time when the application was created.
        self.create_time = create_time
        # The information about the devices.
        self.device_infos = device_infos
        # The ID of the instance.
        self.instance_id = instance_id
        # The status of the instance.
        self.instance_status = instance_status
        # The internal IP addresses.
        self.internal_ips = internal_ips
        # The public IP addresses.
        self.public_ips = public_ips
        # The ID of the region.
        self.region_code = region_code
        # The ID of the ENS node.
        self.region_id = region_id
        # The name of the region.
        self.region_name = region_name

    def validate(self):
        if self.device_infos:
            for k in self.device_infos:
                if k:
                    k.validate()
        if self.internal_ips:
            for k in self.internal_ips:
                if k:
                    k.validate()
        if self.public_ips:
            for k in self.public_ips:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_version is not None:
            result['AppVersion'] = self.app_version
        if self.area_code is not None:
            result['AreaCode'] = self.area_code
        if self.area_name is not None:
            result['AreaName'] = self.area_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        result['DeviceInfos'] = []
        if self.device_infos is not None:
            for k in self.device_infos:
                result['DeviceInfos'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_status is not None:
            result['InstanceStatus'] = self.instance_status
        result['InternalIps'] = []
        if self.internal_ips is not None:
            for k in self.internal_ips:
                result['InternalIps'].append(k.to_map() if k else None)
        result['PublicIps'] = []
        if self.public_ips is not None:
            for k in self.public_ips:
                result['PublicIps'].append(k.to_map() if k else None)
        if self.region_code is not None:
            result['RegionCode'] = self.region_code
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.region_name is not None:
            result['RegionName'] = self.region_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppVersion') is not None:
            self.app_version = m.get('AppVersion')
        if m.get('AreaCode') is not None:
            self.area_code = m.get('AreaCode')
        if m.get('AreaName') is not None:
            self.area_name = m.get('AreaName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        self.device_infos = []
        if m.get('DeviceInfos') is not None:
            for k in m.get('DeviceInfos'):
                temp_model = DescribeDeviceServiceResponseBodyResourceInfosDeviceInfos()
                self.device_infos.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceStatus') is not None:
            self.instance_status = m.get('InstanceStatus')
        self.internal_ips = []
        if m.get('InternalIps') is not None:
            for k in m.get('InternalIps'):
                temp_model = DescribeDeviceServiceResponseBodyResourceInfosInternalIps()
                self.internal_ips.append(temp_model.from_map(k))
        self.public_ips = []
        if m.get('PublicIps') is not None:
            for k in m.get('PublicIps'):
                temp_model = DescribeDeviceServiceResponseBodyResourceInfosPublicIps()
                self.public_ips.append(temp_model.from_map(k))
        if m.get('RegionCode') is not None:
            self.region_code = m.get('RegionCode')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RegionName') is not None:
            self.region_name = m.get('RegionName')
        return self


class DescribeDeviceServiceResponseBody(TeaModel):
    def __init__(
        self,
        app_meta_data: DescribeDeviceServiceResponseBodyAppMetaData = None,
        app_status: DescribeDeviceServiceResponseBodyAppStatus = None,
        request_id: str = None,
        resource_detail_infos: List[DescribeDeviceServiceResponseBodyResourceDetailInfos] = None,
        resource_infos: List[DescribeDeviceServiceResponseBodyResourceInfos] = None,
    ):
        # The basic properties of the application.
        self.app_meta_data = app_meta_data
        # The status information of the application.
        self.app_status = app_status
        # The ID of the request.
        self.request_id = request_id
        # The information about the devices.
        self.resource_detail_infos = resource_detail_infos
        # The information about the instances.
        self.resource_infos = resource_infos

    def validate(self):
        if self.app_meta_data:
            self.app_meta_data.validate()
        if self.app_status:
            self.app_status.validate()
        if self.resource_detail_infos:
            for k in self.resource_detail_infos:
                if k:
                    k.validate()
        if self.resource_infos:
            for k in self.resource_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_meta_data is not None:
            result['AppMetaData'] = self.app_meta_data.to_map()
        if self.app_status is not None:
            result['AppStatus'] = self.app_status.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['ResourceDetailInfos'] = []
        if self.resource_detail_infos is not None:
            for k in self.resource_detail_infos:
                result['ResourceDetailInfos'].append(k.to_map() if k else None)
        result['ResourceInfos'] = []
        if self.resource_infos is not None:
            for k in self.resource_infos:
                result['ResourceInfos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppMetaData') is not None:
            temp_model = DescribeDeviceServiceResponseBodyAppMetaData()
            self.app_meta_data = temp_model.from_map(m['AppMetaData'])
        if m.get('AppStatus') is not None:
            temp_model = DescribeDeviceServiceResponseBodyAppStatus()
            self.app_status = temp_model.from_map(m['AppStatus'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.resource_detail_infos = []
        if m.get('ResourceDetailInfos') is not None:
            for k in m.get('ResourceDetailInfos'):
                temp_model = DescribeDeviceServiceResponseBodyResourceDetailInfos()
                self.resource_detail_infos.append(temp_model.from_map(k))
        self.resource_infos = []
        if m.get('ResourceInfos') is not None:
            for k in m.get('ResourceInfos'):
                temp_model = DescribeDeviceServiceResponseBodyResourceInfos()
                self.resource_infos.append(temp_model.from_map(k))
        return self


class DescribeDeviceServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDeviceServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDeviceServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDiskIopsListRequest(TeaModel):
    def __init__(
        self,
        disk_id: str = None,
        end_time: str = None,
        start_time: str = None,
    ):
        # The ID of the disk. Format: d-\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*.
        # 
        # This parameter is required.
        self.disk_id = disk_id
        # The beginning of the time range to query. Specify the time in the format of yyyy-MM-dd HH:mm:ss. The time range specified by the StartTime and EndTime parameters cannot exceed one day for a query.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The beginning of the time range to query. Specify the time in the format of yyyy-MM-dd HH:mm:ss.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeDiskIopsListResponseBodyDiskIopsList(TeaModel):
    def __init__(
        self,
        biz_time: str = None,
        disk_id: str = None,
        read_bytes: int = None,
        read_latency: int = None,
        read_ops: int = None,
        region_id: str = None,
        write_bytes: int = None,
        write_latency: int = None,
        write_ops: int = None,
    ):
        # The business time . The time is displayed in the yyyy-MM-dd HH:mm:ss.
        self.biz_time = biz_time
        # The ID of the disk.
        self.disk_id = disk_id
        # The read throughput. Unit: bytes.
        self.read_bytes = read_bytes
        # The read latency. Unit: ms.
        self.read_latency = read_latency
        # The read IOPS.
        self.read_ops = read_ops
        # The ID of the node.
        self.region_id = region_id
        # The write throughput. Unit: bytes.
        self.write_bytes = write_bytes
        # The write latency. Unit: microseconds.
        self.write_latency = write_latency
        # The write IOPS.
        self.write_ops = write_ops

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_time is not None:
            result['BizTime'] = self.biz_time
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.read_bytes is not None:
            result['ReadBytes'] = self.read_bytes
        if self.read_latency is not None:
            result['ReadLatency'] = self.read_latency
        if self.read_ops is not None:
            result['ReadOps'] = self.read_ops
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.write_bytes is not None:
            result['WriteBytes'] = self.write_bytes
        if self.write_latency is not None:
            result['WriteLatency'] = self.write_latency
        if self.write_ops is not None:
            result['WriteOps'] = self.write_ops
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizTime') is not None:
            self.biz_time = m.get('BizTime')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('ReadBytes') is not None:
            self.read_bytes = m.get('ReadBytes')
        if m.get('ReadLatency') is not None:
            self.read_latency = m.get('ReadLatency')
        if m.get('ReadOps') is not None:
            self.read_ops = m.get('ReadOps')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('WriteBytes') is not None:
            self.write_bytes = m.get('WriteBytes')
        if m.get('WriteLatency') is not None:
            self.write_latency = m.get('WriteLatency')
        if m.get('WriteOps') is not None:
            self.write_ops = m.get('WriteOps')
        return self


class DescribeDiskIopsListResponseBody(TeaModel):
    def __init__(
        self,
        disk_iops_list: List[DescribeDiskIopsListResponseBodyDiskIopsList] = None,
        request_id: str = None,
    ):
        # The IOPS monitoring data of the cloud disk.
        self.disk_iops_list = disk_iops_list
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.disk_iops_list:
            for k in self.disk_iops_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DiskIopsList'] = []
        if self.disk_iops_list is not None:
            for k in self.disk_iops_list:
                result['DiskIopsList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.disk_iops_list = []
        if m.get('DiskIopsList') is not None:
            for k in m.get('DiskIopsList'):
                temp_model = DescribeDiskIopsListResponseBodyDiskIopsList()
                self.disk_iops_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDiskIopsListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDiskIopsListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDiskIopsListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDisksRequest(TeaModel):
    def __init__(
        self,
        category: str = None,
        disk_charge_type: str = None,
        disk_id: str = None,
        disk_ids: str = None,
        disk_name: str = None,
        disk_type: str = None,
        ens_region_id: str = None,
        ens_region_ids: str = None,
        instance_id: str = None,
        order_by_params: str = None,
        page_number: str = None,
        page_size: str = None,
        snapshot_id: str = None,
        status: str = None,
        type: str = None,
    ):
        # The category of the disk.
        # 
        # *   cloud_efficiency: ultra disk.
        # *   cloud_ssd: all-flash disk.
        # *   local_hdd: local HDD.
        # *   local_ssd: local SSD.
        self.category = category
        # The billing method.
        # 
        # *   prePay: subscription.
        # *   postpay: pay-as-you-go.
        self.disk_charge_type = disk_charge_type
        # The ID of the disk.
        self.disk_id = disk_id
        # The ID of the disk.
        self.disk_ids = disk_ids
        # The name of the disk.
        self.disk_name = disk_name
        # The purchase method of the disk. Valid values:
        # 
        # *   ServiceDisk: The disk is purchased when ENS is activated.
        # *   ResoureDisk: The disk is purchased when the instance is created.
        # *   PostPayDisk: The disk is separately purchased.
        self.disk_type = disk_type
        # The ID of the edge node.
        self.ens_region_id = ens_region_id
        # The node information.
        self.ens_region_ids = ens_region_ids
        # The ID of the instance to which the disk is attached.
        self.instance_id = instance_id
        # The order in which you want to sort the returned data. Example: {"EnsRegionId":"desc"}. By default, the nodes are sorted by IDs in descending order.
        self.order_by_params = order_by_params
        # The number of the page to return. Pages start from page **1**.
        # 
        # Default value: **1**.
        self.page_number = page_number
        # The number of entries to return on each page. Maximum value: **50**.
        # 
        # Default value: **10**.
        self.page_size = page_size
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id
        # The status of the disk. Valid values:
        # 
        # *   In-use: The disk is in use.
        # *   Available: The disk can be attached.
        # *   Attaching: The disk is being attached.
        # *   Detaching: The disk is being detached.
        # *   Creating: The disk is being created.
        # *   ReIniting: The disk is being reset.
        # *   Deleting: The disk is being released.
        # *   Deleted: The disk is released.
        # *   Expiring: The disk is about to expire.
        self.status = status
        # The type of the disk. Valid values:
        # 
        # *   system: system disk.
        # *   data: data disk.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.disk_charge_type is not None:
            result['DiskChargeType'] = self.disk_charge_type
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.disk_ids is not None:
            result['DiskIds'] = self.disk_ids
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.ens_region_ids is not None:
            result['EnsRegionIds'] = self.ens_region_ids
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.order_by_params is not None:
            result['OrderByParams'] = self.order_by_params
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('DiskChargeType') is not None:
            self.disk_charge_type = m.get('DiskChargeType')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('DiskIds') is not None:
            self.disk_ids = m.get('DiskIds')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('EnsRegionIds') is not None:
            self.ens_region_ids = m.get('EnsRegionIds')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OrderByParams') is not None:
            self.order_by_params = m.get('OrderByParams')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeDisksResponseBodyDisksDisksTagsTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeDisksResponseBodyDisksDisksTags(TeaModel):
    def __init__(
        self,
        tags: List[DescribeDisksResponseBodyDisksDisksTagsTags] = None,
    ):
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = DescribeDisksResponseBodyDisksDisksTagsTags()
                self.tags.append(temp_model.from_map(k))
        return self


class DescribeDisksResponseBodyDisksDisks(TeaModel):
    def __init__(
        self,
        category: str = None,
        creation_time: str = None,
        delete_with_instance: bool = None,
        description: str = None,
        disk_charge_type: str = None,
        disk_id: str = None,
        disk_name: str = None,
        encrypted: bool = None,
        encrypted_key_id: str = None,
        ens_region_id: str = None,
        instance_id: str = None,
        instance_name: str = None,
        portable: bool = None,
        serial_id: str = None,
        size: int = None,
        snapshot_id: str = None,
        status: str = None,
        tags: DescribeDisksResponseBodyDisksDisksTags = None,
        type: str = None,
    ):
        # The category of the disk.
        # 
        # *   cloud_efficiency: ultra disk.
        # *   cloud_ssd: all-flash disk.
        # *   local_hdd: local HDD.
        # *   local_ssd: local SSD.
        self.category = category
        # The time when the disk was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.creation_time = creation_time
        # Indicates whether the disk is released when the instance to which the disk is attached is released. Valid values:
        # 
        # *   true: The disk is released when the associated instance is released.
        # *   false: The disk is retained when the associated instance is released.
        self.delete_with_instance = delete_with_instance
        # The namespace description.
        self.description = description
        # The billing method of the cloud disk or local disk. Valid values:
        # 
        # *   **prepaid**: subscription.
        # *   **postpaid**: pay-as-you-go.
        self.disk_charge_type = disk_charge_type
        # The ID of the disk.
        self.disk_id = disk_id
        # The name of the disk.
        self.disk_name = disk_name
        # Indicates whether the cloud disk is encrypted. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.encrypted = encrypted
        # The ID of the Key Management Service (KMS) key that is used for the cloud disk.
        self.encrypted_key_id = encrypted_key_id
        # The ID of the edge node.
        self.ens_region_id = ens_region_id
        # The ID of the instance.
        self.instance_id = instance_id
        # The name of the instance.
        self.instance_name = instance_name
        # Indicates whether the cloud disk or local disk is removable. Valid values:
        # 
        # *   true: The disk is removable. A removable disk can independently exist and can be attached to or detached from an instance within the same zone.
        # *   false: The disk is not removable. A disk that is not removable cannot independently exist or be attached to or detached from an instance within the same zone.
        # 
        # If disks are of the following categories or types, the **Portable** value is **false** and the disks have the same lifecycle as their attached instances:
        # 
        # *   Local HDDs
        # *   Local SSDs
        # *   Data disks that use the subscription billing method
        self.portable = portable
        # The serial number.
        self.serial_id = serial_id
        # The size of the disk. Unit: MiB.
        self.size = size
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id
        # The status of the disk. Valid values:
        # 
        # *   In-use: The disk is in use.
        # *   Available: The disk can be attached.
        # *   Attaching: The disk is being attached.
        # *   Detaching: The disk is being detached.
        # *   Creating: The disk is being created.
        # *   ReIniting: The disk is being reset.
        self.status = status
        self.tags = tags
        # The type of the cloud disk or local disk. Valid values:
        # 
        # *   1: system disk.
        # *   2: data disk.
        self.type = type

    def validate(self):
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.delete_with_instance is not None:
            result['DeleteWithInstance'] = self.delete_with_instance
        if self.description is not None:
            result['Description'] = self.description
        if self.disk_charge_type is not None:
            result['DiskChargeType'] = self.disk_charge_type
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.encrypted_key_id is not None:
            result['EncryptedKeyId'] = self.encrypted_key_id
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.portable is not None:
            result['Portable'] = self.portable
        if self.serial_id is not None:
            result['SerialId'] = self.serial_id
        if self.size is not None:
            result['Size'] = self.size
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.status is not None:
            result['Status'] = self.status
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DeleteWithInstance') is not None:
            self.delete_with_instance = m.get('DeleteWithInstance')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DiskChargeType') is not None:
            self.disk_charge_type = m.get('DiskChargeType')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('EncryptedKeyId') is not None:
            self.encrypted_key_id = m.get('EncryptedKeyId')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Portable') is not None:
            self.portable = m.get('Portable')
        if m.get('SerialId') is not None:
            self.serial_id = m.get('SerialId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tags') is not None:
            temp_model = DescribeDisksResponseBodyDisksDisksTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeDisksResponseBodyDisks(TeaModel):
    def __init__(
        self,
        disks: List[DescribeDisksResponseBodyDisksDisks] = None,
    ):
        self.disks = disks

    def validate(self):
        if self.disks:
            for k in self.disks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Disks'] = []
        if self.disks is not None:
            for k in self.disks:
                result['Disks'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.disks = []
        if m.get('Disks') is not None:
            for k in m.get('Disks'):
                temp_model = DescribeDisksResponseBodyDisksDisks()
                self.disks.append(temp_model.from_map(k))
        return self


class DescribeDisksResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        disks: DescribeDisksResponseBodyDisks = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The returned service code. 0 indicates that the request was successful.
        self.code = code
        # The information about the disks.
        self.disks = disks
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page. Maximum value: **50**. Default value: **10**.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of returned pages.
        self.total_count = total_count

    def validate(self):
        if self.disks:
            self.disks.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.disks is not None:
            result['Disks'] = self.disks.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Disks') is not None:
            temp_model = DescribeDisksResponseBodyDisks()
            self.disks = temp_model.from_map(m['Disks'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDisksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDisksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDisksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeElbAvailableResourceInfoResponseBodyElbAvailableResourceInfo(TeaModel):
    def __init__(
        self,
        ability: List[str] = None,
        area: str = None,
        can_buy_count: str = None,
        en_name: str = None,
        ens_region_id: str = None,
        load_balancer_spec: List[str] = None,
        name: str = None,
        province: str = None,
    ):
        self.ability = ability
        # The ID of the region.
        self.area = area
        # The number of resources that you can purchase.
        self.can_buy_count = can_buy_count
        # The name of the node.
        self.en_name = en_name
        # The ID of the Edge Node Service (ENS) node.
        self.ens_region_id = ens_region_id
        # The specifications of the ELB instances.
        self.load_balancer_spec = load_balancer_spec
        # The Chinese name of the node.
        self.name = name
        # The province where the node is deployed.
        self.province = province

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ability is not None:
            result['Ability'] = self.ability
        if self.area is not None:
            result['Area'] = self.area
        if self.can_buy_count is not None:
            result['CanBuyCount'] = self.can_buy_count
        if self.en_name is not None:
            result['EnName'] = self.en_name
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.load_balancer_spec is not None:
            result['LoadBalancerSpec'] = self.load_balancer_spec
        if self.name is not None:
            result['Name'] = self.name
        if self.province is not None:
            result['Province'] = self.province
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ability') is not None:
            self.ability = m.get('Ability')
        if m.get('Area') is not None:
            self.area = m.get('Area')
        if m.get('CanBuyCount') is not None:
            self.can_buy_count = m.get('CanBuyCount')
        if m.get('EnName') is not None:
            self.en_name = m.get('EnName')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('LoadBalancerSpec') is not None:
            self.load_balancer_spec = m.get('LoadBalancerSpec')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Province') is not None:
            self.province = m.get('Province')
        return self


class DescribeElbAvailableResourceInfoResponseBody(TeaModel):
    def __init__(
        self,
        elb_available_resource_info: List[DescribeElbAvailableResourceInfoResponseBodyElbAvailableResourceInfo] = None,
        request_id: str = None,
    ):
        # The information about resources.
        self.elb_available_resource_info = elb_available_resource_info
        # The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use the ID to troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.elb_available_resource_info:
            for k in self.elb_available_resource_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ElbAvailableResourceInfo'] = []
        if self.elb_available_resource_info is not None:
            for k in self.elb_available_resource_info:
                result['ElbAvailableResourceInfo'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.elb_available_resource_info = []
        if m.get('ElbAvailableResourceInfo') is not None:
            for k in m.get('ElbAvailableResourceInfo'):
                temp_model = DescribeElbAvailableResourceInfoResponseBodyElbAvailableResourceInfo()
                self.elb_available_resource_info.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeElbAvailableResourceInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeElbAvailableResourceInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeElbAvailableResourceInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnsCommodityCodeRequest(TeaModel):
    def __init__(
        self,
        commodity_code: str = None,
    ):
        self.commodity_code = commodity_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        return self


class DescribeEnsCommodityCodeResponseBodyCommodityCodeInfo(TeaModel):
    def __init__(
        self,
        commodity_code: str = None,
        commodity_name: str = None,
    ):
        self.commodity_code = commodity_code
        self.commodity_name = commodity_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.commodity_name is not None:
            result['CommodityName'] = self.commodity_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('CommodityName') is not None:
            self.commodity_name = m.get('CommodityName')
        return self


class DescribeEnsCommodityCodeResponseBody(TeaModel):
    def __init__(
        self,
        commodity_code_info: List[DescribeEnsCommodityCodeResponseBodyCommodityCodeInfo] = None,
        request_id: str = None,
    ):
        self.commodity_code_info = commodity_code_info
        self.request_id = request_id

    def validate(self):
        if self.commodity_code_info:
            for k in self.commodity_code_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CommodityCodeInfo'] = []
        if self.commodity_code_info is not None:
            for k in self.commodity_code_info:
                result['CommodityCodeInfo'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.commodity_code_info = []
        if m.get('CommodityCodeInfo') is not None:
            for k in m.get('CommodityCodeInfo'):
                temp_model = DescribeEnsCommodityCodeResponseBodyCommodityCodeInfo()
                self.commodity_code_info.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeEnsCommodityCodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnsCommodityCodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnsCommodityCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnsCommodityModuleCodeRequest(TeaModel):
    def __init__(
        self,
        commodity_code: str = None,
        module_code: str = None,
    ):
        self.commodity_code = commodity_code
        self.module_code = module_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.module_code is not None:
            result['ModuleCode'] = self.module_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('ModuleCode') is not None:
            self.module_code = m.get('ModuleCode')
        return self


class DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfoModuleCodesInfo(TeaModel):
    def __init__(
        self,
        module_code: str = None,
        module_name: str = None,
    ):
        self.module_code = module_code
        self.module_name = module_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.module_code is not None:
            result['ModuleCode'] = self.module_code
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ModuleCode') is not None:
            self.module_code = m.get('ModuleCode')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        return self


class DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfo(TeaModel):
    def __init__(
        self,
        commodity_code: str = None,
        module_codes_info: List[DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfoModuleCodesInfo] = None,
    ):
        self.commodity_code = commodity_code
        self.module_codes_info = module_codes_info

    def validate(self):
        if self.module_codes_info:
            for k in self.module_codes_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        result['ModuleCodesInfo'] = []
        if self.module_codes_info is not None:
            for k in self.module_codes_info:
                result['ModuleCodesInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        self.module_codes_info = []
        if m.get('ModuleCodesInfo') is not None:
            for k in m.get('ModuleCodesInfo'):
                temp_model = DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfoModuleCodesInfo()
                self.module_codes_info.append(temp_model.from_map(k))
        return self


class DescribeEnsCommodityModuleCodeResponseBody(TeaModel):
    def __init__(
        self,
        commodity_codes_info: List[DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfo] = None,
        request_id: str = None,
    ):
        self.commodity_codes_info = commodity_codes_info
        self.request_id = request_id

    def validate(self):
        if self.commodity_codes_info:
            for k in self.commodity_codes_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CommodityCodesInfo'] = []
        if self.commodity_codes_info is not None:
            for k in self.commodity_codes_info:
                result['CommodityCodesInfo'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.commodity_codes_info = []
        if m.get('CommodityCodesInfo') is not None:
            for k in m.get('CommodityCodesInfo'):
                temp_model = DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfo()
                self.commodity_codes_info.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeEnsCommodityModuleCodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnsCommodityModuleCodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnsCommodityModuleCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnsEipAddressesRequest(TeaModel):
    def __init__(
        self,
        allocation_id: str = None,
        associated_instance_id: str = None,
        associated_instance_type: str = None,
        eip_address: str = None,
        eip_name: str = None,
        ens_region_id: str = None,
        ens_region_ids: List[str] = None,
        page_number: int = None,
        page_size: int = None,
        standby: str = None,
    ):
        # The ID of the EIP that you want to query. You can specify up to 50 EIP IDs. Separate multiple IDs with commas (,).
        self.allocation_id = allocation_id
        # The ID of the instance with which you want to associate the EIP.
        self.associated_instance_id = associated_instance_id
        # The type of the instance that is associated with the EIP. Valid values:
        # 
        # *   **EnsInstance**: ENS instance in a VPC
        # *   **SlbInstance**: SLB instance
        self.associated_instance_type = associated_instance_type
        # The EIP that you want to query. You can specify up to 50 EIPs. Separate multiple EIPs with commas (,).
        self.eip_address = eip_address
        # The name of the EIP.
        self.eip_name = eip_name
        # The ID of the Edge Node Service (ENS) node.
        self.ens_region_id = ens_region_id
        # The IDs of edge nodes. You can specify 1 to 100 IDs.
        self.ens_region_ids = ens_region_ids
        # The page number. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Maximum value: 100. Default value: 10.
        self.page_size = page_size
        # Specifies whether the EIP is a secondary EIP. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.standby = standby

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.associated_instance_id is not None:
            result['AssociatedInstanceId'] = self.associated_instance_id
        if self.associated_instance_type is not None:
            result['AssociatedInstanceType'] = self.associated_instance_type
        if self.eip_address is not None:
            result['EipAddress'] = self.eip_address
        if self.eip_name is not None:
            result['EipName'] = self.eip_name
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.ens_region_ids is not None:
            result['EnsRegionIds'] = self.ens_region_ids
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.standby is not None:
            result['Standby'] = self.standby
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('AssociatedInstanceId') is not None:
            self.associated_instance_id = m.get('AssociatedInstanceId')
        if m.get('AssociatedInstanceType') is not None:
            self.associated_instance_type = m.get('AssociatedInstanceType')
        if m.get('EipAddress') is not None:
            self.eip_address = m.get('EipAddress')
        if m.get('EipName') is not None:
            self.eip_name = m.get('EipName')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('EnsRegionIds') is not None:
            self.ens_region_ids = m.get('EnsRegionIds')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Standby') is not None:
            self.standby = m.get('Standby')
        return self


class DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTagsTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        tag_key: str = None,
        tag_value: str = None,
        value: str = None,
    ):
        self.key = key
        self.tag_key = tag_key
        self.tag_value = tag_value
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTags(TeaModel):
    def __init__(
        self,
        tag: List[DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTagsTag] = None,
    ):
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeEnsEipAddressesResponseBodyEipAddressesEipAddress(TeaModel):
    def __init__(
        self,
        allocation_id: str = None,
        allocation_time: str = None,
        bandwidth: int = None,
        charge_type: str = None,
        description: str = None,
        ens_region_id: str = None,
        instance_id: str = None,
        instance_type: str = None,
        internet_charge_type: str = None,
        ip_address: str = None,
        ip_status: str = None,
        isp: str = None,
        name: str = None,
        standby: bool = None,
        status: str = None,
        tags: DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTags = None,
    ):
        self.allocation_id = allocation_id
        self.allocation_time = allocation_time
        self.bandwidth = bandwidth
        self.charge_type = charge_type
        self.description = description
        self.ens_region_id = ens_region_id
        self.instance_id = instance_id
        self.instance_type = instance_type
        self.internet_charge_type = internet_charge_type
        self.ip_address = ip_address
        self.ip_status = ip_status
        self.isp = isp
        self.name = name
        self.standby = standby
        self.status = status
        self.tags = tags

    def validate(self):
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.allocation_time is not None:
            result['AllocationTime'] = self.allocation_time
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.charge_type is not None:
            result['ChargeType'] = self.charge_type
        if self.description is not None:
            result['Description'] = self.description
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        if self.ip_status is not None:
            result['IpStatus'] = self.ip_status
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.name is not None:
            result['Name'] = self.name
        if self.standby is not None:
            result['Standby'] = self.standby
        if self.status is not None:
            result['Status'] = self.status
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('AllocationTime') is not None:
            self.allocation_time = m.get('AllocationTime')
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('ChargeType') is not None:
            self.charge_type = m.get('ChargeType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        if m.get('IpStatus') is not None:
            self.ip_status = m.get('IpStatus')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Standby') is not None:
            self.standby = m.get('Standby')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tags') is not None:
            temp_model = DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTags()
            self.tags = temp_model.from_map(m['Tags'])
        return self


class DescribeEnsEipAddressesResponseBodyEipAddresses(TeaModel):
    def __init__(
        self,
        eip_address: List[DescribeEnsEipAddressesResponseBodyEipAddressesEipAddress] = None,
    ):
        self.eip_address = eip_address

    def validate(self):
        if self.eip_address:
            for k in self.eip_address:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EipAddress'] = []
        if self.eip_address is not None:
            for k in self.eip_address:
                result['EipAddress'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.eip_address = []
        if m.get('EipAddress') is not None:
            for k in m.get('EipAddress'):
                temp_model = DescribeEnsEipAddressesResponseBodyEipAddressesEipAddress()
                self.eip_address.append(temp_model.from_map(k))
        return self


class DescribeEnsEipAddressesResponseBody(TeaModel):
    def __init__(
        self,
        eip_addresses: DescribeEnsEipAddressesResponseBodyEipAddresses = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # Details of the EIPs.
        self.eip_addresses = eip_addresses
        # The page number. Valid values: an integer that is greater than 0. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Valid values: **10** to **100**.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.eip_addresses:
            self.eip_addresses.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.eip_addresses is not None:
            result['EipAddresses'] = self.eip_addresses.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EipAddresses') is not None:
            temp_model = DescribeEnsEipAddressesResponseBodyEipAddresses()
            self.eip_addresses = temp_model.from_map(m['EipAddresses'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeEnsEipAddressesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnsEipAddressesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnsEipAddressesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnsNetDistrictRequest(TeaModel):
    def __init__(
        self,
        net_district_code: str = None,
        net_level_code: str = None,
    ):
        # The code of the region.
        # 
        # If you do not specify this parameter, only nodes in the regions of the level that is specified by the NetLevelCode parameter are queried.
        # 
        # If you specify this parameter, only nodes in the regions of the level that is specified by this parameter are queried.
        self.net_district_code = net_district_code
        # The level of the region.
        # 
        # *   **Big**: area
        # *   **Middle**: province
        # *   **Small**: city
        # 
        # This parameter is required.
        self.net_level_code = net_level_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.net_district_code is not None:
            result['NetDistrictCode'] = self.net_district_code
        if self.net_level_code is not None:
            result['NetLevelCode'] = self.net_level_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetDistrictCode') is not None:
            self.net_district_code = m.get('NetDistrictCode')
        if m.get('NetLevelCode') is not None:
            self.net_level_code = m.get('NetLevelCode')
        return self


class DescribeEnsNetDistrictResponseBodyEnsNetDistrictsEnsNetDistrict(TeaModel):
    def __init__(
        self,
        ens_region_id_count: str = None,
        net_district_code: str = None,
        net_district_en_name: str = None,
        net_district_father_code: str = None,
        net_district_level: str = None,
        net_district_name: str = None,
    ):
        # The number of nodes in the region.
        self.ens_region_id_count = ens_region_id_count
        # The code of the region.
        self.net_district_code = net_district_code
        # The name of the region.
        self.net_district_en_name = net_district_en_name
        # The parent code of the region.
        self.net_district_father_code = net_district_father_code
        # The level of the region.
        # 
        # *   **Big**: area
        # *   **Middle**: province
        # *   **Small**: city
        self.net_district_level = net_district_level
        # The name of the region.
        self.net_district_name = net_district_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id_count is not None:
            result['EnsRegionIdCount'] = self.ens_region_id_count
        if self.net_district_code is not None:
            result['NetDistrictCode'] = self.net_district_code
        if self.net_district_en_name is not None:
            result['NetDistrictEnName'] = self.net_district_en_name
        if self.net_district_father_code is not None:
            result['NetDistrictFatherCode'] = self.net_district_father_code
        if self.net_district_level is not None:
            result['NetDistrictLevel'] = self.net_district_level
        if self.net_district_name is not None:
            result['NetDistrictName'] = self.net_district_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionIdCount') is not None:
            self.ens_region_id_count = m.get('EnsRegionIdCount')
        if m.get('NetDistrictCode') is not None:
            self.net_district_code = m.get('NetDistrictCode')
        if m.get('NetDistrictEnName') is not None:
            self.net_district_en_name = m.get('NetDistrictEnName')
        if m.get('NetDistrictFatherCode') is not None:
            self.net_district_father_code = m.get('NetDistrictFatherCode')
        if m.get('NetDistrictLevel') is not None:
            self.net_district_level = m.get('NetDistrictLevel')
        if m.get('NetDistrictName') is not None:
            self.net_district_name = m.get('NetDistrictName')
        return self


class DescribeEnsNetDistrictResponseBodyEnsNetDistricts(TeaModel):
    def __init__(
        self,
        ens_net_district: List[DescribeEnsNetDistrictResponseBodyEnsNetDistrictsEnsNetDistrict] = None,
    ):
        self.ens_net_district = ens_net_district

    def validate(self):
        if self.ens_net_district:
            for k in self.ens_net_district:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EnsNetDistrict'] = []
        if self.ens_net_district is not None:
            for k in self.ens_net_district:
                result['EnsNetDistrict'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ens_net_district = []
        if m.get('EnsNetDistrict') is not None:
            for k in m.get('EnsNetDistrict'):
                temp_model = DescribeEnsNetDistrictResponseBodyEnsNetDistrictsEnsNetDistrict()
                self.ens_net_district.append(temp_model.from_map(k))
        return self


class DescribeEnsNetDistrictResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        ens_net_districts: DescribeEnsNetDistrictResponseBodyEnsNetDistricts = None,
        request_id: str = None,
    ):
        # The returned service code. A value of 0 indicates that the operation was successful.
        self.code = code
        # The information about the regions.
        self.ens_net_districts = ens_net_districts
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.ens_net_districts:
            self.ens_net_districts.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.ens_net_districts is not None:
            result['EnsNetDistricts'] = self.ens_net_districts.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EnsNetDistricts') is not None:
            temp_model = DescribeEnsNetDistrictResponseBodyEnsNetDistricts()
            self.ens_net_districts = temp_model.from_map(m['EnsNetDistricts'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeEnsNetDistrictResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnsNetDistrictResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnsNetDistrictResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnsNetLevelResponseBodyEnsNetLevelsEnsNetLevel(TeaModel):
    def __init__(
        self,
        ens_net_level_code: str = None,
    ):
        # The network level. Valid values:
        # 
        # *   Big: greater area.
        # *   Middle: province.
        # *   Small: city.
        self.ens_net_level_code = ens_net_level_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_net_level_code is not None:
            result['EnsNetLevelCode'] = self.ens_net_level_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsNetLevelCode') is not None:
            self.ens_net_level_code = m.get('EnsNetLevelCode')
        return self


class DescribeEnsNetLevelResponseBodyEnsNetLevels(TeaModel):
    def __init__(
        self,
        ens_net_level: List[DescribeEnsNetLevelResponseBodyEnsNetLevelsEnsNetLevel] = None,
    ):
        self.ens_net_level = ens_net_level

    def validate(self):
        if self.ens_net_level:
            for k in self.ens_net_level:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EnsNetLevel'] = []
        if self.ens_net_level is not None:
            for k in self.ens_net_level:
                result['EnsNetLevel'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ens_net_level = []
        if m.get('EnsNetLevel') is not None:
            for k in m.get('EnsNetLevel'):
                temp_model = DescribeEnsNetLevelResponseBodyEnsNetLevelsEnsNetLevel()
                self.ens_net_level.append(temp_model.from_map(k))
        return self


class DescribeEnsNetLevelResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        ens_net_levels: DescribeEnsNetLevelResponseBodyEnsNetLevels = None,
        request_id: str = None,
    ):
        # The returned service code. A value of 0 indicates that the operation was successful.
        self.code = code
        # The network levels.
        self.ens_net_levels = ens_net_levels
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.ens_net_levels:
            self.ens_net_levels.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.ens_net_levels is not None:
            result['EnsNetLevels'] = self.ens_net_levels.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EnsNetLevels') is not None:
            temp_model = DescribeEnsNetLevelResponseBodyEnsNetLevels()
            self.ens_net_levels = temp_model.from_map(m['EnsNetLevels'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeEnsNetLevelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnsNetLevelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnsNetLevelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnsNetSaleDistrictRequest(TeaModel):
    def __init__(
        self,
        net_district_code: str = None,
        net_level_code: str = None,
    ):
        # The region code.
        # 
        # *   If you do not specify this parameter, only nodes under the area level that is specified by NetLevelCode are queried.
        # *   If you specify this parameter, only child nodes in the area that is specified by NetDistrictCode are queried.
        self.net_district_code = net_district_code
        # The network level. Valid values:
        # 
        # *   **Big**: area
        # *   **Middle**: province
        # *   **Small**: city
        # 
        # This parameter is required.
        self.net_level_code = net_level_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.net_district_code is not None:
            result['NetDistrictCode'] = self.net_district_code
        if self.net_level_code is not None:
            result['NetLevelCode'] = self.net_level_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetDistrictCode') is not None:
            self.net_district_code = m.get('NetDistrictCode')
        if m.get('NetLevelCode') is not None:
            self.net_level_code = m.get('NetLevelCode')
        return self


class DescribeEnsNetSaleDistrictResponseBodyEnsNetDistrictsEnsNetDistrict(TeaModel):
    def __init__(
        self,
        ens_region_id_count: str = None,
        instance_count: str = None,
        net_district_code: str = None,
        net_district_en_name: str = None,
        net_district_father_code: str = None,
        net_district_level: str = None,
        net_district_name: str = None,
    ):
        # The information about the ISP.
        self.ens_region_id_count = ens_region_id_count
        # The information about the instance.
        self.instance_count = instance_count
        # The region code.
        self.net_district_code = net_district_code
        # The name of the region.
        self.net_district_en_name = net_district_en_name
        # The parent code of the region.
        self.net_district_father_code = net_district_father_code
        # The region level. Valid values:
        # 
        # *   **Big**: area
        # *   **Middle**: province
        # *   **Small**: city
        self.net_district_level = net_district_level
        # The Chinese name of the region.
        self.net_district_name = net_district_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id_count is not None:
            result['EnsRegionIdCount'] = self.ens_region_id_count
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.net_district_code is not None:
            result['NetDistrictCode'] = self.net_district_code
        if self.net_district_en_name is not None:
            result['NetDistrictEnName'] = self.net_district_en_name
        if self.net_district_father_code is not None:
            result['NetDistrictFatherCode'] = self.net_district_father_code
        if self.net_district_level is not None:
            result['NetDistrictLevel'] = self.net_district_level
        if self.net_district_name is not None:
            result['NetDistrictName'] = self.net_district_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionIdCount') is not None:
            self.ens_region_id_count = m.get('EnsRegionIdCount')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('NetDistrictCode') is not None:
            self.net_district_code = m.get('NetDistrictCode')
        if m.get('NetDistrictEnName') is not None:
            self.net_district_en_name = m.get('NetDistrictEnName')
        if m.get('NetDistrictFatherCode') is not None:
            self.net_district_father_code = m.get('NetDistrictFatherCode')
        if m.get('NetDistrictLevel') is not None:
            self.net_district_level = m.get('NetDistrictLevel')
        if m.get('NetDistrictName') is not None:
            self.net_district_name = m.get('NetDistrictName')
        return self


class DescribeEnsNetSaleDistrictResponseBodyEnsNetDistricts(TeaModel):
    def __init__(
        self,
        ens_net_district: List[DescribeEnsNetSaleDistrictResponseBodyEnsNetDistrictsEnsNetDistrict] = None,
    ):
        self.ens_net_district = ens_net_district

    def validate(self):
        if self.ens_net_district:
            for k in self.ens_net_district:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EnsNetDistrict'] = []
        if self.ens_net_district is not None:
            for k in self.ens_net_district:
                result['EnsNetDistrict'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ens_net_district = []
        if m.get('EnsNetDistrict') is not None:
            for k in m.get('EnsNetDistrict'):
                temp_model = DescribeEnsNetSaleDistrictResponseBodyEnsNetDistrictsEnsNetDistrict()
                self.ens_net_district.append(temp_model.from_map(k))
        return self


class DescribeEnsNetSaleDistrictResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        ens_net_districts: DescribeEnsNetSaleDistrictResponseBodyEnsNetDistricts = None,
        request_id: str = None,
    ):
        # The returned service code. A value of 0 indicates that the operation was successful.
        self.code = code
        # The information about the ISPs in the area.
        self.ens_net_districts = ens_net_districts
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.ens_net_districts:
            self.ens_net_districts.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.ens_net_districts is not None:
            result['EnsNetDistricts'] = self.ens_net_districts.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EnsNetDistricts') is not None:
            temp_model = DescribeEnsNetSaleDistrictResponseBodyEnsNetDistricts()
            self.ens_net_districts = temp_model.from_map(m['EnsNetDistricts'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeEnsNetSaleDistrictResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnsNetSaleDistrictResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnsNetSaleDistrictResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnsRegionIdIpv6InfoRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
    ):
        # The ID of the node. You can specify only one node ID in a call.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        return self


class DescribeEnsRegionIdIpv6InfoResponseBodySupportIpv6Info(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        support_ipv_6: bool = None,
    ):
        # The ID of the node.
        self.ens_region_id = ens_region_id
        # Specifies whether IPv6 is supported. Valid values:
        # 
        # *   true
        # *   false
        self.support_ipv_6 = support_ipv_6

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.support_ipv_6 is not None:
            result['SupportIpv6'] = self.support_ipv_6
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('SupportIpv6') is not None:
            self.support_ipv_6 = m.get('SupportIpv6')
        return self


class DescribeEnsRegionIdIpv6InfoResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        support_ipv_6info: DescribeEnsRegionIdIpv6InfoResponseBodySupportIpv6Info = None,
    ):
        # The request ID.
        self.request_id = request_id
        # IPv6 support information.
        self.support_ipv_6info = support_ipv_6info

    def validate(self):
        if self.support_ipv_6info:
            self.support_ipv_6info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.support_ipv_6info is not None:
            result['SupportIpv6Info'] = self.support_ipv_6info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SupportIpv6Info') is not None:
            temp_model = DescribeEnsRegionIdIpv6InfoResponseBodySupportIpv6Info()
            self.support_ipv_6info = temp_model.from_map(m['SupportIpv6Info'])
        return self


class DescribeEnsRegionIdIpv6InfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnsRegionIdIpv6InfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnsRegionIdIpv6InfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnsRegionIdResourceRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        isp: str = None,
        order_by_params: str = None,
        page_number: int = None,
        page_size: str = None,
        start_time: str = None,
    ):
        # The end time of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The Internet service provider (ISP). Valid values:
        # 
        # *   cmcc: China Mobile
        # *   telecom: China Telecom
        # *   unicom: China Unicom
        # *   multiCarrier: multi-line ISP
        self.isp = isp
        # The order in which the resources to return are sorted. Valid values:
        # 
        # *   InstanceCount: desc
        # *   Area: asc
        # *   InternetBandwidth: asc
        self.order_by_params = order_by_params
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Maximum value: **100**. Default value: **10**.
        self.page_size = page_size
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.order_by_params is not None:
            result['OrderByParams'] = self.order_by_params
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('OrderByParams') is not None:
            self.order_by_params = m.get('OrderByParams')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResourcesEnsRegionIdResource(TeaModel):
    def __init__(
        self,
        area: str = None,
        area_code: str = None,
        biz_date: str = None,
        ens_region_id: str = None,
        ens_region_id_name: str = None,
        instance_count: int = None,
        internet_bandwidth: int = None,
        isp: str = None,
        vcpu: int = None,
    ):
        # The region. Set the value to West.
        self.area = area
        # The code of the region.
        self.area_code = area_code
        # The date when the transaction was processed.
        self.biz_date = biz_date
        # The ID of the node.
        self.ens_region_id = ens_region_id
        # The name of the node.
        self.ens_region_id_name = ens_region_id_name
        # The number of instances.
        self.instance_count = instance_count
        # The public bandwidth of the instance. Unit: Bits/s.
        self.internet_bandwidth = internet_bandwidth
        # The ISP. Valid values:
        # 
        # *   cmcc: China Mobile
        # *   unicom: China Unicom
        # *   telecom: China Telecom
        # *   multiCarrier: multi-line ISP
        self.isp = isp
        # The number of vCPUs.
        self.vcpu = vcpu

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.area is not None:
            result['Area'] = self.area
        if self.area_code is not None:
            result['AreaCode'] = self.area_code
        if self.biz_date is not None:
            result['BizDate'] = self.biz_date
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.ens_region_id_name is not None:
            result['EnsRegionIdName'] = self.ens_region_id_name
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.internet_bandwidth is not None:
            result['InternetBandwidth'] = self.internet_bandwidth
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.vcpu is not None:
            result['VCpu'] = self.vcpu
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Area') is not None:
            self.area = m.get('Area')
        if m.get('AreaCode') is not None:
            self.area_code = m.get('AreaCode')
        if m.get('BizDate') is not None:
            self.biz_date = m.get('BizDate')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('EnsRegionIdName') is not None:
            self.ens_region_id_name = m.get('EnsRegionIdName')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('InternetBandwidth') is not None:
            self.internet_bandwidth = m.get('InternetBandwidth')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('VCpu') is not None:
            self.vcpu = m.get('VCpu')
        return self


class DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResources(TeaModel):
    def __init__(
        self,
        ens_region_id_resource: List[DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResourcesEnsRegionIdResource] = None,
    ):
        self.ens_region_id_resource = ens_region_id_resource

    def validate(self):
        if self.ens_region_id_resource:
            for k in self.ens_region_id_resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EnsRegionIdResource'] = []
        if self.ens_region_id_resource is not None:
            for k in self.ens_region_id_resource:
                result['EnsRegionIdResource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ens_region_id_resource = []
        if m.get('EnsRegionIdResource') is not None:
            for k in m.get('EnsRegionIdResource'):
                temp_model = DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResourcesEnsRegionIdResource()
                self.ens_region_id_resource.append(temp_model.from_map(k))
        return self


class DescribeEnsRegionIdResourceResponseBody(TeaModel):
    def __init__(
        self,
        ens_region_id_resources: DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResources = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The returned data. For more information, see EnsRegionIdResources in sample JSON responses.
        self.ens_region_id_resources = ens_region_id_resources
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of queried nodes.
        self.total_count = total_count

    def validate(self):
        if self.ens_region_id_resources:
            self.ens_region_id_resources.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id_resources is not None:
            result['EnsRegionIdResources'] = self.ens_region_id_resources.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionIdResources') is not None:
            temp_model = DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResources()
            self.ens_region_id_resources = temp_model.from_map(m['EnsRegionIdResources'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeEnsRegionIdResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnsRegionIdResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnsRegionIdResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnsRegionsRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
    ):
        # The ID of the node.
        # 
        # By default, all available node IDs are returned.
        self.ens_region_id = ens_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        return self


class DescribeEnsRegionsResponseBodyEnsRegionsEnsRegions(TeaModel):
    def __init__(
        self,
        area: str = None,
        en_name: str = None,
        ens_region_id: str = None,
        name: str = None,
        province: str = None,
    ):
        # The code of the region.
        self.area = area
        # The name of the node.
        self.en_name = en_name
        # The ID of the node.
        self.ens_region_id = ens_region_id
        # The name of the node.
        self.name = name
        # The province where the node is deployed.
        self.province = province

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.area is not None:
            result['Area'] = self.area
        if self.en_name is not None:
            result['EnName'] = self.en_name
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.name is not None:
            result['Name'] = self.name
        if self.province is not None:
            result['Province'] = self.province
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Area') is not None:
            self.area = m.get('Area')
        if m.get('EnName') is not None:
            self.en_name = m.get('EnName')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Province') is not None:
            self.province = m.get('Province')
        return self


class DescribeEnsRegionsResponseBodyEnsRegions(TeaModel):
    def __init__(
        self,
        ens_regions: List[DescribeEnsRegionsResponseBodyEnsRegionsEnsRegions] = None,
    ):
        self.ens_regions = ens_regions

    def validate(self):
        if self.ens_regions:
            for k in self.ens_regions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EnsRegions'] = []
        if self.ens_regions is not None:
            for k in self.ens_regions:
                result['EnsRegions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ens_regions = []
        if m.get('EnsRegions') is not None:
            for k in m.get('EnsRegions'):
                temp_model = DescribeEnsRegionsResponseBodyEnsRegionsEnsRegions()
                self.ens_regions.append(temp_model.from_map(k))
        return self


class DescribeEnsRegionsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        ens_regions: DescribeEnsRegionsResponseBodyEnsRegions = None,
        request_id: str = None,
    ):
        # The service code. 0 is returned for a successful request. An error code is returned for a failed request.
        self.code = code
        # The information about the regions.
        self.ens_regions = ens_regions
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.ens_regions:
            self.ens_regions.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.ens_regions is not None:
            result['EnsRegions'] = self.ens_regions.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EnsRegions') is not None:
            temp_model = DescribeEnsRegionsResponseBodyEnsRegions()
            self.ens_regions = temp_model.from_map(m['EnsRegions'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeEnsRegionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnsRegionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnsRegionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnsResourceUsageRequest(TeaModel):
    def __init__(
        self,
        expired_end_time: str = None,
        expired_start_time: str = None,
    ):
        # The end of the time range to query. Format: yyyy-MM-dd or yyyy-MM-dd HH:mm:ss.
        self.expired_end_time = expired_end_time
        # The beginning of the time range to query. Format: yyyy-MM-dd or yyyy-MM-dd HH:mm:ss.
        self.expired_start_time = expired_start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expired_end_time is not None:
            result['ExpiredEndTime'] = self.expired_end_time
        if self.expired_start_time is not None:
            result['ExpiredStartTime'] = self.expired_start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExpiredEndTime') is not None:
            self.expired_end_time = m.get('ExpiredEndTime')
        if m.get('ExpiredStartTime') is not None:
            self.expired_start_time = m.get('ExpiredStartTime')
        return self


class DescribeEnsResourceUsageResponseBodyEnsResourceUsage(TeaModel):
    def __init__(
        self,
        compute_resource_count: int = None,
        cpu_sum: int = None,
        disk_count: int = None,
        down_count: int = None,
        expired_count: int = None,
        expiring_count: int = None,
        gpu_sum: int = None,
        instance_count: int = None,
        running_count: int = None,
        service_type: str = None,
        storage_sum: int = None,
    ):
        # The number of edge services. This parameter is available only when you set the ServiceType parameter to 2.
        self.compute_resource_count = compute_resource_count
        # The CPU usage. Unit: cores.
        self.cpu_sum = cpu_sum
        # The number of data disks.
        self.disk_count = disk_count
        # The number of stopped VMs.
        self.down_count = down_count
        # The number of expired VM instances.
        self.expired_count = expired_count
        # The number of VM instances that are about to expire.
        self.expiring_count = expiring_count
        # The number of GPUs.
        self.gpu_sum = gpu_sum
        # The number of instances.
        self.instance_count = instance_count
        # The number of running instances.
        self.running_count = running_count
        # The type of the service. Valid values:
        # 
        # *   1: subscription instance.
        # *   2: edge service instance.
        # *   3: pay-as-you-go instance.
        self.service_type = service_type
        # The total disk size.
        self.storage_sum = storage_sum

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.compute_resource_count is not None:
            result['ComputeResourceCount'] = self.compute_resource_count
        if self.cpu_sum is not None:
            result['CpuSum'] = self.cpu_sum
        if self.disk_count is not None:
            result['DiskCount'] = self.disk_count
        if self.down_count is not None:
            result['DownCount'] = self.down_count
        if self.expired_count is not None:
            result['ExpiredCount'] = self.expired_count
        if self.expiring_count is not None:
            result['ExpiringCount'] = self.expiring_count
        if self.gpu_sum is not None:
            result['GpuSum'] = self.gpu_sum
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.running_count is not None:
            result['RunningCount'] = self.running_count
        if self.service_type is not None:
            result['ServiceType'] = self.service_type
        if self.storage_sum is not None:
            result['StorageSum'] = self.storage_sum
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComputeResourceCount') is not None:
            self.compute_resource_count = m.get('ComputeResourceCount')
        if m.get('CpuSum') is not None:
            self.cpu_sum = m.get('CpuSum')
        if m.get('DiskCount') is not None:
            self.disk_count = m.get('DiskCount')
        if m.get('DownCount') is not None:
            self.down_count = m.get('DownCount')
        if m.get('ExpiredCount') is not None:
            self.expired_count = m.get('ExpiredCount')
        if m.get('ExpiringCount') is not None:
            self.expiring_count = m.get('ExpiringCount')
        if m.get('GpuSum') is not None:
            self.gpu_sum = m.get('GpuSum')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('RunningCount') is not None:
            self.running_count = m.get('RunningCount')
        if m.get('ServiceType') is not None:
            self.service_type = m.get('ServiceType')
        if m.get('StorageSum') is not None:
            self.storage_sum = m.get('StorageSum')
        return self


class DescribeEnsResourceUsageResponseBody(TeaModel):
    def __init__(
        self,
        ens_resource_usage: List[DescribeEnsResourceUsageResponseBodyEnsResourceUsage] = None,
        request_id: str = None,
    ):
        # The resource usage data.
        self.ens_resource_usage = ens_resource_usage
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.ens_resource_usage:
            for k in self.ens_resource_usage:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EnsResourceUsage'] = []
        if self.ens_resource_usage is not None:
            for k in self.ens_resource_usage:
                result['EnsResourceUsage'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ens_resource_usage = []
        if m.get('EnsResourceUsage') is not None:
            for k in m.get('EnsResourceUsage'):
                temp_model = DescribeEnsResourceUsageResponseBodyEnsResourceUsage()
                self.ens_resource_usage.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeEnsResourceUsageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnsResourceUsageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnsResourceUsageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnsRouteEntryListRequest(TeaModel):
    def __init__(
        self,
        destination_cidr_block: str = None,
        next_hop_id: str = None,
        next_hop_type: str = None,
        page_number: int = None,
        page_size: int = None,
        route_entry_id: str = None,
        route_entry_name: str = None,
        route_entry_type: str = None,
        route_table_id: str = None,
    ):
        # The destination Classless Inter-Domain Routing (CIDR) block of the route entry.
        self.destination_cidr_block = destination_cidr_block
        # The ID of the next hop.
        self.next_hop_id = next_hop_id
        # The type of next hop of the custom route entry. Valid values:
        # 
        # *   Instance (default): an ENS instance.
        # *   HaVip: a high-availability virtual IP address (HAVIP).
        # *   NetworkPeer: VPC peering connection.
        self.next_hop_type = next_hop_type
        # The page number of the returned page. Valid values: integers that are greater than 0. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Valid values: 10 to 100.
        self.page_size = page_size
        # The ID of the route that you want to query.
        self.route_entry_id = route_entry_id
        # The name of the route.
        self.route_entry_name = route_entry_name
        # The route type. Valid values:
        # 
        # *   Custom: custom route
        # *   System: system route
        self.route_entry_type = route_entry_type
        # The ID of the route table that you want to query.
        self.route_table_id = route_table_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_cidr_block is not None:
            result['DestinationCidrBlock'] = self.destination_cidr_block
        if self.next_hop_id is not None:
            result['NextHopId'] = self.next_hop_id
        if self.next_hop_type is not None:
            result['NextHopType'] = self.next_hop_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.route_entry_id is not None:
            result['RouteEntryId'] = self.route_entry_id
        if self.route_entry_name is not None:
            result['RouteEntryName'] = self.route_entry_name
        if self.route_entry_type is not None:
            result['RouteEntryType'] = self.route_entry_type
        if self.route_table_id is not None:
            result['RouteTableId'] = self.route_table_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationCidrBlock') is not None:
            self.destination_cidr_block = m.get('DestinationCidrBlock')
        if m.get('NextHopId') is not None:
            self.next_hop_id = m.get('NextHopId')
        if m.get('NextHopType') is not None:
            self.next_hop_type = m.get('NextHopType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RouteEntryId') is not None:
            self.route_entry_id = m.get('RouteEntryId')
        if m.get('RouteEntryName') is not None:
            self.route_entry_name = m.get('RouteEntryName')
        if m.get('RouteEntryType') is not None:
            self.route_entry_type = m.get('RouteEntryType')
        if m.get('RouteTableId') is not None:
            self.route_table_id = m.get('RouteTableId')
        return self


class DescribeEnsRouteEntryListResponseBodyRouteEntrysNextHops(TeaModel):
    def __init__(
        self,
        next_hop_id: str = None,
        next_hop_name: str = None,
        next_hop_type: str = None,
    ):
        # The ID of the next hop.
        self.next_hop_id = next_hop_id
        # The instance ID of the next hop.
        self.next_hop_name = next_hop_name
        # The type of the next hop. Valid values:
        self.next_hop_type = next_hop_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_hop_id is not None:
            result['NextHopId'] = self.next_hop_id
        if self.next_hop_name is not None:
            result['NextHopName'] = self.next_hop_name
        if self.next_hop_type is not None:
            result['NextHopType'] = self.next_hop_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NextHopId') is not None:
            self.next_hop_id = m.get('NextHopId')
        if m.get('NextHopName') is not None:
            self.next_hop_name = m.get('NextHopName')
        if m.get('NextHopType') is not None:
            self.next_hop_type = m.get('NextHopType')
        return self


class DescribeEnsRouteEntryListResponseBodyRouteEntrys(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        description: str = None,
        destination_cidr_block: str = None,
        next_hops: List[DescribeEnsRouteEntryListResponseBodyRouteEntrysNextHops] = None,
        route_entry_id: str = None,
        route_entry_name: str = None,
        route_table_id: str = None,
        source_cidr_block: str = None,
        status: str = None,
        type: str = None,
    ):
        # The time when the IP address was created. The time is displayed in UTC.
        self.creation_time = creation_time
        # Enter a description for the route.
        self.description = description
        # The destination CIDR block of the route.
        self.destination_cidr_block = destination_cidr_block
        # The information about the next hop.
        self.next_hops = next_hops
        # The ID of the route.
        self.route_entry_id = route_entry_id
        # The name of the route.
        self.route_entry_name = route_entry_name
        # The ID of the route table.
        self.route_table_id = route_table_id
        # The source CIDR block. This field is used when you configure a route entry in the gateway route table. This field is not supported in the vSwitch route table.
        self.source_cidr_block = source_cidr_block
        # The status of the route entry. Valid values:
        self.status = status
        # The type of the route entry.
        self.type = type

    def validate(self):
        if self.next_hops:
            for k in self.next_hops:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.destination_cidr_block is not None:
            result['DestinationCidrBlock'] = self.destination_cidr_block
        result['NextHops'] = []
        if self.next_hops is not None:
            for k in self.next_hops:
                result['NextHops'].append(k.to_map() if k else None)
        if self.route_entry_id is not None:
            result['RouteEntryId'] = self.route_entry_id
        if self.route_entry_name is not None:
            result['RouteEntryName'] = self.route_entry_name
        if self.route_table_id is not None:
            result['RouteTableId'] = self.route_table_id
        if self.source_cidr_block is not None:
            result['SourceCidrBlock'] = self.source_cidr_block
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestinationCidrBlock') is not None:
            self.destination_cidr_block = m.get('DestinationCidrBlock')
        self.next_hops = []
        if m.get('NextHops') is not None:
            for k in m.get('NextHops'):
                temp_model = DescribeEnsRouteEntryListResponseBodyRouteEntrysNextHops()
                self.next_hops.append(temp_model.from_map(k))
        if m.get('RouteEntryId') is not None:
            self.route_entry_id = m.get('RouteEntryId')
        if m.get('RouteEntryName') is not None:
            self.route_entry_name = m.get('RouteEntryName')
        if m.get('RouteTableId') is not None:
            self.route_table_id = m.get('RouteTableId')
        if m.get('SourceCidrBlock') is not None:
            self.source_cidr_block = m.get('SourceCidrBlock')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeEnsRouteEntryListResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        route_entrys: List[DescribeEnsRouteEntryListResponseBodyRouteEntrys] = None,
        total_count: int = None,
    ):
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The information about the routes.
        self.route_entrys = route_entrys
        # The number of returned entries.
        self.total_count = total_count

    def validate(self):
        if self.route_entrys:
            for k in self.route_entrys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['RouteEntrys'] = []
        if self.route_entrys is not None:
            for k in self.route_entrys:
                result['RouteEntrys'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.route_entrys = []
        if m.get('RouteEntrys') is not None:
            for k in m.get('RouteEntrys'):
                temp_model = DescribeEnsRouteEntryListResponseBodyRouteEntrys()
                self.route_entrys.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeEnsRouteEntryListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnsRouteEntryListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnsRouteEntryListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnsRouteTablesRequest(TeaModel):
    def __init__(
        self,
        associate_type: str = None,
        ens_region_id: str = None,
        ens_region_ids: List[str] = None,
        network_id: str = None,
        page_number: int = None,
        page_size: int = None,
        route_table_id: str = None,
        route_table_name: str = None,
        type: str = None,
    ):
        # The type of the resource with which the route table is associated. Valid values:
        # 
        # *   **VSwitch**\
        # *   **Gateway**\
        self.associate_type = associate_type
        # The ID of the ENS node.
        self.ens_region_id = ens_region_id
        # The IDs of edge nodes. You can specify 1 to 100 IDs.
        self.ens_region_ids = ens_region_ids
        # The ID of the network.
        self.network_id = network_id
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the route table.
        self.route_table_id = route_table_id
        # The name of the route table.
        self.route_table_name = route_table_name
        # The SNAT type.
        # 
        # *   FullCone: full cone NAT.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.associate_type is not None:
            result['AssociateType'] = self.associate_type
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.ens_region_ids is not None:
            result['EnsRegionIds'] = self.ens_region_ids
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.route_table_id is not None:
            result['RouteTableId'] = self.route_table_id
        if self.route_table_name is not None:
            result['RouteTableName'] = self.route_table_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssociateType') is not None:
            self.associate_type = m.get('AssociateType')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('EnsRegionIds') is not None:
            self.ens_region_ids = m.get('EnsRegionIds')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RouteTableId') is not None:
            self.route_table_id = m.get('RouteTableId')
        if m.get('RouteTableName') is not None:
            self.route_table_name = m.get('RouteTableName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeEnsRouteTablesResponseBodyRouteTables(TeaModel):
    def __init__(
        self,
        associate_type: str = None,
        creation_time: str = None,
        description: str = None,
        ens_region_id: str = None,
        is_default_gateway_route_table: bool = None,
        network_id: str = None,
        route_table_id: str = None,
        route_table_name: str = None,
        status: str = None,
        type: str = None,
        v_switch_ids: List[str] = None,
    ):
        # The type of the resource with which the route table is associated. Valid values:
        # 
        # *   **VSwitch**\
        # *   **Gateway**\
        self.associate_type = associate_type
        # The time when the route table was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.creation_time = creation_time
        # The description.
        self.description = description
        # The ID of the edge node.
        self.ens_region_id = ens_region_id
        # Specifies whether it is the default gateway route table.
        self.is_default_gateway_route_table = is_default_gateway_route_table
        # The ID of the network.
        self.network_id = network_id
        # The ID of the route table.
        self.route_table_id = route_table_id
        # The name of the route table that you want to query.
        # 
        # The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (_), and hyphens (-).
        self.route_table_name = route_table_name
        # The status. Valid values:
        # 
        # *   Available: The route table is available.
        self.status = status
        # The type of the route table. Examples:
        # 
        # *   Custom: custom route table.
        # *   System: system route table.
        self.type = type
        # The vSwitches that are associated with the route table.
        self.v_switch_ids = v_switch_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.associate_type is not None:
            result['AssociateType'] = self.associate_type
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.is_default_gateway_route_table is not None:
            result['IsDefaultGatewayRouteTable'] = self.is_default_gateway_route_table
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.route_table_id is not None:
            result['RouteTableId'] = self.route_table_id
        if self.route_table_name is not None:
            result['RouteTableName'] = self.route_table_name
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.v_switch_ids is not None:
            result['VSwitchIds'] = self.v_switch_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssociateType') is not None:
            self.associate_type = m.get('AssociateType')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('IsDefaultGatewayRouteTable') is not None:
            self.is_default_gateway_route_table = m.get('IsDefaultGatewayRouteTable')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('RouteTableId') is not None:
            self.route_table_id = m.get('RouteTableId')
        if m.get('RouteTableName') is not None:
            self.route_table_name = m.get('RouteTableName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VSwitchIds') is not None:
            self.v_switch_ids = m.get('VSwitchIds')
        return self


class DescribeEnsRouteTablesResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        route_tables: List[DescribeEnsRouteTablesResponseBodyRouteTables] = None,
        total_count: int = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The information about the route tables.
        self.route_tables = route_tables
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.route_tables:
            for k in self.route_tables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['RouteTables'] = []
        if self.route_tables is not None:
            for k in self.route_tables:
                result['RouteTables'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.route_tables = []
        if m.get('RouteTables') is not None:
            for k in m.get('RouteTables'):
                temp_model = DescribeEnsRouteTablesResponseBodyRouteTables()
                self.route_tables.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeEnsRouteTablesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnsRouteTablesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnsRouteTablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnsSaleControlRequest(TeaModel):
    def __init__(
        self,
        ali_uid_account: str = None,
        commodity_code: str = None,
        custom_account: str = None,
        module_code: str = None,
        order_type: str = None,
    ):
        self.ali_uid_account = ali_uid_account
        # This parameter is required.
        self.commodity_code = commodity_code
        self.custom_account = custom_account
        self.module_code = module_code
        self.order_type = order_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uid_account is not None:
            result['AliUidAccount'] = self.ali_uid_account
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.custom_account is not None:
            result['CustomAccount'] = self.custom_account
        if self.module_code is not None:
            result['ModuleCode'] = self.module_code
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliUidAccount') is not None:
            self.ali_uid_account = m.get('AliUidAccount')
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('CustomAccount') is not None:
            self.custom_account = m.get('CustomAccount')
        if m.get('ModuleCode') is not None:
            self.module_code = m.get('ModuleCode')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        return self


class DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControlModuleValue(TeaModel):
    def __init__(
        self,
        module_max_value: str = None,
        module_min_value: str = None,
        module_value: List[str] = None,
    ):
        self.module_max_value = module_max_value
        self.module_min_value = module_min_value
        self.module_value = module_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.module_max_value is not None:
            result['ModuleMaxValue'] = self.module_max_value
        if self.module_min_value is not None:
            result['ModuleMinValue'] = self.module_min_value
        if self.module_value is not None:
            result['ModuleValue'] = self.module_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ModuleMaxValue') is not None:
            self.module_max_value = m.get('ModuleMaxValue')
        if m.get('ModuleMinValue') is not None:
            self.module_min_value = m.get('ModuleMinValue')
        if m.get('ModuleValue') is not None:
            self.module_value = m.get('ModuleValue')
        return self


class DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControl(TeaModel):
    def __init__(
        self,
        description: str = None,
        module_value: DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControlModuleValue = None,
        operator: str = None,
    ):
        self.description = description
        self.module_value = module_value
        self.operator = operator

    def validate(self):
        if self.module_value:
            self.module_value.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.module_value is not None:
            result['ModuleValue'] = self.module_value.to_map()
        if self.operator is not None:
            result['Operator'] = self.operator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ModuleValue') is not None:
            temp_model = DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControlModuleValue()
            self.module_value = temp_model.from_map(m['ModuleValue'])
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        return self


class DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlConditionControl(TeaModel):
    def __init__(
        self,
        condition_control_module_code: str = None,
        condition_control_module_value: str = None,
    ):
        self.condition_control_module_code = condition_control_module_code
        self.condition_control_module_value = condition_control_module_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition_control_module_code is not None:
            result['ConditionControlModuleCode'] = self.condition_control_module_code
        if self.condition_control_module_value is not None:
            result['ConditionControlModuleValue'] = self.condition_control_module_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConditionControlModuleCode') is not None:
            self.condition_control_module_code = m.get('ConditionControlModuleCode')
        if m.get('ConditionControlModuleValue') is not None:
            self.condition_control_module_value = m.get('ConditionControlModuleValue')
        return self


class DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlModuleValue(TeaModel):
    def __init__(
        self,
        module_max_value: str = None,
        module_min_value: str = None,
        module_value: List[str] = None,
    ):
        self.module_max_value = module_max_value
        self.module_min_value = module_min_value
        self.module_value = module_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.module_max_value is not None:
            result['ModuleMaxValue'] = self.module_max_value
        if self.module_min_value is not None:
            result['ModuleMinValue'] = self.module_min_value
        if self.module_value is not None:
            result['ModuleValue'] = self.module_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ModuleMaxValue') is not None:
            self.module_max_value = m.get('ModuleMaxValue')
        if m.get('ModuleMinValue') is not None:
            self.module_min_value = m.get('ModuleMinValue')
        if m.get('ModuleValue') is not None:
            self.module_value = m.get('ModuleValue')
        return self


class DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl(TeaModel):
    def __init__(
        self,
        condition_control: DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlConditionControl = None,
        description: str = None,
        module_value: DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlModuleValue = None,
        operator: str = None,
    ):
        self.condition_control = condition_control
        self.description = description
        self.module_value = module_value
        self.operator = operator

    def validate(self):
        if self.condition_control:
            self.condition_control.validate()
        if self.module_value:
            self.module_value.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition_control is not None:
            result['ConditionControl'] = self.condition_control.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.module_value is not None:
            result['ModuleValue'] = self.module_value.to_map()
        if self.operator is not None:
            result['Operator'] = self.operator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConditionControl') is not None:
            temp_model = DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlConditionControl()
            self.condition_control = temp_model.from_map(m['ConditionControl'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ModuleValue') is not None:
            temp_model = DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlModuleValue()
            self.module_value = temp_model.from_map(m['ModuleValue'])
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        return self


class DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItem(TeaModel):
    def __init__(
        self,
        basic_sale_control: DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControl = None,
        condition_sale_control: List[DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl] = None,
    ):
        self.basic_sale_control = basic_sale_control
        self.condition_sale_control = condition_sale_control

    def validate(self):
        if self.basic_sale_control:
            self.basic_sale_control.validate()
        if self.condition_sale_control:
            for k in self.condition_sale_control:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.basic_sale_control is not None:
            result['BasicSaleControl'] = self.basic_sale_control.to_map()
        result['ConditionSaleControl'] = []
        if self.condition_sale_control is not None:
            for k in self.condition_sale_control:
                result['ConditionSaleControl'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BasicSaleControl') is not None:
            temp_model = DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControl()
            self.basic_sale_control = temp_model.from_map(m['BasicSaleControl'])
        self.condition_sale_control = []
        if m.get('ConditionSaleControl') is not None:
            for k in m.get('ConditionSaleControl'):
                temp_model = DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl()
                self.condition_sale_control.append(temp_model.from_map(k))
        return self


class DescribeEnsSaleControlResponseBodySaleControlSaleControlItems(TeaModel):
    def __init__(
        self,
        module_code: str = None,
        sale_control_item: DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItem = None,
    ):
        self.module_code = module_code
        self.sale_control_item = sale_control_item

    def validate(self):
        if self.sale_control_item:
            self.sale_control_item.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.module_code is not None:
            result['ModuleCode'] = self.module_code
        if self.sale_control_item is not None:
            result['SaleControlItem'] = self.sale_control_item.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ModuleCode') is not None:
            self.module_code = m.get('ModuleCode')
        if m.get('SaleControlItem') is not None:
            temp_model = DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItem()
            self.sale_control_item = temp_model.from_map(m['SaleControlItem'])
        return self


class DescribeEnsSaleControlResponseBodySaleControl(TeaModel):
    def __init__(
        self,
        commodity_code: str = None,
        order_type: str = None,
        sale_control_items: List[DescribeEnsSaleControlResponseBodySaleControlSaleControlItems] = None,
    ):
        self.commodity_code = commodity_code
        self.order_type = order_type
        self.sale_control_items = sale_control_items

    def validate(self):
        if self.sale_control_items:
            for k in self.sale_control_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        result['SaleControlItems'] = []
        if self.sale_control_items is not None:
            for k in self.sale_control_items:
                result['SaleControlItems'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        self.sale_control_items = []
        if m.get('SaleControlItems') is not None:
            for k in m.get('SaleControlItems'):
                temp_model = DescribeEnsSaleControlResponseBodySaleControlSaleControlItems()
                self.sale_control_items.append(temp_model.from_map(k))
        return self


class DescribeEnsSaleControlResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        sale_control: List[DescribeEnsSaleControlResponseBodySaleControl] = None,
    ):
        self.request_id = request_id
        self.sale_control = sale_control

    def validate(self):
        if self.sale_control:
            for k in self.sale_control:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SaleControl'] = []
        if self.sale_control is not None:
            for k in self.sale_control:
                result['SaleControl'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sale_control = []
        if m.get('SaleControl') is not None:
            for k in m.get('SaleControl'):
                temp_model = DescribeEnsSaleControlResponseBodySaleControl()
                self.sale_control.append(temp_model.from_map(k))
        return self


class DescribeEnsSaleControlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnsSaleControlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnsSaleControlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnsSaleControlAvailableResourceRequest(TeaModel):
    def __init__(
        self,
        commodity_code: str = None,
        custom_account: str = None,
        order_type: str = None,
    ):
        # This parameter is required.
        self.commodity_code = commodity_code
        self.custom_account = custom_account
        self.order_type = order_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.custom_account is not None:
            result['CustomAccount'] = self.custom_account
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('CustomAccount') is not None:
            self.custom_account = m.get('CustomAccount')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        return self


class DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableDiskType(TeaModel):
    def __init__(
        self,
        disk_name: str = None,
        disk_type: str = None,
    ):
        self.disk_name = disk_name
        self.disk_type = disk_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        return self


class DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableRegion(TeaModel):
    def __init__(
        self,
        area: str = None,
        city: str = None,
        country: str = None,
        ens_region_id: str = None,
        ens_region_name: str = None,
        isp: str = None,
        province: str = None,
    ):
        self.area = area
        self.city = city
        self.country = country
        self.ens_region_id = ens_region_id
        self.ens_region_name = ens_region_name
        self.isp = isp
        self.province = province

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.area is not None:
            result['Area'] = self.area
        if self.city is not None:
            result['City'] = self.city
        if self.country is not None:
            result['Country'] = self.country
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.ens_region_name is not None:
            result['EnsRegionName'] = self.ens_region_name
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.province is not None:
            result['Province'] = self.province
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Area') is not None:
            self.area = m.get('Area')
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('Country') is not None:
            self.country = m.get('Country')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('EnsRegionName') is not None:
            self.ens_region_name = m.get('EnsRegionName')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('Province') is not None:
            self.province = m.get('Province')
        return self


class DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableSpec(TeaModel):
    def __init__(
        self,
        cores: str = None,
        memory: str = None,
        spec_name: str = None,
        spec_value: str = None,
    ):
        self.cores = cores
        self.memory = memory
        self.spec_name = spec_name
        self.spec_value = spec_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cores is not None:
            result['Cores'] = self.cores
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.spec_name is not None:
            result['SpecName'] = self.spec_name
        if self.spec_value is not None:
            result['SpecValue'] = self.spec_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cores') is not None:
            self.cores = m.get('Cores')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('SpecName') is not None:
            self.spec_name = m.get('SpecName')
        if m.get('SpecValue') is not None:
            self.spec_value = m.get('SpecValue')
        return self


class DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageTypeAvailableDefaultStorageType(TeaModel):
    def __init__(
        self,
        storage_name: str = None,
        storage_type: str = None,
    ):
        self.storage_name = storage_name
        self.storage_type = storage_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.storage_name is not None:
            result['StorageName'] = self.storage_name
        if self.storage_type is not None:
            result['StorageType'] = self.storage_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('StorageName') is not None:
            self.storage_name = m.get('StorageName')
        if m.get('StorageType') is not None:
            self.storage_type = m.get('StorageType')
        return self


class DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageTypeAvailableSpecialStorageType(TeaModel):
    def __init__(
        self,
        storage_type: str = None,
        storage_name: str = None,
        ens_region_id: str = None,
    ):
        self.storage_type = storage_type
        self.storage_name = storage_name
        self.ens_region_id = ens_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.storage_type is not None:
            result['StorageType'] = self.storage_type
        if self.storage_name is not None:
            result['StorageName'] = self.storage_name
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('StorageType') is not None:
            self.storage_type = m.get('StorageType')
        if m.get('StorageName') is not None:
            self.storage_name = m.get('StorageName')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        return self


class DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageType(TeaModel):
    def __init__(
        self,
        available_default_storage_type: List[DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageTypeAvailableDefaultStorageType] = None,
        available_special_storage_type: List[List[DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageTypeAvailableSpecialStorageType]] = None,
    ):
        self.available_default_storage_type = available_default_storage_type
        self.available_special_storage_type = available_special_storage_type

    def validate(self):
        if self.available_default_storage_type:
            for k in self.available_default_storage_type:
                if k:
                    k.validate()
        if self.available_special_storage_type:
            for k in self.available_special_storage_type:
                for k1 in k:
                    if k1:
                        k1.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AvailableDefaultStorageType'] = []
        if self.available_default_storage_type is not None:
            for k in self.available_default_storage_type:
                result['AvailableDefaultStorageType'].append(k.to_map() if k else None)
        result['AvailableSpecialStorageType'] = []
        if self.available_special_storage_type is not None:
            for k in self.available_special_storage_type:
                l1 = []
                for k1 in k:
                    l1.append(k1.to_map() if k1 else None)
                result['AvailableSpecialStorageType'].append(l1)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.available_default_storage_type = []
        if m.get('AvailableDefaultStorageType') is not None:
            for k in m.get('AvailableDefaultStorageType'):
                temp_model = DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageTypeAvailableDefaultStorageType()
                self.available_default_storage_type.append(temp_model.from_map(k))
        self.available_special_storage_type = []
        if m.get('AvailableSpecialStorageType') is not None:
            for k in m.get('AvailableSpecialStorageType'):
                l1 = []
                for k1 in k:
                    temp_model = DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageTypeAvailableSpecialStorageType()
                    l1.append(temp_model.from_map(k1))
                self.available_special_storage_type.append(l1)
        return self


class DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResource(TeaModel):
    def __init__(
        self,
        available_disk_type: List[DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableDiskType] = None,
        available_region: List[DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableRegion] = None,
        available_spec: List[DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableSpec] = None,
        available_storage_type: DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageType = None,
        commodity_code: str = None,
        order_type: str = None,
    ):
        self.available_disk_type = available_disk_type
        self.available_region = available_region
        self.available_spec = available_spec
        self.available_storage_type = available_storage_type
        self.commodity_code = commodity_code
        self.order_type = order_type

    def validate(self):
        if self.available_disk_type:
            for k in self.available_disk_type:
                if k:
                    k.validate()
        if self.available_region:
            for k in self.available_region:
                if k:
                    k.validate()
        if self.available_spec:
            for k in self.available_spec:
                if k:
                    k.validate()
        if self.available_storage_type:
            self.available_storage_type.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AvailableDiskType'] = []
        if self.available_disk_type is not None:
            for k in self.available_disk_type:
                result['AvailableDiskType'].append(k.to_map() if k else None)
        result['AvailableRegion'] = []
        if self.available_region is not None:
            for k in self.available_region:
                result['AvailableRegion'].append(k.to_map() if k else None)
        result['AvailableSpec'] = []
        if self.available_spec is not None:
            for k in self.available_spec:
                result['AvailableSpec'].append(k.to_map() if k else None)
        if self.available_storage_type is not None:
            result['AvailableStorageType'] = self.available_storage_type.to_map()
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.available_disk_type = []
        if m.get('AvailableDiskType') is not None:
            for k in m.get('AvailableDiskType'):
                temp_model = DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableDiskType()
                self.available_disk_type.append(temp_model.from_map(k))
        self.available_region = []
        if m.get('AvailableRegion') is not None:
            for k in m.get('AvailableRegion'):
                temp_model = DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableRegion()
                self.available_region.append(temp_model.from_map(k))
        self.available_spec = []
        if m.get('AvailableSpec') is not None:
            for k in m.get('AvailableSpec'):
                temp_model = DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableSpec()
                self.available_spec.append(temp_model.from_map(k))
        if m.get('AvailableStorageType') is not None:
            temp_model = DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageType()
            self.available_storage_type = temp_model.from_map(m['AvailableStorageType'])
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        return self


class DescribeEnsSaleControlAvailableResourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        sale_control_available_resource: List[DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResource] = None,
    ):
        self.request_id = request_id
        self.sale_control_available_resource = sale_control_available_resource

    def validate(self):
        if self.sale_control_available_resource:
            for k in self.sale_control_available_resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SaleControlAvailableResource'] = []
        if self.sale_control_available_resource is not None:
            for k in self.sale_control_available_resource:
                result['SaleControlAvailableResource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sale_control_available_resource = []
        if m.get('SaleControlAvailableResource') is not None:
            for k in m.get('SaleControlAvailableResource'):
                temp_model = DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResource()
                self.sale_control_available_resource.append(temp_model.from_map(k))
        return self


class DescribeEnsSaleControlAvailableResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnsSaleControlAvailableResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnsSaleControlAvailableResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnsSaleControlStockRequest(TeaModel):
    def __init__(
        self,
        ali_uid_account: str = None,
        commodity_code: str = None,
        custom_account: str = None,
        module_code: str = None,
        order_type: str = None,
    ):
        self.ali_uid_account = ali_uid_account
        # This parameter is required.
        self.commodity_code = commodity_code
        self.custom_account = custom_account
        self.module_code = module_code
        self.order_type = order_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uid_account is not None:
            result['AliUidAccount'] = self.ali_uid_account
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.custom_account is not None:
            result['CustomAccount'] = self.custom_account
        if self.module_code is not None:
            result['ModuleCode'] = self.module_code
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliUidAccount') is not None:
            self.ali_uid_account = m.get('AliUidAccount')
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('CustomAccount') is not None:
            self.custom_account = m.get('CustomAccount')
        if m.get('ModuleCode') is not None:
            self.module_code = m.get('ModuleCode')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        return self


class DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControlModuleValue(TeaModel):
    def __init__(
        self,
        module_max_value: str = None,
        module_min_value: str = None,
    ):
        self.module_max_value = module_max_value
        self.module_min_value = module_min_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.module_max_value is not None:
            result['ModuleMaxValue'] = self.module_max_value
        if self.module_min_value is not None:
            result['ModuleMinValue'] = self.module_min_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ModuleMaxValue') is not None:
            self.module_max_value = m.get('ModuleMaxValue')
        if m.get('ModuleMinValue') is not None:
            self.module_min_value = m.get('ModuleMinValue')
        return self


class DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControl(TeaModel):
    def __init__(
        self,
        module_value: DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControlModuleValue = None,
        stock_value: str = None,
    ):
        self.module_value = module_value
        self.stock_value = stock_value

    def validate(self):
        if self.module_value:
            self.module_value.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.module_value is not None:
            result['ModuleValue'] = self.module_value.to_map()
        if self.stock_value is not None:
            result['StockValue'] = self.stock_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ModuleValue') is not None:
            temp_model = DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControlModuleValue()
            self.module_value = temp_model.from_map(m['ModuleValue'])
        if m.get('StockValue') is not None:
            self.stock_value = m.get('StockValue')
        return self


class DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlConditionControl(TeaModel):
    def __init__(
        self,
        condition_control_module_code: str = None,
        condition_control_module_value: str = None,
    ):
        self.condition_control_module_code = condition_control_module_code
        self.condition_control_module_value = condition_control_module_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition_control_module_code is not None:
            result['ConditionControlModuleCode'] = self.condition_control_module_code
        if self.condition_control_module_value is not None:
            result['ConditionControlModuleValue'] = self.condition_control_module_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConditionControlModuleCode') is not None:
            self.condition_control_module_code = m.get('ConditionControlModuleCode')
        if m.get('ConditionControlModuleValue') is not None:
            self.condition_control_module_value = m.get('ConditionControlModuleValue')
        return self


class DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlModuleValue(TeaModel):
    def __init__(
        self,
        module_max_value: str = None,
        module_min_value: str = None,
    ):
        self.module_max_value = module_max_value
        self.module_min_value = module_min_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.module_max_value is not None:
            result['ModuleMaxValue'] = self.module_max_value
        if self.module_min_value is not None:
            result['ModuleMinValue'] = self.module_min_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ModuleMaxValue') is not None:
            self.module_max_value = m.get('ModuleMaxValue')
        if m.get('ModuleMinValue') is not None:
            self.module_min_value = m.get('ModuleMinValue')
        return self


class DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl(TeaModel):
    def __init__(
        self,
        condition_control: DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlConditionControl = None,
        module_value: DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlModuleValue = None,
        stock_value: str = None,
    ):
        self.condition_control = condition_control
        self.module_value = module_value
        self.stock_value = stock_value

    def validate(self):
        if self.condition_control:
            self.condition_control.validate()
        if self.module_value:
            self.module_value.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition_control is not None:
            result['ConditionControl'] = self.condition_control.to_map()
        if self.module_value is not None:
            result['ModuleValue'] = self.module_value.to_map()
        if self.stock_value is not None:
            result['StockValue'] = self.stock_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConditionControl') is not None:
            temp_model = DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlConditionControl()
            self.condition_control = temp_model.from_map(m['ConditionControl'])
        if m.get('ModuleValue') is not None:
            temp_model = DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlModuleValue()
            self.module_value = temp_model.from_map(m['ModuleValue'])
        if m.get('StockValue') is not None:
            self.stock_value = m.get('StockValue')
        return self


class DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItem(TeaModel):
    def __init__(
        self,
        basic_sale_control: DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControl = None,
        condition_sale_control: List[DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl] = None,
    ):
        self.basic_sale_control = basic_sale_control
        self.condition_sale_control = condition_sale_control

    def validate(self):
        if self.basic_sale_control:
            self.basic_sale_control.validate()
        if self.condition_sale_control:
            for k in self.condition_sale_control:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.basic_sale_control is not None:
            result['BasicSaleControl'] = self.basic_sale_control.to_map()
        result['ConditionSaleControl'] = []
        if self.condition_sale_control is not None:
            for k in self.condition_sale_control:
                result['ConditionSaleControl'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BasicSaleControl') is not None:
            temp_model = DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControl()
            self.basic_sale_control = temp_model.from_map(m['BasicSaleControl'])
        self.condition_sale_control = []
        if m.get('ConditionSaleControl') is not None:
            for k in m.get('ConditionSaleControl'):
                temp_model = DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl()
                self.condition_sale_control.append(temp_model.from_map(k))
        return self


class DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItems(TeaModel):
    def __init__(
        self,
        module_code: str = None,
        sale_control_item: DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItem = None,
    ):
        self.module_code = module_code
        self.sale_control_item = sale_control_item

    def validate(self):
        if self.sale_control_item:
            self.sale_control_item.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.module_code is not None:
            result['ModuleCode'] = self.module_code
        if self.sale_control_item is not None:
            result['SaleControlItem'] = self.sale_control_item.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ModuleCode') is not None:
            self.module_code = m.get('ModuleCode')
        if m.get('SaleControlItem') is not None:
            temp_model = DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItem()
            self.sale_control_item = temp_model.from_map(m['SaleControlItem'])
        return self


class DescribeEnsSaleControlStockResponseBodySaleControl(TeaModel):
    def __init__(
        self,
        commodity_code: str = None,
        order_type: str = None,
        sale_control_items: List[DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItems] = None,
    ):
        self.commodity_code = commodity_code
        self.order_type = order_type
        self.sale_control_items = sale_control_items

    def validate(self):
        if self.sale_control_items:
            for k in self.sale_control_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        result['SaleControlItems'] = []
        if self.sale_control_items is not None:
            for k in self.sale_control_items:
                result['SaleControlItems'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        self.sale_control_items = []
        if m.get('SaleControlItems') is not None:
            for k in m.get('SaleControlItems'):
                temp_model = DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItems()
                self.sale_control_items.append(temp_model.from_map(k))
        return self


class DescribeEnsSaleControlStockResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        sale_control: List[DescribeEnsSaleControlStockResponseBodySaleControl] = None,
    ):
        self.request_id = request_id
        self.sale_control = sale_control

    def validate(self):
        if self.sale_control:
            for k in self.sale_control:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SaleControl'] = []
        if self.sale_control is not None:
            for k in self.sale_control:
                result['SaleControl'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sale_control = []
        if m.get('SaleControl') is not None:
            for k in m.get('SaleControl'):
                temp_model = DescribeEnsSaleControlStockResponseBodySaleControl()
                self.sale_control.append(temp_model.from_map(k))
        return self


class DescribeEnsSaleControlStockResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnsSaleControlStockResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnsSaleControlStockResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEpnBandWidthDataRequest(TeaModel):
    def __init__(
        self,
        epninstance_id: str = None,
        end_time: str = None,
        ens_region_id: str = None,
        instance_id: str = None,
        isp: str = None,
        networking_model: str = None,
        period: str = None,
        start_time: str = None,
    ):
        # The ID of the EPN instance.
        self.epninstance_id = epninstance_id
        # The end of the time range to query.
        # 
        # *   Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # *   If the value of the seconds place is not 00, the start time is automatically set to the next minute.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The ID of the Edge Node Service (ENS) node.
        self.ens_region_id = ens_region_id
        # The ID of the instance.
        self.instance_id = instance_id
        # The Internet service provider (ISP). Valid values:
        # 
        # *   cmcc: China Mobile
        # *   telecom: China Telecom
        # *   unicom: China Unicom
        # *   multiCarrier: multi-line ISP
        self.isp = isp
        # The networking mode. Valid values:
        # 
        # *   **SpeedUp**: intelligent acceleration network (Internet)
        # *   **Connection**: internal network
        # *   **SpeedUpAndConnection**: intelligent acceleration network and internal network
        self.networking_model = networking_model
        # The precision of the monitoring data that you want to obtain. Valid values: 300, 1200, 3600, and 14400. Default value: 300. Unit: seconds.
        # 
        # This parameter is required.
        self.period = period
        # The beginning of the time range to query.
        # 
        # *   Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # *   If the value of the seconds place is not 00, the start time is automatically set to the next minute.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.epninstance_id is not None:
            result['EPNInstanceId'] = self.epninstance_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.networking_model is not None:
            result['NetworkingModel'] = self.networking_model
        if self.period is not None:
            result['Period'] = self.period
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EPNInstanceId') is not None:
            self.epninstance_id = m.get('EPNInstanceId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('NetworkingModel') is not None:
            self.networking_model = m.get('NetworkingModel')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeEpnBandWidthDataResponseBodyMonitorDataBandWidthMonitorData(TeaModel):
    def __init__(
        self,
        down_band_width: int = None,
        internet_rx: int = None,
        internet_tx: int = None,
        time_stamp: str = None,
        up_band_width: int = None,
    ):
        # The outbound bandwidth. Unit: bit/s.
        self.down_band_width = down_band_width
        # The Internet traffic to the instance. Unit: bytes.
        self.internet_rx = internet_rx
        # The Internet traffic from the instance. Unit: bytes.
        self.internet_tx = internet_tx
        # The timestamp when the monitoring data was queried. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.time_stamp = time_stamp
        # The inbound bandwidth. Unit: bit/s.
        self.up_band_width = up_band_width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.down_band_width is not None:
            result['DownBandWidth'] = self.down_band_width
        if self.internet_rx is not None:
            result['InternetRX'] = self.internet_rx
        if self.internet_tx is not None:
            result['InternetTX'] = self.internet_tx
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        if self.up_band_width is not None:
            result['UpBandWidth'] = self.up_band_width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DownBandWidth') is not None:
            self.down_band_width = m.get('DownBandWidth')
        if m.get('InternetRX') is not None:
            self.internet_rx = m.get('InternetRX')
        if m.get('InternetTX') is not None:
            self.internet_tx = m.get('InternetTX')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        if m.get('UpBandWidth') is not None:
            self.up_band_width = m.get('UpBandWidth')
        return self


class DescribeEpnBandWidthDataResponseBodyMonitorData(TeaModel):
    def __init__(
        self,
        band_width_monitor_data: List[DescribeEpnBandWidthDataResponseBodyMonitorDataBandWidthMonitorData] = None,
        max_down_band_width: int = None,
        max_up_band_width: int = None,
    ):
        # The bandwidth data.
        self.band_width_monitor_data = band_width_monitor_data
        # The maximum outbound bandwidth within the queried time range. Unit: bit/s.
        self.max_down_band_width = max_down_band_width
        # The maximum inbound bandwidth within the queried time range. Unit: bit/s.
        self.max_up_band_width = max_up_band_width

    def validate(self):
        if self.band_width_monitor_data:
            for k in self.band_width_monitor_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BandWidthMonitorData'] = []
        if self.band_width_monitor_data is not None:
            for k in self.band_width_monitor_data:
                result['BandWidthMonitorData'].append(k.to_map() if k else None)
        if self.max_down_band_width is not None:
            result['MaxDownBandWidth'] = self.max_down_band_width
        if self.max_up_band_width is not None:
            result['MaxUpBandWidth'] = self.max_up_band_width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.band_width_monitor_data = []
        if m.get('BandWidthMonitorData') is not None:
            for k in m.get('BandWidthMonitorData'):
                temp_model = DescribeEpnBandWidthDataResponseBodyMonitorDataBandWidthMonitorData()
                self.band_width_monitor_data.append(temp_model.from_map(k))
        if m.get('MaxDownBandWidth') is not None:
            self.max_down_band_width = m.get('MaxDownBandWidth')
        if m.get('MaxUpBandWidth') is not None:
            self.max_up_band_width = m.get('MaxUpBandWidth')
        return self


class DescribeEpnBandWidthDataResponseBody(TeaModel):
    def __init__(
        self,
        monitor_data: DescribeEpnBandWidthDataResponseBodyMonitorData = None,
        request_id: str = None,
    ):
        # The monitoring data of the instance.
        self.monitor_data = monitor_data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.monitor_data:
            self.monitor_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.monitor_data is not None:
            result['MonitorData'] = self.monitor_data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MonitorData') is not None:
            temp_model = DescribeEpnBandWidthDataResponseBodyMonitorData()
            self.monitor_data = temp_model.from_map(m['MonitorData'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeEpnBandWidthDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEpnBandWidthDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEpnBandWidthDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEpnBandwitdhByInternetChargeTypeRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        ens_region_id: str = None,
        isp: str = None,
        networking_model: str = None,
        start_time: str = None,
    ):
        # The end of the time range to query.
        # 
        # *   Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # *   If the value of the seconds place is not 00, the start time is automatically set to the next minute.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The ID of the Edge Node Service (ENS) node.
        self.ens_region_id = ens_region_id
        # The Internet service provider (ISP). Valid values:
        # 
        # *   cmcc: China Mobile
        # *   telecom: China Telecom
        # *   unicom: China Unicom
        # *   multiCarrier: multi-line ISP
        self.isp = isp
        # The networking mode. Valid values:
        # 
        # *   **SpeedUp**: intelligent acceleration network (Internet)
        # *   **Connection**: internal network
        # *   **SpeedUpAndConnection**: intelligent acceleration network and internal network
        self.networking_model = networking_model
        # The beginning of the time range to query.
        # 
        # *   Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # *   If the value of the seconds place is not 00, the start time is automatically set to the next minute.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.networking_model is not None:
            result['NetworkingModel'] = self.networking_model
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('NetworkingModel') is not None:
            self.networking_model = m.get('NetworkingModel')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeEpnBandwitdhByInternetChargeTypeResponseBody(TeaModel):
    def __init__(
        self,
        bandwidth_value: int = None,
        internet_charge_type: str = None,
        request_id: str = None,
        time_stamp: str = None,
    ):
        # The bandwidth. Unit: bit/s.
        self.bandwidth_value = bandwidth_value
        # The metering method. Valid values:
        # 
        # *   BandwidthByDay: Pay by daily peak bandwidth
        # *   95BandwidthByMonth: Pay by monthly 95th percentile bandwidth
        # *   PayByBandwidth4thMonth: Pay by monthly fourth peak bandwidth
        # *   PayByBandwidth: Pay by fixed bandwidth
        # 
        # You can specify only one metering method for network usage and cannot overwrite the existing metering method.
        self.internet_charge_type = internet_charge_type
        # The request ID.
        self.request_id = request_id
        # The timestamp when the monitoring data was queried. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidth_value is not None:
            result['BandwidthValue'] = self.bandwidth_value
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BandwidthValue') is not None:
            self.bandwidth_value = m.get('BandwidthValue')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeEpnBandwitdhByInternetChargeTypeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEpnBandwitdhByInternetChargeTypeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEpnBandwitdhByInternetChargeTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEpnInstanceAttributeRequest(TeaModel):
    def __init__(
        self,
        epninstance_id: str = None,
    ):
        # The ID of the EPN instance.
        # 
        # This parameter is required.
        self.epninstance_id = epninstance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.epninstance_id is not None:
            result['EPNInstanceId'] = self.epninstance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EPNInstanceId') is not None:
            self.epninstance_id = m.get('EPNInstanceId')
        return self


class DescribeEpnInstanceAttributeResponseBodyConfVersions(TeaModel):
    def __init__(
        self,
        conf_version: str = None,
        ens_region_id: str = None,
    ):
        # The version number.
        self.conf_version = conf_version
        # The ID of the node.
        self.ens_region_id = ens_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.conf_version is not None:
            result['ConfVersion'] = self.conf_version
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfVersion') is not None:
            self.conf_version = m.get('ConfVersion')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        return self


class DescribeEpnInstanceAttributeResponseBodyInstances(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        instance_id: str = None,
        instance_name: str = None,
        isp: str = None,
        private_ip_address: str = None,
        public_ip_address: str = None,
        status: str = None,
    ):
        # The ID of the node.
        self.ens_region_id = ens_region_id
        # The ID of the instance.
        self.instance_id = instance_id
        # The name of the instance.
        self.instance_name = instance_name
        # The ISP. Valid values:
        # 
        # *   cmcc: China Mobile
        # *   unicom: China Unicom
        # *   telecom: China Telecom
        self.isp = isp
        # The private IP address.
        self.private_ip_address = private_ip_address
        # The public IP address.
        self.public_ip_address = public_ip_address
        # The status of the instance. Valid values:
        # 
        # *   Running
        # *   Stopped
        # *   Expired
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        if self.public_ip_address is not None:
            result['PublicIpAddress'] = self.public_ip_address
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        if m.get('PublicIpAddress') is not None:
            self.public_ip_address = m.get('PublicIpAddress')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeEpnInstanceAttributeResponseBodyVSwitches(TeaModel):
    def __init__(
        self,
        cidr_block: str = None,
        ens_region_id: str = None,
        v_switch_id: str = None,
        v_switch_name: str = None,
    ):
        # The CIDR block.
        self.cidr_block = cidr_block
        # The ID of the node.
        self.ens_region_id = ens_region_id
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id
        # The name of the vSwitch.
        self.v_switch_name = v_switch_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.v_switch_name is not None:
            result['VSwitchName'] = self.v_switch_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VSwitchName') is not None:
            self.v_switch_name = m.get('VSwitchName')
        return self


class DescribeEpnInstanceAttributeResponseBody(TeaModel):
    def __init__(
        self,
        conf_versions: List[DescribeEpnInstanceAttributeResponseBodyConfVersions] = None,
        epninstance_id: str = None,
        epninstance_name: str = None,
        instances: List[DescribeEpnInstanceAttributeResponseBodyInstances] = None,
        networking_model: str = None,
        request_id: str = None,
        v_switches: List[DescribeEpnInstanceAttributeResponseBodyVSwitches] = None,
    ):
        # The information about the EPN configurations.
        self.conf_versions = conf_versions
        # The ID of the EPN instance.
        self.epninstance_id = epninstance_id
        # The name of the EPN instance.
        self.epninstance_name = epninstance_name
        # The information about the instance.
        self.instances = instances
        # The networking mode. Valid values:
        # 
        # *   SpeedUp: intelligent acceleration network (Internet)
        # *   Connection: internal network
        # *   SpeedUpAndConnection: intelligent acceleration network and internal network
        self.networking_model = networking_model
        # The request ID.
        self.request_id = request_id
        # Details of the vSwitch.
        self.v_switches = v_switches

    def validate(self):
        if self.conf_versions:
            for k in self.conf_versions:
                if k:
                    k.validate()
        if self.instances:
            for k in self.instances:
                if k:
                    k.validate()
        if self.v_switches:
            for k in self.v_switches:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConfVersions'] = []
        if self.conf_versions is not None:
            for k in self.conf_versions:
                result['ConfVersions'].append(k.to_map() if k else None)
        if self.epninstance_id is not None:
            result['EPNInstanceId'] = self.epninstance_id
        if self.epninstance_name is not None:
            result['EPNInstanceName'] = self.epninstance_name
        result['Instances'] = []
        if self.instances is not None:
            for k in self.instances:
                result['Instances'].append(k.to_map() if k else None)
        if self.networking_model is not None:
            result['NetworkingModel'] = self.networking_model
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['VSwitches'] = []
        if self.v_switches is not None:
            for k in self.v_switches:
                result['VSwitches'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.conf_versions = []
        if m.get('ConfVersions') is not None:
            for k in m.get('ConfVersions'):
                temp_model = DescribeEpnInstanceAttributeResponseBodyConfVersions()
                self.conf_versions.append(temp_model.from_map(k))
        if m.get('EPNInstanceId') is not None:
            self.epninstance_id = m.get('EPNInstanceId')
        if m.get('EPNInstanceName') is not None:
            self.epninstance_name = m.get('EPNInstanceName')
        self.instances = []
        if m.get('Instances') is not None:
            for k in m.get('Instances'):
                temp_model = DescribeEpnInstanceAttributeResponseBodyInstances()
                self.instances.append(temp_model.from_map(k))
        if m.get('NetworkingModel') is not None:
            self.networking_model = m.get('NetworkingModel')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.v_switches = []
        if m.get('VSwitches') is not None:
            for k in m.get('VSwitches'):
                temp_model = DescribeEpnInstanceAttributeResponseBodyVSwitches()
                self.v_switches.append(temp_model.from_map(k))
        return self


class DescribeEpnInstanceAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEpnInstanceAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEpnInstanceAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEpnInstancesRequest(TeaModel):
    def __init__(
        self,
        epninstance_id: str = None,
        epninstance_name: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The version number.
        self.epninstance_id = epninstance_id
        # The name of the EPN instance.
        self.epninstance_name = epninstance_name
        # The page number. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Valid values: **1 to 50**. Default value: **10**.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.epninstance_id is not None:
            result['EPNInstanceId'] = self.epninstance_id
        if self.epninstance_name is not None:
            result['EPNInstanceName'] = self.epninstance_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EPNInstanceId') is not None:
            self.epninstance_id = m.get('EPNInstanceId')
        if m.get('EPNInstanceName') is not None:
            self.epninstance_name = m.get('EPNInstanceName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeEpnInstancesResponseBodyEPNInstancesEPNInstance(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        epninstance_id: str = None,
        epninstance_name: str = None,
        epninstance_type: str = None,
        end_time: str = None,
        internet_max_bandwidth_out: int = None,
        modify_time: str = None,
        networking_model: str = None,
        start_time: str = None,
        status: str = None,
    ):
        # The time when the instance was created. The time is displayed in UTC.
        self.creation_time = creation_time
        # The ID of the EPN instance.
        self.epninstance_id = epninstance_id
        # The name of the EPN instance.
        self.epninstance_name = epninstance_name
        # Set the value to EdgeToEdge.
        self.epninstance_type = epninstance_type
        # The end of the time range during which the data was queried. The time is displayed in UTC.
        self.end_time = end_time
        # The inbound bandwidth. Unit: Mbit/s.
        self.internet_max_bandwidth_out = internet_max_bandwidth_out
        # The time when the instance was last modified. The time is displayed in UTC.
        self.modify_time = modify_time
        # The networking mode. Valid values:
        # 
        # *   SpeedUp: intelligent acceleration network (Internet)
        # *   Connection: internal network
        # *   SpeedUpAndConnection: intelligent acceleration network and internal network
        self.networking_model = networking_model
        # The beginning of the time range during which the data was queried. The time is displayed in UTC.
        self.start_time = start_time
        # The status of the instance. Valid values:
        # 
        # *   Running
        # *   Excuting
        # *   Stopped
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.epninstance_id is not None:
            result['EPNInstanceId'] = self.epninstance_id
        if self.epninstance_name is not None:
            result['EPNInstanceName'] = self.epninstance_name
        if self.epninstance_type is not None:
            result['EPNInstanceType'] = self.epninstance_type
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.internet_max_bandwidth_out is not None:
            result['InternetMaxBandwidthOut'] = self.internet_max_bandwidth_out
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.networking_model is not None:
            result['NetworkingModel'] = self.networking_model
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('EPNInstanceId') is not None:
            self.epninstance_id = m.get('EPNInstanceId')
        if m.get('EPNInstanceName') is not None:
            self.epninstance_name = m.get('EPNInstanceName')
        if m.get('EPNInstanceType') is not None:
            self.epninstance_type = m.get('EPNInstanceType')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InternetMaxBandwidthOut') is not None:
            self.internet_max_bandwidth_out = m.get('InternetMaxBandwidthOut')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('NetworkingModel') is not None:
            self.networking_model = m.get('NetworkingModel')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeEpnInstancesResponseBodyEPNInstances(TeaModel):
    def __init__(
        self,
        epninstance: List[DescribeEpnInstancesResponseBodyEPNInstancesEPNInstance] = None,
    ):
        self.epninstance = epninstance

    def validate(self):
        if self.epninstance:
            for k in self.epninstance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EPNInstance'] = []
        if self.epninstance is not None:
            for k in self.epninstance:
                result['EPNInstance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.epninstance = []
        if m.get('EPNInstance') is not None:
            for k in m.get('EPNInstance'):
                temp_model = DescribeEpnInstancesResponseBodyEPNInstancesEPNInstance()
                self.epninstance.append(temp_model.from_map(k))
        return self


class DescribeEpnInstancesResponseBody(TeaModel):
    def __init__(
        self,
        epninstances: DescribeEpnInstancesResponseBodyEPNInstances = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # Details of EPN instances.
        self.epninstances = epninstances
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of pages returned.
        self.total_count = total_count

    def validate(self):
        if self.epninstances:
            self.epninstances.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.epninstances is not None:
            result['EPNInstances'] = self.epninstances.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EPNInstances') is not None:
            temp_model = DescribeEpnInstancesResponseBodyEPNInstances()
            self.epninstances = temp_model.from_map(m['EPNInstances'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeEpnInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEpnInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEpnInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEpnMeasurementDataRequest(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        start_date: str = None,
    ):
        # The end of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_date = end_date
        # The beginning of the time range to query. Specify the time in the yyyy-mm-ddthh:mm:ssz format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        return self


class DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData(TeaModel):
    def __init__(
        self,
        cost_code: str = None,
        cost_name: str = None,
        cost_type: str = None,
        cost_val: int = None,
        isp_line: str = None,
    ):
        # The code of the billable item.
        self.cost_code = cost_code
        # The name of the billable item.
        self.cost_name = cost_name
        # Metering method
        # 
        # *   SpeedUp: bandwidth of intelligent acceleration
        # *   IntranetConnection: internal bandwidth
        self.cost_type = cost_type
        # The value of the billable item.
        self.cost_val = cost_val
        # This parameter is unavailable.
        self.isp_line = isp_line

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cost_code is not None:
            result['CostCode'] = self.cost_code
        if self.cost_name is not None:
            result['CostName'] = self.cost_name
        if self.cost_type is not None:
            result['CostType'] = self.cost_type
        if self.cost_val is not None:
            result['CostVal'] = self.cost_val
        if self.isp_line is not None:
            result['IspLine'] = self.isp_line
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CostCode') is not None:
            self.cost_code = m.get('CostCode')
        if m.get('CostName') is not None:
            self.cost_name = m.get('CostName')
        if m.get('CostType') is not None:
            self.cost_type = m.get('CostType')
        if m.get('CostVal') is not None:
            self.cost_val = m.get('CostVal')
        if m.get('IspLine') is not None:
            self.isp_line = m.get('IspLine')
        return self


class DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas(TeaModel):
    def __init__(
        self,
        band_width_fee_data: List[DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData] = None,
    ):
        self.band_width_fee_data = band_width_fee_data

    def validate(self):
        if self.band_width_fee_data:
            for k in self.band_width_fee_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BandWidthFeeData'] = []
        if self.band_width_fee_data is not None:
            for k in self.band_width_fee_data:
                result['BandWidthFeeData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.band_width_fee_data = []
        if m.get('BandWidthFeeData') is not None:
            for k in m.get('BandWidthFeeData'):
                temp_model = DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData()
                self.band_width_fee_data.append(temp_model.from_map(k))
        return self


class DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementData(TeaModel):
    def __init__(
        self,
        band_width_fee_datas: DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas = None,
        charge_model: str = None,
        cost_cycle: str = None,
        cost_end_time: str = None,
        cost_start_time: str = None,
    ):
        # The bandwidth data returned.
        self.band_width_fee_datas = band_width_fee_datas
        # The metering method. Valid values:
        # 
        # *   ChargeByUnified: unified metering.
        # *   ChargeByGrade: differential metering.
        self.charge_model = charge_model
        # The metering cycle.
        self.cost_cycle = cost_cycle
        # The end time of the metering cycle.
        self.cost_end_time = cost_end_time
        # The start time of the metering cycle.
        self.cost_start_time = cost_start_time

    def validate(self):
        if self.band_width_fee_datas:
            self.band_width_fee_datas.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.band_width_fee_datas is not None:
            result['BandWidthFeeDatas'] = self.band_width_fee_datas.to_map()
        if self.charge_model is not None:
            result['ChargeModel'] = self.charge_model
        if self.cost_cycle is not None:
            result['CostCycle'] = self.cost_cycle
        if self.cost_end_time is not None:
            result['CostEndTime'] = self.cost_end_time
        if self.cost_start_time is not None:
            result['CostStartTime'] = self.cost_start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BandWidthFeeDatas') is not None:
            temp_model = DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas()
            self.band_width_fee_datas = temp_model.from_map(m['BandWidthFeeDatas'])
        if m.get('ChargeModel') is not None:
            self.charge_model = m.get('ChargeModel')
        if m.get('CostCycle') is not None:
            self.cost_cycle = m.get('CostCycle')
        if m.get('CostEndTime') is not None:
            self.cost_end_time = m.get('CostEndTime')
        if m.get('CostStartTime') is not None:
            self.cost_start_time = m.get('CostStartTime')
        return self


class DescribeEpnMeasurementDataResponseBodyMeasurementDatas(TeaModel):
    def __init__(
        self,
        measurement_data: List[DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementData] = None,
    ):
        self.measurement_data = measurement_data

    def validate(self):
        if self.measurement_data:
            for k in self.measurement_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MeasurementData'] = []
        if self.measurement_data is not None:
            for k in self.measurement_data:
                result['MeasurementData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.measurement_data = []
        if m.get('MeasurementData') is not None:
            for k in m.get('MeasurementData'):
                temp_model = DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementData()
                self.measurement_data.append(temp_model.from_map(k))
        return self


class DescribeEpnMeasurementDataResponseBody(TeaModel):
    def __init__(
        self,
        measurement_datas: DescribeEpnMeasurementDataResponseBodyMeasurementDatas = None,
        request_id: str = None,
    ):
        # The metering data returned.
        self.measurement_datas = measurement_datas
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.measurement_datas:
            self.measurement_datas.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.measurement_datas is not None:
            result['MeasurementDatas'] = self.measurement_datas.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MeasurementDatas') is not None:
            temp_model = DescribeEpnMeasurementDataResponseBodyMeasurementDatas()
            self.measurement_datas = temp_model.from_map(m['MeasurementDatas'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeEpnMeasurementDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEpnMeasurementDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEpnMeasurementDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExportImageInfoRequest(TeaModel):
    def __init__(
        self,
        image_id: str = None,
        image_name: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The ID of the image.
        self.image_id = image_id
        # The name of the image.
        self.image_name = image_name
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Maximum value: **50**. Default value: **10**.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeExportImageInfoResponseBodyImagesImage(TeaModel):
    def __init__(
        self,
        architecture: str = None,
        creation_time: str = None,
        exported_image_url: str = None,
        image_export_status: str = None,
        image_id: str = None,
        image_name: str = None,
        image_owner_alias: str = None,
        platform: str = None,
    ):
        # The architecture of the image. Example: **x86_64**.
        self.architecture = architecture
        # The time when the image was created.
        self.creation_time = creation_time
        # The URL of the exported image.
        self.exported_image_url = exported_image_url
        # The export status of the image. Valid values:
        # 
        # *   Exporting
        # *   Exported
        # *   ExportError
        # *   Unexported
        self.image_export_status = image_export_status
        # The ID of the image.
        self.image_id = image_id
        # The name of the image.
        self.image_name = image_name
        # The source of the image. Valid values:
        # 
        # *   system: public image
        # *   self: custom image
        self.image_owner_alias = image_owner_alias
        # The OS.
        self.platform = platform

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.architecture is not None:
            result['Architecture'] = self.architecture
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.exported_image_url is not None:
            result['ExportedImageURL'] = self.exported_image_url
        if self.image_export_status is not None:
            result['ImageExportStatus'] = self.image_export_status
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.image_owner_alias is not None:
            result['ImageOwnerAlias'] = self.image_owner_alias
        if self.platform is not None:
            result['Platform'] = self.platform
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Architecture') is not None:
            self.architecture = m.get('Architecture')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('ExportedImageURL') is not None:
            self.exported_image_url = m.get('ExportedImageURL')
        if m.get('ImageExportStatus') is not None:
            self.image_export_status = m.get('ImageExportStatus')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('ImageOwnerAlias') is not None:
            self.image_owner_alias = m.get('ImageOwnerAlias')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        return self


class DescribeExportImageInfoResponseBodyImages(TeaModel):
    def __init__(
        self,
        image: List[DescribeExportImageInfoResponseBodyImagesImage] = None,
    ):
        self.image = image

    def validate(self):
        if self.image:
            for k in self.image:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Image'] = []
        if self.image is not None:
            for k in self.image:
                result['Image'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.image = []
        if m.get('Image') is not None:
            for k in m.get('Image'):
                temp_model = DescribeExportImageInfoResponseBodyImagesImage()
                self.image.append(temp_model.from_map(k))
        return self


class DescribeExportImageInfoResponseBody(TeaModel):
    def __init__(
        self,
        images: DescribeExportImageInfoResponseBodyImages = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The returned result. For more information, see the Images parameter described in the JSON-formatted sample success response.
        self.images = images
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.images:
            self.images.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.images is not None:
            result['Images'] = self.images.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Images') is not None:
            temp_model = DescribeExportImageInfoResponseBodyImages()
            self.images = temp_model.from_map(m['Images'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeExportImageInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeExportImageInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExportImageInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExportImageStatusRequest(TeaModel):
    def __init__(
        self,
        image_id: str = None,
    ):
        # The ID of the image.
        # 
        # This parameter is required.
        self.image_id = image_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        return self


class DescribeExportImageStatusResponseBody(TeaModel):
    def __init__(
        self,
        image_export_status: str = None,
        request_id: str = None,
    ):
        # The export status of the image. Valid values:
        # 
        # *   Exporting
        # *   Exported
        # *   ExportError
        # *   Unexported
        self.image_export_status = image_export_status
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_export_status is not None:
            result['ImageExportStatus'] = self.image_export_status
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageExportStatus') is not None:
            self.image_export_status = m.get('ImageExportStatus')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeExportImageStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeExportImageStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExportImageStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeFileSystemsRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        file_system_id: str = None,
        file_system_name: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The ID of the region.
        self.ens_region_id = ens_region_id
        # The ID of the file system.
        self.file_system_id = file_system_id
        # The name of the file system.
        self.file_system_name = file_system_name
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Maximum value: **100**. Default value: **10**.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.file_system_id is not None:
            result['FileSystemId'] = self.file_system_id
        if self.file_system_name is not None:
            result['FileSystemName'] = self.file_system_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('FileSystemId') is not None:
            self.file_system_id = m.get('FileSystemId')
        if m.get('FileSystemName') is not None:
            self.file_system_name = m.get('FileSystemName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeFileSystemsResponseBodyFileSystemsMountTargets(TeaModel):
    def __init__(
        self,
        mount_target_domain: str = None,
        mount_target_name: str = None,
        net_work_id: str = None,
        status: str = None,
    ):
        # The path of the mount target.
        self.mount_target_domain = mount_target_domain
        # The name of the mount target.
        self.mount_target_name = mount_target_name
        # The ID of the network.
        self.net_work_id = net_work_id
        # The status of the mount target. Valid values:
        # 
        # *   active: The mount target is available.
        # *   inactive: The mount target is unavailable.
        # *   pending: The task is running.
        # *   deleting: The mount target is being deleted.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mount_target_domain is not None:
            result['MountTargetDomain'] = self.mount_target_domain
        if self.mount_target_name is not None:
            result['MountTargetName'] = self.mount_target_name
        if self.net_work_id is not None:
            result['NetWorkId'] = self.net_work_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MountTargetDomain') is not None:
            self.mount_target_domain = m.get('MountTargetDomain')
        if m.get('MountTargetName') is not None:
            self.mount_target_name = m.get('MountTargetName')
        if m.get('NetWorkId') is not None:
            self.net_work_id = m.get('NetWorkId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeFileSystemsResponseBodyFileSystems(TeaModel):
    def __init__(
        self,
        capacity: int = None,
        creation_time: str = None,
        description: str = None,
        ens_region_id: str = None,
        file_system_id: str = None,
        file_system_name: str = None,
        metered_size: int = None,
        mount_targets: List[DescribeFileSystemsResponseBodyFileSystemsMountTargets] = None,
        pay_type: str = None,
        protocol_type: str = None,
        status: str = None,
        storage_type: str = None,
    ):
        # The capacity of the file system. Unit: MiB.
        self.capacity = capacity
        # The time when the file system was created.
        self.creation_time = creation_time
        self.description = description
        # The ID of the region.
        self.ens_region_id = ens_region_id
        # The ID of the file system.
        self.file_system_id = file_system_id
        # The name of the file system.
        self.file_system_name = file_system_name
        # The storage usage of the file system. The value of this parameter is the maximum storage usage of the file system over the last hour. Unit: bytes.
        self.metered_size = metered_size
        # The information about mount targets.
        self.mount_targets = mount_targets
        # The billing method. PostPaid is returned. PostPaid indicates the pay-as-you-go billing method.
        self.pay_type = pay_type
        # The protocol type of the file system. Valid values:
        # 
        # *   NFS: Network File System (NFS)
        # *   SMB: Server Message Block (SMB)
        self.protocol_type = protocol_type
        # The status of the file system. Valid values:
        # 
        # *   pending: The file system is being created or modified.
        # *   running: The file system is available. Before you create a mount target for the file system, make sure that the file system is in the running state.
        # *   stopped: The file system is unavailable.
        # *   extending: The file system is being scaled out.
        # *   stopping: The file system is being disabled.
        # *   deleting: The file system is being deleted.
        self.status = status
        # The storage type. Valid values:
        # 
        # *   capacity: Capacity NAS file systems
        # *   performance: Performance NAS file systems
        self.storage_type = storage_type

    def validate(self):
        if self.mount_targets:
            for k in self.mount_targets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.capacity is not None:
            result['Capacity'] = self.capacity
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.file_system_id is not None:
            result['FileSystemId'] = self.file_system_id
        if self.file_system_name is not None:
            result['FileSystemName'] = self.file_system_name
        if self.metered_size is not None:
            result['MeteredSize'] = self.metered_size
        result['MountTargets'] = []
        if self.mount_targets is not None:
            for k in self.mount_targets:
                result['MountTargets'].append(k.to_map() if k else None)
        if self.pay_type is not None:
            result['PayType'] = self.pay_type
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.status is not None:
            result['Status'] = self.status
        if self.storage_type is not None:
            result['StorageType'] = self.storage_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Capacity') is not None:
            self.capacity = m.get('Capacity')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('FileSystemId') is not None:
            self.file_system_id = m.get('FileSystemId')
        if m.get('FileSystemName') is not None:
            self.file_system_name = m.get('FileSystemName')
        if m.get('MeteredSize') is not None:
            self.metered_size = m.get('MeteredSize')
        self.mount_targets = []
        if m.get('MountTargets') is not None:
            for k in m.get('MountTargets'):
                temp_model = DescribeFileSystemsResponseBodyFileSystemsMountTargets()
                self.mount_targets.append(temp_model.from_map(k))
        if m.get('PayType') is not None:
            self.pay_type = m.get('PayType')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StorageType') is not None:
            self.storage_type = m.get('StorageType')
        return self


class DescribeFileSystemsResponseBody(TeaModel):
    def __init__(
        self,
        file_systems: List[DescribeFileSystemsResponseBodyFileSystems] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The information about the file systems.
        self.file_systems = file_systems
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.file_systems:
            for k in self.file_systems:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FileSystems'] = []
        if self.file_systems is not None:
            for k in self.file_systems:
                result['FileSystems'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.file_systems = []
        if m.get('FileSystems') is not None:
            for k in m.get('FileSystems'):
                temp_model = DescribeFileSystemsResponseBodyFileSystems()
                self.file_systems.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeFileSystemsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeFileSystemsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeFileSystemsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeForwardTableEntriesRequest(TeaModel):
    def __init__(
        self,
        external_ip: str = None,
        forward_entry_id: str = None,
        forward_entry_name: str = None,
        internal_ip: str = None,
        ip_protocol: str = None,
        nat_gateway_id: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The EIP in the DNAT entry. The public IP address is used to access the Internet.
        self.external_ip = external_ip
        # The ID of the DNAT entry.
        self.forward_entry_id = forward_entry_id
        # The name of the DNAT entry.
        self.forward_entry_name = forward_entry_name
        # The private IP address of the instance that uses the DNAT entry for Internet communication.
        self.internal_ip = internal_ip
        # The protocol. Valid values:
        # 
        # *   **TCP**: forwards TCP packets.
        # *   **UDP**: forwards UDP packets.
        # *   **Any**: forwards all packets.
        self.ip_protocol = ip_protocol
        # The ID of the NAT gateway.
        # 
        # This parameter is required.
        self.nat_gateway_id = nat_gateway_id
        # The page number. Pages start from page **1**.
        # 
        # Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Maximum value: **100**.
        # 
        # Default value: **10**.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.external_ip is not None:
            result['ExternalIp'] = self.external_ip
        if self.forward_entry_id is not None:
            result['ForwardEntryId'] = self.forward_entry_id
        if self.forward_entry_name is not None:
            result['ForwardEntryName'] = self.forward_entry_name
        if self.internal_ip is not None:
            result['InternalIp'] = self.internal_ip
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.nat_gateway_id is not None:
            result['NatGatewayId'] = self.nat_gateway_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExternalIp') is not None:
            self.external_ip = m.get('ExternalIp')
        if m.get('ForwardEntryId') is not None:
            self.forward_entry_id = m.get('ForwardEntryId')
        if m.get('ForwardEntryName') is not None:
            self.forward_entry_name = m.get('ForwardEntryName')
        if m.get('InternalIp') is not None:
            self.internal_ip = m.get('InternalIp')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('NatGatewayId') is not None:
            self.nat_gateway_id = m.get('NatGatewayId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeForwardTableEntriesResponseBodyForwardTableEntries(TeaModel):
    def __init__(
        self,
        external_ip: str = None,
        external_port: str = None,
        forward_entry_id: str = None,
        forward_entry_name: str = None,
        health_check_port: str = None,
        internal_ip: str = None,
        internal_port: str = None,
        ip_protocol: str = None,
        nat_gateway_id: str = None,
        standby_external_ip: str = None,
        standby_status: str = None,
        status: str = None,
    ):
        # The EIP in the DNAT entry. The public IP address is used to access the Internet.
        self.external_ip = external_ip
        # The external port or port range that is used in port forwarding.
        self.external_port = external_port
        # The ID of the DNAT entry.
        self.forward_entry_id = forward_entry_id
        # The name of the DNAT entry.
        self.forward_entry_name = forward_entry_name
        # The probe port of DNAT.
        self.health_check_port = health_check_port
        # The private IP address of the instance that uses the DNAT entry for Internet communication.
        self.internal_ip = internal_ip
        # The internal port or port range that is used for port forwarding.
        self.internal_port = internal_port
        # The protocol. Valid values:
        # 
        # *   **TCP**: forwards TCP packets.
        # *   **UDP**: forwards UDP packets.
        # *   **Any**: forwards all packets.
        self.ip_protocol = ip_protocol
        # The ID of the NAT gateway.
        self.nat_gateway_id = nat_gateway_id
        # The secondary EIP that is used to access the Internet.
        self.standby_external_ip = standby_external_ip
        # The status of the secondary EIP. Valid values:
        # 
        # *   Running
        # *   Stopping
        # *   Stopped
        # *   Starting
        self.standby_status = standby_status
        # The status of the DNAT entry. Valid values:
        # 
        # *   Pending: The DNAT entry is being created or modified.
        # *   Available: The DNAT entry is available.
        # *   Deleting: The DNAT entry is being deleted.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.external_ip is not None:
            result['ExternalIp'] = self.external_ip
        if self.external_port is not None:
            result['ExternalPort'] = self.external_port
        if self.forward_entry_id is not None:
            result['ForwardEntryId'] = self.forward_entry_id
        if self.forward_entry_name is not None:
            result['ForwardEntryName'] = self.forward_entry_name
        if self.health_check_port is not None:
            result['HealthCheckPort'] = self.health_check_port
        if self.internal_ip is not None:
            result['InternalIp'] = self.internal_ip
        if self.internal_port is not None:
            result['InternalPort'] = self.internal_port
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.nat_gateway_id is not None:
            result['NatGatewayId'] = self.nat_gateway_id
        if self.standby_external_ip is not None:
            result['StandbyExternalIp'] = self.standby_external_ip
        if self.standby_status is not None:
            result['StandbyStatus'] = self.standby_status
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExternalIp') is not None:
            self.external_ip = m.get('ExternalIp')
        if m.get('ExternalPort') is not None:
            self.external_port = m.get('ExternalPort')
        if m.get('ForwardEntryId') is not None:
            self.forward_entry_id = m.get('ForwardEntryId')
        if m.get('ForwardEntryName') is not None:
            self.forward_entry_name = m.get('ForwardEntryName')
        if m.get('HealthCheckPort') is not None:
            self.health_check_port = m.get('HealthCheckPort')
        if m.get('InternalIp') is not None:
            self.internal_ip = m.get('InternalIp')
        if m.get('InternalPort') is not None:
            self.internal_port = m.get('InternalPort')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('NatGatewayId') is not None:
            self.nat_gateway_id = m.get('NatGatewayId')
        if m.get('StandbyExternalIp') is not None:
            self.standby_external_ip = m.get('StandbyExternalIp')
        if m.get('StandbyStatus') is not None:
            self.standby_status = m.get('StandbyStatus')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeForwardTableEntriesResponseBody(TeaModel):
    def __init__(
        self,
        forward_table_entries: List[DescribeForwardTableEntriesResponseBodyForwardTableEntries] = None,
        page_number: str = None,
        page_size: str = None,
        request_id: str = None,
        total_count: str = None,
    ):
        # Details of DNAT entries.
        self.forward_table_entries = forward_table_entries
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.forward_table_entries:
            for k in self.forward_table_entries:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ForwardTableEntries'] = []
        if self.forward_table_entries is not None:
            for k in self.forward_table_entries:
                result['ForwardTableEntries'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.forward_table_entries = []
        if m.get('ForwardTableEntries') is not None:
            for k in m.get('ForwardTableEntries'):
                temp_model = DescribeForwardTableEntriesResponseBodyForwardTableEntries()
                self.forward_table_entries.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeForwardTableEntriesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeForwardTableEntriesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeForwardTableEntriesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeHaVipsRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        ens_region_ids: List[str] = None,
        ha_vip_address: str = None,
        ha_vip_id: str = None,
        name: str = None,
        network_id: str = None,
        page_number: str = None,
        page_size: str = None,
        status: str = None,
        v_switch_id: str = None,
    ):
        # The ID of the region.
        self.ens_region_id = ens_region_id
        # The IDs of edge nodes. You can specify 1 to 100 IDs.
        self.ens_region_ids = ens_region_ids
        # The IP address of the HAVIP.
        self.ha_vip_address = ha_vip_address
        # The ID of the HAVIP.
        self.ha_vip_id = ha_vip_id
        # The name of the HAVIP.
        self.name = name
        # The ID of the network.
        self.network_id = network_id
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The status of the HAVIP. Valid values:
        # 
        # *   Creating
        # *   Available
        # *   InUse
        # *   Deleting
        self.status = status
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.ens_region_ids is not None:
            result['EnsRegionIds'] = self.ens_region_ids
        if self.ha_vip_address is not None:
            result['HaVipAddress'] = self.ha_vip_address
        if self.ha_vip_id is not None:
            result['HaVipId'] = self.ha_vip_id
        if self.name is not None:
            result['Name'] = self.name
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.status is not None:
            result['Status'] = self.status
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('EnsRegionIds') is not None:
            self.ens_region_ids = m.get('EnsRegionIds')
        if m.get('HaVipAddress') is not None:
            self.ha_vip_address = m.get('HaVipAddress')
        if m.get('HaVipId') is not None:
            self.ha_vip_id = m.get('HaVipId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeHaVipsResponseBodyHaVipsAssociatedEipAddresses(TeaModel):
    def __init__(
        self,
        eip: str = None,
        eip_id: str = None,
    ):
        # The EIP.
        self.eip = eip
        # The ID of the EIP.
        self.eip_id = eip_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.eip is not None:
            result['Eip'] = self.eip
        if self.eip_id is not None:
            result['EipId'] = self.eip_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Eip') is not None:
            self.eip = m.get('Eip')
        if m.get('EipId') is not None:
            self.eip_id = m.get('EipId')
        return self


class DescribeHaVipsResponseBodyHaVipsAssociatedInstances(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        instance_id: str = None,
        instance_type: str = None,
        ip_address: str = None,
        status: str = None,
    ):
        # The time when the instance was created.
        self.creation_time = creation_time
        # The ID of the instance.
        self.instance_id = instance_id
        # The type of the instance that is associated with the HAVIP. Valid values:
        # 
        # *   EnsInstance: ENS instance
        # *   NetworkInterface: elastic network interface (ENI)
        self.instance_type = instance_type
        # The private IP address of the instance that is associated with the HAVIP. Valid values:
        self.ip_address = ip_address
        # The association status of the HAVIP. Valid values:
        # 
        # *   Associating
        # *   InUse
        # *   Unassociating
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeHaVipsResponseBodyHaVips(TeaModel):
    def __init__(
        self,
        associated_eip_addresses: List[DescribeHaVipsResponseBodyHaVipsAssociatedEipAddresses] = None,
        associated_instances: List[DescribeHaVipsResponseBodyHaVipsAssociatedInstances] = None,
        creation_time: str = None,
        description: str = None,
        ens_region_id: str = None,
        ha_vip_id: str = None,
        ip_address: str = None,
        name: str = None,
        network_id: str = None,
        status: str = None,
        v_switch_id: str = None,
    ):
        # The elastic IP addresses (EIPs) that are associated with the HAVIP.
        self.associated_eip_addresses = associated_eip_addresses
        # The information about instances that are associated with the HAVIP.
        self.associated_instances = associated_instances
        # The time when the HAVIP was created.
        self.creation_time = creation_time
        # The description of the HAVIP.
        self.description = description
        # The ID of the region.
        self.ens_region_id = ens_region_id
        # The ID of the HAVIP.
        self.ha_vip_id = ha_vip_id
        # The IP address of the HAVIP.
        self.ip_address = ip_address
        # The name of the HAVIP.
        self.name = name
        # The ID of the network.
        self.network_id = network_id
        # The status of the HAVIP. Valid values:
        # 
        # *   Creating
        # *   Available
        # *   InUse
        # *   Deleting
        self.status = status
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id

    def validate(self):
        if self.associated_eip_addresses:
            for k in self.associated_eip_addresses:
                if k:
                    k.validate()
        if self.associated_instances:
            for k in self.associated_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AssociatedEipAddresses'] = []
        if self.associated_eip_addresses is not None:
            for k in self.associated_eip_addresses:
                result['AssociatedEipAddresses'].append(k.to_map() if k else None)
        result['AssociatedInstances'] = []
        if self.associated_instances is not None:
            for k in self.associated_instances:
                result['AssociatedInstances'].append(k.to_map() if k else None)
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.ha_vip_id is not None:
            result['HaVipId'] = self.ha_vip_id
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        if self.name is not None:
            result['Name'] = self.name
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.status is not None:
            result['Status'] = self.status
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.associated_eip_addresses = []
        if m.get('AssociatedEipAddresses') is not None:
            for k in m.get('AssociatedEipAddresses'):
                temp_model = DescribeHaVipsResponseBodyHaVipsAssociatedEipAddresses()
                self.associated_eip_addresses.append(temp_model.from_map(k))
        self.associated_instances = []
        if m.get('AssociatedInstances') is not None:
            for k in m.get('AssociatedInstances'):
                temp_model = DescribeHaVipsResponseBodyHaVipsAssociatedInstances()
                self.associated_instances.append(temp_model.from_map(k))
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('HaVipId') is not None:
            self.ha_vip_id = m.get('HaVipId')
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeHaVipsResponseBody(TeaModel):
    def __init__(
        self,
        ha_vips: List[DescribeHaVipsResponseBodyHaVips] = None,
        page_number: str = None,
        page_size: str = None,
        request_id: str = None,
        total_count: str = None,
    ):
        # Details of the HAVIPs.
        self.ha_vips = ha_vips
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.ha_vips:
            for k in self.ha_vips:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['HaVips'] = []
        if self.ha_vips is not None:
            for k in self.ha_vips:
                result['HaVips'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ha_vips = []
        if m.get('HaVips') is not None:
            for k in m.get('HaVips'):
                temp_model = DescribeHaVipsResponseBodyHaVips()
                self.ha_vips.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeHaVipsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeHaVipsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeHaVipsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageInfosRequest(TeaModel):
    def __init__(
        self,
        os_type: str = None,
    ):
        # The operating system (OS). You can specify only one OS in a request. If you do not specify a value for this parameter, images for all supported OSs are queried. Valid values:
        # 
        # *   linux
        # *   windows
        self.os_type = os_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.os_type is not None:
            result['OsType'] = self.os_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OsType') is not None:
            self.os_type = m.get('OsType')
        return self


class DescribeImageInfosResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping(TeaModel):
    def __init__(
        self,
        format: str = None,
        size: str = None,
        type: str = None,
        image_id: str = None,
    ):
        # The format of the image.
        self.format = format
        # The size of the image. Unit: GB.
        self.size = size
        # The type of the disk. Valid values: System and Data.
        self.type = type
        # The ID of the image.
        self.image_id = image_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        if self.size is not None:
            result['Size'] = self.size
        if self.type is not None:
            result['Type'] = self.type
        if self.image_id is not None:
            result['imageId'] = self.image_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('imageId') is not None:
            self.image_id = m.get('imageId')
        return self


class DescribeImageInfosResponseBodyImagesImageDiskDeviceMappings(TeaModel):
    def __init__(
        self,
        disk_device_mapping: List[DescribeImageInfosResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping] = None,
    ):
        self.disk_device_mapping = disk_device_mapping

    def validate(self):
        if self.disk_device_mapping:
            for k in self.disk_device_mapping:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DiskDeviceMapping'] = []
        if self.disk_device_mapping is not None:
            for k in self.disk_device_mapping:
                result['DiskDeviceMapping'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.disk_device_mapping = []
        if m.get('DiskDeviceMapping') is not None:
            for k in m.get('DiskDeviceMapping'):
                temp_model = DescribeImageInfosResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping()
                self.disk_device_mapping.append(temp_model.from_map(k))
        return self


class DescribeImageInfosResponseBodyImagesImage(TeaModel):
    def __init__(
        self,
        compute_type: str = None,
        description: str = None,
        disk_device_mappings: DescribeImageInfosResponseBodyImagesImageDiskDeviceMappings = None,
        image_id: str = None,
        image_size: str = None,
        image_version: str = None,
        osname: str = None,
        ostype: str = None,
        region_id: str = None,
    ):
        # The computing type of the image. Valid values:
        # 
        # *   ens_vm: x86 computing.
        # *   arm_vm: ARM computing.
        # *   bare_metal: x86 bare machine.
        # *   pcfarm: heterogeneous computing.
        self.compute_type = compute_type
        # The description of the image.
        self.description = description
        # The mappings between disks and snapshots in the image.
        self.disk_device_mappings = disk_device_mappings
        # The ID of the image.
        self.image_id = image_id
        # The size of the image. Unit: GiB.
        self.image_size = image_size
        # The version of the image.
        self.image_version = image_version
        # The type of the image. Valid values: **centos**, **debian**, **ubuntu**, and **windows**.
        self.osname = osname
        # The type of the operating system.
        self.ostype = ostype
        # The ID of the region.
        self.region_id = region_id

    def validate(self):
        if self.disk_device_mappings:
            self.disk_device_mappings.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.compute_type is not None:
            result['ComputeType'] = self.compute_type
        if self.description is not None:
            result['Description'] = self.description
        if self.disk_device_mappings is not None:
            result['DiskDeviceMappings'] = self.disk_device_mappings.to_map()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_size is not None:
            result['ImageSize'] = self.image_size
        if self.image_version is not None:
            result['ImageVersion'] = self.image_version
        if self.osname is not None:
            result['OSName'] = self.osname
        if self.ostype is not None:
            result['OSType'] = self.ostype
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComputeType') is not None:
            self.compute_type = m.get('ComputeType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DiskDeviceMappings') is not None:
            temp_model = DescribeImageInfosResponseBodyImagesImageDiskDeviceMappings()
            self.disk_device_mappings = temp_model.from_map(m['DiskDeviceMappings'])
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageSize') is not None:
            self.image_size = m.get('ImageSize')
        if m.get('ImageVersion') is not None:
            self.image_version = m.get('ImageVersion')
        if m.get('OSName') is not None:
            self.osname = m.get('OSName')
        if m.get('OSType') is not None:
            self.ostype = m.get('OSType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeImageInfosResponseBodyImages(TeaModel):
    def __init__(
        self,
        image: List[DescribeImageInfosResponseBodyImagesImage] = None,
    ):
        self.image = image

    def validate(self):
        if self.image:
            for k in self.image:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Image'] = []
        if self.image is not None:
            for k in self.image:
                result['Image'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.image = []
        if m.get('Image') is not None:
            for k in m.get('Image'):
                temp_model = DescribeImageInfosResponseBodyImagesImage()
                self.image.append(temp_model.from_map(k))
        return self


class DescribeImageInfosResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        images: DescribeImageInfosResponseBodyImages = None,
        request_id: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The information about images.
        self.images = images
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.images:
            self.images.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.images is not None:
            result['Images'] = self.images.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Images') is not None:
            temp_model = DescribeImageInfosResponseBodyImages()
            self.images = temp_model.from_map(m['Images'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageInfosResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageInfosResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageInfosResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageSharePermissionRequest(TeaModel):
    def __init__(
        self,
        aliyun_id: int = None,
        image_id: str = None,
        page_number: str = None,
        page_size: str = None,
    ):
        # The ID of the Alibaba Cloud account.
        self.aliyun_id = aliyun_id
        # The ID of the image.
        # 
        # This parameter is required.
        self.image_id = image_id
        # The page number. Pages start from page **1**.
        # 
        # Default value: **1**.
        self.page_number = page_number
        # The number of entries to return on each page. Maximum value: **100**.
        # 
        # Default value: **10**.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_id is not None:
            result['AliyunId'] = self.aliyun_id
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunId') is not None:
            self.aliyun_id = m.get('AliyunId')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeImageSharePermissionResponseBodyAccountsAccount(TeaModel):
    def __init__(
        self,
        aliyun_uid: str = None,
    ):
        # The Alibaba Cloud account with which you share the image.
        self.aliyun_uid = aliyun_uid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_uid is not None:
            result['AliyunUid'] = self.aliyun_uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunUid') is not None:
            self.aliyun_uid = m.get('AliyunUid')
        return self


class DescribeImageSharePermissionResponseBodyAccounts(TeaModel):
    def __init__(
        self,
        account: List[DescribeImageSharePermissionResponseBodyAccountsAccount] = None,
    ):
        self.account = account

    def validate(self):
        if self.account:
            for k in self.account:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Account'] = []
        if self.account is not None:
            for k in self.account:
                result['Account'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.account = []
        if m.get('Account') is not None:
            for k in m.get('Account'):
                temp_model = DescribeImageSharePermissionResponseBodyAccountsAccount()
                self.account.append(temp_model.from_map(k))
        return self


class DescribeImageSharePermissionResponseBody(TeaModel):
    def __init__(
        self,
        accounts: DescribeImageSharePermissionResponseBodyAccounts = None,
        image_id: str = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The account information.
        self.accounts = accounts
        # The ID of the image.
        self.image_id = image_id
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of Alibaba Cloud accounts with which you share the image.
        self.total_count = total_count

    def validate(self):
        if self.accounts:
            self.accounts.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accounts is not None:
            result['Accounts'] = self.accounts.to_map()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Accounts') is not None:
            temp_model = DescribeImageSharePermissionResponseBodyAccounts()
            self.accounts = temp_model.from_map(m['Accounts'])
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageSharePermissionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImageSharePermissionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageSharePermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImagesRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        image_id: str = None,
        image_name: str = None,
        page_number: str = None,
        page_size: str = None,
        snapshot_id: str = None,
        status: str = None,
    ):
        # The ID of the Edge Node Service (ENS) node.
        self.ens_region_id = ens_region_id
        # The ID of the image. You can specify only one image ID.
        # 
        # Custom images and public images are supported.
        self.image_id = image_id
        # The name of the custom image. The name must be 2 to 128 characters in length The name must start with a letter and cannot start with `acs:` or `aliyun`. The name cannot contain `http://` or `https://`. The name can contain letters, digits, periods (.), colons (:), underscores (_), and hyphens (-).
        # 
        # By default, this parameter is left empty, which indicates that the original name is retained.
        self.image_name = image_name
        # The page number. Pages start from page **1**.
        # 
        # Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Maximum value: **50**.
        # 
        # Default value: **10**.
        self.page_size = page_size
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id
        # This parameter is unavailable.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping(TeaModel):
    def __init__(
        self,
        format: str = None,
        size: str = None,
        type: str = None,
        image_id: str = None,
    ):
        # The format of the image.
        self.format = format
        # The size of the disk. Unit: GiB.
        self.size = size
        # The type of the disk. Valid values:
        # 
        # *   system: system disk.
        # *   data: data disk.
        self.type = type
        # The ID of image.
        self.image_id = image_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        if self.size is not None:
            result['Size'] = self.size
        if self.type is not None:
            result['Type'] = self.type
        if self.image_id is not None:
            result['imageId'] = self.image_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('imageId') is not None:
            self.image_id = m.get('imageId')
        return self


class DescribeImagesResponseBodyImagesImageDiskDeviceMappings(TeaModel):
    def __init__(
        self,
        disk_device_mapping: List[DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping] = None,
    ):
        self.disk_device_mapping = disk_device_mapping

    def validate(self):
        if self.disk_device_mapping:
            for k in self.disk_device_mapping:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DiskDeviceMapping'] = []
        if self.disk_device_mapping is not None:
            for k in self.disk_device_mapping:
                result['DiskDeviceMapping'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.disk_device_mapping = []
        if m.get('DiskDeviceMapping') is not None:
            for k in m.get('DiskDeviceMapping'):
                temp_model = DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping()
                self.disk_device_mapping.append(temp_model.from_map(k))
        return self


class DescribeImagesResponseBodyImagesImage(TeaModel):
    def __init__(
        self,
        architecture: str = None,
        creation_time: str = None,
        disk_device_mappings: DescribeImagesResponseBodyImagesImageDiskDeviceMappings = None,
        image_id: str = None,
        image_name: str = None,
        image_owner_alias: str = None,
        image_size: str = None,
        platform: str = None,
        region_id: str = None,
        snapshot_id: str = None,
    ):
        # The architecture of the image. Example: **x86_64**.
        self.architecture = architecture
        # The time when the image was created. The time follows the ISO 8601 standard.
        self.creation_time = creation_time
        # The mappings between the disk and the snapshot in the image.
        self.disk_device_mappings = disk_device_mappings
        # The ID of the image.
        self.image_id = image_id
        # The name of the image.
        self.image_name = image_name
        # The source of the image. Valid values:
        # 
        # *   system: Alibaba Cloud public images
        # *   self: your custom images
        # *   others: shared images from other Alibaba Cloud accounts, or community images published by other Alibaba Cloud accounts
        self.image_owner_alias = image_owner_alias
        # The size of the image. Unit: GiB.
        self.image_size = image_size
        # The operating system type of the image. Valid values:
        # 
        # *   Linux
        # *   Windows
        self.platform = platform
        # The region ID.
        self.region_id = region_id
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id

    def validate(self):
        if self.disk_device_mappings:
            self.disk_device_mappings.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.architecture is not None:
            result['Architecture'] = self.architecture
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.disk_device_mappings is not None:
            result['DiskDeviceMappings'] = self.disk_device_mappings.to_map()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.image_owner_alias is not None:
            result['ImageOwnerAlias'] = self.image_owner_alias
        if self.image_size is not None:
            result['ImageSize'] = self.image_size
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Architecture') is not None:
            self.architecture = m.get('Architecture')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DiskDeviceMappings') is not None:
            temp_model = DescribeImagesResponseBodyImagesImageDiskDeviceMappings()
            self.disk_device_mappings = temp_model.from_map(m['DiskDeviceMappings'])
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('ImageOwnerAlias') is not None:
            self.image_owner_alias = m.get('ImageOwnerAlias')
        if m.get('ImageSize') is not None:
            self.image_size = m.get('ImageSize')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        return self


class DescribeImagesResponseBodyImages(TeaModel):
    def __init__(
        self,
        image: List[DescribeImagesResponseBodyImagesImage] = None,
    ):
        self.image = image

    def validate(self):
        if self.image:
            for k in self.image:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Image'] = []
        if self.image is not None:
            for k in self.image:
                result['Image'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.image = []
        if m.get('Image') is not None:
            for k in m.get('Image'):
                temp_model = DescribeImagesResponseBodyImagesImage()
                self.image.append(temp_model.from_map(k))
        return self


class DescribeImagesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        images: DescribeImagesResponseBodyImages = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The returned service code. 0 indicates that the request was successful.
        self.code = code
        # The information about the images.
        self.images = images
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of images.
        self.total_count = total_count

    def validate(self):
        if self.images:
            self.images.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.images is not None:
            result['Images'] = self.images.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Images') is not None:
            temp_model = DescribeImagesResponseBodyImages()
            self.images = temp_model.from_map(m['Images'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImagesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeImagesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImagesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceAutoRenewAttributeRequest(TeaModel):
    def __init__(
        self,
        instance_ids: str = None,
        owner_id: int = None,
    ):
        # The ID of an instance. Separate multiple IDs with semicolons (;).
        # 
        # This parameter is required.
        self.instance_ids = instance_ids
        self.owner_id = owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        return self


class DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute(TeaModel):
    def __init__(
        self,
        auto_renewal: bool = None,
        duration: str = None,
        instance_id: str = None,
    ):
        # The renewal type of the instance.
        # 
        # *   **true**: enables auto-renewal.
        # *   **false**: disables auto-renewal.
        self.auto_renewal = auto_renewal
        # The unit of the auto-renewal period.
        self.duration = duration
        # The ID of the instance.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_renewal is not None:
            result['AutoRenewal'] = self.auto_renewal
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRenewal') is not None:
            self.auto_renewal = m.get('AutoRenewal')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes(TeaModel):
    def __init__(
        self,
        instance_renew_attribute: List[DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute] = None,
    ):
        self.instance_renew_attribute = instance_renew_attribute

    def validate(self):
        if self.instance_renew_attribute:
            for k in self.instance_renew_attribute:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceRenewAttribute'] = []
        if self.instance_renew_attribute is not None:
            for k in self.instance_renew_attribute:
                result['InstanceRenewAttribute'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_renew_attribute = []
        if m.get('InstanceRenewAttribute') is not None:
            for k in m.get('InstanceRenewAttribute'):
                temp_model = DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute()
                self.instance_renew_attribute.append(temp_model.from_map(k))
        return self


class DescribeInstanceAutoRenewAttributeResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        instance_renew_attributes: DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes = None,
        request_id: str = None,
    ):
        # The returned service code. A value of 0 indicates that the operation was successful.
        self.code = code
        # The renewal status of the instance.
        self.instance_renew_attributes = instance_renew_attributes
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.instance_renew_attributes:
            self.instance_renew_attributes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.instance_renew_attributes is not None:
            result['InstanceRenewAttributes'] = self.instance_renew_attributes.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('InstanceRenewAttributes') is not None:
            temp_model = DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes()
            self.instance_renew_attributes = temp_model.from_map(m['InstanceRenewAttributes'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstanceAutoRenewAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInstanceAutoRenewAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceAutoRenewAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceBandwidthDetailRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        ens_region_id: str = None,
        instance_id: str = None,
        instance_type: str = None,
        page_number: int = None,
        page_size: int = None,
        service_type: str = None,
        start_time: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        self.ens_region_id = ens_region_id
        self.instance_id = instance_id
        self.instance_type = instance_type
        # The page number. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 200.
        self.page_size = page_size
        self.service_type = service_type
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.service_type is not None:
            result['ServiceType'] = self.service_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ServiceType') is not None:
            self.service_type = m.get('ServiceType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeInstanceBandwidthDetailResponseBodyBandwidths(TeaModel):
    def __init__(
        self,
        ali_uid: int = None,
        biz_time: str = None,
        ens_region_id: str = None,
        flow_type: int = None,
        instance_id: str = None,
        instance_type: str = None,
        ip: str = None,
        isp: str = None,
        rx_bw: int = None,
        service_type: str = None,
        tx_bw: int = None,
    ):
        self.ali_uid = ali_uid
        self.biz_time = biz_time
        self.ens_region_id = ens_region_id
        self.flow_type = flow_type
        self.instance_id = instance_id
        self.instance_type = instance_type
        self.ip = ip
        self.isp = isp
        self.rx_bw = rx_bw
        self.service_type = service_type
        self.tx_bw = tx_bw

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uid is not None:
            result['AliUid'] = self.ali_uid
        if self.biz_time is not None:
            result['BizTime'] = self.biz_time
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.flow_type is not None:
            result['FlowType'] = self.flow_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.rx_bw is not None:
            result['RxBw'] = self.rx_bw
        if self.service_type is not None:
            result['ServiceType'] = self.service_type
        if self.tx_bw is not None:
            result['TxBw'] = self.tx_bw
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliUid') is not None:
            self.ali_uid = m.get('AliUid')
        if m.get('BizTime') is not None:
            self.biz_time = m.get('BizTime')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('FlowType') is not None:
            self.flow_type = m.get('FlowType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('RxBw') is not None:
            self.rx_bw = m.get('RxBw')
        if m.get('ServiceType') is not None:
            self.service_type = m.get('ServiceType')
        if m.get('TxBw') is not None:
            self.tx_bw = m.get('TxBw')
        return self


class DescribeInstanceBandwidthDetailResponseBody(TeaModel):
    def __init__(
        self,
        bandwidths: List[DescribeInstanceBandwidthDetailResponseBodyBandwidths] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.bandwidths = bandwidths
        self.page_number = page_number
        self.page_size = page_size
        # Id of the request
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.bandwidths:
            for k in self.bandwidths:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Bandwidths'] = []
        if self.bandwidths is not None:
            for k in self.bandwidths:
                result['Bandwidths'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.bandwidths = []
        if m.get('Bandwidths') is not None:
            for k in m.get('Bandwidths'):
                temp_model = DescribeInstanceBandwidthDetailResponseBodyBandwidths()
                self.bandwidths.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeInstanceBandwidthDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInstanceBandwidthDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceBandwidthDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceBootConfigurationRequest(TeaModel):
    def __init__(
        self,
        boot_set: str = None,
        boot_type: str = None,
        disk_set: str = None,
        instance_id: str = None,
    ):
        # The startup method.
        self.boot_set = boot_set
        # The startup type.
        self.boot_type = boot_type
        # Specifies whether the startup depends on the disk.
        self.disk_set = disk_set
        # The ID of the instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.boot_set is not None:
            result['BootSet'] = self.boot_set
        if self.boot_type is not None:
            result['BootType'] = self.boot_type
        if self.disk_set is not None:
            result['DiskSet'] = self.disk_set
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BootSet') is not None:
            self.boot_set = m.get('BootSet')
        if m.get('BootType') is not None:
            self.boot_type = m.get('BootType')
        if m.get('DiskSet') is not None:
            self.disk_set = m.get('DiskSet')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeInstanceBootConfigurationResponseBodyInstances(TeaModel):
    def __init__(
        self,
        boot_set: str = None,
        boot_type: str = None,
        disk_set: str = None,
        instance_id: str = None,
    ):
        # The startup method.
        self.boot_set = boot_set
        # The startup type.
        self.boot_type = boot_type
        # Specifies whether the startup depends on the disk.
        self.disk_set = disk_set
        # The ID of the instance.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.boot_set is not None:
            result['BootSet'] = self.boot_set
        if self.boot_type is not None:
            result['BootType'] = self.boot_type
        if self.disk_set is not None:
            result['DiskSet'] = self.disk_set
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BootSet') is not None:
            self.boot_set = m.get('BootSet')
        if m.get('BootType') is not None:
            self.boot_type = m.get('BootType')
        if m.get('DiskSet') is not None:
            self.disk_set = m.get('DiskSet')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeInstanceBootConfigurationResponseBody(TeaModel):
    def __init__(
        self,
        instances: DescribeInstanceBootConfigurationResponseBodyInstances = None,
        request_id: str = None,
    ):
        # Schema of Response
        self.instances = instances
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.instances:
            self.instances.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instances is not None:
            result['Instances'] = self.instances.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Instances') is not None:
            temp_model = DescribeInstanceBootConfigurationResponseBodyInstances()
            self.instances = temp_model.from_map(m['Instances'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstanceBootConfigurationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInstanceBootConfigurationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceBootConfigurationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceMonitorDataRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        instance_id: str = None,
        period: str = None,
        start_time: str = None,
    ):
        # The end of the time range to query.
        # 
        # Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. If the value of the seconds place is not 00, the start time is automatically set to the next minute.
        self.end_time = end_time
        # The ID of the instance. You can specify only one instance ID.
        self.instance_id = instance_id
        # The precision of the monitoring data that you want to obtain. Valid values: 60, 300, 1200, 3600, and 14400. Default value: 60. Unit: seconds.
        self.period = period
        # The beginning of the time range to query.
        # 
        # Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. If the value of the seconds place is not 00, the start time is automatically set to the next minute.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.period is not None:
            result['Period'] = self.period
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData(TeaModel):
    def __init__(
        self,
        cpu: str = None,
        instance_id: str = None,
        memory: str = None,
    ):
        # The vCPU usage of the instance, which is raw data. For example, a value of 0.02 indicates that the usage is 2%.
        self.cpu = cpu
        # The ID of the instance.
        self.instance_id = instance_id
        # This parameter is not yet supported.
        self.memory = memory

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu is not None:
            result['CPU'] = self.cpu
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.memory is not None:
            result['Memory'] = self.memory
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CPU') is not None:
            self.cpu = m.get('CPU')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        return self


class DescribeInstanceMonitorDataResponseBodyMonitorData(TeaModel):
    def __init__(
        self,
        instance_monitor_data: List[DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData] = None,
    ):
        self.instance_monitor_data = instance_monitor_data

    def validate(self):
        if self.instance_monitor_data:
            for k in self.instance_monitor_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceMonitorData'] = []
        if self.instance_monitor_data is not None:
            for k in self.instance_monitor_data:
                result['InstanceMonitorData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_monitor_data = []
        if m.get('InstanceMonitorData') is not None:
            for k in m.get('InstanceMonitorData'):
                temp_model = DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData()
                self.instance_monitor_data.append(temp_model.from_map(k))
        return self


class DescribeInstanceMonitorDataResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        monitor_data: DescribeInstanceMonitorDataResponseBodyMonitorData = None,
        request_id: str = None,
    ):
        # The returned service code. A value of 0 indicates that the operation was successful.
        self.code = code
        # The set of InstanceMonitorDataType data.
        self.monitor_data = monitor_data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.monitor_data:
            self.monitor_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.monitor_data is not None:
            result['MonitorData'] = self.monitor_data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('MonitorData') is not None:
            temp_model = DescribeInstanceMonitorDataResponseBodyMonitorData()
            self.monitor_data = temp_model.from_map(m['MonitorData'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstanceMonitorDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInstanceMonitorDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceMonitorDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceSDGStatusRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        sdgids: List[str] = None,
        status: str = None,
    ):
        # The ID of the AIC instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The number of the page to return. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries returned on each page.
        self.page_size = page_size
        # The IDs of SDGs that you want to query. By default, all SDGs are queried.
        self.sdgids = sdgids
        # The deployment status of the SDG.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sdgids is not None:
            result['SDGIds'] = self.sdgids
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SDGIds') is not None:
            self.sdgids = m.get('SDGIds')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeInstanceSDGStatusShrinkRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        sdgids_shrink: str = None,
        status: str = None,
    ):
        # The ID of the AIC instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The number of the page to return. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries returned on each page.
        self.page_size = page_size
        # The IDs of SDGs that you want to query. By default, all SDGs are queried.
        self.sdgids_shrink = sdgids_shrink
        # The deployment status of the SDG.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sdgids_shrink is not None:
            result['SDGIds'] = self.sdgids_shrink
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SDGIds') is not None:
            self.sdgids_shrink = m.get('SDGIds')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeInstanceSDGStatusResponseBodyDeploymentStatus(TeaModel):
    def __init__(
        self,
        block_rw_split_size: int = None,
        cache_size: int = None,
        disk_access_protocol: str = None,
        disk_type: str = None,
        ens_region_id: str = None,
        instance_id: str = None,
        mount_type: str = None,
        phase: str = None,
        sdgid: str = None,
        status: str = None,
        update_time: str = None,
    ):
        self.block_rw_split_size = block_rw_split_size
        self.cache_size = cache_size
        self.disk_access_protocol = disk_access_protocol
        self.disk_type = disk_type
        # The ID of the edge node.
        self.ens_region_id = ens_region_id
        # The ID of the AIC instance.
        self.instance_id = instance_id
        # The deployment type of the SDG.
        self.mount_type = mount_type
        # Deployment Phase
        self.phase = phase
        # The ID of the SDG.
        self.sdgid = sdgid
        # The deployment status of the SDG.
        self.status = status
        # The time when the status was last updated.
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_rw_split_size is not None:
            result['BlockRwSplitSize'] = self.block_rw_split_size
        if self.cache_size is not None:
            result['CacheSize'] = self.cache_size
        if self.disk_access_protocol is not None:
            result['DiskAccessProtocol'] = self.disk_access_protocol
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.mount_type is not None:
            result['MountType'] = self.mount_type
        if self.phase is not None:
            result['Phase'] = self.phase
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        if self.status is not None:
            result['Status'] = self.status
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BlockRwSplitSize') is not None:
            self.block_rw_split_size = m.get('BlockRwSplitSize')
        if m.get('CacheSize') is not None:
            self.cache_size = m.get('CacheSize')
        if m.get('DiskAccessProtocol') is not None:
            self.disk_access_protocol = m.get('DiskAccessProtocol')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MountType') is not None:
            self.mount_type = m.get('MountType')
        if m.get('Phase') is not None:
            self.phase = m.get('Phase')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeInstanceSDGStatusResponseBody(TeaModel):
    def __init__(
        self,
        deployment_status: List[DescribeInstanceSDGStatusResponseBodyDeploymentStatus] = None,
        page_number: int = None,
        page_size: str = None,
        request_id: str = None,
        total_count: str = None,
    ):
        # The deployment information of the SDGs.
        self.deployment_status = deployment_status
        # The number of the page to return. Pages start from page 1. Default value: 1
        self.page_number = page_number
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of queried deployment records.
        self.total_count = total_count

    def validate(self):
        if self.deployment_status:
            for k in self.deployment_status:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeploymentStatus'] = []
        if self.deployment_status is not None:
            for k in self.deployment_status:
                result['DeploymentStatus'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.deployment_status = []
        if m.get('DeploymentStatus') is not None:
            for k in m.get('DeploymentStatus'):
                temp_model = DescribeInstanceSDGStatusResponseBodyDeploymentStatus()
                self.deployment_status.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeInstanceSDGStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInstanceSDGStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceSDGStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceSpecResponseBodyInstanceSpecsInstanceSpec(TeaModel):
    def __init__(
        self,
        core: str = None,
        display_name: str = None,
        instance_type: str = None,
        memory: str = None,
    ):
        # The number of CPU cores.
        self.core = core
        # The display name of the instance type.
        self.display_name = display_name
        # The type of the instance.
        self.instance_type = instance_type
        # The memory size. Unit: MB.
        self.memory = memory

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.core is not None:
            result['Core'] = self.core
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.memory is not None:
            result['Memory'] = self.memory
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Core') is not None:
            self.core = m.get('Core')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        return self


class DescribeInstanceSpecResponseBodyInstanceSpecs(TeaModel):
    def __init__(
        self,
        instance_spec: List[DescribeInstanceSpecResponseBodyInstanceSpecsInstanceSpec] = None,
    ):
        self.instance_spec = instance_spec

    def validate(self):
        if self.instance_spec:
            for k in self.instance_spec:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceSpec'] = []
        if self.instance_spec is not None:
            for k in self.instance_spec:
                result['InstanceSpec'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_spec = []
        if m.get('InstanceSpec') is not None:
            for k in m.get('InstanceSpec'):
                temp_model = DescribeInstanceSpecResponseBodyInstanceSpecsInstanceSpec()
                self.instance_spec.append(temp_model.from_map(k))
        return self


class DescribeInstanceSpecResponseBody(TeaModel):
    def __init__(
        self,
        bandwidth_limit: int = None,
        code: int = None,
        data_disk_max_size: int = None,
        data_disk_min_size: int = None,
        instance_specs: DescribeInstanceSpecResponseBodyInstanceSpecs = None,
        request_id: str = None,
        system_disk_max_size: int = None,
    ):
        # The bandwidth limit for a single instance. Unit: Mbit/s.
        self.bandwidth_limit = bandwidth_limit
        # The returned service code. A value of 0 indicates that the operation was successful.
        self.code = code
        # The maximum capacity of a data disk. Unit: GB.
        self.data_disk_max_size = data_disk_max_size
        # The minimum capacity of a data disk. Unit: GB.
        self.data_disk_min_size = data_disk_min_size
        # The information about instance specifications.
        self.instance_specs = instance_specs
        # The request ID.
        self.request_id = request_id
        # The maximum capacity of the system disk. Unit: GiB.
        self.system_disk_max_size = system_disk_max_size

    def validate(self):
        if self.instance_specs:
            self.instance_specs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidth_limit is not None:
            result['BandwidthLimit'] = self.bandwidth_limit
        if self.code is not None:
            result['Code'] = self.code
        if self.data_disk_max_size is not None:
            result['DataDiskMaxSize'] = self.data_disk_max_size
        if self.data_disk_min_size is not None:
            result['DataDiskMinSize'] = self.data_disk_min_size
        if self.instance_specs is not None:
            result['InstanceSpecs'] = self.instance_specs.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.system_disk_max_size is not None:
            result['SystemDiskMaxSize'] = self.system_disk_max_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BandwidthLimit') is not None:
            self.bandwidth_limit = m.get('BandwidthLimit')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DataDiskMaxSize') is not None:
            self.data_disk_max_size = m.get('DataDiskMaxSize')
        if m.get('DataDiskMinSize') is not None:
            self.data_disk_min_size = m.get('DataDiskMinSize')
        if m.get('InstanceSpecs') is not None:
            temp_model = DescribeInstanceSpecResponseBodyInstanceSpecs()
            self.instance_specs = temp_model.from_map(m['InstanceSpecs'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SystemDiskMaxSize') is not None:
            self.system_disk_max_size = m.get('SystemDiskMaxSize')
        return self


class DescribeInstanceSpecResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInstanceSpecResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceSpecResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceTypesResponseBodyInstanceTypesInstanceType(TeaModel):
    def __init__(
        self,
        cpu_core_count: int = None,
        instance_type_id: str = None,
        instance_type_name: str = None,
        memory_size: int = None,
    ):
        # The number of vCPUs.
        self.cpu_core_count = cpu_core_count
        # This parameter is unavailable.
        self.instance_type_id = instance_type_id
        # The name of the instance type.
        self.instance_type_name = instance_type_name
        # The memory size. Unit: MB.
        self.memory_size = memory_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu_core_count is not None:
            result['CpuCoreCount'] = self.cpu_core_count
        if self.instance_type_id is not None:
            result['InstanceTypeId'] = self.instance_type_id
        if self.instance_type_name is not None:
            result['InstanceTypeName'] = self.instance_type_name
        if self.memory_size is not None:
            result['MemorySize'] = self.memory_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CpuCoreCount') is not None:
            self.cpu_core_count = m.get('CpuCoreCount')
        if m.get('InstanceTypeId') is not None:
            self.instance_type_id = m.get('InstanceTypeId')
        if m.get('InstanceTypeName') is not None:
            self.instance_type_name = m.get('InstanceTypeName')
        if m.get('MemorySize') is not None:
            self.memory_size = m.get('MemorySize')
        return self


class DescribeInstanceTypesResponseBodyInstanceTypes(TeaModel):
    def __init__(
        self,
        instance_type: List[DescribeInstanceTypesResponseBodyInstanceTypesInstanceType] = None,
    ):
        self.instance_type = instance_type

    def validate(self):
        if self.instance_type:
            for k in self.instance_type:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceType'] = []
        if self.instance_type is not None:
            for k in self.instance_type:
                result['InstanceType'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_type = []
        if m.get('InstanceType') is not None:
            for k in m.get('InstanceType'):
                temp_model = DescribeInstanceTypesResponseBodyInstanceTypesInstanceType()
                self.instance_type.append(temp_model.from_map(k))
        return self


class DescribeInstanceTypesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        instance_types: DescribeInstanceTypesResponseBodyInstanceTypes = None,
        request_id: str = None,
    ):
        # The status code. If the request is successful, 0 is returned. If the request fails, a non-zero error code is returned.
        self.code = code
        # Details about the instance types.
        self.instance_types = instance_types
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.instance_types:
            self.instance_types.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.instance_types is not None:
            result['InstanceTypes'] = self.instance_types.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('InstanceTypes') is not None:
            temp_model = DescribeInstanceTypesResponseBodyInstanceTypes()
            self.instance_types = temp_model.from_map(m['InstanceTypes'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstanceTypesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInstanceTypesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceTypesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceVncUrlRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # The ID of the instance
        # 
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeInstanceVncUrlResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vnc_url: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The URL of the VNC management terminal.
        self.vnc_url = vnc_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.vnc_url is not None:
            result['VncUrl'] = self.vnc_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VncUrl') is not None:
            self.vnc_url = m.get('VncUrl')
        return self


class DescribeInstanceVncUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInstanceVncUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceVncUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstancesRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag that are to add to the instance. Valid values: 1 to 20.
        self.key = key
        # The tag value of the instance. Valid values: 1 to 20.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeInstancesRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        ens_region_ids: str = None,
        ens_service_id: str = None,
        image_id: str = None,
        instance_id: str = None,
        instance_ids: str = None,
        instance_name: str = None,
        instance_resource_type: str = None,
        instance_type: str = None,
        intranet_ip: str = None,
        network_id: str = None,
        order_by_params: str = None,
        page_number: int = None,
        page_size: str = None,
        search_key: str = None,
        security_group_id: str = None,
        service_status: List[str] = None,
        status: str = None,
        tags: List[DescribeInstancesRequestTags] = None,
        v_switch_id: str = None,
    ):
        # The region ID.
        self.ens_region_id = ens_region_id
        # The IDs of the regions. The value is a JSON array that consists of up to 100 IDs. Separate multiple IDs with commas (,).
        self.ens_region_ids = ens_region_ids
        # The ID of the edge service. You can use the ID to query information about the instances that are created in the edge service.
        self.ens_service_id = ens_service_id
        # The ID of the image.
        self.image_id = image_id
        # The ID of the instance.
        self.instance_id = instance_id
        # The IDs of the instances. The value is a JSON array that consists of up to 100 IDs. Separate IDs with commas (,).
        self.instance_ids = instance_ids
        # The name of the instance.
        self.instance_name = instance_name
        # The condition that you want to use to filter instances by category. Valid values:
        # 
        # *   EnsInstance: ENS instances that you purchase.
        # *   EnsService: ENS instances that belong to edge services.
        # *   BuildMachine: ENS instances that are configured with image builders.
        # *   EnsPostPaidInstance: Pay-as-you-go ENS instances that you purchase.
        self.instance_resource_type = instance_resource_type
        # The instance type.
        self.instance_type = instance_type
        # The internal IP address of the instance.
        self.intranet_ip = intranet_ip
        # The ID of the network.
        self.network_id = network_id
        # The method that you want to use to sort instances. The value of this parameter is in the JSON format.
        # 
        # You can sort instances by name, expiration time, node ID, or creation time. You can specify one or more methods.
        self.order_by_params = order_by_params
        # The page number. Pages start from page **1**.
        # 
        # Default value: **1**.
        self.page_number = page_number
        # The number of entries to return on each page. The maximum value is **100**.
        # 
        # Default value: **10**.
        self.page_size = page_size
        # The keyword that you use to query the logs of the service. You can specify the values of parameters such as **ip**, **InstanceName**, and **InstanceId** as the keyword.
        self.search_key = search_key
        # The ID of the security group.
        self.security_group_id = security_group_id
        # The status of the service. Valid values.
        self.service_status = service_status
        # The status of the instance. Valid values:
        # 
        # *   Running
        # *   Stopped
        # *   Expired
        self.status = status
        # The tags that are added to the resource. This operation does not return tag information. You can call this operation in combination with the tag-related operations.
        self.tags = tags
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.ens_region_ids is not None:
            result['EnsRegionIds'] = self.ens_region_ids
        if self.ens_service_id is not None:
            result['EnsServiceId'] = self.ens_service_id
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_resource_type is not None:
            result['InstanceResourceType'] = self.instance_resource_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.order_by_params is not None:
            result['OrderByParams'] = self.order_by_params
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.service_status is not None:
            result['ServiceStatus'] = self.service_status
        if self.status is not None:
            result['Status'] = self.status
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('EnsRegionIds') is not None:
            self.ens_region_ids = m.get('EnsRegionIds')
        if m.get('EnsServiceId') is not None:
            self.ens_service_id = m.get('EnsServiceId')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceResourceType') is not None:
            self.instance_resource_type = m.get('InstanceResourceType')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('OrderByParams') is not None:
            self.order_by_params = m.get('OrderByParams')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('ServiceStatus') is not None:
            self.service_status = m.get('ServiceStatus')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = DescribeInstancesRequestTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        ens_region_ids: str = None,
        ens_service_id: str = None,
        image_id: str = None,
        instance_id: str = None,
        instance_ids: str = None,
        instance_name: str = None,
        instance_resource_type: str = None,
        instance_type: str = None,
        intranet_ip: str = None,
        network_id: str = None,
        order_by_params: str = None,
        page_number: int = None,
        page_size: str = None,
        search_key: str = None,
        security_group_id: str = None,
        service_status_shrink: str = None,
        status: str = None,
        tags_shrink: str = None,
        v_switch_id: str = None,
    ):
        # The region ID.
        self.ens_region_id = ens_region_id
        # The IDs of the regions. The value is a JSON array that consists of up to 100 IDs. Separate multiple IDs with commas (,).
        self.ens_region_ids = ens_region_ids
        # The ID of the edge service. You can use the ID to query information about the instances that are created in the edge service.
        self.ens_service_id = ens_service_id
        # The ID of the image.
        self.image_id = image_id
        # The ID of the instance.
        self.instance_id = instance_id
        # The IDs of the instances. The value is a JSON array that consists of up to 100 IDs. Separate IDs with commas (,).
        self.instance_ids = instance_ids
        # The name of the instance.
        self.instance_name = instance_name
        # The condition that you want to use to filter instances by category. Valid values:
        # 
        # *   EnsInstance: ENS instances that you purchase.
        # *   EnsService: ENS instances that belong to edge services.
        # *   BuildMachine: ENS instances that are configured with image builders.
        # *   EnsPostPaidInstance: Pay-as-you-go ENS instances that you purchase.
        self.instance_resource_type = instance_resource_type
        # The instance type.
        self.instance_type = instance_type
        # The internal IP address of the instance.
        self.intranet_ip = intranet_ip
        # The ID of the network.
        self.network_id = network_id
        # The method that you want to use to sort instances. The value of this parameter is in the JSON format.
        # 
        # You can sort instances by name, expiration time, node ID, or creation time. You can specify one or more methods.
        self.order_by_params = order_by_params
        # The page number. Pages start from page **1**.
        # 
        # Default value: **1**.
        self.page_number = page_number
        # The number of entries to return on each page. The maximum value is **100**.
        # 
        # Default value: **10**.
        self.page_size = page_size
        # The keyword that you use to query the logs of the service. You can specify the values of parameters such as **ip**, **InstanceName**, and **InstanceId** as the keyword.
        self.search_key = search_key
        # The ID of the security group.
        self.security_group_id = security_group_id
        # The status of the service. Valid values.
        self.service_status_shrink = service_status_shrink
        # The status of the instance. Valid values:
        # 
        # *   Running
        # *   Stopped
        # *   Expired
        self.status = status
        # The tags that are added to the resource. This operation does not return tag information. You can call this operation in combination with the tag-related operations.
        self.tags_shrink = tags_shrink
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.ens_region_ids is not None:
            result['EnsRegionIds'] = self.ens_region_ids
        if self.ens_service_id is not None:
            result['EnsServiceId'] = self.ens_service_id
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_resource_type is not None:
            result['InstanceResourceType'] = self.instance_resource_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.order_by_params is not None:
            result['OrderByParams'] = self.order_by_params
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.service_status_shrink is not None:
            result['ServiceStatus'] = self.service_status_shrink
        if self.status is not None:
            result['Status'] = self.status
        if self.tags_shrink is not None:
            result['Tags'] = self.tags_shrink
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('EnsRegionIds') is not None:
            self.ens_region_ids = m.get('EnsRegionIds')
        if m.get('EnsServiceId') is not None:
            self.ens_service_id = m.get('EnsServiceId')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceResourceType') is not None:
            self.instance_resource_type = m.get('InstanceResourceType')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('OrderByParams') is not None:
            self.order_by_params = m.get('OrderByParams')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('ServiceStatus') is not None:
            self.service_status_shrink = m.get('ServiceStatus')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tags') is not None:
            self.tags_shrink = m.get('Tags')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeInstancesResponseBodyInstancesInstanceDataDiskDataDisk(TeaModel):
    def __init__(
        self,
        category: str = None,
        disk_id: str = None,
        disk_name: str = None,
        disk_size: int = None,
        encrypt_key_id: str = None,
        encrypted: bool = None,
        size: int = None,
        device_type: str = None,
        disk_type: str = None,
        name: str = None,
        storage: int = None,
        uuid: str = None,
    ):
        # The category of the cloud disk or local disk. Valid values:
        # 
        # *   **file**: local disk.
        # *   **pangu**: ultra disk.
        # *   **local_hdd**: local HDD.
        self.category = category
        # The ID of the disk.
        self.disk_id = disk_id
        # The name of the disk.
        self.disk_name = disk_name
        # The size of the disk. Unit: GiB.
        self.disk_size = disk_size
        # The KMS key ID used by the cloud drive.
        self.encrypt_key_id = encrypt_key_id
        # Specifies whether to encrypt the disk.
        self.encrypted = encrypted
        # The size of the disk. Unit: MiB.
        self.size = size
        # The extended field of the disk category. Valid values:
        # 
        # *   **file**: local disk.
        # *   **pangu**: ultra disk.
        # *   **local_hdd**: local HDD.
        self.device_type = device_type
        # The type of the cloud disk or local disk. Valid values:
        # 
        # **system**: system disk. **data**: data disk.
        self.disk_type = disk_type
        # The name of the disk.
        self.name = name
        # The size of the disk. Unit: MiB.
        self.storage = storage
        # The UUID of the disk.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.disk_size is not None:
            result['DiskSize'] = self.disk_size
        if self.encrypt_key_id is not None:
            result['EncryptKeyId'] = self.encrypt_key_id
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.size is not None:
            result['Size'] = self.size
        if self.device_type is not None:
            result['device_type'] = self.device_type
        if self.disk_type is not None:
            result['disk_type'] = self.disk_type
        if self.name is not None:
            result['name'] = self.name
        if self.storage is not None:
            result['storage'] = self.storage
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('DiskSize') is not None:
            self.disk_size = m.get('DiskSize')
        if m.get('EncryptKeyId') is not None:
            self.encrypt_key_id = m.get('EncryptKeyId')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('device_type') is not None:
            self.device_type = m.get('device_type')
        if m.get('disk_type') is not None:
            self.disk_type = m.get('disk_type')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('storage') is not None:
            self.storage = m.get('storage')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class DescribeInstancesResponseBodyInstancesInstanceDataDisk(TeaModel):
    def __init__(
        self,
        data_disk: List[DescribeInstancesResponseBodyInstancesInstanceDataDiskDataDisk] = None,
    ):
        self.data_disk = data_disk

    def validate(self):
        if self.data_disk:
            for k in self.data_disk:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataDisk'] = []
        if self.data_disk is not None:
            for k in self.data_disk:
                result['DataDisk'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_disk = []
        if m.get('DataDisk') is not None:
            for k in m.get('DataDisk'):
                temp_model = DescribeInstancesResponseBodyInstancesInstanceDataDiskDataDisk()
                self.data_disk.append(temp_model.from_map(k))
        return self


class DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress(TeaModel):
    def __init__(
        self,
        ip_address: List[str] = None,
    ):
        self.ip_address = ip_address

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        return self


class DescribeInstancesResponseBodyInstancesInstanceNetworkAttributesPrivateIpAddress(TeaModel):
    def __init__(
        self,
        ip_address: List[str] = None,
    ):
        self.ip_address = ip_address

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        return self


class DescribeInstancesResponseBodyInstancesInstanceNetworkAttributes(TeaModel):
    def __init__(
        self,
        network_id: str = None,
        private_ip_address: DescribeInstancesResponseBodyInstancesInstanceNetworkAttributesPrivateIpAddress = None,
        v_switch_id: str = None,
    ):
        # The ID of the network.
        self.network_id = network_id
        # Details of the private IP addresses.
        self.private_ip_address = private_ip_address
        # The vSwitch ID.
        self.v_switch_id = v_switch_id

    def validate(self):
        if self.private_ip_address:
            self.private_ip_address.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address.to_map()
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('PrivateIpAddress') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceNetworkAttributesPrivateIpAddress()
            self.private_ip_address = temp_model.from_map(m['PrivateIpAddress'])
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6SetsIpv6Set(TeaModel):
    def __init__(
        self,
        ipv_6address: str = None,
    ):
        # IPv6 addresses N of the ENI. You can specify multiple IPv6 addresses. Valid values of N: 1 to 100.
        self.ipv_6address = ipv_6address

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_6address is not None:
            result['Ipv6Address'] = self.ipv_6address
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ipv6Address') is not None:
            self.ipv_6address = m.get('Ipv6Address')
        return self


class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6Sets(TeaModel):
    def __init__(
        self,
        ipv_6set: List[DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6SetsIpv6Set] = None,
    ):
        self.ipv_6set = ipv_6set

    def validate(self):
        if self.ipv_6set:
            for k in self.ipv_6set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ipv6Set'] = []
        if self.ipv_6set is not None:
            for k in self.ipv_6set:
                result['Ipv6Set'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ipv_6set = []
        if m.get('Ipv6Set') is not None:
            for k in m.get('Ipv6Set'):
                temp_model = DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6SetsIpv6Set()
                self.ipv_6set.append(temp_model.from_map(k))
        return self


class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSetsPrivateIpSet(TeaModel):
    def __init__(
        self,
        primary: bool = None,
        private_ip_address: str = None,
    ):
        # Indicates whether the IP address is the primary private IP address. Valid values:
        # 
        # *   true
        # *   false
        self.primary = primary
        # The private IP address.
        # 
        # >  This parameter is available only if ScheduleAreaLevel is set to Region and cannot be configured if ScheduleAreaLevel is set to other values. Otherwise, an error occurs. If you specify a private IP address, the number of instances must be 1. The private IP address takes effect only when the private IP address and the vSwitch ID are not empty.
        self.private_ip_address = private_ip_address

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.primary is not None:
            result['Primary'] = self.primary
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Primary') is not None:
            self.primary = m.get('Primary')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        return self


class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSets(TeaModel):
    def __init__(
        self,
        private_ip_set: List[DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSetsPrivateIpSet] = None,
    ):
        self.private_ip_set = private_ip_set

    def validate(self):
        if self.private_ip_set:
            for k in self.private_ip_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PrivateIpSet'] = []
        if self.private_ip_set is not None:
            for k in self.private_ip_set:
                result['PrivateIpSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.private_ip_set = []
        if m.get('PrivateIpSet') is not None:
            for k in m.get('PrivateIpSet'):
                temp_model = DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSetsPrivateIpSet()
                self.private_ip_set.append(temp_model.from_map(k))
        return self


class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaces(TeaModel):
    def __init__(
        self,
        ipv_6sets: DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6Sets = None,
        mac_address: str = None,
        network_interface_id: str = None,
        primary_ip_address: str = None,
        private_ip_sets: DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSets = None,
        type: str = None,
    ):
        # The IPv6 addresses of the ENI. This parameter has a value only when `AdditionalAttributes.N` is set to `NETWORK_PRIMARY_ENI_IP`.
        self.ipv_6sets = ipv_6sets
        # The MAC address of the ENI.
        self.mac_address = mac_address
        # The ID of the ENI.
        self.network_interface_id = network_interface_id
        # The primary IP address of the ENI.
        self.primary_ip_address = primary_ip_address
        # The private IP addresses of the ENI.
        self.private_ip_sets = private_ip_sets
        # The type of the disk. Valid values:
        # 
        # *   system: system disk.
        # *   data: data disk.
        self.type = type

    def validate(self):
        if self.ipv_6sets:
            self.ipv_6sets.validate()
        if self.private_ip_sets:
            self.private_ip_sets.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_6sets is not None:
            result['Ipv6Sets'] = self.ipv_6sets.to_map()
        if self.mac_address is not None:
            result['MacAddress'] = self.mac_address
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.primary_ip_address is not None:
            result['PrimaryIpAddress'] = self.primary_ip_address
        if self.private_ip_sets is not None:
            result['PrivateIpSets'] = self.private_ip_sets.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ipv6Sets') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6Sets()
            self.ipv_6sets = temp_model.from_map(m['Ipv6Sets'])
        if m.get('MacAddress') is not None:
            self.mac_address = m.get('MacAddress')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('PrimaryIpAddress') is not None:
            self.primary_ip_address = m.get('PrimaryIpAddress')
        if m.get('PrivateIpSets') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSets()
            self.private_ip_sets = temp_model.from_map(m['PrivateIpSets'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces(TeaModel):
    def __init__(
        self,
        network_interfaces: List[DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaces] = None,
    ):
        self.network_interfaces = network_interfaces

    def validate(self):
        if self.network_interfaces:
            for k in self.network_interfaces:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NetworkInterfaces'] = []
        if self.network_interfaces is not None:
            for k in self.network_interfaces:
                result['NetworkInterfaces'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.network_interfaces = []
        if m.get('NetworkInterfaces') is not None:
            for k in m.get('NetworkInterfaces'):
                temp_model = DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaces()
                self.network_interfaces.append(temp_model.from_map(k))
        return self


class DescribeInstancesResponseBodyInstancesInstancePrivateIpAddressesPrivateIpAddress(TeaModel):
    def __init__(
        self,
        gate_way: str = None,
        ip: str = None,
        isp: str = None,
    ):
        # The gateway.
        self.gate_way = gate_way
        # The IP address.
        self.ip = ip
        # The ISP.
        self.isp = isp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gate_way is not None:
            result['GateWay'] = self.gate_way
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.isp is not None:
            result['Isp'] = self.isp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GateWay') is not None:
            self.gate_way = m.get('GateWay')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        return self


class DescribeInstancesResponseBodyInstancesInstancePrivateIpAddresses(TeaModel):
    def __init__(
        self,
        private_ip_address: List[DescribeInstancesResponseBodyInstancesInstancePrivateIpAddressesPrivateIpAddress] = None,
    ):
        self.private_ip_address = private_ip_address

    def validate(self):
        if self.private_ip_address:
            for k in self.private_ip_address:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PrivateIpAddress'] = []
        if self.private_ip_address is not None:
            for k in self.private_ip_address:
                result['PrivateIpAddress'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.private_ip_address = []
        if m.get('PrivateIpAddress') is not None:
            for k in m.get('PrivateIpAddress'):
                temp_model = DescribeInstancesResponseBodyInstancesInstancePrivateIpAddressesPrivateIpAddress()
                self.private_ip_address.append(temp_model.from_map(k))
        return self


class DescribeInstancesResponseBodyInstancesInstancePublicIpAddress(TeaModel):
    def __init__(
        self,
        ip_address: List[str] = None,
    ):
        self.ip_address = ip_address

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        return self


class DescribeInstancesResponseBodyInstancesInstancePublicIpAddressesPublicIpAddress(TeaModel):
    def __init__(
        self,
        gate_way: str = None,
        ip: str = None,
        isp: str = None,
    ):
        # The gateway.
        self.gate_way = gate_way
        # The IP address.
        self.ip = ip
        # The Internet service provider (ISP).
        self.isp = isp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gate_way is not None:
            result['GateWay'] = self.gate_way
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.isp is not None:
            result['Isp'] = self.isp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GateWay') is not None:
            self.gate_way = m.get('GateWay')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        return self


class DescribeInstancesResponseBodyInstancesInstancePublicIpAddresses(TeaModel):
    def __init__(
        self,
        public_ip_address: List[DescribeInstancesResponseBodyInstancesInstancePublicIpAddressesPublicIpAddress] = None,
    ):
        self.public_ip_address = public_ip_address

    def validate(self):
        if self.public_ip_address:
            for k in self.public_ip_address:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PublicIpAddress'] = []
        if self.public_ip_address is not None:
            for k in self.public_ip_address:
                result['PublicIpAddress'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.public_ip_address = []
        if m.get('PublicIpAddress') is not None:
            for k in m.get('PublicIpAddress'):
                temp_model = DescribeInstancesResponseBodyInstancesInstancePublicIpAddressesPublicIpAddress()
                self.public_ip_address.append(temp_model.from_map(k))
        return self


class DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds(TeaModel):
    def __init__(
        self,
        security_group_id: List[str] = None,
    ):
        self.security_group_id = security_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class DescribeInstancesResponseBodyInstancesInstanceSystemDisk(TeaModel):
    def __init__(
        self,
        category: str = None,
        disk_id: str = None,
        disk_name: str = None,
        size: int = None,
        device_type: str = None,
        disk_type: str = None,
        name: str = None,
        storage: int = None,
        uuid: str = None,
    ):
        # The category of the cloud disk or local disk. Valid values:
        # 
        # *   **file**: local disk.
        # *   **pangu**: ultra disk.
        # *   **local_hdd**: local HDD.
        self.category = category
        # The ID of the disk.
        self.disk_id = disk_id
        # The name of the disk.
        self.disk_name = disk_name
        # The size of the disk. Unit: MiB.
        self.size = size
        # The extended field of the disk category. Valid values:
        # 
        # *   **file**: local disk.
        # *   **pangu**: ultra disk.
        # *   **local_hdd**: local HDD.
        self.device_type = device_type
        # The type of the cloud disk or local disk. Valid values:
        # 
        # *   **system**: system disk.
        # *   **data**: data disk.
        self.disk_type = disk_type
        # The name of the disk.
        self.name = name
        # The size of the disk. Unit: MiB.
        self.storage = storage
        # The UUID of the disk.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.size is not None:
            result['Size'] = self.size
        if self.device_type is not None:
            result['device_type'] = self.device_type
        if self.disk_type is not None:
            result['disk_type'] = self.disk_type
        if self.name is not None:
            result['name'] = self.name
        if self.storage is not None:
            result['storage'] = self.storage
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('device_type') is not None:
            self.device_type = m.get('device_type')
        if m.get('disk_type') is not None:
            self.disk_type = m.get('disk_type')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('storage') is not None:
            self.storage = m.get('storage')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class DescribeInstancesResponseBodyInstancesInstanceTagsTags(TeaModel):
    def __init__(
        self,
        tag_key: str = None,
        tag_value: str = None,
    ):
        # The tag key.
        self.tag_key = tag_key
        # The tag value.
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeInstancesResponseBodyInstancesInstanceTags(TeaModel):
    def __init__(
        self,
        tags: List[DescribeInstancesResponseBodyInstancesInstanceTagsTags] = None,
    ):
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = DescribeInstancesResponseBodyInstancesInstanceTagsTags()
                self.tags.append(temp_model.from_map(k))
        return self


class DescribeInstancesResponseBodyInstancesInstance(TeaModel):
    def __init__(
        self,
        auto_release_time: str = None,
        cpu: str = None,
        creation_time: str = None,
        data_disk: DescribeInstancesResponseBodyInstancesInstanceDataDisk = None,
        deletion_protection: bool = None,
        disk: int = None,
        ens_region_id: str = None,
        expired_time: str = None,
        host_name: str = None,
        image_id: str = None,
        inner_ip_address: DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress = None,
        instance_id: str = None,
        instance_name: str = None,
        instance_resource_type: str = None,
        instance_type_family: str = None,
        internet_max_bandwidth_in: int = None,
        internet_max_bandwidth_out: int = None,
        key_pair_name: str = None,
        memory: int = None,
        network_attributes: DescribeInstancesResponseBodyInstancesInstanceNetworkAttributes = None,
        network_interfaces: DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces = None,
        osname: str = None,
        private_ip_addresses: DescribeInstancesResponseBodyInstancesInstancePrivateIpAddresses = None,
        public_ip_address: DescribeInstancesResponseBodyInstancesInstancePublicIpAddress = None,
        public_ip_addresses: DescribeInstancesResponseBodyInstancesInstancePublicIpAddresses = None,
        security_group_ids: DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds = None,
        service_status: str = None,
        spec_name: str = None,
        spot_strategy: str = None,
        status: str = None,
        system_disk: DescribeInstancesResponseBodyInstancesInstanceSystemDisk = None,
        tags: DescribeInstancesResponseBodyInstancesInstanceTags = None,
    ):
        # The automatic release time of the instance.
        self.auto_release_time = auto_release_time
        # The number of vCPUs.
        self.cpu = cpu
        # The time when the instance was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.creation_time = creation_time
        # Details of the data disk.
        self.data_disk = data_disk
        self.deletion_protection = deletion_protection
        # The total size of the disk. Unit: MiB.
        self.disk = disk
        # The region ID of the instance.
        self.ens_region_id = ens_region_id
        # The expiration time. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.expired_time = expired_time
        # The hostname of the instance.
        # 
        # *   The hostname cannot start or end with a period (.) or hyphen (-). It cannot contain consecutive periods (.) or hyphens (-).
        # *   For a Windows instance, the hostname must be 2 to 15 characters in length and can contain letters, digits, and hyphens (-). The hostname cannot contain periods (.) or contain only digits.
        # *   For an instance that runs another operating system such as Linux, the hostname must be 2 to 64 characters in length. You can use periods (.) to separate the hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).
        self.host_name = host_name
        # The ID of the image.
        self.image_id = image_id
        # The private IP addresses of the instances.
        self.inner_ip_address = inner_ip_address
        # The ID of the instance.
        self.instance_id = instance_id
        # The name of the instance.
        self.instance_name = instance_name
        # The category of the instance. Valid values:
        # 
        # *   EnsInstance: ENS instances that you purchase.
        # *   EnsService: ENS instances that belong to edge services.
        # *   BuildMachine: ENS instances that are configured with image builders.
        # *   EnsPostPaidInstance: pay-as-you-go ENS instances that you purchase.
        self.instance_resource_type = instance_resource_type
        # The instance family. Valid values:
        # 
        # *   x86_vm: x86-based computing instance.
        # *   x86_pm: x86-based physical machine.
        # *   x86_bmi: x86-based bare metal instance.
        # *   x86_bm: bare metal instance with the SmartNIC.
        # *   pc_bmi: heterogeneous bare metal instance.
        # *   pc_vm: heterogeneous virtual machine.
        # *   arm_bmi: Arm-based computing instance.
        self.instance_type_family = instance_type_family
        # The maximum outbound bandwidth. Unit: Mbit/s.
        self.internet_max_bandwidth_in = internet_max_bandwidth_in
        # The minimum inbound bandwidth. Unit: Mbit/s.
        self.internet_max_bandwidth_out = internet_max_bandwidth_out
        # The name of the SSH key pair.
        self.key_pair_name = key_pair_name
        # The memory size. Unit: MB.
        self.memory = memory
        # Details of the network.
        self.network_attributes = network_attributes
        # The ENI attached to the instance.
        self.network_interfaces = network_interfaces
        # The name of the image.
        self.osname = osname
        # Details of the private IP addresses.
        self.private_ip_addresses = private_ip_addresses
        # The public IP addresses of the instances.
        self.public_ip_address = public_ip_address
        # Details of the public IP addresses.
        self.public_ip_addresses = public_ip_addresses
        # The IDs of the security groups.
        self.security_group_ids = security_group_ids
        # The ID of your Alibaba Cloud account.
        self.service_status = service_status
        # The instance type.
        self.spec_name = spec_name
        # The bidding policy of the preemptible instance.
        self.spot_strategy = spot_strategy
        # The status of the instance. Valid values:
        # 
        # *   Running
        # *   Expired
        # *   Stopped
        self.status = status
        # Details of the system disk.
        self.system_disk = system_disk
        # The tags of the instance.
        # 
        # >  This operation does not return tag information. You can call this operation in combination with the tag-related operations.
        self.tags = tags

    def validate(self):
        if self.data_disk:
            self.data_disk.validate()
        if self.inner_ip_address:
            self.inner_ip_address.validate()
        if self.network_attributes:
            self.network_attributes.validate()
        if self.network_interfaces:
            self.network_interfaces.validate()
        if self.private_ip_addresses:
            self.private_ip_addresses.validate()
        if self.public_ip_address:
            self.public_ip_address.validate()
        if self.public_ip_addresses:
            self.public_ip_addresses.validate()
        if self.security_group_ids:
            self.security_group_ids.validate()
        if self.system_disk:
            self.system_disk.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_release_time is not None:
            result['AutoReleaseTime'] = self.auto_release_time
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.data_disk is not None:
            result['DataDisk'] = self.data_disk.to_map()
        if self.deletion_protection is not None:
            result['DeletionProtection'] = self.deletion_protection
        if self.disk is not None:
            result['Disk'] = self.disk
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.expired_time is not None:
            result['ExpiredTime'] = self.expired_time
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.inner_ip_address is not None:
            result['InnerIpAddress'] = self.inner_ip_address.to_map()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_resource_type is not None:
            result['InstanceResourceType'] = self.instance_resource_type
        if self.instance_type_family is not None:
            result['InstanceTypeFamily'] = self.instance_type_family
        if self.internet_max_bandwidth_in is not None:
            result['InternetMaxBandwidthIn'] = self.internet_max_bandwidth_in
        if self.internet_max_bandwidth_out is not None:
            result['InternetMaxBandwidthOut'] = self.internet_max_bandwidth_out
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.network_attributes is not None:
            result['NetworkAttributes'] = self.network_attributes.to_map()
        if self.network_interfaces is not None:
            result['NetworkInterfaces'] = self.network_interfaces.to_map()
        if self.osname is not None:
            result['OSName'] = self.osname
        if self.private_ip_addresses is not None:
            result['PrivateIpAddresses'] = self.private_ip_addresses.to_map()
        if self.public_ip_address is not None:
            result['PublicIpAddress'] = self.public_ip_address.to_map()
        if self.public_ip_addresses is not None:
            result['PublicIpAddresses'] = self.public_ip_addresses.to_map()
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids.to_map()
        if self.service_status is not None:
            result['ServiceStatus'] = self.service_status
        if self.spec_name is not None:
            result['SpecName'] = self.spec_name
        if self.spot_strategy is not None:
            result['SpotStrategy'] = self.spot_strategy
        if self.status is not None:
            result['Status'] = self.status
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoReleaseTime') is not None:
            self.auto_release_time = m.get('AutoReleaseTime')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DataDisk') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceDataDisk()
            self.data_disk = temp_model.from_map(m['DataDisk'])
        if m.get('DeletionProtection') is not None:
            self.deletion_protection = m.get('DeletionProtection')
        if m.get('Disk') is not None:
            self.disk = m.get('Disk')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('ExpiredTime') is not None:
            self.expired_time = m.get('ExpiredTime')
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InnerIpAddress') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress()
            self.inner_ip_address = temp_model.from_map(m['InnerIpAddress'])
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceResourceType') is not None:
            self.instance_resource_type = m.get('InstanceResourceType')
        if m.get('InstanceTypeFamily') is not None:
            self.instance_type_family = m.get('InstanceTypeFamily')
        if m.get('InternetMaxBandwidthIn') is not None:
            self.internet_max_bandwidth_in = m.get('InternetMaxBandwidthIn')
        if m.get('InternetMaxBandwidthOut') is not None:
            self.internet_max_bandwidth_out = m.get('InternetMaxBandwidthOut')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('NetworkAttributes') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceNetworkAttributes()
            self.network_attributes = temp_model.from_map(m['NetworkAttributes'])
        if m.get('NetworkInterfaces') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces()
            self.network_interfaces = temp_model.from_map(m['NetworkInterfaces'])
        if m.get('OSName') is not None:
            self.osname = m.get('OSName')
        if m.get('PrivateIpAddresses') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstancePrivateIpAddresses()
            self.private_ip_addresses = temp_model.from_map(m['PrivateIpAddresses'])
        if m.get('PublicIpAddress') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstancePublicIpAddress()
            self.public_ip_address = temp_model.from_map(m['PublicIpAddress'])
        if m.get('PublicIpAddresses') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstancePublicIpAddresses()
            self.public_ip_addresses = temp_model.from_map(m['PublicIpAddresses'])
        if m.get('SecurityGroupIds') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds()
            self.security_group_ids = temp_model.from_map(m['SecurityGroupIds'])
        if m.get('ServiceStatus') is not None:
            self.service_status = m.get('ServiceStatus')
        if m.get('SpecName') is not None:
            self.spec_name = m.get('SpecName')
        if m.get('SpotStrategy') is not None:
            self.spot_strategy = m.get('SpotStrategy')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SystemDisk') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceSystemDisk()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        if m.get('Tags') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceTags()
            self.tags = temp_model.from_map(m['Tags'])
        return self


class DescribeInstancesResponseBodyInstances(TeaModel):
    def __init__(
        self,
        instance: List[DescribeInstancesResponseBodyInstancesInstance] = None,
    ):
        self.instance = instance

    def validate(self):
        if self.instance:
            for k in self.instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instance'] = []
        if self.instance is not None:
            for k in self.instance:
                result['Instance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance = []
        if m.get('Instance') is not None:
            for k in m.get('Instance'):
                temp_model = DescribeInstancesResponseBodyInstancesInstance()
                self.instance.append(temp_model.from_map(k))
        return self


class DescribeInstancesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        instances: DescribeInstancesResponseBodyInstances = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The returned service code. 0 indicates that the request was successful.
        self.code = code
        # The returned instance information. It is an array that consists of InstanceAttributesType data.
        self.instances = instances
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.instances:
            self.instances.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.instances is not None:
            result['Instances'] = self.instances.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Instances') is not None:
            temp_model = DescribeInstancesResponseBodyInstances()
            self.instances = temp_model.from_map(m['Instances'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeKeyPairsRequest(TeaModel):
    def __init__(
        self,
        key_pair_id: str = None,
        key_pair_name: str = None,
        page_number: str = None,
        page_size: str = None,
    ):
        # The ID of the key pair.
        self.key_pair_id = key_pair_id
        # The name of the key pair that you want to bind to the simple application server. The name must be 2 to 128 characters in length. The name must start with a letter but cannot start with `http://` or `https://`. The name can contain the following characters:
        # 
        # *   Numbers.
        # *   :
        # *   _
        # *   .
        # 
        # You can specify only one name. By default, all key pairs are queried.
        self.key_pair_name = key_pair_name
        # The page number of the returned page. Valid values: integers that are greater than 0. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Valid values: integers that are greater than 0. Default value: 10.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_pair_id is not None:
            result['KeyPairId'] = self.key_pair_id
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('KeyPairId') is not None:
            self.key_pair_id = m.get('KeyPairId')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeKeyPairsResponseBodyKeyPairsKeyPair(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        key_pair_finger_print: str = None,
        key_pair_id: str = None,
        key_pair_name: str = None,
    ):
        # The time when the key pair was created. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
        self.creation_time = creation_time
        # The fingerprint of the key pair.
        self.key_pair_finger_print = key_pair_finger_print
        # The ID of the key pair.
        self.key_pair_id = key_pair_id
        # The name of the SSH key pair.
        self.key_pair_name = key_pair_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.key_pair_finger_print is not None:
            result['KeyPairFingerPrint'] = self.key_pair_finger_print
        if self.key_pair_id is not None:
            result['KeyPairId'] = self.key_pair_id
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('KeyPairFingerPrint') is not None:
            self.key_pair_finger_print = m.get('KeyPairFingerPrint')
        if m.get('KeyPairId') is not None:
            self.key_pair_id = m.get('KeyPairId')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        return self


class DescribeKeyPairsResponseBodyKeyPairs(TeaModel):
    def __init__(
        self,
        key_pair: List[DescribeKeyPairsResponseBodyKeyPairsKeyPair] = None,
    ):
        self.key_pair = key_pair

    def validate(self):
        if self.key_pair:
            for k in self.key_pair:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['KeyPair'] = []
        if self.key_pair is not None:
            for k in self.key_pair:
                result['KeyPair'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.key_pair = []
        if m.get('KeyPair') is not None:
            for k in m.get('KeyPair'):
                temp_model = DescribeKeyPairsResponseBodyKeyPairsKeyPair()
                self.key_pair.append(temp_model.from_map(k))
        return self


class DescribeKeyPairsResponseBody(TeaModel):
    def __init__(
        self,
        key_pairs: DescribeKeyPairsResponseBodyKeyPairs = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # Details about the key pairs.
        self.key_pairs = key_pairs
        # The page number.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of key pairs.
        self.total_count = total_count

    def validate(self):
        if self.key_pairs:
            self.key_pairs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_pairs is not None:
            result['KeyPairs'] = self.key_pairs.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('KeyPairs') is not None:
            temp_model = DescribeKeyPairsResponseBodyKeyPairs()
            self.key_pairs = temp_model.from_map(m['KeyPairs'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeKeyPairsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeKeyPairsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeKeyPairsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLoadBalancerAttributeRequest(TeaModel):
    def __init__(
        self,
        load_balancer_id: str = None,
    ):
        # The ID of the ELB instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        return self


class DescribeLoadBalancerAttributeResponseBodyBackendServers(TeaModel):
    def __init__(
        self,
        ip: str = None,
        port: str = None,
        server_id: str = None,
        type: str = None,
        weight: int = None,
    ):
        # The IP address of the backend server.
        self.ip = ip
        # The port that is used by the backend server.
        self.port = port
        # The ID of the backend server.
        self.server_id = server_id
        # The type of backend server.
        self.type = type
        # The weight of the backend server.
        self.weight = weight

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.port is not None:
            result['Port'] = self.port
        if self.server_id is not None:
            result['ServerId'] = self.server_id
        if self.type is not None:
            result['Type'] = self.type
        if self.weight is not None:
            result['Weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('ServerId') is not None:
            self.server_id = m.get('ServerId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        return self


class DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocols(TeaModel):
    def __init__(
        self,
        backend_server_port: int = None,
        description: str = None,
        forward_port: int = None,
        listener_forward: str = None,
        listener_port: int = None,
        listener_protocol: str = None,
    ):
        # The backend port that is used by the ELB instance. Valid values: **1** to **65535**.
        self.backend_server_port = backend_server_port
        # The description of the listener.
        self.description = description
        # The destination listening port to which requests are forwarded.
        self.forward_port = forward_port
        # Indicates whether the listener is enabled.
        self.listener_forward = listener_forward
        # The listener port of the instance.
        self.listener_port = listener_port
        # The listener protocol of the instance.
        self.listener_protocol = listener_protocol

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backend_server_port is not None:
            result['BackendServerPort'] = self.backend_server_port
        if self.description is not None:
            result['Description'] = self.description
        if self.forward_port is not None:
            result['ForwardPort'] = self.forward_port
        if self.listener_forward is not None:
            result['ListenerForward'] = self.listener_forward
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.listener_protocol is not None:
            result['ListenerProtocol'] = self.listener_protocol
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackendServerPort') is not None:
            self.backend_server_port = m.get('BackendServerPort')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ForwardPort') is not None:
            self.forward_port = m.get('ForwardPort')
        if m.get('ListenerForward') is not None:
            self.listener_forward = m.get('ListenerForward')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('ListenerProtocol') is not None:
            self.listener_protocol = m.get('ListenerProtocol')
        return self


class DescribeLoadBalancerAttributeResponseBody(TeaModel):
    def __init__(
        self,
        address: str = None,
        address_ipversion: str = None,
        address_type: str = None,
        backend_servers: List[DescribeLoadBalancerAttributeResponseBodyBackendServers] = None,
        bandwidth: int = None,
        create_time: str = None,
        end_time: str = None,
        ens_region_id: str = None,
        listener_ports: List[str] = None,
        listener_ports_and_protocols: List[DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocols] = None,
        load_balancer_id: str = None,
        load_balancer_name: str = None,
        load_balancer_spec: str = None,
        load_balancer_status: str = None,
        load_balancer_type: str = None,
        network_id: str = None,
        pay_type: str = None,
        request_id: str = None,
        v_switch_id: str = None,
    ):
        # The IP address that the Edge Load Balancer (ELB) instance uses to provide services.
        self.address = address
        # The IP version of the ELB instance. Valid values: ipv4 and ipv6.
        self.address_ipversion = address_ipversion
        self.address_type = address_type
        # The list of backend servers.
        self.backend_servers = backend_servers
        # The peak bandwidth of the ELB. The default value is -1, which indicates that the bandwidth is unlimited.
        self.bandwidth = bandwidth
        # The time when the ELB instance was created. The time is displayed in UTC.
        self.create_time = create_time
        # The time when the ELB instance was disabled.
        self.end_time = end_time
        # The ID of the ENS node.
        self.ens_region_id = ens_region_id
        # The frontend ports that are used by the ELB instance.
        self.listener_ports = listener_ports
        # The frontend ports and protocols that are used by the ELB instance.
        self.listener_ports_and_protocols = listener_ports_and_protocols
        # The ID of the ELB instance.
        self.load_balancer_id = load_balancer_id
        # The name of the ELB instance.
        self.load_balancer_name = load_balancer_name
        # The specifications of the ELB instance.
        self.load_balancer_spec = load_balancer_spec
        # The status of the ELB instance. Valid values:
        # 
        # *   **Active** (default): The listener for the instance can forward the received traffic based on the rule.
        # *   **InActive**: The listener for the instance does not forward the received traffic.
        self.load_balancer_status = load_balancer_status
        self.load_balancer_type = load_balancer_type
        # The ID of the network.
        self.network_id = network_id
        # The billing method. Valid values:
        # 
        # *   **PrePaid**: subscription.
        # *   **PostPaid**: pay-as-you-go. Only this billing method is supported.
        self.pay_type = pay_type
        # The ID of the request.
        self.request_id = request_id
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id

    def validate(self):
        if self.backend_servers:
            for k in self.backend_servers:
                if k:
                    k.validate()
        if self.listener_ports_and_protocols:
            for k in self.listener_ports_and_protocols:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.address_ipversion is not None:
            result['AddressIPVersion'] = self.address_ipversion
        if self.address_type is not None:
            result['AddressType'] = self.address_type
        result['BackendServers'] = []
        if self.backend_servers is not None:
            for k in self.backend_servers:
                result['BackendServers'].append(k.to_map() if k else None)
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.listener_ports is not None:
            result['ListenerPorts'] = self.listener_ports
        result['ListenerPortsAndProtocols'] = []
        if self.listener_ports_and_protocols is not None:
            for k in self.listener_ports_and_protocols:
                result['ListenerPortsAndProtocols'].append(k.to_map() if k else None)
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.load_balancer_name is not None:
            result['LoadBalancerName'] = self.load_balancer_name
        if self.load_balancer_spec is not None:
            result['LoadBalancerSpec'] = self.load_balancer_spec
        if self.load_balancer_status is not None:
            result['LoadBalancerStatus'] = self.load_balancer_status
        if self.load_balancer_type is not None:
            result['LoadBalancerType'] = self.load_balancer_type
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.pay_type is not None:
            result['PayType'] = self.pay_type
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AddressIPVersion') is not None:
            self.address_ipversion = m.get('AddressIPVersion')
        if m.get('AddressType') is not None:
            self.address_type = m.get('AddressType')
        self.backend_servers = []
        if m.get('BackendServers') is not None:
            for k in m.get('BackendServers'):
                temp_model = DescribeLoadBalancerAttributeResponseBodyBackendServers()
                self.backend_servers.append(temp_model.from_map(k))
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('ListenerPorts') is not None:
            self.listener_ports = m.get('ListenerPorts')
        self.listener_ports_and_protocols = []
        if m.get('ListenerPortsAndProtocols') is not None:
            for k in m.get('ListenerPortsAndProtocols'):
                temp_model = DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocols()
                self.listener_ports_and_protocols.append(temp_model.from_map(k))
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('LoadBalancerName') is not None:
            self.load_balancer_name = m.get('LoadBalancerName')
        if m.get('LoadBalancerSpec') is not None:
            self.load_balancer_spec = m.get('LoadBalancerSpec')
        if m.get('LoadBalancerStatus') is not None:
            self.load_balancer_status = m.get('LoadBalancerStatus')
        if m.get('LoadBalancerType') is not None:
            self.load_balancer_type = m.get('LoadBalancerType')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('PayType') is not None:
            self.pay_type = m.get('PayType')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeLoadBalancerAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLoadBalancerAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLoadBalancerAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLoadBalancerHTTPListenerAttributeRequest(TeaModel):
    def __init__(
        self,
        listener_port: int = None,
        load_balancer_id: str = None,
    ):
        # The listener port that you want to query. Valid values: **1 to 65535**.
        # 
        # This parameter is required.
        self.listener_port = listener_port
        # The ID of the ELB instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        return self


class DescribeLoadBalancerHTTPListenerAttributeResponseBody(TeaModel):
    def __init__(
        self,
        backend_server_port: int = None,
        bandwidth: int = None,
        description: str = None,
        forward_port: int = None,
        health_check: str = None,
        health_check_connect_port: int = None,
        health_check_domain: str = None,
        health_check_http_code: str = None,
        health_check_interval: int = None,
        health_check_method: str = None,
        health_check_timeout: int = None,
        health_check_uri: str = None,
        healthy_threshold: int = None,
        idle_timeout: int = None,
        listener_forward: str = None,
        listener_port: int = None,
        request_id: str = None,
        request_timeout: int = None,
        scheduler: str = None,
        server_certificate_id: str = None,
        status: str = None,
        unhealthy_threshold: int = None,
        xforwarded_for: str = None,
    ):
        # The port used by the backend server of the ELB instance. Valid values: **1** to **65535**.
        self.backend_server_port = backend_server_port
        # The peak bandwidth of the Edge Load Balancer (ELB) instance. The default value is -1, which indicates that the bandwidth is not limited.
        self.bandwidth = bandwidth
        # The description of the listener. The description must be **1** to **80** characters in length.
        # 
        # >  The value cannot start with `http://` or `https://`.
        self.description = description
        # The listener port that is used to redirect HTTP requests to HTTPS.
        self.forward_port = forward_port
        # Indicates whether the health check feature is enabled. Valid values:
        # 
        # *   **on**\
        # *   **off**\
        self.health_check = health_check
        # The port that is used for health checks. Valid values: **1** to **65535**. If you leave this parameter empty, the port specified by BackendServerPort is used for health checks.
        # 
        # >  This parameter is returned only if you set HealthCheck to on.
        self.health_check_connect_port = health_check_connect_port
        # The domain name that is used for health checks.
        # 
        # >  This parameter is returned only if you set HealthCheck to on.
        self.health_check_domain = health_check_domain
        # The HTTP status codes for a successful health check. Valid values:
        # 
        # *   **http_2xx** (default)
        # *   **http_3xx**.
        # *   **http_4xx**\
        # *   **http_5xx**\
        # 
        # >  This parameter is returned only if you set HealthCheck to on.
        self.health_check_http_code = health_check_http_code
        # The interval at which health checks are performed. Valid values: **1** to **50**. Unit: seconds.
        # 
        # >  This parameter is returned only if you set HealthCheck to on.
        self.health_check_interval = health_check_interval
        # The health check method used in HTTP health checks. Valid values:
        # 
        # *   **head**: requests the head of the page.
        # *   **get**: requests the specified part of the page and returns the entity body.
        # 
        # >  This parameter is returned only if you set HealthCheck to on.
        self.health_check_method = health_check_method
        # The timeout period of a health check response. If a backend server does not respond within the specified timeout period, the server fails the health check.
        # 
        # *   Default value: 5.
        # *   Valid values: **1** to **300**.
        # *   Unit: seconds.
        # 
        # > 
        # 
        # *   This parameter takes effect only if the HealthCheck parameter is set to on.
        # 
        # *   If the value of HealthCheckTimeout is smaller than the value of HealthCheckInterval, the timeout period specified by HealthCheckTimeout becomes invalid, and the value of HealthCheckInterval is used as the timeout period.
        self.health_check_timeout = health_check_timeout
        # The URI used for health checks. The URI must be **1** to **80** characters in length.
        # 
        # > 
        # 
        # *   A URL must start with a forward slash (`/`) but cannot contain only forward slashes (`/`).
        # 
        # *   This parameter takes effect only if the HealthCheck parameter is set to on.
        self.health_check_uri = health_check_uri
        # The number of consecutive successful health checks that must occur before an unhealthy and inaccessible backend server is declared healthy and accessible. Valid values: **2** to **10**.
        # 
        # >  This parameter is returned only if you set HealthCheck to on.
        self.healthy_threshold = healthy_threshold
        # The timeout period for idle connections. Default value: 15. Valid values: **1** to **60**. Unit: seconds.
        # 
        # >  If no request is received within the specified timeout period, ELB closes the connection. When another request is received, ELB establishes a new connection.
        self.idle_timeout = idle_timeout
        # Indicates whether HTTP-to-HTTPS redirection is enabled. Valid values:
        # 
        # *   **on**: HTTP-to-HTTPS redirection is enabled.
        # *   **off** (default)
        self.listener_forward = listener_forward
        # The listener port.
        self.listener_port = listener_port
        # The ID of the request.
        self.request_id = request_id
        # The timeout period of requests. Default value: 60. Valid values: **1** to **180**. Unit: seconds.
        # 
        # >  If no response is received from the backend server within the specified timeout period, ELB returns an HTTP 504 error code to the client.
        self.request_timeout = request_timeout
        # The routing algorithm. Valid values:
        # 
        # *   **wrr**: Backend servers with higher weights receive more requests than those with lower weights.
        # *   **wlc**: Requests are distributed based on the weight and load of each backend server. The load refers to the number of connections to a backend server. If two backend servers have the same weight, the backend server that has fewer connections receives more requests.
        # *   **rr**: Requests are distributed to backend servers in sequence.
        # *   **sch**: consistent hashing that is based on source IP addresses. Requests from the same source IP address are distributed to the same backend server.
        # *   **qch**: consistent hashing that is based on QUIC connection IDs. Requests that contain the same QUIC connection ID are distributed to the same backend server.
        # *   **iqch**: consistent hashing that is based on specific three bytes of the iQUIC CIDs. Requests whose second to fourth bytes are the same are distributed to the same backend server.
        self.scheduler = scheduler
        # The ID of the server certificate.
        self.server_certificate_id = server_certificate_id
        # The status of the listener. Valid values:
        # 
        # *   **Running**\
        # *   **Stopped**\
        # *   **Starting**\
        # *   **Configuring**\
        # *   **Stopping**\
        self.status = status
        # The number of consecutive failed health checks that must occur before a healthy and accessible backend server is declared unhealthy and inaccessible. Valid values: **2** to **10**.
        # 
        # >  This parameter is returned only if you set HealthCheck to on.
        self.unhealthy_threshold = unhealthy_threshold
        # Indicates whether the X-Forwarded-For header is used to obtain the real IP address of the client. Valid values:
        # 
        # *   **on** (default)
        # *   **off**\
        self.xforwarded_for = xforwarded_for

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backend_server_port is not None:
            result['BackendServerPort'] = self.backend_server_port
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.description is not None:
            result['Description'] = self.description
        if self.forward_port is not None:
            result['ForwardPort'] = self.forward_port
        if self.health_check is not None:
            result['HealthCheck'] = self.health_check
        if self.health_check_connect_port is not None:
            result['HealthCheckConnectPort'] = self.health_check_connect_port
        if self.health_check_domain is not None:
            result['HealthCheckDomain'] = self.health_check_domain
        if self.health_check_http_code is not None:
            result['HealthCheckHttpCode'] = self.health_check_http_code
        if self.health_check_interval is not None:
            result['HealthCheckInterval'] = self.health_check_interval
        if self.health_check_method is not None:
            result['HealthCheckMethod'] = self.health_check_method
        if self.health_check_timeout is not None:
            result['HealthCheckTimeout'] = self.health_check_timeout
        if self.health_check_uri is not None:
            result['HealthCheckURI'] = self.health_check_uri
        if self.healthy_threshold is not None:
            result['HealthyThreshold'] = self.healthy_threshold
        if self.idle_timeout is not None:
            result['IdleTimeout'] = self.idle_timeout
        if self.listener_forward is not None:
            result['ListenerForward'] = self.listener_forward
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.request_timeout is not None:
            result['RequestTimeout'] = self.request_timeout
        if self.scheduler is not None:
            result['Scheduler'] = self.scheduler
        if self.server_certificate_id is not None:
            result['ServerCertificateId'] = self.server_certificate_id
        if self.status is not None:
            result['Status'] = self.status
        if self.unhealthy_threshold is not None:
            result['UnhealthyThreshold'] = self.unhealthy_threshold
        if self.xforwarded_for is not None:
            result['XForwardedFor'] = self.xforwarded_for
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackendServerPort') is not None:
            self.backend_server_port = m.get('BackendServerPort')
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ForwardPort') is not None:
            self.forward_port = m.get('ForwardPort')
        if m.get('HealthCheck') is not None:
            self.health_check = m.get('HealthCheck')
        if m.get('HealthCheckConnectPort') is not None:
            self.health_check_connect_port = m.get('HealthCheckConnectPort')
        if m.get('HealthCheckDomain') is not None:
            self.health_check_domain = m.get('HealthCheckDomain')
        if m.get('HealthCheckHttpCode') is not None:
            self.health_check_http_code = m.get('HealthCheckHttpCode')
        if m.get('HealthCheckInterval') is not None:
            self.health_check_interval = m.get('HealthCheckInterval')
        if m.get('HealthCheckMethod') is not None:
            self.health_check_method = m.get('HealthCheckMethod')
        if m.get('HealthCheckTimeout') is not None:
            self.health_check_timeout = m.get('HealthCheckTimeout')
        if m.get('HealthCheckURI') is not None:
            self.health_check_uri = m.get('HealthCheckURI')
        if m.get('HealthyThreshold') is not None:
            self.healthy_threshold = m.get('HealthyThreshold')
        if m.get('IdleTimeout') is not None:
            self.idle_timeout = m.get('IdleTimeout')
        if m.get('ListenerForward') is not None:
            self.listener_forward = m.get('ListenerForward')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RequestTimeout') is not None:
            self.request_timeout = m.get('RequestTimeout')
        if m.get('Scheduler') is not None:
            self.scheduler = m.get('Scheduler')
        if m.get('ServerCertificateId') is not None:
            self.server_certificate_id = m.get('ServerCertificateId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UnhealthyThreshold') is not None:
            self.unhealthy_threshold = m.get('UnhealthyThreshold')
        if m.get('XForwardedFor') is not None:
            self.xforwarded_for = m.get('XForwardedFor')
        return self


class DescribeLoadBalancerHTTPListenerAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLoadBalancerHTTPListenerAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLoadBalancerHTTPListenerAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLoadBalancerHTTPSListenerAttributeRequest(TeaModel):
    def __init__(
        self,
        listener_port: int = None,
        load_balancer_id: str = None,
    ):
        # The listening port that you want to query. Valid values: **1** to **65535**.
        # 
        # This parameter is required.
        self.listener_port = listener_port
        # The ID of the ELB instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        return self


class DescribeLoadBalancerHTTPSListenerAttributeResponseBody(TeaModel):
    def __init__(
        self,
        backend_server_port: int = None,
        bandwidth: int = None,
        description: str = None,
        forward_port: int = None,
        health_check: str = None,
        health_check_connect_port: int = None,
        health_check_domain: str = None,
        health_check_http_code: str = None,
        health_check_interval: int = None,
        health_check_method: str = None,
        health_check_timeout: int = None,
        health_check_uri: str = None,
        healthy_threshold: int = None,
        idle_timeout: int = None,
        listener_forward: str = None,
        listener_port: int = None,
        request_id: str = None,
        request_timeout: int = None,
        scheduler: str = None,
        server_certificate_id: str = None,
        status: str = None,
        unhealthy_threshold: int = None,
    ):
        # The port used by the backend server of the ELB instance. Valid values: **1** to **65535**.
        self.backend_server_port = backend_server_port
        # The peak bandwidth of the Edge Load Balancer (ELB). The default value is -1, which indicates that the bandwidth is not limited.
        self.bandwidth = bandwidth
        # The description of the listener. The description must be **1** to **80** characters in length.
        self.description = description
        # The listener port that is used to redirect HTTP requests to HTTPS.
        self.forward_port = forward_port
        # Indicates whether the health check feature is enabled. Valid values:
        # 
        # *   **on**\
        # *   **off**\
        self.health_check = health_check
        # The port that is used for health checks. Valid values: **1** to **65535**. If an empty string is returned for this parameter, the port specified by BackendServerPort is used for health checks.
        # 
        # >  This parameter is returned only if the HealthCheck parameter is set to on.
        self.health_check_connect_port = health_check_connect_port
        # The domain name that is used for health checks.
        # 
        # >  This parameter is returned only if the HealthCheck parameter is set to on.
        self.health_check_domain = health_check_domain
        # The HTTP status code for a successful health check. Valid values:
        # 
        # *   **http_2xx** (default)
        # *   **http_3xx**.
        # *   **http_4xx**\
        # *   **http_5xx**\
        # 
        # >  This parameter is returned only if the HealthCheck parameter is set to on.
        self.health_check_http_code = health_check_http_code
        # The interval at which health checks are performed. Valid values: **1** to **50**. Unit: seconds.
        # 
        # >  This parameter is returned only if the HealthCheck parameter is set to on.
        self.health_check_interval = health_check_interval
        # The health check method used in HTTP health checks. Valid values:
        # 
        # *   **head**: requests the head of the page.
        # *   **get**: requests the specified part of the page and returns the entity body.
        # 
        # >  This parameter is returned only if the HealthCheck parameter is set to on.
        self.health_check_method = health_check_method
        # The timeout period of a health check response. If a backend server does not respond within the specified timeout period, the server fails the health check.
        # 
        # *   Default value: 5.
        # *   Valid values: **1** to **300**.
        # *   Unit: seconds.
        # 
        # > 
        # 
        # *   This parameter takes effect only if the HealthCheck parameter is set to on.
        # 
        # *   If the value of HealthCheckTimeout is smaller than the value of HealthCheckInterval, the timeout period specified by HealthCheckTimeout becomes invalid, and the value of HealthCheckInterval is used as the timeout period.
        self.health_check_timeout = health_check_timeout
        # The URI that is used for health checks. The URI must be **1** to **80** characters in length.
        # 
        # *   The URL must start with `/` and contain characters other than `/`.
        # *   This parameter is returned only if the HealthCheck parameter is set to on.
        self.health_check_uri = health_check_uri
        # The number of consecutive successful health checks that must occur before an unhealthy and inaccessible backend server is declared healthy and accessible. Valid values: **2** to **10**.
        # 
        # >  This parameter is returned only if the HealthCheck parameter is set to on.
        self.healthy_threshold = healthy_threshold
        # The timeout period for idle connections. Default value: 15. Valid values: **1** to **60**. Unit: seconds.
        # 
        # >  If no request is received within the specified timeout period, ELB closes the connection. When another request is received, CLB establishes a new connection.
        self.idle_timeout = idle_timeout
        # Indicates whether HTTP-to-HTTPS redirection is enabled. Valid values:
        # 
        # *   on
        # *   off
        self.listener_forward = listener_forward
        # The frontend port that is used by the ELB instance. Valid values: **1** to **65535**.
        self.listener_port = listener_port
        # The ID of the request.
        self.request_id = request_id
        # The timeout period of requests. Default value: 60. Valid values: **1** to **180**. Unit: seconds.
        # 
        # >  If no response is received from the backend server within the specified timeout period, ELB returns an HTTP 504 error code to the client.
        self.request_timeout = request_timeout
        # The routing algorithm. Valid values:
        # 
        # *   **wrr**: Backend servers with higher weights receive more requests than those with lower weights.
        # *   **wlc**: Requests are distributed based on the weight and load of each backend server. The load refers to the number of connections to a backend server. If two backend servers have the same weight, the backend server that has fewer connections receives more requests.
        # *   **rr**: Requests are distributed to backend servers in sequence.
        # *   **sch**: consistent hashing that is based on source IP addresses. Requests from the same source IP address are distributed to the same backend server.
        # *   **qch**: consistent hashing that is based on QUIC connection IDs. Requests that contain the same QUIC connection ID are distributed to the same backend server.
        # *   **iqch**: consistent hashing that is based on specific three bytes of the iQUIC CIDs. Requests whose second to fourth bytes are the same are distributed to the same backend server.
        self.scheduler = scheduler
        # The ID of the server certificate.
        self.server_certificate_id = server_certificate_id
        # The status of the listener. Valid values:
        # 
        # *   **Running**\
        # *   **Stopped**\
        # *   **Starting**\
        # *   **Configuring**\
        # *   **Stopping**\
        self.status = status
        # The number of consecutive failed health checks that must occur before a healthy and accessible backend server is declared unhealthy and inaccessible. Valid values: **2** to **10**.
        # 
        # >  This parameter is returned only if the HealthCheck parameter is set to on.
        self.unhealthy_threshold = unhealthy_threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backend_server_port is not None:
            result['BackendServerPort'] = self.backend_server_port
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.description is not None:
            result['Description'] = self.description
        if self.forward_port is not None:
            result['ForwardPort'] = self.forward_port
        if self.health_check is not None:
            result['HealthCheck'] = self.health_check
        if self.health_check_connect_port is not None:
            result['HealthCheckConnectPort'] = self.health_check_connect_port
        if self.health_check_domain is not None:
            result['HealthCheckDomain'] = self.health_check_domain
        if self.health_check_http_code is not None:
            result['HealthCheckHttpCode'] = self.health_check_http_code
        if self.health_check_interval is not None:
            result['HealthCheckInterval'] = self.health_check_interval
        if self.health_check_method is not None:
            result['HealthCheckMethod'] = self.health_check_method
        if self.health_check_timeout is not None:
            result['HealthCheckTimeout'] = self.health_check_timeout
        if self.health_check_uri is not None:
            result['HealthCheckURI'] = self.health_check_uri
        if self.healthy_threshold is not None:
            result['HealthyThreshold'] = self.healthy_threshold
        if self.idle_timeout is not None:
            result['IdleTimeout'] = self.idle_timeout
        if self.listener_forward is not None:
            result['ListenerForward'] = self.listener_forward
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.request_timeout is not None:
            result['RequestTimeout'] = self.request_timeout
        if self.scheduler is not None:
            result['Scheduler'] = self.scheduler
        if self.server_certificate_id is not None:
            result['ServerCertificateId'] = self.server_certificate_id
        if self.status is not None:
            result['Status'] = self.status
        if self.unhealthy_threshold is not None:
            result['UnhealthyThreshold'] = self.unhealthy_threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackendServerPort') is not None:
            self.backend_server_port = m.get('BackendServerPort')
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ForwardPort') is not None:
            self.forward_port = m.get('ForwardPort')
        if m.get('HealthCheck') is not None:
            self.health_check = m.get('HealthCheck')
        if m.get('HealthCheckConnectPort') is not None:
            self.health_check_connect_port = m.get('HealthCheckConnectPort')
        if m.get('HealthCheckDomain') is not None:
            self.health_check_domain = m.get('HealthCheckDomain')
        if m.get('HealthCheckHttpCode') is not None:
            self.health_check_http_code = m.get('HealthCheckHttpCode')
        if m.get('HealthCheckInterval') is not None:
            self.health_check_interval = m.get('HealthCheckInterval')
        if m.get('HealthCheckMethod') is not None:
            self.health_check_method = m.get('HealthCheckMethod')
        if m.get('HealthCheckTimeout') is not None:
            self.health_check_timeout = m.get('HealthCheckTimeout')
        if m.get('HealthCheckURI') is not None:
            self.health_check_uri = m.get('HealthCheckURI')
        if m.get('HealthyThreshold') is not None:
            self.healthy_threshold = m.get('HealthyThreshold')
        if m.get('IdleTimeout') is not None:
            self.idle_timeout = m.get('IdleTimeout')
        if m.get('ListenerForward') is not None:
            self.listener_forward = m.get('ListenerForward')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RequestTimeout') is not None:
            self.request_timeout = m.get('RequestTimeout')
        if m.get('Scheduler') is not None:
            self.scheduler = m.get('Scheduler')
        if m.get('ServerCertificateId') is not None:
            self.server_certificate_id = m.get('ServerCertificateId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UnhealthyThreshold') is not None:
            self.unhealthy_threshold = m.get('UnhealthyThreshold')
        return self


class DescribeLoadBalancerHTTPSListenerAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLoadBalancerHTTPSListenerAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLoadBalancerHTTPSListenerAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLoadBalancerListenMonitorRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        load_balancer_id: str = None,
        proto: str = None,
        start_time: str = None,
        vport: str = None,
    ):
        # The end of the time range to query.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The ID of the ELB instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id
        # The network protocol, such as tcp or udp.
        self.proto = proto
        # The beginning of the time range to query.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The virtual IP address (VIP) port of the ELB instance.
        # 
        # This parameter is required.
        self.vport = vport

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.proto is not None:
            result['Proto'] = self.proto
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.vport is not None:
            result['VPort'] = self.vport
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('Proto') is not None:
            self.proto = m.get('Proto')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('VPort') is not None:
            self.vport = m.get('VPort')
        return self


class DescribeLoadBalancerListenMonitorResponseBodyLoadBalancerMonitorListenData(TeaModel):
    def __init__(
        self,
        act_conns: str = None,
        biz_time: str = None,
        conns: str = None,
        drop_conns: str = None,
        ens_region_id: str = None,
        in_act_conns: str = None,
        in_bytes: str = None,
        in_drop_bytes: str = None,
        in_drop_pkts: str = None,
        in_pkts: str = None,
        in_valid_rs_num: str = None,
        load_balancer_id: str = None,
        out_bytes: str = None,
        out_drop_bytes: str = None,
        out_drop_pkts: str = None,
        out_pkts: str = None,
        proto: str = None,
        vport: str = None,
        valid_rs_num: str = None,
        vip: str = None,
        vni: str = None,
    ):
        # The number of active connections.
        self.act_conns = act_conns
        # The business time.
        self.biz_time = biz_time
        # The number of new connections.
        self.conns = conns
        # The number of dropped connections.
        self.drop_conns = drop_conns
        # The ID of the node to which the ELB instance belongs.
        self.ens_region_id = ens_region_id
        # The number of inactive connections.
        self.in_act_conns = in_act_conns
        # The inbound traffic.
        self.in_bytes = in_bytes
        # The dropped inbound traffic.
        self.in_drop_bytes = in_drop_bytes
        # The number of dropped inbound packets.
        self.in_drop_pkts = in_drop_pkts
        # The number of inbound packets.
        self.in_pkts = in_pkts
        # The number of unavailable servers that are attached to the monitored ELB instance.
        self.in_valid_rs_num = in_valid_rs_num
        # The ID of the ELB instance.
        self.load_balancer_id = load_balancer_id
        # The outbound traffic.
        self.out_bytes = out_bytes
        # The dropped outbound traffic.
        self.out_drop_bytes = out_drop_bytes
        # The number of dropped outbound packets.
        self.out_drop_pkts = out_drop_pkts
        # The number of outbound packets.
        self.out_pkts = out_pkts
        # The network protocol.
        self.proto = proto
        # The VIP port of the ELB instance.
        self.vport = vport
        # The number of available servers that are attached to the monitored ELB instance.
        self.valid_rs_num = valid_rs_num
        # The virtual IP address (VIP) of the instance.
        self.vip = vip
        # The ID of the tunnel.
        self.vni = vni

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.act_conns is not None:
            result['ActConns'] = self.act_conns
        if self.biz_time is not None:
            result['BizTime'] = self.biz_time
        if self.conns is not None:
            result['Conns'] = self.conns
        if self.drop_conns is not None:
            result['DropConns'] = self.drop_conns
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.in_act_conns is not None:
            result['InActConns'] = self.in_act_conns
        if self.in_bytes is not None:
            result['InBytes'] = self.in_bytes
        if self.in_drop_bytes is not None:
            result['InDropBytes'] = self.in_drop_bytes
        if self.in_drop_pkts is not None:
            result['InDropPkts'] = self.in_drop_pkts
        if self.in_pkts is not None:
            result['InPkts'] = self.in_pkts
        if self.in_valid_rs_num is not None:
            result['InValidRsNum'] = self.in_valid_rs_num
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.out_bytes is not None:
            result['OutBytes'] = self.out_bytes
        if self.out_drop_bytes is not None:
            result['OutDropBytes'] = self.out_drop_bytes
        if self.out_drop_pkts is not None:
            result['OutDropPkts'] = self.out_drop_pkts
        if self.out_pkts is not None:
            result['OutPkts'] = self.out_pkts
        if self.proto is not None:
            result['Proto'] = self.proto
        if self.vport is not None:
            result['VPort'] = self.vport
        if self.valid_rs_num is not None:
            result['ValidRsNum'] = self.valid_rs_num
        if self.vip is not None:
            result['Vip'] = self.vip
        if self.vni is not None:
            result['Vni'] = self.vni
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActConns') is not None:
            self.act_conns = m.get('ActConns')
        if m.get('BizTime') is not None:
            self.biz_time = m.get('BizTime')
        if m.get('Conns') is not None:
            self.conns = m.get('Conns')
        if m.get('DropConns') is not None:
            self.drop_conns = m.get('DropConns')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InActConns') is not None:
            self.in_act_conns = m.get('InActConns')
        if m.get('InBytes') is not None:
            self.in_bytes = m.get('InBytes')
        if m.get('InDropBytes') is not None:
            self.in_drop_bytes = m.get('InDropBytes')
        if m.get('InDropPkts') is not None:
            self.in_drop_pkts = m.get('InDropPkts')
        if m.get('InPkts') is not None:
            self.in_pkts = m.get('InPkts')
        if m.get('InValidRsNum') is not None:
            self.in_valid_rs_num = m.get('InValidRsNum')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('OutBytes') is not None:
            self.out_bytes = m.get('OutBytes')
        if m.get('OutDropBytes') is not None:
            self.out_drop_bytes = m.get('OutDropBytes')
        if m.get('OutDropPkts') is not None:
            self.out_drop_pkts = m.get('OutDropPkts')
        if m.get('OutPkts') is not None:
            self.out_pkts = m.get('OutPkts')
        if m.get('Proto') is not None:
            self.proto = m.get('Proto')
        if m.get('VPort') is not None:
            self.vport = m.get('VPort')
        if m.get('ValidRsNum') is not None:
            self.valid_rs_num = m.get('ValidRsNum')
        if m.get('Vip') is not None:
            self.vip = m.get('Vip')
        if m.get('Vni') is not None:
            self.vni = m.get('Vni')
        return self


class DescribeLoadBalancerListenMonitorResponseBody(TeaModel):
    def __init__(
        self,
        load_balancer_monitor_listen_data: List[DescribeLoadBalancerListenMonitorResponseBodyLoadBalancerMonitorListenData] = None,
        request_id: str = None,
    ):
        # The TCP/UDP monitoring data of the ELB instance.
        self.load_balancer_monitor_listen_data = load_balancer_monitor_listen_data
        # Id of the request.
        self.request_id = request_id

    def validate(self):
        if self.load_balancer_monitor_listen_data:
            for k in self.load_balancer_monitor_listen_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LoadBalancerMonitorListenData'] = []
        if self.load_balancer_monitor_listen_data is not None:
            for k in self.load_balancer_monitor_listen_data:
                result['LoadBalancerMonitorListenData'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.load_balancer_monitor_listen_data = []
        if m.get('LoadBalancerMonitorListenData') is not None:
            for k in m.get('LoadBalancerMonitorListenData'):
                temp_model = DescribeLoadBalancerListenMonitorResponseBodyLoadBalancerMonitorListenData()
                self.load_balancer_monitor_listen_data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLoadBalancerListenMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLoadBalancerListenMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLoadBalancerListenMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLoadBalancerListenersRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        listener_port: int = None,
        load_balancer_id: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The description of the image.
        self.description = description
        # The listener port.
        self.listener_port = listener_port
        # The ID of the ELB instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeLoadBalancerListenersResponseBodyListenersListener(TeaModel):
    def __init__(
        self,
        backend_server_port: int = None,
        create_time: str = None,
        description: str = None,
        forward_port: str = None,
        listener_forward: str = None,
        listener_port: str = None,
        load_balancer_id: str = None,
        protocol: str = None,
        status: str = None,
    ):
        # The backend port that is used by the ELB instance. Valid values: **1** to **65535**.
        self.backend_server_port = backend_server_port
        # The timestamp when the listener was created.
        self.create_time = create_time
        # The description of the listener.
        self.description = description
        # The listener port that is used for HTTP-to-HTTPS redirection.
        self.forward_port = forward_port
        # Indicates whether HTTP-to-HTTPS redirection is enabled for the listener. Valid values:
        # 
        # *   **on**\
        # *   **off**\
        self.listener_forward = listener_forward
        # The listening port.
        self.listener_port = listener_port
        # The ID of the ELB instance.
        self.load_balancer_id = load_balancer_id
        # The network transmission protocol that is used by the listener.
        # 
        # *   **tcp**\
        # *   **udp**\
        # *   **http**\
        # *   **https**\
        self.protocol = protocol
        # The status of the listener. Valid values:
        # 
        # *   **running**\
        # *   **stopped**\
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backend_server_port is not None:
            result['BackendServerPort'] = self.backend_server_port
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.forward_port is not None:
            result['ForwardPort'] = self.forward_port
        if self.listener_forward is not None:
            result['ListenerForward'] = self.listener_forward
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackendServerPort') is not None:
            self.backend_server_port = m.get('BackendServerPort')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ForwardPort') is not None:
            self.forward_port = m.get('ForwardPort')
        if m.get('ListenerForward') is not None:
            self.listener_forward = m.get('ListenerForward')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeLoadBalancerListenersResponseBodyListeners(TeaModel):
    def __init__(
        self,
        listener: List[DescribeLoadBalancerListenersResponseBodyListenersListener] = None,
    ):
        self.listener = listener

    def validate(self):
        if self.listener:
            for k in self.listener:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Listener'] = []
        if self.listener is not None:
            for k in self.listener:
                result['Listener'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.listener = []
        if m.get('Listener') is not None:
            for k in m.get('Listener'):
                temp_model = DescribeLoadBalancerListenersResponseBodyListenersListener()
                self.listener.append(temp_model.from_map(k))
        return self


class DescribeLoadBalancerListenersResponseBody(TeaModel):
    def __init__(
        self,
        listeners: DescribeLoadBalancerListenersResponseBodyListeners = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The listeners of the ELB instance.
        self.listeners = listeners
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries.
        self.total_count = total_count

    def validate(self):
        if self.listeners:
            self.listeners.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.listeners is not None:
            result['Listeners'] = self.listeners.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Listeners') is not None:
            temp_model = DescribeLoadBalancerListenersResponseBodyListeners()
            self.listeners = temp_model.from_map(m['Listeners'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeLoadBalancerListenersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLoadBalancerListenersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLoadBalancerListenersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLoadBalancerSpecRequest(TeaModel):
    def __init__(
        self,
        load_balancer_spec: str = None,
    ):
        # The specifications of the ELB instance.
        self.load_balancer_spec = load_balancer_spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.load_balancer_spec is not None:
            result['LoadBalancerSpec'] = self.load_balancer_spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LoadBalancerSpec') is not None:
            self.load_balancer_spec = m.get('LoadBalancerSpec')
        return self


class DescribeLoadBalancerSpecResponseBodyLoadBalancerSpecs(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        load_balancer_spec: str = None,
    ):
        # The display name of the instance type.
        self.display_name = display_name
        # The specifications of the ELB instance.
        self.load_balancer_spec = load_balancer_spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.load_balancer_spec is not None:
            result['LoadBalancerSpec'] = self.load_balancer_spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('LoadBalancerSpec') is not None:
            self.load_balancer_spec = m.get('LoadBalancerSpec')
        return self


class DescribeLoadBalancerSpecResponseBody(TeaModel):
    def __init__(
        self,
        load_balancer_specs: List[DescribeLoadBalancerSpecResponseBodyLoadBalancerSpecs] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The specifications. Valid values:
        self.load_balancer_specs = load_balancer_specs
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Maximum value: 100. Default value: 10.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.load_balancer_specs:
            for k in self.load_balancer_specs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LoadBalancerSpecs'] = []
        if self.load_balancer_specs is not None:
            for k in self.load_balancer_specs:
                result['LoadBalancerSpecs'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.load_balancer_specs = []
        if m.get('LoadBalancerSpecs') is not None:
            for k in m.get('LoadBalancerSpecs'):
                temp_model = DescribeLoadBalancerSpecResponseBodyLoadBalancerSpecs()
                self.load_balancer_specs.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeLoadBalancerSpecResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLoadBalancerSpecResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLoadBalancerSpecResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLoadBalancerTCPListenerAttributeRequest(TeaModel):
    def __init__(
        self,
        listener_port: int = None,
        load_balancer_id: str = None,
    ):
        # The listening port that you want to query. Valid values: **1** to **65535**.
        # 
        # This parameter is required.
        self.listener_port = listener_port
        # The ID of the ELB instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        return self


class DescribeLoadBalancerTCPListenerAttributeResponseBody(TeaModel):
    def __init__(
        self,
        backend_server_port: int = None,
        bandwidth: int = None,
        description: str = None,
        eip_transmit: str = None,
        established_timeout: int = None,
        health_check: str = None,
        health_check_connect_port: int = None,
        health_check_connect_timeout: int = None,
        health_check_domain: str = None,
        health_check_http_code: str = None,
        health_check_interval: int = None,
        health_check_type: str = None,
        health_check_uri: str = None,
        healthy_threshold: int = None,
        listener_port: int = None,
        persistence_timeout: int = None,
        request_id: str = None,
        scheduler: str = None,
        status: str = None,
        unhealthy_threshold: int = None,
    ):
        # The port used by the backend server of the ELB instance. Valid values: **1** to **65535**.
        self.backend_server_port = backend_server_port
        # The peak bandwidth of the Edge Load Balancer (ELB) instance. The default value is -1, which indicates that the bandwidth is not limited.
        self.bandwidth = bandwidth
        # The name of the listener.
        self.description = description
        # Indicates whether EIP pass-through is enabled. Valid values:
        # 
        # *   **on**\
        # *   **off** (default)
        self.eip_transmit = eip_transmit
        # The timeout period of a connection. Valid values: **10** to **900**. Unit: seconds.
        self.established_timeout = established_timeout
        # Indicates whether the health check feature is enabled. Valid values:
        # 
        # *   **on**\
        # *   **off**\
        self.health_check = health_check
        # The port that is used for health checks. Valid values: **1** to **65535**. If an empty string is returned for this parameter, the port specified by BackendServerPort is used for health checks.
        # 
        # >  This parameter is returned only if you set HealthCheck to on.
        self.health_check_connect_port = health_check_connect_port
        # The timeout period for a health check response. If a backend server does not respond within the specified timeout period, the server fails the health check.
        # 
        # *   Default value: 5.
        # *   Valid values: **1** to **300**.
        # *   Unit: seconds.
        # 
        # > 
        # 
        # *   This parameter takes effect only if the HealthCheck parameter is set to on.
        # 
        # *   If the value of the HealthCheckTimeout property is smaller than the value of the HealthCheckInterval property, the timeout period specified by the HealthCheckTimeout property becomes invalid and the value of the HealthCheckInterval property is used as the timeout period.
        self.health_check_connect_timeout = health_check_connect_timeout
        # The domain name that is used for health checks.
        # 
        # >  This parameter is returned only if you set HealthCheck to on.
        self.health_check_domain = health_check_domain
        # The HTTP status codes for a successful health check. Valid values:
        # 
        # *   **http_2xx** (default)
        # *   **http_3xx**\
        # *   **http_4xx**\
        # *   **http_5xx**\
        # 
        # >  This parameter is returned only if you set HealthCheck to on.
        self.health_check_http_code = health_check_http_code
        # The interval at which health checks are performed. Valid values: **1** to **50**. Unit: seconds.
        self.health_check_interval = health_check_interval
        # The type of health checks. Valid values:
        # 
        # *   **tcp** (default)
        # *   **http**\
        self.health_check_type = health_check_type
        # The URI used for health checks. The URI must be **1** to **80** characters in length.
        # 
        # > 
        # 
        # *   A URL must start with a forward slash (`/`) but cannot contain only forward slashes (`/`).
        # 
        # *   This parameter takes effect only if the HealthCheck parameter is set to on.
        self.health_check_uri = health_check_uri
        # The number of consecutive successful health checks that must occur before an unhealthy and inaccessible backend server is declared healthy and accessible. Valid values: **2** to **10**.
        # 
        # >  This parameter is returned only if you set HealthCheck to on.
        self.healthy_threshold = healthy_threshold
        # The frontend port that is used by the ELB instance.
        self.listener_port = listener_port
        # The timeout period of session persistence.
        # 
        # *   Default value: 0. If the default value is used, the system disables session persistence.
        # *   Valid values: **0** to **3600**.
        # *   Unit: seconds.
        self.persistence_timeout = persistence_timeout
        # The ID of the request.
        self.request_id = request_id
        # The routing algorithm. Valid values:
        # 
        # *   **wrr**: Backend servers with higher weights receive more requests than those with lower weights.
        # *   **wlc**: Requests are distributed based on the weight and load of each backend server. The load refers to the number of connections to a backend server. If two backend servers have the same weight, the backend server that has fewer connections receives more requests.
        # *   **rr**: Requests are distributed to backend servers in sequence.
        # *   **sch**: consistent hashing that is based on source IP addresses. Requests from the same source IP address are distributed to the same backend server.
        # *   **qch**: consistent hashing that is based on QUIC connection IDs. Requests that contain the same QUIC connection ID are distributed to the same backend server.
        # *   **iqch**: consistent hashing that is based on specific three bytes of the iQUIC CIDs. Requests whose second to fourth bytes are the same are distributed to the same backend server.
        self.scheduler = scheduler
        # The status of the listener. Valid values:
        # 
        # *   **Running**\
        # *   **Stopped**\
        # *   **Starting**\
        # *   **Configuring**\
        # *   **Stopping**\
        self.status = status
        # The number of consecutive failed health checks that must occur before a healthy and accessible backend server is declared unhealthy and inaccessible. Valid values: **2** to **10**.
        # 
        # >  This parameter is returned only if you set HealthCheck to on.
        self.unhealthy_threshold = unhealthy_threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backend_server_port is not None:
            result['BackendServerPort'] = self.backend_server_port
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.description is not None:
            result['Description'] = self.description
        if self.eip_transmit is not None:
            result['EipTransmit'] = self.eip_transmit
        if self.established_timeout is not None:
            result['EstablishedTimeout'] = self.established_timeout
        if self.health_check is not None:
            result['HealthCheck'] = self.health_check
        if self.health_check_connect_port is not None:
            result['HealthCheckConnectPort'] = self.health_check_connect_port
        if self.health_check_connect_timeout is not None:
            result['HealthCheckConnectTimeout'] = self.health_check_connect_timeout
        if self.health_check_domain is not None:
            result['HealthCheckDomain'] = self.health_check_domain
        if self.health_check_http_code is not None:
            result['HealthCheckHttpCode'] = self.health_check_http_code
        if self.health_check_interval is not None:
            result['HealthCheckInterval'] = self.health_check_interval
        if self.health_check_type is not None:
            result['HealthCheckType'] = self.health_check_type
        if self.health_check_uri is not None:
            result['HealthCheckURI'] = self.health_check_uri
        if self.healthy_threshold is not None:
            result['HealthyThreshold'] = self.healthy_threshold
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.persistence_timeout is not None:
            result['PersistenceTimeout'] = self.persistence_timeout
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.scheduler is not None:
            result['Scheduler'] = self.scheduler
        if self.status is not None:
            result['Status'] = self.status
        if self.unhealthy_threshold is not None:
            result['UnhealthyThreshold'] = self.unhealthy_threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackendServerPort') is not None:
            self.backend_server_port = m.get('BackendServerPort')
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EipTransmit') is not None:
            self.eip_transmit = m.get('EipTransmit')
        if m.get('EstablishedTimeout') is not None:
            self.established_timeout = m.get('EstablishedTimeout')
        if m.get('HealthCheck') is not None:
            self.health_check = m.get('HealthCheck')
        if m.get('HealthCheckConnectPort') is not None:
            self.health_check_connect_port = m.get('HealthCheckConnectPort')
        if m.get('HealthCheckConnectTimeout') is not None:
            self.health_check_connect_timeout = m.get('HealthCheckConnectTimeout')
        if m.get('HealthCheckDomain') is not None:
            self.health_check_domain = m.get('HealthCheckDomain')
        if m.get('HealthCheckHttpCode') is not None:
            self.health_check_http_code = m.get('HealthCheckHttpCode')
        if m.get('HealthCheckInterval') is not None:
            self.health_check_interval = m.get('HealthCheckInterval')
        if m.get('HealthCheckType') is not None:
            self.health_check_type = m.get('HealthCheckType')
        if m.get('HealthCheckURI') is not None:
            self.health_check_uri = m.get('HealthCheckURI')
        if m.get('HealthyThreshold') is not None:
            self.healthy_threshold = m.get('HealthyThreshold')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('PersistenceTimeout') is not None:
            self.persistence_timeout = m.get('PersistenceTimeout')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Scheduler') is not None:
            self.scheduler = m.get('Scheduler')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UnhealthyThreshold') is not None:
            self.unhealthy_threshold = m.get('UnhealthyThreshold')
        return self


class DescribeLoadBalancerTCPListenerAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLoadBalancerTCPListenerAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLoadBalancerTCPListenerAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLoadBalancerUDPListenerAttributeRequest(TeaModel):
    def __init__(
        self,
        listener_port: int = None,
        load_balancer_id: str = None,
    ):
        # The listening port that you want to query. Valid values: **1** to **65535**.
        # 
        # This parameter is required.
        self.listener_port = listener_port
        # The ID of the ELB instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        return self


class DescribeLoadBalancerUDPListenerAttributeResponseBody(TeaModel):
    def __init__(
        self,
        backend_server_port: int = None,
        bandwidth: int = None,
        description: str = None,
        eip_transmit: str = None,
        established_timeout: int = None,
        health_check: str = None,
        health_check_connect_port: int = None,
        health_check_connect_timeout: int = None,
        health_check_exp: str = None,
        health_check_interval: int = None,
        health_check_req: str = None,
        healthy_threshold: int = None,
        listener_port: int = None,
        request_id: str = None,
        scheduler: str = None,
        status: str = None,
        unhealthy_threshold: int = None,
    ):
        # The port used by the backend ELB server of the ELB instance. Valid values: **1** to **65535**.
        self.backend_server_port = backend_server_port
        # The peak bandwidth of the Edge Load Balancer (ELB) instance. The default value is -1, which indicates that the bandwidth is not limited.
        self.bandwidth = bandwidth
        # The name of the listener.
        self.description = description
        # Indicates whether EIP pass-through is enabled. Valid values:
        # 
        # *   **on**\
        # *   **off** (default)
        self.eip_transmit = eip_transmit
        # The timeout period of a connection. Valid values: **10** to **900**. Unit: seconds.
        self.established_timeout = established_timeout
        # Specifies whether to enable the health check feature. Valid values:
        # 
        # *   **on**\
        # *   **off**\
        self.health_check = health_check
        # The port that is used for health checks. Valid values: **1** to **65535**. If you leave this parameter empty, the port specified by BackendServerPort is used for health checks.
        self.health_check_connect_port = health_check_connect_port
        # The timeout period for a health check response. If a backend server does not respond within the specified timeout period, the server fails the health check.
        # 
        # *   Default value: 5.
        # *   Valid values: **1** to **300**.
        # *   Unit: seconds.
        # 
        # > 
        # 
        # *   This parameter takes effect only if the HealthCheck parameter is set to on.
        # 
        # *   If the value of the HealthCheckTimeout property is smaller than the value of the HealthCheckInterval property, the timeout period specified by the HealthCheckTimeout property becomes invalid and the value of the HealthCheckInterval property is used as the timeout period.
        self.health_check_connect_timeout = health_check_connect_timeout
        # The response string for UDP listener health checks. The string can be up to 64 characters in length and can contain only letters and digits.
        self.health_check_exp = health_check_exp
        # The interval at which health checks are performed. Valid values: **1** to **50**. Unit: seconds.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.health_check_interval = health_check_interval
        # The request string for UDP listener health checks. The string can be up to 64 characters in length and can contain only letters and digits.
        self.health_check_req = health_check_req
        # The number of consecutive successful health checks that must occur before an unhealthy and inaccessible backend server is declared healthy and accessible. Valid values: **2** to **10**.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.healthy_threshold = healthy_threshold
        # The listener port.
        self.listener_port = listener_port
        # The ID of the request.
        self.request_id = request_id
        # The routing algorithm. Valid values:
        # 
        # *   **wrr**: Backend servers with higher weights receive more requests than those with lower weights.
        # *   **wlc**: Requests are distributed based on the weight and load of each backend server. The load refers to the number of connections to a backend server. If two backend servers have the same weight, the backend server that has fewer connections receives more requests.
        # *   **rr**: Requests are distributed to backend servers in sequence.
        # *   **sch**: consistent hashing that is based on source IP addresses. Requests from the same source IP address are distributed to the same backend server.
        # *   **qch**: consistent hashing that is based on QUIC connection IDs. Requests that contain the same QUIC connection ID are distributed to the same backend server.
        # *   **iqch**: consistent hashing that is based on specific three bytes of the iQUIC CIDs. Requests whose second to fourth bytes are the same are distributed to the same backend server.
        self.scheduler = scheduler
        # The status of the listener. Valid values:
        # 
        # *   **Running**\
        # *   **Stopped**\
        # *   **Starting**\
        # *   **Configuring**\
        # *   **Stopping**\
        self.status = status
        # The number of consecutive failed health checks that must occur before a healthy and accessible backend server is declared unhealthy and inaccessible. Valid values: **2** to **10**.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.unhealthy_threshold = unhealthy_threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backend_server_port is not None:
            result['BackendServerPort'] = self.backend_server_port
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.description is not None:
            result['Description'] = self.description
        if self.eip_transmit is not None:
            result['EipTransmit'] = self.eip_transmit
        if self.established_timeout is not None:
            result['EstablishedTimeout'] = self.established_timeout
        if self.health_check is not None:
            result['HealthCheck'] = self.health_check
        if self.health_check_connect_port is not None:
            result['HealthCheckConnectPort'] = self.health_check_connect_port
        if self.health_check_connect_timeout is not None:
            result['HealthCheckConnectTimeout'] = self.health_check_connect_timeout
        if self.health_check_exp is not None:
            result['HealthCheckExp'] = self.health_check_exp
        if self.health_check_interval is not None:
            result['HealthCheckInterval'] = self.health_check_interval
        if self.health_check_req is not None:
            result['HealthCheckReq'] = self.health_check_req
        if self.healthy_threshold is not None:
            result['HealthyThreshold'] = self.healthy_threshold
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.scheduler is not None:
            result['Scheduler'] = self.scheduler
        if self.status is not None:
            result['Status'] = self.status
        if self.unhealthy_threshold is not None:
            result['UnhealthyThreshold'] = self.unhealthy_threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackendServerPort') is not None:
            self.backend_server_port = m.get('BackendServerPort')
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EipTransmit') is not None:
            self.eip_transmit = m.get('EipTransmit')
        if m.get('EstablishedTimeout') is not None:
            self.established_timeout = m.get('EstablishedTimeout')
        if m.get('HealthCheck') is not None:
            self.health_check = m.get('HealthCheck')
        if m.get('HealthCheckConnectPort') is not None:
            self.health_check_connect_port = m.get('HealthCheckConnectPort')
        if m.get('HealthCheckConnectTimeout') is not None:
            self.health_check_connect_timeout = m.get('HealthCheckConnectTimeout')
        if m.get('HealthCheckExp') is not None:
            self.health_check_exp = m.get('HealthCheckExp')
        if m.get('HealthCheckInterval') is not None:
            self.health_check_interval = m.get('HealthCheckInterval')
        if m.get('HealthCheckReq') is not None:
            self.health_check_req = m.get('HealthCheckReq')
        if m.get('HealthyThreshold') is not None:
            self.healthy_threshold = m.get('HealthyThreshold')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Scheduler') is not None:
            self.scheduler = m.get('Scheduler')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UnhealthyThreshold') is not None:
            self.unhealthy_threshold = m.get('UnhealthyThreshold')
        return self


class DescribeLoadBalancerUDPListenerAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLoadBalancerUDPListenerAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLoadBalancerUDPListenerAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLoadBalancersRequest(TeaModel):
    def __init__(
        self,
        address: str = None,
        ens_region_id: str = None,
        ens_region_ids: List[str] = None,
        load_balancer_id: str = None,
        load_balancer_name: str = None,
        load_balancer_status: str = None,
        load_balancer_type: str = None,
        network_id: str = None,
        page_number: int = None,
        page_size: int = None,
        server_id: str = None,
        v_switch_id: str = None,
    ):
        # The IP address that the ELB instance uses to provide services.
        self.address = address
        # The ID of the Edge Node Service (ENS) node.
        self.ens_region_id = ens_region_id
        # The IDs of the Edge Node Service (ENS) nodes.
        self.ens_region_ids = ens_region_ids
        # The ID of the ELB instance.
        self.load_balancer_id = load_balancer_id
        # The name of the ELB instance.
        self.load_balancer_name = load_balancer_name
        # The status of the listener for the ELB instance. Valid values:
        # 
        # *   **Active**: The listener for the instance can forward the received traffic based on forwarding rules.
        # *   **InActive**: The listener for the instance does not forward the received traffic.
        self.load_balancer_status = load_balancer_status
        self.load_balancer_type = load_balancer_type
        # The ID of the network.
        self.network_id = network_id
        # The page number. Default value: 1.
        self.page_number = page_number
        # The number of entries to return on each page. Default value: 10. Valid values: **10** to **100**.
        self.page_size = page_size
        # The ID of the backend server.
        self.server_id = server_id
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.ens_region_ids is not None:
            result['EnsRegionIds'] = self.ens_region_ids
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.load_balancer_name is not None:
            result['LoadBalancerName'] = self.load_balancer_name
        if self.load_balancer_status is not None:
            result['LoadBalancerStatus'] = self.load_balancer_status
        if self.load_balancer_type is not None:
            result['LoadBalancerType'] = self.load_balancer_type
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.server_id is not None:
            result['ServerId'] = self.server_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('EnsRegionIds') is not None:
            self.ens_region_ids = m.get('EnsRegionIds')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('LoadBalancerName') is not None:
            self.load_balancer_name = m.get('LoadBalancerName')
        if m.get('LoadBalancerStatus') is not None:
            self.load_balancer_status = m.get('LoadBalancerStatus')
        if m.get('LoadBalancerType') is not None:
            self.load_balancer_type = m.get('LoadBalancerType')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ServerId') is not None:
            self.server_id = m.get('ServerId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer(TeaModel):
    def __init__(
        self,
        address: str = None,
        address_ipversion: str = None,
        address_type: str = None,
        create_time: str = None,
        ens_region_id: str = None,
        load_balancer_id: str = None,
        load_balancer_name: str = None,
        load_balancer_status: str = None,
        load_balancer_type: str = None,
        network_id: str = None,
        pay_type: str = None,
        v_switch_id: str = None,
    ):
        # The IP address that the ELB instance uses to provide services.
        self.address = address
        # The IP version. Valid values: ipv4 and ipv6.
        self.address_ipversion = address_ipversion
        self.address_type = address_type
        # The time when the ELB instance was created. The time is displayed in UTC.
        self.create_time = create_time
        # The ID of the ENS node.
        self.ens_region_id = ens_region_id
        # The ID of the ELB instance.
        self.load_balancer_id = load_balancer_id
        # The name of the ELB instance.
        self.load_balancer_name = load_balancer_name
        # The status of the listener for the ELB instance. Valid values:
        # 
        # *   **Active**: The listener for the instance can forward the received traffic based on forwarding rules.
        # *   **InActive**: The listener for the instance does not forward the received traffic.
        self.load_balancer_status = load_balancer_status
        self.load_balancer_type = load_balancer_type
        # The ID of the network.
        self.network_id = network_id
        # The billing method. Valid values:
        # 
        # *   **PrePaid**: subscription.
        # *   **PostPaid**: pay-as-you-go. Only this billing method is supported.
        self.pay_type = pay_type
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.address_ipversion is not None:
            result['AddressIPVersion'] = self.address_ipversion
        if self.address_type is not None:
            result['AddressType'] = self.address_type
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.load_balancer_name is not None:
            result['LoadBalancerName'] = self.load_balancer_name
        if self.load_balancer_status is not None:
            result['LoadBalancerStatus'] = self.load_balancer_status
        if self.load_balancer_type is not None:
            result['LoadBalancerType'] = self.load_balancer_type
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.pay_type is not None:
            result['PayType'] = self.pay_type
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AddressIPVersion') is not None:
            self.address_ipversion = m.get('AddressIPVersion')
        if m.get('AddressType') is not None:
            self.address_type = m.get('AddressType')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('LoadBalancerName') is not None:
            self.load_balancer_name = m.get('LoadBalancerName')
        if m.get('LoadBalancerStatus') is not None:
            self.load_balancer_status = m.get('LoadBalancerStatus')
        if m.get('LoadBalancerType') is not None:
            self.load_balancer_type = m.get('LoadBalancerType')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('PayType') is not None:
            self.pay_type = m.get('PayType')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeLoadBalancersResponseBodyLoadBalancers(TeaModel):
    def __init__(
        self,
        load_balancer: List[DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer] = None,
    ):
        self.load_balancer = load_balancer

    def validate(self):
        if self.load_balancer:
            for k in self.load_balancer:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LoadBalancer'] = []
        if self.load_balancer is not None:
            for k in self.load_balancer:
                result['LoadBalancer'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.load_balancer = []
        if m.get('LoadBalancer') is not None:
            for k in m.get('LoadBalancer'):
                temp_model = DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer()
                self.load_balancer.append(temp_model.from_map(k))
        return self


class DescribeLoadBalancersResponseBody(TeaModel):
    def __init__(
        self,
        load_balancers: DescribeLoadBalancersResponseBodyLoadBalancers = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # An array of ELB instances.
        self.load_balancers = load_balancers
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Valid values: **10** to **100**.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.load_balancers:
            self.load_balancers.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.load_balancers is not None:
            result['LoadBalancers'] = self.load_balancers.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LoadBalancers') is not None:
            temp_model = DescribeLoadBalancersResponseBodyLoadBalancers()
            self.load_balancers = temp_model.from_map(m['LoadBalancers'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeLoadBalancersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLoadBalancersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLoadBalancersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMeasurementDataRequest(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        start_date: str = None,
    ):
        # The end of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_date = end_date
        # The beginning of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        return self


class DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData(TeaModel):
    def __init__(
        self,
        cost_code: str = None,
        cost_name: str = None,
        cost_val: int = None,
    ):
        # The code of the bandwidth plan.
        self.cost_code = cost_code
        # The name of the bandwidth plan.
        self.cost_name = cost_name
        # The bandwidth consumption. Unit: bit/second.
        self.cost_val = cost_val

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cost_code is not None:
            result['CostCode'] = self.cost_code
        if self.cost_name is not None:
            result['CostName'] = self.cost_name
        if self.cost_val is not None:
            result['CostVal'] = self.cost_val
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CostCode') is not None:
            self.cost_code = m.get('CostCode')
        if m.get('CostName') is not None:
            self.cost_name = m.get('CostName')
        if m.get('CostVal') is not None:
            self.cost_val = m.get('CostVal')
        return self


class DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas(TeaModel):
    def __init__(
        self,
        band_width_fee_data: List[DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData] = None,
    ):
        self.band_width_fee_data = band_width_fee_data

    def validate(self):
        if self.band_width_fee_data:
            for k in self.band_width_fee_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BandWidthFeeData'] = []
        if self.band_width_fee_data is not None:
            for k in self.band_width_fee_data:
                result['BandWidthFeeData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.band_width_fee_data = []
        if m.get('BandWidthFeeData') is not None:
            for k in m.get('BandWidthFeeData'):
                temp_model = DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData()
                self.band_width_fee_data.append(temp_model.from_map(k))
        return self


class DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeData(TeaModel):
    def __init__(
        self,
        memory: int = None,
        storage: int = None,
        vcpu: int = None,
    ):
        # The memory size. Unit: GB.
        self.memory = memory
        # The storage capacity. Unit: GB.
        self.storage = storage
        # The number of vCPUs.
        self.vcpu = vcpu

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.storage is not None:
            result['Storage'] = self.storage
        if self.vcpu is not None:
            result['Vcpu'] = self.vcpu
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('Storage') is not None:
            self.storage = m.get('Storage')
        if m.get('Vcpu') is not None:
            self.vcpu = m.get('Vcpu')
        return self


class DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetailsResourceFeeDataDetail(TeaModel):
    def __init__(
        self,
        cost_code: str = None,
        cost_name: str = None,
        cost_val: int = None,
        resource_type: str = None,
    ):
        # The code of the resource.
        self.cost_code = cost_code
        # The name of the resource.
        self.cost_name = cost_name
        # The consumption of the resource.
        # 
        # *   Memory unit: GB.
        # *   CPU unit: vCPU.
        # *   Storage unit: GB.
        self.cost_val = cost_val
        # The type of the resource.
        self.resource_type = resource_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cost_code is not None:
            result['CostCode'] = self.cost_code
        if self.cost_name is not None:
            result['CostName'] = self.cost_name
        if self.cost_val is not None:
            result['CostVal'] = self.cost_val
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CostCode') is not None:
            self.cost_code = m.get('CostCode')
        if m.get('CostName') is not None:
            self.cost_name = m.get('CostName')
        if m.get('CostVal') is not None:
            self.cost_val = m.get('CostVal')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetails(TeaModel):
    def __init__(
        self,
        resource_fee_data_detail: List[DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetailsResourceFeeDataDetail] = None,
    ):
        self.resource_fee_data_detail = resource_fee_data_detail

    def validate(self):
        if self.resource_fee_data_detail:
            for k in self.resource_fee_data_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ResourceFeeDataDetail'] = []
        if self.resource_fee_data_detail is not None:
            for k in self.resource_fee_data_detail:
                result['ResourceFeeDataDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.resource_fee_data_detail = []
        if m.get('ResourceFeeDataDetail') is not None:
            for k in m.get('ResourceFeeDataDetail'):
                temp_model = DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetailsResourceFeeDataDetail()
                self.resource_fee_data_detail.append(temp_model.from_map(k))
        return self


class DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementData(TeaModel):
    def __init__(
        self,
        band_width_fee_datas: DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas = None,
        charge_model: str = None,
        cost_cycle: str = None,
        cost_end_time: str = None,
        cost_start_time: str = None,
        resource_fee_data: DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeData = None,
        resource_fee_data_details: DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetails = None,
    ):
        # The bandwidth data returned.
        self.band_width_fee_datas = band_width_fee_datas
        # The metering method. Valid values:
        # 
        # *   ChargeByUnified: unified metering.
        # *   ChargeByGrade: differential metering.
        self.charge_model = charge_model
        # The metering cycle.
        self.cost_cycle = cost_cycle
        # The end time of the metering cycle.
        self.cost_end_time = cost_end_time
        # The start time of the metering cycle.
        self.cost_start_time = cost_start_time
        # The information about computing resources.
        self.resource_fee_data = resource_fee_data
        # Details of the computing resources.
        self.resource_fee_data_details = resource_fee_data_details

    def validate(self):
        if self.band_width_fee_datas:
            self.band_width_fee_datas.validate()
        if self.resource_fee_data:
            self.resource_fee_data.validate()
        if self.resource_fee_data_details:
            self.resource_fee_data_details.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.band_width_fee_datas is not None:
            result['BandWidthFeeDatas'] = self.band_width_fee_datas.to_map()
        if self.charge_model is not None:
            result['ChargeModel'] = self.charge_model
        if self.cost_cycle is not None:
            result['CostCycle'] = self.cost_cycle
        if self.cost_end_time is not None:
            result['CostEndTime'] = self.cost_end_time
        if self.cost_start_time is not None:
            result['CostStartTime'] = self.cost_start_time
        if self.resource_fee_data is not None:
            result['ResourceFeeData'] = self.resource_fee_data.to_map()
        if self.resource_fee_data_details is not None:
            result['ResourceFeeDataDetails'] = self.resource_fee_data_details.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BandWidthFeeDatas') is not None:
            temp_model = DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas()
            self.band_width_fee_datas = temp_model.from_map(m['BandWidthFeeDatas'])
        if m.get('ChargeModel') is not None:
            self.charge_model = m.get('ChargeModel')
        if m.get('CostCycle') is not None:
            self.cost_cycle = m.get('CostCycle')
        if m.get('CostEndTime') is not None:
            self.cost_end_time = m.get('CostEndTime')
        if m.get('CostStartTime') is not None:
            self.cost_start_time = m.get('CostStartTime')
        if m.get('ResourceFeeData') is not None:
            temp_model = DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeData()
            self.resource_fee_data = temp_model.from_map(m['ResourceFeeData'])
        if m.get('ResourceFeeDataDetails') is not None:
            temp_model = DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetails()
            self.resource_fee_data_details = temp_model.from_map(m['ResourceFeeDataDetails'])
        return self


class DescribeMeasurementDataResponseBodyMeasurementDatas(TeaModel):
    def __init__(
        self,
        measurement_data: List[DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementData] = None,
    ):
        self.measurement_data = measurement_data

    def validate(self):
        if self.measurement_data:
            for k in self.measurement_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MeasurementData'] = []
        if self.measurement_data is not None:
            for k in self.measurement_data:
                result['MeasurementData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.measurement_data = []
        if m.get('MeasurementData') is not None:
            for k in m.get('MeasurementData'):
                temp_model = DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementData()
                self.measurement_data.append(temp_model.from_map(k))
        return self


class DescribeMeasurementDataResponseBody(TeaModel):
    def __init__(
        self,
        measurement_datas: DescribeMeasurementDataResponseBodyMeasurementDatas = None,
        request_id: str = None,
    ):
        # The metering data returned.
        self.measurement_datas = measurement_datas
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.measurement_datas:
            self.measurement_datas.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.measurement_datas is not None:
            result['MeasurementDatas'] = self.measurement_datas.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MeasurementDatas') is not None:
            temp_model = DescribeMeasurementDataResponseBodyMeasurementDatas()
            self.measurement_datas = temp_model.from_map(m['MeasurementDatas'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeMeasurementDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeMeasurementDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMeasurementDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMountTargetsRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        file_system_id: str = None,
        mount_target_name: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The ID of the region.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        # The ID of the file system.
        # 
        # This parameter is required.
        self.file_system_id = file_system_id
        # The name of the mount target.
        self.mount_target_name = mount_target_name
        # The number of the page to return. Pages start from page 1. Default value: 1
        self.page_number = page_number
        # The number of entries returned per page. Maximum value: 100. Default value: 10.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.file_system_id is not None:
            result['FileSystemId'] = self.file_system_id
        if self.mount_target_name is not None:
            result['MountTargetName'] = self.mount_target_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('FileSystemId') is not None:
            self.file_system_id = m.get('FileSystemId')
        if m.get('MountTargetName') is not None:
            self.mount_target_name = m.get('MountTargetName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeMountTargetsResponseBodyMountTargets(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        file_system_id: str = None,
        mount_target_domain: str = None,
        mount_target_name: str = None,
        net_work_id: str = None,
        status: str = None,
    ):
        # The ID of the region.
        self.ens_region_id = ens_region_id
        # The ID of the file system.
        self.file_system_id = file_system_id
        # The path of the mount target.
        self.mount_target_domain = mount_target_domain
        # The name of the mount target.
        self.mount_target_name = mount_target_name
        # The ID of the network.
        self.net_work_id = net_work_id
        # The state of the mount target. Valid values:
        # 
        # *   active: The mount target is available.
        # *   inactive: The mount target is unavailable.
        # *   pending: A task is being queued for the mount target.
        # *   deleting: The mount target is being deleted.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.file_system_id is not None:
            result['FileSystemId'] = self.file_system_id
        if self.mount_target_domain is not None:
            result['MountTargetDomain'] = self.mount_target_domain
        if self.mount_target_name is not None:
            result['MountTargetName'] = self.mount_target_name
        if self.net_work_id is not None:
            result['NetWorkId'] = self.net_work_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('FileSystemId') is not None:
            self.file_system_id = m.get('FileSystemId')
        if m.get('MountTargetDomain') is not None:
            self.mount_target_domain = m.get('MountTargetDomain')
        if m.get('MountTargetName') is not None:
            self.mount_target_name = m.get('MountTargetName')
        if m.get('NetWorkId') is not None:
            self.net_work_id = m.get('NetWorkId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeMountTargetsResponseBody(TeaModel):
    def __init__(
        self,
        mount_targets: List[DescribeMountTargetsResponseBodyMountTargets] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The information about mount targets.
        self.mount_targets = mount_targets
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of mount targets.
        self.total_count = total_count

    def validate(self):
        if self.mount_targets:
            for k in self.mount_targets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MountTargets'] = []
        if self.mount_targets is not None:
            for k in self.mount_targets:
                result['MountTargets'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.mount_targets = []
        if m.get('MountTargets') is not None:
            for k in m.get('MountTargets'):
                temp_model = DescribeMountTargetsResponseBodyMountTargets()
                self.mount_targets.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeMountTargetsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeMountTargetsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMountTargetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNCInformationRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        resource_id: str = None,
    ):
        self.ens_region_id = ens_region_id
        self.resource_id = resource_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        return self


class DescribeNCInformationResponseBodyDataCpu(TeaModel):
    def __init__(
        self,
        display: bool = None,
        oversell_ratio: int = None,
        remain: int = None,
        reserve_disable: bool = None,
        reserve_disable_total: int = None,
        reserved: int = None,
        status_disable: bool = None,
        status_disable_total: int = None,
        total: int = None,
        type: str = None,
        used: int = None,
        used_ratio: int = None,
    ):
        self.display = display
        self.oversell_ratio = oversell_ratio
        self.remain = remain
        self.reserve_disable = reserve_disable
        self.reserve_disable_total = reserve_disable_total
        self.reserved = reserved
        self.status_disable = status_disable
        self.status_disable_total = status_disable_total
        self.total = total
        self.type = type
        self.used = used
        self.used_ratio = used_ratio

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.oversell_ratio is not None:
            result['OversellRatio'] = self.oversell_ratio
        if self.remain is not None:
            result['Remain'] = self.remain
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.reserve_disable_total is not None:
            result['ReserveDisableTotal'] = self.reserve_disable_total
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.status_disable_total is not None:
            result['StatusDisableTotal'] = self.status_disable_total
        if self.total is not None:
            result['Total'] = self.total
        if self.type is not None:
            result['Type'] = self.type
        if self.used is not None:
            result['Used'] = self.used
        if self.used_ratio is not None:
            result['UsedRatio'] = self.used_ratio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('OversellRatio') is not None:
            self.oversell_ratio = m.get('OversellRatio')
        if m.get('Remain') is not None:
            self.remain = m.get('Remain')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('ReserveDisableTotal') is not None:
            self.reserve_disable_total = m.get('ReserveDisableTotal')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('StatusDisableTotal') is not None:
            self.status_disable_total = m.get('StatusDisableTotal')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UsedRatio') is not None:
            self.used_ratio = m.get('UsedRatio')
        return self


class DescribeNCInformationResponseBodyDataGpu(TeaModel):
    def __init__(
        self,
        display: bool = None,
        oversell_ratio: int = None,
        remain: int = None,
        reserve_disable: bool = None,
        reserve_disable_total: int = None,
        reserved: int = None,
        status_disable: bool = None,
        status_disable_total: int = None,
        total: int = None,
        type: str = None,
        used: int = None,
        used_ratio: int = None,
    ):
        self.display = display
        self.oversell_ratio = oversell_ratio
        self.remain = remain
        self.reserve_disable = reserve_disable
        self.reserve_disable_total = reserve_disable_total
        self.reserved = reserved
        self.status_disable = status_disable
        self.status_disable_total = status_disable_total
        self.total = total
        self.type = type
        self.used = used
        self.used_ratio = used_ratio

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.oversell_ratio is not None:
            result['OversellRatio'] = self.oversell_ratio
        if self.remain is not None:
            result['Remain'] = self.remain
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.reserve_disable_total is not None:
            result['ReserveDisableTotal'] = self.reserve_disable_total
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.status_disable_total is not None:
            result['StatusDisableTotal'] = self.status_disable_total
        if self.total is not None:
            result['Total'] = self.total
        if self.type is not None:
            result['Type'] = self.type
        if self.used is not None:
            result['Used'] = self.used
        if self.used_ratio is not None:
            result['UsedRatio'] = self.used_ratio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('OversellRatio') is not None:
            self.oversell_ratio = m.get('OversellRatio')
        if m.get('Remain') is not None:
            self.remain = m.get('Remain')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('ReserveDisableTotal') is not None:
            self.reserve_disable_total = m.get('ReserveDisableTotal')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('StatusDisableTotal') is not None:
            self.status_disable_total = m.get('StatusDisableTotal')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UsedRatio') is not None:
            self.used_ratio = m.get('UsedRatio')
        return self


class DescribeNCInformationResponseBodyDataHdd(TeaModel):
    def __init__(
        self,
        display: bool = None,
        oversell_ratio: int = None,
        remain: int = None,
        reserve_disable: bool = None,
        reserve_disable_total: int = None,
        reserved: int = None,
        status_disable: bool = None,
        status_disable_total: int = None,
        total: int = None,
        type: str = None,
        used: int = None,
        used_ratio: int = None,
    ):
        self.display = display
        self.oversell_ratio = oversell_ratio
        self.remain = remain
        self.reserve_disable = reserve_disable
        self.reserve_disable_total = reserve_disable_total
        self.reserved = reserved
        self.status_disable = status_disable
        self.status_disable_total = status_disable_total
        self.total = total
        self.type = type
        self.used = used
        self.used_ratio = used_ratio

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.oversell_ratio is not None:
            result['OversellRatio'] = self.oversell_ratio
        if self.remain is not None:
            result['Remain'] = self.remain
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.reserve_disable_total is not None:
            result['ReserveDisableTotal'] = self.reserve_disable_total
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.status_disable_total is not None:
            result['StatusDisableTotal'] = self.status_disable_total
        if self.total is not None:
            result['Total'] = self.total
        if self.type is not None:
            result['Type'] = self.type
        if self.used is not None:
            result['Used'] = self.used
        if self.used_ratio is not None:
            result['UsedRatio'] = self.used_ratio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('OversellRatio') is not None:
            self.oversell_ratio = m.get('OversellRatio')
        if m.get('Remain') is not None:
            self.remain = m.get('Remain')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('ReserveDisableTotal') is not None:
            self.reserve_disable_total = m.get('ReserveDisableTotal')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('StatusDisableTotal') is not None:
            self.status_disable_total = m.get('StatusDisableTotal')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UsedRatio') is not None:
            self.used_ratio = m.get('UsedRatio')
        return self


class DescribeNCInformationResponseBodyDataInfo(TeaModel):
    def __init__(
        self,
        ip: str = None,
        name: str = None,
        tag: List[str] = None,
        uuid: str = None,
    ):
        self.ip = ip
        self.name = name
        self.tag = tag
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.name is not None:
            result['Name'] = self.name
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeNCInformationResponseBodyDataMemory(TeaModel):
    def __init__(
        self,
        display: bool = None,
        oversell_ratio: int = None,
        remain: int = None,
        reserve_disable: bool = None,
        reserve_disable_total: int = None,
        reserved: int = None,
        status_disable: bool = None,
        status_disable_total: int = None,
        total: int = None,
        type: str = None,
        used: int = None,
        used_ratio: int = None,
    ):
        self.display = display
        self.oversell_ratio = oversell_ratio
        self.remain = remain
        self.reserve_disable = reserve_disable
        self.reserve_disable_total = reserve_disable_total
        self.reserved = reserved
        self.status_disable = status_disable
        self.status_disable_total = status_disable_total
        self.total = total
        self.type = type
        self.used = used
        self.used_ratio = used_ratio

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.oversell_ratio is not None:
            result['OversellRatio'] = self.oversell_ratio
        if self.remain is not None:
            result['Remain'] = self.remain
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.reserve_disable_total is not None:
            result['ReserveDisableTotal'] = self.reserve_disable_total
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.status_disable_total is not None:
            result['StatusDisableTotal'] = self.status_disable_total
        if self.total is not None:
            result['Total'] = self.total
        if self.type is not None:
            result['Type'] = self.type
        if self.used is not None:
            result['Used'] = self.used
        if self.used_ratio is not None:
            result['UsedRatio'] = self.used_ratio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('OversellRatio') is not None:
            self.oversell_ratio = m.get('OversellRatio')
        if m.get('Remain') is not None:
            self.remain = m.get('Remain')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('ReserveDisableTotal') is not None:
            self.reserve_disable_total = m.get('ReserveDisableTotal')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('StatusDisableTotal') is not None:
            self.status_disable_total = m.get('StatusDisableTotal')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UsedRatio') is not None:
            self.used_ratio = m.get('UsedRatio')
        return self


class DescribeNCInformationResponseBodyDataNvme(TeaModel):
    def __init__(
        self,
        display: bool = None,
        oversell_ratio: int = None,
        remain: int = None,
        reserve_disable: bool = None,
        reserve_disable_total: int = None,
        reserved: int = None,
        status_disable: bool = None,
        status_disable_total: int = None,
        total: int = None,
        type: str = None,
        used: int = None,
        used_ratio: int = None,
    ):
        self.display = display
        self.oversell_ratio = oversell_ratio
        self.remain = remain
        self.reserve_disable = reserve_disable
        self.reserve_disable_total = reserve_disable_total
        self.reserved = reserved
        self.status_disable = status_disable
        self.status_disable_total = status_disable_total
        self.total = total
        self.type = type
        self.used = used
        self.used_ratio = used_ratio

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.oversell_ratio is not None:
            result['OversellRatio'] = self.oversell_ratio
        if self.remain is not None:
            result['Remain'] = self.remain
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.reserve_disable_total is not None:
            result['ReserveDisableTotal'] = self.reserve_disable_total
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.status_disable_total is not None:
            result['StatusDisableTotal'] = self.status_disable_total
        if self.total is not None:
            result['Total'] = self.total
        if self.type is not None:
            result['Type'] = self.type
        if self.used is not None:
            result['Used'] = self.used
        if self.used_ratio is not None:
            result['UsedRatio'] = self.used_ratio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('OversellRatio') is not None:
            self.oversell_ratio = m.get('OversellRatio')
        if m.get('Remain') is not None:
            self.remain = m.get('Remain')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('ReserveDisableTotal') is not None:
            self.reserve_disable_total = m.get('ReserveDisableTotal')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('StatusDisableTotal') is not None:
            self.status_disable_total = m.get('StatusDisableTotal')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UsedRatio') is not None:
            self.used_ratio = m.get('UsedRatio')
        return self


class DescribeNCInformationResponseBodyDataSsd(TeaModel):
    def __init__(
        self,
        display: bool = None,
        oversell_ratio: int = None,
        remain: int = None,
        reserve_disable: bool = None,
        reserve_disable_total: int = None,
        reserved: int = None,
        status_disable: bool = None,
        status_disable_total: int = None,
        total: int = None,
        type: str = None,
        used: int = None,
        used_ratio: int = None,
    ):
        self.display = display
        self.oversell_ratio = oversell_ratio
        self.remain = remain
        self.reserve_disable = reserve_disable
        self.reserve_disable_total = reserve_disable_total
        self.reserved = reserved
        self.status_disable = status_disable
        self.status_disable_total = status_disable_total
        self.total = total
        self.type = type
        self.used = used
        self.used_ratio = used_ratio

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.oversell_ratio is not None:
            result['OversellRatio'] = self.oversell_ratio
        if self.remain is not None:
            result['Remain'] = self.remain
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.reserve_disable_total is not None:
            result['ReserveDisableTotal'] = self.reserve_disable_total
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.status_disable_total is not None:
            result['StatusDisableTotal'] = self.status_disable_total
        if self.total is not None:
            result['Total'] = self.total
        if self.type is not None:
            result['Type'] = self.type
        if self.used is not None:
            result['Used'] = self.used
        if self.used_ratio is not None:
            result['UsedRatio'] = self.used_ratio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('OversellRatio') is not None:
            self.oversell_ratio = m.get('OversellRatio')
        if m.get('Remain') is not None:
            self.remain = m.get('Remain')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('ReserveDisableTotal') is not None:
            self.reserve_disable_total = m.get('ReserveDisableTotal')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('StatusDisableTotal') is not None:
            self.status_disable_total = m.get('StatusDisableTotal')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UsedRatio') is not None:
            self.used_ratio = m.get('UsedRatio')
        return self


class DescribeNCInformationResponseBodyData(TeaModel):
    def __init__(
        self,
        cpu: DescribeNCInformationResponseBodyDataCpu = None,
        gpu: DescribeNCInformationResponseBodyDataGpu = None,
        hdd: DescribeNCInformationResponseBodyDataHdd = None,
        info: DescribeNCInformationResponseBodyDataInfo = None,
        memory: DescribeNCInformationResponseBodyDataMemory = None,
        nvme: DescribeNCInformationResponseBodyDataNvme = None,
        online: bool = None,
        region: str = None,
        ssd: DescribeNCInformationResponseBodyDataSsd = None,
        virtual: str = None,
    ):
        self.cpu = cpu
        self.gpu = gpu
        self.hdd = hdd
        self.info = info
        self.memory = memory
        self.nvme = nvme
        self.online = online
        self.region = region
        self.ssd = ssd
        self.virtual = virtual

    def validate(self):
        if self.cpu:
            self.cpu.validate()
        if self.gpu:
            self.gpu.validate()
        if self.hdd:
            self.hdd.validate()
        if self.info:
            self.info.validate()
        if self.memory:
            self.memory.validate()
        if self.nvme:
            self.nvme.validate()
        if self.ssd:
            self.ssd.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu is not None:
            result['Cpu'] = self.cpu.to_map()
        if self.gpu is not None:
            result['Gpu'] = self.gpu.to_map()
        if self.hdd is not None:
            result['Hdd'] = self.hdd.to_map()
        if self.info is not None:
            result['Info'] = self.info.to_map()
        if self.memory is not None:
            result['Memory'] = self.memory.to_map()
        if self.nvme is not None:
            result['Nvme'] = self.nvme.to_map()
        if self.online is not None:
            result['Online'] = self.online
        if self.region is not None:
            result['Region'] = self.region
        if self.ssd is not None:
            result['Ssd'] = self.ssd.to_map()
        if self.virtual is not None:
            result['Virtual'] = self.virtual
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cpu') is not None:
            temp_model = DescribeNCInformationResponseBodyDataCpu()
            self.cpu = temp_model.from_map(m['Cpu'])
        if m.get('Gpu') is not None:
            temp_model = DescribeNCInformationResponseBodyDataGpu()
            self.gpu = temp_model.from_map(m['Gpu'])
        if m.get('Hdd') is not None:
            temp_model = DescribeNCInformationResponseBodyDataHdd()
            self.hdd = temp_model.from_map(m['Hdd'])
        if m.get('Info') is not None:
            temp_model = DescribeNCInformationResponseBodyDataInfo()
            self.info = temp_model.from_map(m['Info'])
        if m.get('Memory') is not None:
            temp_model = DescribeNCInformationResponseBodyDataMemory()
            self.memory = temp_model.from_map(m['Memory'])
        if m.get('Nvme') is not None:
            temp_model = DescribeNCInformationResponseBodyDataNvme()
            self.nvme = temp_model.from_map(m['Nvme'])
        if m.get('Online') is not None:
            self.online = m.get('Online')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Ssd') is not None:
            temp_model = DescribeNCInformationResponseBodyDataSsd()
            self.ssd = temp_model.from_map(m['Ssd'])
        if m.get('Virtual') is not None:
            self.virtual = m.get('Virtual')
        return self


class DescribeNCInformationResponseBodyPager(TeaModel):
    def __init__(
        self,
        page: int = None,
        size: int = None,
        total: int = None,
    ):
        self.page = page
        self.size = size
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page is not None:
            result['Page'] = self.page
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeNCInformationResponseBody(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        data: List[DescribeNCInformationResponseBodyData] = None,
        desc: str = None,
        msg: str = None,
        pager: DescribeNCInformationResponseBodyPager = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.current_page = current_page
        self.data = data
        self.desc = desc
        self.msg = msg
        self.pager = pager
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.pager:
            self.pager.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.pager is not None:
            result['Pager'] = self.pager.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeNCInformationResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('Pager') is not None:
            temp_model = DescribeNCInformationResponseBodyPager()
            self.pager = temp_model.from_map(m['Pager'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeNCInformationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNCInformationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNCInformationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNatGatewaysRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        ens_region_ids: List[str] = None,
        name: str = None,
        nat_gateway_id: str = None,
        nat_gateway_ids: List[str] = None,
        network_id: str = None,
        page_number: int = None,
        page_size: int = None,
        v_switch_id: str = None,
    ):
        # The ID of the Edge Node Service (ENS) node.
        self.ens_region_id = ens_region_id
        # The IDs of edge nodes. You can specify 1 to 100 IDs.
        self.ens_region_ids = ens_region_ids
        # The name of the NAT gateway.
        self.name = name
        # The ID of the NAT gateway.
        self.nat_gateway_id = nat_gateway_id
        # The IDs of the NAT gateways. You can specify 1 to 100 IDs.
        self.nat_gateway_ids = nat_gateway_ids
        # The ID of the network.
        self.network_id = network_id
        # The page number. Pages start from page **1**.
        # 
        # Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. The maximum value is **100**.
        # 
        # Default value: **10**.
        self.page_size = page_size
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.ens_region_ids is not None:
            result['EnsRegionIds'] = self.ens_region_ids
        if self.name is not None:
            result['Name'] = self.name
        if self.nat_gateway_id is not None:
            result['NatGatewayId'] = self.nat_gateway_id
        if self.nat_gateway_ids is not None:
            result['NatGatewayIds'] = self.nat_gateway_ids
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('EnsRegionIds') is not None:
            self.ens_region_ids = m.get('EnsRegionIds')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NatGatewayId') is not None:
            self.nat_gateway_id = m.get('NatGatewayId')
        if m.get('NatGatewayIds') is not None:
            self.nat_gateway_ids = m.get('NatGatewayIds')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeNatGatewaysResponseBodyNatGatewaysIpLists(TeaModel):
    def __init__(
        self,
        allocation_id: str = None,
        ip_address: str = None,
        using_status: str = None,
    ):
        # The ID of the EIP.
        self.allocation_id = allocation_id
        # The EIP.
        self.ip_address = ip_address
        # The association between the EIP and the Internet NAT gateway. Valid values:
        # 
        # *   **UsedByForwardTable**: The EIP is specified in a DNAT entry.
        # *   **UsedBySnatTable**: The EIP is specified in an SNAT entry.
        # *   **Idle**: The EIP is not specified in an SNAT entry or a DNAT entry.
        self.using_status = using_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        if self.using_status is not None:
            result['UsingStatus'] = self.using_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        if m.get('UsingStatus') is not None:
            self.using_status = m.get('UsingStatus')
        return self


class DescribeNatGatewaysResponseBodyNatGatewaysTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        tag_key: str = None,
        tag_value: str = None,
        value: str = None,
    ):
        self.key = key
        self.tag_key = tag_key
        self.tag_value = tag_value
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeNatGatewaysResponseBodyNatGateways(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        ens_region_id: str = None,
        ip_lists: List[DescribeNatGatewaysResponseBodyNatGatewaysIpLists] = None,
        name: str = None,
        nat_gateway_id: str = None,
        network_id: str = None,
        spec: str = None,
        status: str = None,
        tags: List[DescribeNatGatewaysResponseBodyNatGatewaysTags] = None,
        v_switch_id: str = None,
    ):
        # The time when the NAT gateway was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
        self.creation_time = creation_time
        # The ID of the ENS node.
        self.ens_region_id = ens_region_id
        # The EIPs that are associated with the NAT gateway.
        self.ip_lists = ip_lists
        # The name of the NAT gateway.
        self.name = name
        # The ID of the NAT gateway.
        self.nat_gateway_id = nat_gateway_id
        # The ID of the network.
        self.network_id = network_id
        # The type of the NAT gateway.
        self.spec = spec
        # The status of the NAT gateway. Valid values:
        # 
        # *   **Creating**: After you send a request to create a NAT gateway, the system creates the NAT gateway in the background. The NAT gateway remains in the Creating state until the operation is completed.
        # *   **Available**: The NAT gateway is in the Available state after the creation is complete.
        # *   **Deleting**: After you send a request to delete a NAT gateway, the system deletes the NAT gateway in the background. The NAT gateway remains in the Deleting state until the operation is completed.
        self.status = status
        self.tags = tags
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id

    def validate(self):
        if self.ip_lists:
            for k in self.ip_lists:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        result['IpLists'] = []
        if self.ip_lists is not None:
            for k in self.ip_lists:
                result['IpLists'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.nat_gateway_id is not None:
            result['NatGatewayId'] = self.nat_gateway_id
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.status is not None:
            result['Status'] = self.status
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        self.ip_lists = []
        if m.get('IpLists') is not None:
            for k in m.get('IpLists'):
                temp_model = DescribeNatGatewaysResponseBodyNatGatewaysIpLists()
                self.ip_lists.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NatGatewayId') is not None:
            self.nat_gateway_id = m.get('NatGatewayId')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = DescribeNatGatewaysResponseBodyNatGatewaysTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeNatGatewaysResponseBody(TeaModel):
    def __init__(
        self,
        nat_gateways: List[DescribeNatGatewaysResponseBodyNatGateways] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The details of the NAT gateways.
        self.nat_gateways = nat_gateways
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The number of NAT gateways that are returned.
        self.total_count = total_count

    def validate(self):
        if self.nat_gateways:
            for k in self.nat_gateways:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NatGateways'] = []
        if self.nat_gateways is not None:
            for k in self.nat_gateways:
                result['NatGateways'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.nat_gateways = []
        if m.get('NatGateways') is not None:
            for k in m.get('NatGateways'):
                temp_model = DescribeNatGatewaysResponseBodyNatGateways()
                self.nat_gateways.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeNatGatewaysResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNatGatewaysResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNatGatewaysResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNetworkAclsRequest(TeaModel):
    def __init__(
        self,
        network_acl_id: str = None,
        network_acl_name: str = None,
        page_number: str = None,
        page_size: str = None,
        resource_id: str = None,
    ):
        # The ID of the network ACL.
        self.network_acl_id = network_acl_id
        # The name of the network ACL.
        self.network_acl_name = network_acl_name
        # The page number. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Maximum value: **50**. Default value: **10**.
        self.page_size = page_size
        # The ID of the associated instance.
        self.resource_id = resource_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_acl_id is not None:
            result['NetworkAclId'] = self.network_acl_id
        if self.network_acl_name is not None:
            result['NetworkAclName'] = self.network_acl_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkAclId') is not None:
            self.network_acl_id = m.get('NetworkAclId')
        if m.get('NetworkAclName') is not None:
            self.network_acl_name = m.get('NetworkAclName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        return self


class DescribeNetworkAclsResponseBodyNetworkAclsEgressAclEntries(TeaModel):
    def __init__(
        self,
        cidr_block: str = None,
        description: str = None,
        network_acl_entry_id: str = None,
        network_acl_entry_name: str = None,
        policy: str = None,
        port_range: str = None,
        priority: int = None,
        protocol: str = None,
        type: str = None,
    ):
        # The destination CIDR block.
        self.cidr_block = cidr_block
        # The description of the outbound rule.
        self.description = description
        # The ID of the outbound rule.
        self.network_acl_entry_id = network_acl_entry_id
        # The name of the outbound rule.
        self.network_acl_entry_name = network_acl_entry_name
        # The action that is performed on network traffic that matches the rule. Valid values:
        # 
        # *   **accept**: allows the network traffic.
        # *   **drop**: blocks the network traffic.
        self.policy = policy
        # The destination port range of the outbound rule.
        # 
        # *   If **Protocol** of the outbound rule is set to **all** or **icmp** the port range is **-1/-1**, which indicates all ports.
        # *   If **Protocol** of the outbound rule is set to **tcp** or **udp**, the port range is in the following format: **1/200** or **80/80**. 1/200 indicates port 1 to port 200. 80/80 indicates port 80. Valid values for a port: **1 to 65535**.
        self.port_range = port_range
        # The priority of the rule. Valid values: **1 to 100**. Default value: **1**.
        self.priority = priority
        # The protocol type. Valid values:
        # 
        # *   **icmp**: ICMP.
        # *   **tcp**: TCP.
        # *   **udp**: UDP.
        # *   **all**: all protocols.
        self.protocol = protocol
        # The type of the rule. Valid values:
        # 
        # *   **system**: The rule is created by the system.
        # *   **custom**: The rule is created by a user.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.description is not None:
            result['Description'] = self.description
        if self.network_acl_entry_id is not None:
            result['NetworkAclEntryId'] = self.network_acl_entry_id
        if self.network_acl_entry_name is not None:
            result['NetworkAclEntryName'] = self.network_acl_entry_name
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('NetworkAclEntryId') is not None:
            self.network_acl_entry_id = m.get('NetworkAclEntryId')
        if m.get('NetworkAclEntryName') is not None:
            self.network_acl_entry_name = m.get('NetworkAclEntryName')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeNetworkAclsResponseBodyNetworkAclsIngressAclEntries(TeaModel):
    def __init__(
        self,
        cidr_block: str = None,
        description: str = None,
        destination_cidr_block: str = None,
        network_acl_entry_id: str = None,
        network_acl_entry_name: str = None,
        policy: str = None,
        port_range: str = None,
        priority: int = None,
        protocol: str = None,
        type: str = None,
    ):
        # The source CIDR block.
        self.cidr_block = cidr_block
        # The description of the inbound rule.
        self.description = description
        self.destination_cidr_block = destination_cidr_block
        # The ID of the inbound rule.
        self.network_acl_entry_id = network_acl_entry_id
        # The name of the inbound rule.
        self.network_acl_entry_name = network_acl_entry_name
        # The action that is performed on network traffic that matches the rule. Valid values:
        # 
        # *   **accept**: allows the network traffic.
        # *   **drop**: blocks the network traffic.
        self.policy = policy
        # The destination port range of the inbound rule.
        # 
        # *   If **Protocol** of the inbound rule is set to **all** or **icmp**, the port range is **-1/-1**, which indicates all ports.
        # *   If **Protocol** of the inbound rule is set to **tcp** or **udp**, the port range is in the following format: **1/200** or **80/80**. 1/200 indicates port 1 to port 200. 80/80 indicates port 80. Valid values for a port: **1 to 65535**.
        self.port_range = port_range
        # The priority of the rule. Valid values: **1 to 100**. Default value: **1**.
        self.priority = priority
        # The protocol type. Valid values:
        # 
        # *   **icmp**: ICMP.
        # *   **tcp**: TCP.
        # *   **udp**: UDP.
        # *   **all**: all protocols.
        self.protocol = protocol
        # The type of the rule. Valid values:
        # 
        # *   **system**: The rule is created by the system.
        # *   **custom**: The rule is created by a user.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.description is not None:
            result['Description'] = self.description
        if self.destination_cidr_block is not None:
            result['DestinationCidrBlock'] = self.destination_cidr_block
        if self.network_acl_entry_id is not None:
            result['NetworkAclEntryId'] = self.network_acl_entry_id
        if self.network_acl_entry_name is not None:
            result['NetworkAclEntryName'] = self.network_acl_entry_name
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestinationCidrBlock') is not None:
            self.destination_cidr_block = m.get('DestinationCidrBlock')
        if m.get('NetworkAclEntryId') is not None:
            self.network_acl_entry_id = m.get('NetworkAclEntryId')
        if m.get('NetworkAclEntryName') is not None:
            self.network_acl_entry_name = m.get('NetworkAclEntryName')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeNetworkAclsResponseBodyNetworkAclsResources(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        resource_id: str = None,
        resource_type: str = None,
        status: str = None,
    ):
        # The ID of the edge node.
        self.ens_region_id = ens_region_id
        # The ID of the associated resource.
        self.resource_id = resource_id
        # The type of the associated resource.
        self.resource_type = resource_type
        # The association status of the resource. Valid values:
        # 
        # *   **BINDED**: The resource is associated with the network ACL.
        # *   **BINDING**: The resource is being associated with the network ACL.
        # *   **UNBINDING**: The resource is being disassociated from the network ACL.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeNetworkAclsResponseBodyNetworkAcls(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        description: str = None,
        egress_acl_entries: List[DescribeNetworkAclsResponseBodyNetworkAclsEgressAclEntries] = None,
        ingress_acl_entries: List[DescribeNetworkAclsResponseBodyNetworkAclsIngressAclEntries] = None,
        network_acl_id: str = None,
        network_acl_name: str = None,
        resources: List[DescribeNetworkAclsResponseBodyNetworkAclsResources] = None,
        status: str = None,
    ):
        # The time when the network ACL was created. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.
        self.creation_time = creation_time
        # The description of the network ACL.
        self.description = description
        # Details of the outbound rules.
        self.egress_acl_entries = egress_acl_entries
        # Details of the inbound rules.
        self.ingress_acl_entries = ingress_acl_entries
        # The ID of the network ACL.
        self.network_acl_id = network_acl_id
        # The name of the network ACL.
        self.network_acl_name = network_acl_name
        # Details of the associated resources.
        self.resources = resources
        # The status of the network ACL. Valid values:
        # 
        # *   **Available**: The network ACL is available.
        # *   **Modifying**: The network ACL is being configured.
        self.status = status

    def validate(self):
        if self.egress_acl_entries:
            for k in self.egress_acl_entries:
                if k:
                    k.validate()
        if self.ingress_acl_entries:
            for k in self.ingress_acl_entries:
                if k:
                    k.validate()
        if self.resources:
            for k in self.resources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        result['EgressAclEntries'] = []
        if self.egress_acl_entries is not None:
            for k in self.egress_acl_entries:
                result['EgressAclEntries'].append(k.to_map() if k else None)
        result['IngressAclEntries'] = []
        if self.ingress_acl_entries is not None:
            for k in self.ingress_acl_entries:
                result['IngressAclEntries'].append(k.to_map() if k else None)
        if self.network_acl_id is not None:
            result['NetworkAclId'] = self.network_acl_id
        if self.network_acl_name is not None:
            result['NetworkAclName'] = self.network_acl_name
        result['Resources'] = []
        if self.resources is not None:
            for k in self.resources:
                result['Resources'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.egress_acl_entries = []
        if m.get('EgressAclEntries') is not None:
            for k in m.get('EgressAclEntries'):
                temp_model = DescribeNetworkAclsResponseBodyNetworkAclsEgressAclEntries()
                self.egress_acl_entries.append(temp_model.from_map(k))
        self.ingress_acl_entries = []
        if m.get('IngressAclEntries') is not None:
            for k in m.get('IngressAclEntries'):
                temp_model = DescribeNetworkAclsResponseBodyNetworkAclsIngressAclEntries()
                self.ingress_acl_entries.append(temp_model.from_map(k))
        if m.get('NetworkAclId') is not None:
            self.network_acl_id = m.get('NetworkAclId')
        if m.get('NetworkAclName') is not None:
            self.network_acl_name = m.get('NetworkAclName')
        self.resources = []
        if m.get('Resources') is not None:
            for k in m.get('Resources'):
                temp_model = DescribeNetworkAclsResponseBodyNetworkAclsResources()
                self.resources.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeNetworkAclsResponseBody(TeaModel):
    def __init__(
        self,
        network_acls: List[DescribeNetworkAclsResponseBodyNetworkAcls] = None,
        page_number: str = None,
        page_size: str = None,
        request_id: str = None,
        total_count: str = None,
    ):
        # Details of the network ACLs.
        self.network_acls = network_acls
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.network_acls:
            for k in self.network_acls:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NetworkAcls'] = []
        if self.network_acls is not None:
            for k in self.network_acls:
                result['NetworkAcls'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.network_acls = []
        if m.get('NetworkAcls') is not None:
            for k in m.get('NetworkAcls'):
                temp_model = DescribeNetworkAclsResponseBodyNetworkAcls()
                self.network_acls.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeNetworkAclsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNetworkAclsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNetworkAclsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNetworkAttributeRequest(TeaModel):
    def __init__(
        self,
        network_id: str = None,
    ):
        # The ID of the network.
        # 
        # This parameter is required.
        self.network_id = network_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        return self


class DescribeNetworkAttributeResponseBodyCloudResourcesCloudResourceSetType(TeaModel):
    def __init__(
        self,
        resource_count: int = None,
        resource_type: str = None,
    ):
        # The number of resources in the network.
        self.resource_count = resource_count
        # The resource type. VSwitch.
        self.resource_type = resource_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_count is not None:
            result['ResourceCount'] = self.resource_count
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceCount') is not None:
            self.resource_count = m.get('ResourceCount')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class DescribeNetworkAttributeResponseBodyCloudResources(TeaModel):
    def __init__(
        self,
        cloud_resource_set_type: List[DescribeNetworkAttributeResponseBodyCloudResourcesCloudResourceSetType] = None,
    ):
        self.cloud_resource_set_type = cloud_resource_set_type

    def validate(self):
        if self.cloud_resource_set_type:
            for k in self.cloud_resource_set_type:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CloudResourceSetType'] = []
        if self.cloud_resource_set_type is not None:
            for k in self.cloud_resource_set_type:
                result['CloudResourceSetType'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cloud_resource_set_type = []
        if m.get('CloudResourceSetType') is not None:
            for k in m.get('CloudResourceSetType'):
                temp_model = DescribeNetworkAttributeResponseBodyCloudResourcesCloudResourceSetType()
                self.cloud_resource_set_type.append(temp_model.from_map(k))
        return self


class DescribeNetworkAttributeResponseBodyHaVipIds(TeaModel):
    def __init__(
        self,
        ha_vip_id: List[str] = None,
    ):
        self.ha_vip_id = ha_vip_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ha_vip_id is not None:
            result['HaVipId'] = self.ha_vip_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HaVipId') is not None:
            self.ha_vip_id = m.get('HaVipId')
        return self


class DescribeNetworkAttributeResponseBodyInstanceIds(TeaModel):
    def __init__(
        self,
        instance_id: List[str] = None,
    ):
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeNetworkAttributeResponseBodyLoadBalancerIds(TeaModel):
    def __init__(
        self,
        load_balancer_id: List[str] = None,
    ):
        self.load_balancer_id = load_balancer_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        return self


class DescribeNetworkAttributeResponseBodyNatGatewayIds(TeaModel):
    def __init__(
        self,
        nat_gateway_id: List[str] = None,
    ):
        self.nat_gateway_id = nat_gateway_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nat_gateway_id is not None:
            result['NatGatewayId'] = self.nat_gateway_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NatGatewayId') is not None:
            self.nat_gateway_id = m.get('NatGatewayId')
        return self


class DescribeNetworkAttributeResponseBodyNetworkInterfaceIds(TeaModel):
    def __init__(
        self,
        network_interface_id: List[str] = None,
    ):
        self.network_interface_id = network_interface_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        return self


class DescribeNetworkAttributeResponseBodyRouteTableIds(TeaModel):
    def __init__(
        self,
        route_table_id: List[str] = None,
    ):
        self.route_table_id = route_table_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.route_table_id is not None:
            result['RouteTableId'] = self.route_table_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RouteTableId') is not None:
            self.route_table_id = m.get('RouteTableId')
        return self


class DescribeNetworkAttributeResponseBodyVSwitchIds(TeaModel):
    def __init__(
        self,
        v_switch_id: List[str] = None,
    ):
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeNetworkAttributeResponseBody(TeaModel):
    def __init__(
        self,
        cidr_block: str = None,
        cloud_resources: DescribeNetworkAttributeResponseBodyCloudResources = None,
        created_time: str = None,
        description: str = None,
        ens_region_id: str = None,
        gateway_route_table_id: str = None,
        ha_vip_ids: DescribeNetworkAttributeResponseBodyHaVipIds = None,
        instance_ids: DescribeNetworkAttributeResponseBodyInstanceIds = None,
        load_balancer_ids: DescribeNetworkAttributeResponseBodyLoadBalancerIds = None,
        nat_gateway_ids: DescribeNetworkAttributeResponseBodyNatGatewayIds = None,
        network_acl_id: str = None,
        network_id: str = None,
        network_interface_ids: DescribeNetworkAttributeResponseBodyNetworkInterfaceIds = None,
        network_name: str = None,
        request_id: str = None,
        route_table_id: str = None,
        route_table_ids: DescribeNetworkAttributeResponseBodyRouteTableIds = None,
        router_table_id: str = None,
        status: str = None,
        v_switch_ids: DescribeNetworkAttributeResponseBodyVSwitchIds = None,
    ):
        # The IPv4 CIDR block of the network.
        self.cidr_block = cidr_block
        # The list of resources in the network.
        self.cloud_resources = cloud_resources
        # The time when the network was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
        self.created_time = created_time
        # The description of the network.
        self.description = description
        # The ID of the edge node.
        self.ens_region_id = ens_region_id
        # The ID of the gateway route table.
        self.gateway_route_table_id = gateway_route_table_id
        # List of HaVipIds.
        self.ha_vip_ids = ha_vip_ids
        # The instance IDs.
        self.instance_ids = instance_ids
        # List of ELB instances.
        self.load_balancer_ids = load_balancer_ids
        # List of NAT Gateways.
        self.nat_gateway_ids = nat_gateway_ids
        # The ID of the network access control list (ACL).
        self.network_acl_id = network_acl_id
        # The ID of the network.
        self.network_id = network_id
        # A list of multicast source IDs.
        self.network_interface_ids = network_interface_ids
        # The name of the network.
        self.network_name = network_name
        # The request ID.
        self.request_id = request_id
        # The ID of the route table.
        self.route_table_id = route_table_id
        # List of routing table IDs.
        self.route_table_ids = route_table_ids
        # The ID of the route table.
        self.router_table_id = router_table_id
        # The status of the network. Valid values:
        # 
        # *   Pending
        # *   Available
        self.status = status
        # The list of vSwitches in the network.
        self.v_switch_ids = v_switch_ids

    def validate(self):
        if self.cloud_resources:
            self.cloud_resources.validate()
        if self.ha_vip_ids:
            self.ha_vip_ids.validate()
        if self.instance_ids:
            self.instance_ids.validate()
        if self.load_balancer_ids:
            self.load_balancer_ids.validate()
        if self.nat_gateway_ids:
            self.nat_gateway_ids.validate()
        if self.network_interface_ids:
            self.network_interface_ids.validate()
        if self.route_table_ids:
            self.route_table_ids.validate()
        if self.v_switch_ids:
            self.v_switch_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.cloud_resources is not None:
            result['CloudResources'] = self.cloud_resources.to_map()
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.description is not None:
            result['Description'] = self.description
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.gateway_route_table_id is not None:
            result['GatewayRouteTableId'] = self.gateway_route_table_id
        if self.ha_vip_ids is not None:
            result['HaVipIds'] = self.ha_vip_ids.to_map()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids.to_map()
        if self.load_balancer_ids is not None:
            result['LoadBalancerIds'] = self.load_balancer_ids.to_map()
        if self.nat_gateway_ids is not None:
            result['NatGatewayIds'] = self.nat_gateway_ids.to_map()
        if self.network_acl_id is not None:
            result['NetworkAclId'] = self.network_acl_id
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.network_interface_ids is not None:
            result['NetworkInterfaceIds'] = self.network_interface_ids.to_map()
        if self.network_name is not None:
            result['NetworkName'] = self.network_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.route_table_id is not None:
            result['RouteTableId'] = self.route_table_id
        if self.route_table_ids is not None:
            result['RouteTableIds'] = self.route_table_ids.to_map()
        if self.router_table_id is not None:
            result['RouterTableId'] = self.router_table_id
        if self.status is not None:
            result['Status'] = self.status
        if self.v_switch_ids is not None:
            result['VSwitchIds'] = self.v_switch_ids.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('CloudResources') is not None:
            temp_model = DescribeNetworkAttributeResponseBodyCloudResources()
            self.cloud_resources = temp_model.from_map(m['CloudResources'])
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('GatewayRouteTableId') is not None:
            self.gateway_route_table_id = m.get('GatewayRouteTableId')
        if m.get('HaVipIds') is not None:
            temp_model = DescribeNetworkAttributeResponseBodyHaVipIds()
            self.ha_vip_ids = temp_model.from_map(m['HaVipIds'])
        if m.get('InstanceIds') is not None:
            temp_model = DescribeNetworkAttributeResponseBodyInstanceIds()
            self.instance_ids = temp_model.from_map(m['InstanceIds'])
        if m.get('LoadBalancerIds') is not None:
            temp_model = DescribeNetworkAttributeResponseBodyLoadBalancerIds()
            self.load_balancer_ids = temp_model.from_map(m['LoadBalancerIds'])
        if m.get('NatGatewayIds') is not None:
            temp_model = DescribeNetworkAttributeResponseBodyNatGatewayIds()
            self.nat_gateway_ids = temp_model.from_map(m['NatGatewayIds'])
        if m.get('NetworkAclId') is not None:
            self.network_acl_id = m.get('NetworkAclId')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('NetworkInterfaceIds') is not None:
            temp_model = DescribeNetworkAttributeResponseBodyNetworkInterfaceIds()
            self.network_interface_ids = temp_model.from_map(m['NetworkInterfaceIds'])
        if m.get('NetworkName') is not None:
            self.network_name = m.get('NetworkName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RouteTableId') is not None:
            self.route_table_id = m.get('RouteTableId')
        if m.get('RouteTableIds') is not None:
            temp_model = DescribeNetworkAttributeResponseBodyRouteTableIds()
            self.route_table_ids = temp_model.from_map(m['RouteTableIds'])
        if m.get('RouterTableId') is not None:
            self.router_table_id = m.get('RouterTableId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VSwitchIds') is not None:
            temp_model = DescribeNetworkAttributeResponseBodyVSwitchIds()
            self.v_switch_ids = temp_model.from_map(m['VSwitchIds'])
        return self


class DescribeNetworkAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNetworkAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNetworkAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNetworkInterfacesRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        ens_region_ids: List[str] = None,
        instance_id: str = None,
        ipv_6address: List[str] = None,
        network_id: str = None,
        network_interface_id: str = None,
        network_interface_ids: List[str] = None,
        network_interface_name: str = None,
        page_number: str = None,
        page_size: str = None,
        primary_ip_address: str = None,
        security_group_id: str = None,
        status: str = None,
        type: str = None,
        v_switch_id: str = None,
    ):
        # The region ID of the instance.
        self.ens_region_id = ens_region_id
        # The IDs of edge nodes. N indicates the number of edge node IDs that you can specify at the same time. Valid values of N: 1 to 100.
        self.ens_region_ids = ens_region_ids
        # The ID of the instance.
        self.instance_id = instance_id
        # IPv6 addresses N of the ENI. You can specify multiple IPv6 addresses. Valid values of N: 1 to 100.
        self.ipv_6address = ipv_6address
        # The ID of the network.
        self.network_id = network_id
        # The ID of the ENI.
        self.network_interface_id = network_interface_id
        # The IDs of the elastic network interfaces (ENIs). N indicates the number of ENI IDs that you can specify at the same time. Valid values of N: 1 to 100.
        self.network_interface_ids = network_interface_ids
        # The name of the ENI.
        self.network_interface_name = network_interface_name
        # The page number of the returned page. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries to return on each page. Maximum value: 100. Default value: 50.
        self.page_size = page_size
        # The primary IP address of the ENI.
        self.primary_ip_address = primary_ip_address
        # The ID of the security group to which the secondary ENI belongs. To query the details of secondary ENIs based on the ID of a security group, specify this parameter.
        self.security_group_id = security_group_id
        # The status of the ENI. Valid values:
        # 
        # *   Available: The ENI is available.
        # *   Attaching: The ENI is being attached to an instance.
        # *   InUse: The ENI is attached to an instance.
        # *   Detaching: The ENI is being detached from an instance.
        # *   Deleting: The ENI is being deleted.
        # 
        # This parameter is empty by default, which indicates that ENIs in all states are queried.
        self.status = status
        # The type of the ENI. Valid values:
        # 
        # *   Primary: the primary ENI.
        # *   Secondary: the secondary ENI.
        # 
        # This parameter is empty by default, which indicates that both primary and secondary ENIs are queried.
        self.type = type
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.ens_region_ids is not None:
            result['EnsRegionIds'] = self.ens_region_ids
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ipv_6address is not None:
            result['Ipv6Address'] = self.ipv_6address
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.network_interface_ids is not None:
            result['NetworkInterfaceIds'] = self.network_interface_ids
        if self.network_interface_name is not None:
            result['NetworkInterfaceName'] = self.network_interface_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.primary_ip_address is not None:
            result['PrimaryIpAddress'] = self.primary_ip_address
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('EnsRegionIds') is not None:
            self.ens_region_ids = m.get('EnsRegionIds')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Ipv6Address') is not None:
            self.ipv_6address = m.get('Ipv6Address')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('NetworkInterfaceIds') is not None:
            self.network_interface_ids = m.get('NetworkInterfaceIds')
        if m.get('NetworkInterfaceName') is not None:
            self.network_interface_name = m.get('NetworkInterfaceName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PrimaryIpAddress') is not None:
            self.primary_ip_address = m.get('PrimaryIpAddress')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set(TeaModel):
    def __init__(
        self,
        ipv_6address: str = None,
    ):
        # The IPv6 address of the ENI.
        self.ipv_6address = ipv_6address

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_6address is not None:
            result['Ipv6Address'] = self.ipv_6address
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ipv6Address') is not None:
            self.ipv_6address = m.get('Ipv6Address')
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets(TeaModel):
    def __init__(
        self,
        ipv_6set: List[DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set] = None,
    ):
        self.ipv_6set = ipv_6set

    def validate(self):
        if self.ipv_6set:
            for k in self.ipv_6set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ipv6Set'] = []
        if self.ipv_6set is not None:
            for k in self.ipv_6set:
                result['Ipv6Set'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ipv_6set = []
        if m.get('Ipv6Set') is not None:
            for k in m.get('Ipv6Set'):
                temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set()
                self.ipv_6set.append(temp_model.from_map(k))
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet(TeaModel):
    def __init__(
        self,
        primary: bool = None,
        private_ip_address: str = None,
    ):
        # Specifies whether the private IP address is the primary private IP address. Valid values:
        # 
        # *   true
        # *   false
        self.primary = primary
        # The private IP address.
        self.private_ip_address = private_ip_address

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.primary is not None:
            result['Primary'] = self.primary
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Primary') is not None:
            self.primary = m.get('Primary')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets(TeaModel):
    def __init__(
        self,
        private_ip_set: List[DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet] = None,
    ):
        self.private_ip_set = private_ip_set

    def validate(self):
        if self.private_ip_set:
            for k in self.private_ip_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PrivateIpSet'] = []
        if self.private_ip_set is not None:
            for k in self.private_ip_set:
                result['PrivateIpSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.private_ip_set = []
        if m.get('PrivateIpSet') is not None:
            for k in m.get('PrivateIpSet'):
                temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet()
                self.private_ip_set.append(temp_model.from_map(k))
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds(TeaModel):
    def __init__(
        self,
        security_group: List[str] = None,
    ):
        self.security_group = security_group

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_group is not None:
            result['SecurityGroup'] = self.security_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SecurityGroup') is not None:
            self.security_group = m.get('SecurityGroup')
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        description: str = None,
        ens_region_id: str = None,
        instance_id: str = None,
        ipv_6sets: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets = None,
        mac_address: str = None,
        network_id: str = None,
        network_interface_id: str = None,
        network_interface_name: str = None,
        primary_ip: str = None,
        primary_ip_type: str = None,
        private_ip_sets: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets = None,
        security_group_ids: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds = None,
        status: str = None,
        type: str = None,
        v_switch_id: str = None,
    ):
        # The time when the ENI was created. Specify the time in the ISO 8601 standard in the yyyy-MM-ddThh:mmZ format. The time is displayed in UTC.
        self.creation_time = creation_time
        # The description of ENI.
        self.description = description
        # The ID of the edge node.
        self.ens_region_id = ens_region_id
        # The ID of the instance to which the ENI is bound.
        self.instance_id = instance_id
        # The IPv6 addresses of the ENIs.
        self.ipv_6sets = ipv_6sets
        # The MAC address of the ENI.
        self.mac_address = mac_address
        # The ID of the network.
        self.network_id = network_id
        # The ID of the ENI.
        self.network_interface_id = network_interface_id
        # The ENI name.
        self.network_interface_name = network_interface_name
        # The private IP address of the server.
        self.primary_ip = primary_ip
        # The primary private IP address. Valid values:
        # 
        # *   **Public**: public IP address.
        # *   **Private**: internal IP address.
        self.primary_ip_type = primary_ip_type
        # Details about the private IP address.
        self.private_ip_sets = private_ip_sets
        # The ID of the security group.
        self.security_group_ids = security_group_ids
        # The status of the ENI. Valid values:
        # 
        # *   Available: The ENI is available.
        # *   Attaching: The ENI is being attached to an instance.
        # *   InUse: The ENI is attached to an instance.
        # *   Detaching: The ENI is being detached from an instance.
        # *   Deleting: The ENI is being deleted.
        self.status = status
        # The type of the ENI. Valid values:
        # 
        # *   Primary
        # *   Secondary
        self.type = type
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id

    def validate(self):
        if self.ipv_6sets:
            self.ipv_6sets.validate()
        if self.private_ip_sets:
            self.private_ip_sets.validate()
        if self.security_group_ids:
            self.security_group_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ipv_6sets is not None:
            result['Ipv6Sets'] = self.ipv_6sets.to_map()
        if self.mac_address is not None:
            result['MacAddress'] = self.mac_address
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.network_interface_name is not None:
            result['NetworkInterfaceName'] = self.network_interface_name
        if self.primary_ip is not None:
            result['PrimaryIp'] = self.primary_ip
        if self.primary_ip_type is not None:
            result['PrimaryIpType'] = self.primary_ip_type
        if self.private_ip_sets is not None:
            result['PrivateIpSets'] = self.private_ip_sets.to_map()
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Ipv6Sets') is not None:
            temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets()
            self.ipv_6sets = temp_model.from_map(m['Ipv6Sets'])
        if m.get('MacAddress') is not None:
            self.mac_address = m.get('MacAddress')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('NetworkInterfaceName') is not None:
            self.network_interface_name = m.get('NetworkInterfaceName')
        if m.get('PrimaryIp') is not None:
            self.primary_ip = m.get('PrimaryIp')
        if m.get('PrimaryIpType') is not None:
            self.primary_ip_type = m.get('PrimaryIpType')
        if m.get('PrivateIpSets') is not None:
            temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets()
            self.private_ip_sets = temp_model.from_map(m['PrivateIpSets'])
        if m.get('SecurityGroupIds') is not None:
            temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds()
            self.security_group_ids = temp_model.from_map(m['SecurityGroupIds'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets(TeaModel):
    def __init__(
        self,
        network_interface_set: List[DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet] = None,
    ):
        self.network_interface_set = network_interface_set

    def validate(self):
        if self.network_interface_set:
            for k in self.network_interface_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NetworkInterfaceSet'] = []
        if self.network_interface_set is not None:
            for k in self.network_interface_set:
                result['NetworkInterfaceSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.network_interface_set = []
        if m.get('NetworkInterfaceSet') is not None:
            for k in m.get('NetworkInterfaceSet'):
                temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet()
                self.network_interface_set.append(temp_model.from_map(k))
        return self


class DescribeNetworkInterfacesResponseBody(TeaModel):
    def __init__(
        self,
        network_interface_sets: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # Details about the ENIs.
        self.network_interface_sets = network_interface_sets
        # The number of the page to return. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries returned per page. Maximum value: **50**. Default value: **10**.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries in the list.
        self.total_count = total_count

    def validate(self):
        if self.network_interface_sets:
            self.network_interface_sets.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_interface_sets is not None:
            result['NetworkInterfaceSets'] = self.network_interface_sets.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkInterfaceSets') is not None:
            temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets()
            self.network_interface_sets = temp_model.from_map(m['NetworkInterfaceSets'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeNetworkInterfacesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNetworkInterfacesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNetworkInterfacesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNetworksRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        ens_region_ids: List[str] = None,
        network_id: str = None,
        network_ids: List[str] = None,
        network_name: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The ID of the edge node.
        self.ens_region_id = ens_region_id
        # The IDs of edge nodes. You can specify 1 to 100 IDs.
        self.ens_region_ids = ens_region_ids
        # The ID of the network.
        self.network_id = network_id
        # The IDs of VPCs You can specify 1 to 100 IDs.
        self.network_ids = network_ids
        # The name of the network.
        self.network_name = network_name
        # The page number of the returned page. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Valid values: **1 to 50**. Default value: **10**.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.ens_region_ids is not None:
            result['EnsRegionIds'] = self.ens_region_ids
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.network_ids is not None:
            result['NetworkIds'] = self.network_ids
        if self.network_name is not None:
            result['NetworkName'] = self.network_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('EnsRegionIds') is not None:
            self.ens_region_ids = m.get('EnsRegionIds')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('NetworkIds') is not None:
            self.network_ids = m.get('NetworkIds')
        if m.get('NetworkName') is not None:
            self.network_name = m.get('NetworkName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeNetworksResponseBodyNetworksNetworkRouteTableIds(TeaModel):
    def __init__(
        self,
        route_table_id: List[str] = None,
    ):
        self.route_table_id = route_table_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.route_table_id is not None:
            result['RouteTableId'] = self.route_table_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RouteTableId') is not None:
            self.route_table_id = m.get('RouteTableId')
        return self


class DescribeNetworksResponseBodyNetworksNetworkTagsTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        tag_key: str = None,
        tag_value: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        self.tag_key = tag_key
        self.tag_value = tag_value
        # The bandwidth.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeNetworksResponseBodyNetworksNetworkTags(TeaModel):
    def __init__(
        self,
        tag: List[DescribeNetworksResponseBodyNetworksNetworkTagsTag] = None,
    ):
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeNetworksResponseBodyNetworksNetworkTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeNetworksResponseBodyNetworksNetworkVSwitchIds(TeaModel):
    def __init__(
        self,
        v_switch_id: List[str] = None,
    ):
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeNetworksResponseBodyNetworksNetwork(TeaModel):
    def __init__(
        self,
        cidr_block: str = None,
        created_time: str = None,
        description: str = None,
        ens_region_id: str = None,
        gateway_route_table_id: str = None,
        network_acl_id: str = None,
        network_id: str = None,
        network_name: str = None,
        route_table_id: str = None,
        route_table_ids: DescribeNetworksResponseBodyNetworksNetworkRouteTableIds = None,
        router_table_id: str = None,
        status: str = None,
        tags: DescribeNetworksResponseBodyNetworksNetworkTags = None,
        v_switch_ids: DescribeNetworksResponseBodyNetworksNetworkVSwitchIds = None,
    ):
        # The IPv4 CIDR block of the network.
        self.cidr_block = cidr_block
        # The timestamp when the instance was created. Unit: milliseconds.
        self.created_time = created_time
        # The description of the network.
        self.description = description
        # The ID of the edge node.
        self.ens_region_id = ens_region_id
        # The ID of the gateway route table.
        self.gateway_route_table_id = gateway_route_table_id
        # The ID of the network access control list (ACL).
        self.network_acl_id = network_acl_id
        # The ID of the network.
        self.network_id = network_id
        # The name of the network.
        self.network_name = network_name
        # The ID of the route table.
        self.route_table_id = route_table_id
        # The IDs of the route tables.
        self.route_table_ids = route_table_ids
        # The route table ID.
        self.router_table_id = router_table_id
        # The status of the network. Valid values:
        # 
        # *   Pending
        # *   Available
        self.status = status
        self.tags = tags
        # The list of vSwitches in the network.
        self.v_switch_ids = v_switch_ids

    def validate(self):
        if self.route_table_ids:
            self.route_table_ids.validate()
        if self.tags:
            self.tags.validate()
        if self.v_switch_ids:
            self.v_switch_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.description is not None:
            result['Description'] = self.description
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.gateway_route_table_id is not None:
            result['GatewayRouteTableId'] = self.gateway_route_table_id
        if self.network_acl_id is not None:
            result['NetworkAclId'] = self.network_acl_id
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.network_name is not None:
            result['NetworkName'] = self.network_name
        if self.route_table_id is not None:
            result['RouteTableId'] = self.route_table_id
        if self.route_table_ids is not None:
            result['RouteTableIds'] = self.route_table_ids.to_map()
        if self.router_table_id is not None:
            result['RouterTableId'] = self.router_table_id
        if self.status is not None:
            result['Status'] = self.status
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.v_switch_ids is not None:
            result['VSwitchIds'] = self.v_switch_ids.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('GatewayRouteTableId') is not None:
            self.gateway_route_table_id = m.get('GatewayRouteTableId')
        if m.get('NetworkAclId') is not None:
            self.network_acl_id = m.get('NetworkAclId')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('NetworkName') is not None:
            self.network_name = m.get('NetworkName')
        if m.get('RouteTableId') is not None:
            self.route_table_id = m.get('RouteTableId')
        if m.get('RouteTableIds') is not None:
            temp_model = DescribeNetworksResponseBodyNetworksNetworkRouteTableIds()
            self.route_table_ids = temp_model.from_map(m['RouteTableIds'])
        if m.get('RouterTableId') is not None:
            self.router_table_id = m.get('RouterTableId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tags') is not None:
            temp_model = DescribeNetworksResponseBodyNetworksNetworkTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('VSwitchIds') is not None:
            temp_model = DescribeNetworksResponseBodyNetworksNetworkVSwitchIds()
            self.v_switch_ids = temp_model.from_map(m['VSwitchIds'])
        return self


class DescribeNetworksResponseBodyNetworks(TeaModel):
    def __init__(
        self,
        network: List[DescribeNetworksResponseBodyNetworksNetwork] = None,
    ):
        self.network = network

    def validate(self):
        if self.network:
            for k in self.network:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Network'] = []
        if self.network is not None:
            for k in self.network:
                result['Network'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.network = []
        if m.get('Network') is not None:
            for k in m.get('Network'):
                temp_model = DescribeNetworksResponseBodyNetworksNetwork()
                self.network.append(temp_model.from_map(k))
        return self


class DescribeNetworksResponseBody(TeaModel):
    def __init__(
        self,
        networks: DescribeNetworksResponseBodyNetworks = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The VPCs.
        self.networks = networks
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned on each page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries in the list.
        self.total_count = total_count

    def validate(self):
        if self.networks:
            self.networks.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.networks is not None:
            result['Networks'] = self.networks.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Networks') is not None:
            temp_model = DescribeNetworksResponseBodyNetworks()
            self.networks = temp_model.from_map(m['Networks'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeNetworksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNetworksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNetworksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePrePaidInstanceStockRequest(TeaModel):
    def __init__(
        self,
        data_disk_size: int = None,
        ens_region_id: str = None,
        instance_spec: str = None,
        system_disk_size: int = None,
    ):
        # The size of the data disk. Unit: GB.
        # 
        # This parameter is required.
        self.data_disk_size = data_disk_size
        # The ID of the edge node.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        # The specification of the instance.
        # 
        # This parameter is required.
        self.instance_spec = instance_spec
        # The size of the system disk. Unit: GB.
        # 
        # This parameter is required.
        self.system_disk_size = system_disk_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_disk_size is not None:
            result['DataDiskSize'] = self.data_disk_size
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_spec is not None:
            result['InstanceSpec'] = self.instance_spec
        if self.system_disk_size is not None:
            result['SystemDiskSize'] = self.system_disk_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataDiskSize') is not None:
            self.data_disk_size = m.get('DataDiskSize')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceSpec') is not None:
            self.instance_spec = m.get('InstanceSpec')
        if m.get('SystemDiskSize') is not None:
            self.system_disk_size = m.get('SystemDiskSize')
        return self


class DescribePrePaidInstanceStockResponseBody(TeaModel):
    def __init__(
        self,
        avaliable_count: int = None,
        cores: int = None,
        data_disk_size: int = None,
        ens_region_id: str = None,
        instance_spec: str = None,
        memory: int = None,
        request_id: str = None,
        resource_gap: str = None,
        system_disk_size: int = None,
    ):
        # The number of resources that you can purchase.
        self.avaliable_count = avaliable_count
        # The number of CPU cores.
        self.cores = cores
        # The size of the data disk.
        self.data_disk_size = data_disk_size
        # The ID of the node.
        self.ens_region_id = ens_region_id
        # The specification of the instance.
        self.instance_spec = instance_spec
        # The memory size. Unit: GB.
        self.memory = memory
        # The request ID.
        self.request_id = request_id
        # The reason why resources are insufficient.
        self.resource_gap = resource_gap
        # The size of the system disk.
        self.system_disk_size = system_disk_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avaliable_count is not None:
            result['AvaliableCount'] = self.avaliable_count
        if self.cores is not None:
            result['Cores'] = self.cores
        if self.data_disk_size is not None:
            result['DataDiskSize'] = self.data_disk_size
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_spec is not None:
            result['InstanceSpec'] = self.instance_spec
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource_gap is not None:
            result['ResourceGap'] = self.resource_gap
        if self.system_disk_size is not None:
            result['SystemDiskSize'] = self.system_disk_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvaliableCount') is not None:
            self.avaliable_count = m.get('AvaliableCount')
        if m.get('Cores') is not None:
            self.cores = m.get('Cores')
        if m.get('DataDiskSize') is not None:
            self.data_disk_size = m.get('DataDiskSize')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceSpec') is not None:
            self.instance_spec = m.get('InstanceSpec')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResourceGap') is not None:
            self.resource_gap = m.get('ResourceGap')
        if m.get('SystemDiskSize') is not None:
            self.system_disk_size = m.get('SystemDiskSize')
        return self


class DescribePrePaidInstanceStockResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePrePaidInstanceStockResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePrePaidInstanceStockResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePriceRequestDataDisk(TeaModel):
    def __init__(
        self,
        size: int = None,
    ):
        # The size of the data disk. Unit: GB. If you specify this parameter, this parameter takes precedence over the Size property in DataDisks.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class DescribePriceRequestSystemDisk(TeaModel):
    def __init__(
        self,
        size: int = None,
    ):
        # The size of the system disk. Unit: GB.
        # 
        # This parameter is required.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class DescribePriceRequestDataDisks(TeaModel):
    def __init__(
        self,
        category: str = None,
        size: int = None,
    ):
        # The category of the disk.
        self.category = category
        # The size of the data disk. Unit: GB.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class DescribePriceRequest(TeaModel):
    def __init__(
        self,
        data_disk: List[DescribePriceRequestDataDisk] = None,
        system_disk: DescribePriceRequestSystemDisk = None,
        data_disks: List[DescribePriceRequestDataDisks] = None,
        ens_region_id: str = None,
        instance_type: str = None,
        internet_charge_type: str = None,
        period: int = None,
        period_unit: str = None,
        quantity: int = None,
    ):
        self.data_disk = data_disk
        self.system_disk = system_disk
        # If you leave DataDisk.1.Size empty, the value that you specified for this parameter is used.
        self.data_disks = data_disks
        # The ID of the ENS node.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        # The specifications of instances.
        # 
        # This parameter is required.
        self.instance_type = instance_type
        # The bandwidth metering method of the instance. Valid values:
        # 
        # *   BandwidthByDay: Pay by daily peak bandwidth
        # *   95BandwidthByMonth: Pay by monthly 95th percentile bandwidth
        # *   PayByBandwidth4thMonth: Pay by monthly fourth peak bandwidth
        # *   PayByBandwidth: Pay by fixed bandwidth
        # 
        # This parameter is required.
        self.internet_charge_type = internet_charge_type
        # The subscription duration of the instance.
        # 
        # *   If you leave the PeriodUnit parameter empty, the instance is purchased on a monthly basis. Valid values: Day and Month.
        # *   If you set PeriodUnit to Day, you can set Period only to 3.
        # *   If you set PeriodUnit to Month, you can set Period to a number from 1 to 9, or set Period to 12.
        # 
        # This parameter is required.
        self.period = period
        # The billing cycle of the ENS instance. Valid values:
        # 
        # *   Month (default):
        # *   Day
        self.period_unit = period_unit
        # The number of instances.
        # 
        # This parameter is required.
        self.quantity = quantity

    def validate(self):
        if self.data_disk:
            for k in self.data_disk:
                if k:
                    k.validate()
        if self.system_disk:
            self.system_disk.validate()
        if self.data_disks:
            for k in self.data_disks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataDisk'] = []
        if self.data_disk is not None:
            for k in self.data_disk:
                result['DataDisk'].append(k.to_map() if k else None)
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        result['DataDisks'] = []
        if self.data_disks is not None:
            for k in self.data_disks:
                result['DataDisks'].append(k.to_map() if k else None)
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.quantity is not None:
            result['Quantity'] = self.quantity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_disk = []
        if m.get('DataDisk') is not None:
            for k in m.get('DataDisk'):
                temp_model = DescribePriceRequestDataDisk()
                self.data_disk.append(temp_model.from_map(k))
        if m.get('SystemDisk') is not None:
            temp_model = DescribePriceRequestSystemDisk()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        self.data_disks = []
        if m.get('DataDisks') is not None:
            for k in m.get('DataDisks'):
                temp_model = DescribePriceRequestDataDisks()
                self.data_disks.append(temp_model.from_map(k))
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('Quantity') is not None:
            self.quantity = m.get('Quantity')
        return self


class DescribePriceShrinkRequestDataDisk(TeaModel):
    def __init__(
        self,
        size: int = None,
    ):
        # The size of the data disk. Unit: GB. If you specify this parameter, this parameter takes precedence over the Size property in DataDisks.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class DescribePriceShrinkRequestSystemDisk(TeaModel):
    def __init__(
        self,
        size: int = None,
    ):
        # The size of the system disk. Unit: GB.
        # 
        # This parameter is required.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class DescribePriceShrinkRequest(TeaModel):
    def __init__(
        self,
        data_disk: List[DescribePriceShrinkRequestDataDisk] = None,
        system_disk: DescribePriceShrinkRequestSystemDisk = None,
        data_disks_shrink: str = None,
        ens_region_id: str = None,
        instance_type: str = None,
        internet_charge_type: str = None,
        period: int = None,
        period_unit: str = None,
        quantity: int = None,
    ):
        self.data_disk = data_disk
        self.system_disk = system_disk
        # If you leave DataDisk.1.Size empty, the value that you specified for this parameter is used.
        self.data_disks_shrink = data_disks_shrink
        # The ID of the ENS node.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        # The specifications of instances.
        # 
        # This parameter is required.
        self.instance_type = instance_type
        # The bandwidth metering method of the instance. Valid values:
        # 
        # *   BandwidthByDay: Pay by daily peak bandwidth
        # *   95BandwidthByMonth: Pay by monthly 95th percentile bandwidth
        # *   PayByBandwidth4thMonth: Pay by monthly fourth peak bandwidth
        # *   PayByBandwidth: Pay by fixed bandwidth
        # 
        # This parameter is required.
        self.internet_charge_type = internet_charge_type
        # The subscription duration of the instance.
        # 
        # *   If you leave the PeriodUnit parameter empty, the instance is purchased on a monthly basis. Valid values: Day and Month.
        # *   If you set PeriodUnit to Day, you can set Period only to 3.
        # *   If you set PeriodUnit to Month, you can set Period to a number from 1 to 9, or set Period to 12.
        # 
        # This parameter is required.
        self.period = period
        # The billing cycle of the ENS instance. Valid values:
        # 
        # *   Month (default):
        # *   Day
        self.period_unit = period_unit
        # The number of instances.
        # 
        # This parameter is required.
        self.quantity = quantity

    def validate(self):
        if self.data_disk:
            for k in self.data_disk:
                if k:
                    k.validate()
        if self.system_disk:
            self.system_disk.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataDisk'] = []
        if self.data_disk is not None:
            for k in self.data_disk:
                result['DataDisk'].append(k.to_map() if k else None)
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        if self.data_disks_shrink is not None:
            result['DataDisks'] = self.data_disks_shrink
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.quantity is not None:
            result['Quantity'] = self.quantity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_disk = []
        if m.get('DataDisk') is not None:
            for k in m.get('DataDisk'):
                temp_model = DescribePriceShrinkRequestDataDisk()
                self.data_disk.append(temp_model.from_map(k))
        if m.get('SystemDisk') is not None:
            temp_model = DescribePriceShrinkRequestSystemDisk()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        if m.get('DataDisks') is not None:
            self.data_disks_shrink = m.get('DataDisks')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('Quantity') is not None:
            self.quantity = m.get('Quantity')
        return self


class DescribePriceResponseBodyPriceInfoPrice(TeaModel):
    def __init__(
        self,
        currency: str = None,
        discount_price: float = None,
        original_price: float = None,
        trade_price: float = None,
    ):
        # The type of currency.
        # 
        # *   USD: US dollar
        # *   JPY: Japanese Yen
        self.currency = currency
        # The discount.
        self.discount_price = discount_price
        # The original price.
        self.original_price = original_price
        # The final price.
        self.trade_price = trade_price

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.currency is not None:
            result['Currency'] = self.currency
        if self.discount_price is not None:
            result['DiscountPrice'] = self.discount_price
        if self.original_price is not None:
            result['OriginalPrice'] = self.original_price
        if self.trade_price is not None:
            result['TradePrice'] = self.trade_price
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Currency') is not None:
            self.currency = m.get('Currency')
        if m.get('DiscountPrice') is not None:
            self.discount_price = m.get('DiscountPrice')
        if m.get('OriginalPrice') is not None:
            self.original_price = m.get('OriginalPrice')
        if m.get('TradePrice') is not None:
            self.trade_price = m.get('TradePrice')
        return self


class DescribePriceResponseBodyPriceInfo(TeaModel):
    def __init__(
        self,
        price: DescribePriceResponseBodyPriceInfoPrice = None,
    ):
        # The price.
        self.price = price

    def validate(self):
        if self.price:
            self.price.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.price is not None:
            result['Price'] = self.price.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Price') is not None:
            temp_model = DescribePriceResponseBodyPriceInfoPrice()
            self.price = temp_model.from_map(m['Price'])
        return self


class DescribePriceResponseBody(TeaModel):
    def __init__(
        self,
        price_info: DescribePriceResponseBodyPriceInfo = None,
        request_id: str = None,
    ):
        # The price information.
        self.price_info = price_info
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.price_info:
            self.price_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.price_info is not None:
            result['PriceInfo'] = self.price_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PriceInfo') is not None:
            temp_model = DescribePriceResponseBodyPriceInfo()
            self.price_info = temp_model.from_map(m['PriceInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePriceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePriceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePriceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRegionIspsRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
    ):
        # The ID of the node. You can specify only one node ID in a call.
        self.ens_region_id = ens_region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        return self


class DescribeRegionIspsResponseBodyIsps(TeaModel):
    def __init__(
        self,
        code: str = None,
        name: str = None,
    ):
        # The code of the ISP.
        self.code = code
        # The name of the ISP.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeRegionIspsResponseBody(TeaModel):
    def __init__(
        self,
        isps: List[DescribeRegionIspsResponseBodyIsps] = None,
        request_id: str = None,
    ):
        # The list of ISPs.
        self.isps = isps
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.isps:
            for k in self.isps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Isps'] = []
        if self.isps is not None:
            for k in self.isps:
                result['Isps'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.isps = []
        if m.get('Isps') is not None:
            for k in m.get('Isps'):
                temp_model = DescribeRegionIspsResponseBodyIsps()
                self.isps.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeRegionIspsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRegionIspsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRegionIspsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRegionResourceRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        isp_type: str = None,
    ):
        self.ens_region_id = ens_region_id
        self.isp_type = isp_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.isp_type is not None:
            result['IspType'] = self.isp_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('IspType') is not None:
            self.isp_type = m.get('IspType')
        return self


class DescribeRegionResourceResponseBodyDataArmCard(TeaModel):
    def __init__(
        self,
        display: bool = None,
        oversell_ratio: int = None,
        remain: int = None,
        reserve_disable: bool = None,
        reserve_disable_total: int = None,
        reserved: int = None,
        status_disable: bool = None,
        status_disable_total: int = None,
        total: int = None,
        type: str = None,
        used: int = None,
        used_ratio: int = None,
    ):
        self.display = display
        self.oversell_ratio = oversell_ratio
        self.remain = remain
        self.reserve_disable = reserve_disable
        self.reserve_disable_total = reserve_disable_total
        self.reserved = reserved
        self.status_disable = status_disable
        self.status_disable_total = status_disable_total
        self.total = total
        self.type = type
        self.used = used
        self.used_ratio = used_ratio

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.oversell_ratio is not None:
            result['OversellRatio'] = self.oversell_ratio
        if self.remain is not None:
            result['Remain'] = self.remain
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.reserve_disable_total is not None:
            result['ReserveDisableTotal'] = self.reserve_disable_total
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.status_disable_total is not None:
            result['StatusDisableTotal'] = self.status_disable_total
        if self.total is not None:
            result['Total'] = self.total
        if self.type is not None:
            result['Type'] = self.type
        if self.used is not None:
            result['Used'] = self.used
        if self.used_ratio is not None:
            result['UsedRatio'] = self.used_ratio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('OversellRatio') is not None:
            self.oversell_ratio = m.get('OversellRatio')
        if m.get('Remain') is not None:
            self.remain = m.get('Remain')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('ReserveDisableTotal') is not None:
            self.reserve_disable_total = m.get('ReserveDisableTotal')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('StatusDisableTotal') is not None:
            self.status_disable_total = m.get('StatusDisableTotal')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UsedRatio') is not None:
            self.used_ratio = m.get('UsedRatio')
        return self


class DescribeRegionResourceResponseBodyDataBandwidth(TeaModel):
    def __init__(
        self,
        display: bool = None,
        oversell_ratio: int = None,
        remain: int = None,
        reserve_disable: bool = None,
        reserve_disable_total: int = None,
        reserved: int = None,
        status_disable: bool = None,
        status_disable_total: int = None,
        total: int = None,
        type: str = None,
        used: int = None,
        used_ratio: int = None,
    ):
        self.display = display
        self.oversell_ratio = oversell_ratio
        self.remain = remain
        self.reserve_disable = reserve_disable
        self.reserve_disable_total = reserve_disable_total
        self.reserved = reserved
        self.status_disable = status_disable
        self.status_disable_total = status_disable_total
        self.total = total
        self.type = type
        self.used = used
        self.used_ratio = used_ratio

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.oversell_ratio is not None:
            result['OversellRatio'] = self.oversell_ratio
        if self.remain is not None:
            result['Remain'] = self.remain
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.reserve_disable_total is not None:
            result['ReserveDisableTotal'] = self.reserve_disable_total
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.status_disable_total is not None:
            result['StatusDisableTotal'] = self.status_disable_total
        if self.total is not None:
            result['Total'] = self.total
        if self.type is not None:
            result['Type'] = self.type
        if self.used is not None:
            result['Used'] = self.used
        if self.used_ratio is not None:
            result['UsedRatio'] = self.used_ratio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('OversellRatio') is not None:
            self.oversell_ratio = m.get('OversellRatio')
        if m.get('Remain') is not None:
            self.remain = m.get('Remain')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('ReserveDisableTotal') is not None:
            self.reserve_disable_total = m.get('ReserveDisableTotal')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('StatusDisableTotal') is not None:
            self.status_disable_total = m.get('StatusDisableTotal')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UsedRatio') is not None:
            self.used_ratio = m.get('UsedRatio')
        return self


class DescribeRegionResourceResponseBodyDataBlockStorage(TeaModel):
    def __init__(
        self,
        display: bool = None,
        oversell_ratio: int = None,
        remain: int = None,
        reserve_disable: bool = None,
        reserve_disable_total: int = None,
        reserved: int = None,
        status_disable: bool = None,
        status_disable_total: int = None,
        total: int = None,
        type: str = None,
        used: int = None,
        used_ratio: int = None,
    ):
        self.display = display
        self.oversell_ratio = oversell_ratio
        self.remain = remain
        self.reserve_disable = reserve_disable
        self.reserve_disable_total = reserve_disable_total
        self.reserved = reserved
        self.status_disable = status_disable
        self.status_disable_total = status_disable_total
        self.total = total
        self.type = type
        self.used = used
        self.used_ratio = used_ratio

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.oversell_ratio is not None:
            result['OversellRatio'] = self.oversell_ratio
        if self.remain is not None:
            result['Remain'] = self.remain
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.reserve_disable_total is not None:
            result['ReserveDisableTotal'] = self.reserve_disable_total
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.status_disable_total is not None:
            result['StatusDisableTotal'] = self.status_disable_total
        if self.total is not None:
            result['Total'] = self.total
        if self.type is not None:
            result['Type'] = self.type
        if self.used is not None:
            result['Used'] = self.used
        if self.used_ratio is not None:
            result['UsedRatio'] = self.used_ratio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('OversellRatio') is not None:
            self.oversell_ratio = m.get('OversellRatio')
        if m.get('Remain') is not None:
            self.remain = m.get('Remain')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('ReserveDisableTotal') is not None:
            self.reserve_disable_total = m.get('ReserveDisableTotal')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('StatusDisableTotal') is not None:
            self.status_disable_total = m.get('StatusDisableTotal')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UsedRatio') is not None:
            self.used_ratio = m.get('UsedRatio')
        return self


class DescribeRegionResourceResponseBodyDataCpu(TeaModel):
    def __init__(
        self,
        display: bool = None,
        oversell_ratio: int = None,
        remain: int = None,
        reserve_disable: bool = None,
        reserve_disable_total: int = None,
        reserved: int = None,
        status_disable: bool = None,
        status_disable_total: int = None,
        total: int = None,
        type: str = None,
        used: int = None,
        used_ratio: int = None,
    ):
        self.display = display
        self.oversell_ratio = oversell_ratio
        self.remain = remain
        self.reserve_disable = reserve_disable
        self.reserve_disable_total = reserve_disable_total
        self.reserved = reserved
        self.status_disable = status_disable
        self.status_disable_total = status_disable_total
        self.total = total
        self.type = type
        self.used = used
        self.used_ratio = used_ratio

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.oversell_ratio is not None:
            result['OversellRatio'] = self.oversell_ratio
        if self.remain is not None:
            result['Remain'] = self.remain
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.reserve_disable_total is not None:
            result['ReserveDisableTotal'] = self.reserve_disable_total
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.status_disable_total is not None:
            result['StatusDisableTotal'] = self.status_disable_total
        if self.total is not None:
            result['Total'] = self.total
        if self.type is not None:
            result['Type'] = self.type
        if self.used is not None:
            result['Used'] = self.used
        if self.used_ratio is not None:
            result['UsedRatio'] = self.used_ratio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('OversellRatio') is not None:
            self.oversell_ratio = m.get('OversellRatio')
        if m.get('Remain') is not None:
            self.remain = m.get('Remain')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('ReserveDisableTotal') is not None:
            self.reserve_disable_total = m.get('ReserveDisableTotal')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('StatusDisableTotal') is not None:
            self.status_disable_total = m.get('StatusDisableTotal')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UsedRatio') is not None:
            self.used_ratio = m.get('UsedRatio')
        return self


class DescribeRegionResourceResponseBodyDataGpu(TeaModel):
    def __init__(
        self,
        display: bool = None,
        oversell_ratio: int = None,
        remain: int = None,
        reserve_disable: bool = None,
        reserve_disable_total: int = None,
        reserved: int = None,
        status_disable: bool = None,
        status_disable_total: int = None,
        total: int = None,
        type: str = None,
        used: int = None,
        used_ratio: int = None,
    ):
        self.display = display
        self.oversell_ratio = oversell_ratio
        self.remain = remain
        self.reserve_disable = reserve_disable
        self.reserve_disable_total = reserve_disable_total
        self.reserved = reserved
        self.status_disable = status_disable
        self.status_disable_total = status_disable_total
        self.total = total
        self.type = type
        self.used = used
        self.used_ratio = used_ratio

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.oversell_ratio is not None:
            result['OversellRatio'] = self.oversell_ratio
        if self.remain is not None:
            result['Remain'] = self.remain
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.reserve_disable_total is not None:
            result['ReserveDisableTotal'] = self.reserve_disable_total
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.status_disable_total is not None:
            result['StatusDisableTotal'] = self.status_disable_total
        if self.total is not None:
            result['Total'] = self.total
        if self.type is not None:
            result['Type'] = self.type
        if self.used is not None:
            result['Used'] = self.used
        if self.used_ratio is not None:
            result['UsedRatio'] = self.used_ratio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('OversellRatio') is not None:
            self.oversell_ratio = m.get('OversellRatio')
        if m.get('Remain') is not None:
            self.remain = m.get('Remain')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('ReserveDisableTotal') is not None:
            self.reserve_disable_total = m.get('ReserveDisableTotal')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('StatusDisableTotal') is not None:
            self.status_disable_total = m.get('StatusDisableTotal')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UsedRatio') is not None:
            self.used_ratio = m.get('UsedRatio')
        return self


class DescribeRegionResourceResponseBodyDataHdd(TeaModel):
    def __init__(
        self,
        display: bool = None,
        oversell_ratio: int = None,
        remain: int = None,
        reserve_disable: bool = None,
        reserve_disable_total: int = None,
        reserved: int = None,
        status_disable: bool = None,
        status_disable_total: int = None,
        total: int = None,
        type: str = None,
        used: int = None,
        used_ratio: int = None,
    ):
        self.display = display
        self.oversell_ratio = oversell_ratio
        self.remain = remain
        self.reserve_disable = reserve_disable
        self.reserve_disable_total = reserve_disable_total
        self.reserved = reserved
        self.status_disable = status_disable
        self.status_disable_total = status_disable_total
        self.total = total
        self.type = type
        self.used = used
        self.used_ratio = used_ratio

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.oversell_ratio is not None:
            result['OversellRatio'] = self.oversell_ratio
        if self.remain is not None:
            result['Remain'] = self.remain
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.reserve_disable_total is not None:
            result['ReserveDisableTotal'] = self.reserve_disable_total
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.status_disable_total is not None:
            result['StatusDisableTotal'] = self.status_disable_total
        if self.total is not None:
            result['Total'] = self.total
        if self.type is not None:
            result['Type'] = self.type
        if self.used is not None:
            result['Used'] = self.used
        if self.used_ratio is not None:
            result['UsedRatio'] = self.used_ratio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('OversellRatio') is not None:
            self.oversell_ratio = m.get('OversellRatio')
        if m.get('Remain') is not None:
            self.remain = m.get('Remain')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('ReserveDisableTotal') is not None:
            self.reserve_disable_total = m.get('ReserveDisableTotal')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('StatusDisableTotal') is not None:
            self.status_disable_total = m.get('StatusDisableTotal')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UsedRatio') is not None:
            self.used_ratio = m.get('UsedRatio')
        return self


class DescribeRegionResourceResponseBodyDataIpv4s(TeaModel):
    def __init__(
        self,
        display: str = None,
        isp: str = None,
        oversell_ratio: int = None,
        remain: int = None,
        reserve_disable: bool = None,
        reserve_disable_total: int = None,
        reserved: int = None,
        status_disable: bool = None,
        status_disable_total: int = None,
        total: int = None,
        type: str = None,
        used: int = None,
        used_ratio: int = None,
        vlan: str = None,
    ):
        self.display = display
        self.isp = isp
        self.oversell_ratio = oversell_ratio
        self.remain = remain
        self.reserve_disable = reserve_disable
        self.reserve_disable_total = reserve_disable_total
        self.reserved = reserved
        self.status_disable = status_disable
        self.status_disable_total = status_disable_total
        self.total = total
        self.type = type
        self.used = used
        self.used_ratio = used_ratio
        self.vlan = vlan

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.oversell_ratio is not None:
            result['OversellRatio'] = self.oversell_ratio
        if self.remain is not None:
            result['Remain'] = self.remain
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.reserve_disable_total is not None:
            result['ReserveDisableTotal'] = self.reserve_disable_total
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.status_disable_total is not None:
            result['StatusDisableTotal'] = self.status_disable_total
        if self.total is not None:
            result['Total'] = self.total
        if self.type is not None:
            result['Type'] = self.type
        if self.used is not None:
            result['Used'] = self.used
        if self.used_ratio is not None:
            result['UsedRatio'] = self.used_ratio
        if self.vlan is not None:
            result['Vlan'] = self.vlan
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('OversellRatio') is not None:
            self.oversell_ratio = m.get('OversellRatio')
        if m.get('Remain') is not None:
            self.remain = m.get('Remain')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('ReserveDisableTotal') is not None:
            self.reserve_disable_total = m.get('ReserveDisableTotal')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('StatusDisableTotal') is not None:
            self.status_disable_total = m.get('StatusDisableTotal')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UsedRatio') is not None:
            self.used_ratio = m.get('UsedRatio')
        if m.get('Vlan') is not None:
            self.vlan = m.get('Vlan')
        return self


class DescribeRegionResourceResponseBodyDataIpv6s(TeaModel):
    def __init__(
        self,
        display: str = None,
        isp: str = None,
        oversell_ratio: int = None,
        remain: int = None,
        reserve_disable: bool = None,
        reserve_disable_total: int = None,
        reserved: int = None,
        status_disable: bool = None,
        status_disable_total: int = None,
        total: int = None,
        type: str = None,
        used: int = None,
        used_ratio: int = None,
        vlan: str = None,
    ):
        self.display = display
        self.isp = isp
        self.oversell_ratio = oversell_ratio
        self.remain = remain
        self.reserve_disable = reserve_disable
        self.reserve_disable_total = reserve_disable_total
        self.reserved = reserved
        self.status_disable = status_disable
        self.status_disable_total = status_disable_total
        self.total = total
        self.type = type
        self.used = used
        self.used_ratio = used_ratio
        self.vlan = vlan

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.oversell_ratio is not None:
            result['OversellRatio'] = self.oversell_ratio
        if self.remain is not None:
            result['Remain'] = self.remain
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.reserve_disable_total is not None:
            result['ReserveDisableTotal'] = self.reserve_disable_total
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.status_disable_total is not None:
            result['StatusDisableTotal'] = self.status_disable_total
        if self.total is not None:
            result['Total'] = self.total
        if self.type is not None:
            result['Type'] = self.type
        if self.used is not None:
            result['Used'] = self.used
        if self.used_ratio is not None:
            result['UsedRatio'] = self.used_ratio
        if self.vlan is not None:
            result['Vlan'] = self.vlan
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('OversellRatio') is not None:
            self.oversell_ratio = m.get('OversellRatio')
        if m.get('Remain') is not None:
            self.remain = m.get('Remain')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('ReserveDisableTotal') is not None:
            self.reserve_disable_total = m.get('ReserveDisableTotal')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('StatusDisableTotal') is not None:
            self.status_disable_total = m.get('StatusDisableTotal')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UsedRatio') is not None:
            self.used_ratio = m.get('UsedRatio')
        if m.get('Vlan') is not None:
            self.vlan = m.get('Vlan')
        return self


class DescribeRegionResourceResponseBodyDataMemory(TeaModel):
    def __init__(
        self,
        display: bool = None,
        oversell_ratio: int = None,
        remain: int = None,
        reserve_disable: bool = None,
        reserve_disable_total: int = None,
        reserved: int = None,
        status_disable: bool = None,
        status_disable_total: int = None,
        total: int = None,
        type: str = None,
        used: int = None,
        used_ratio: int = None,
    ):
        self.display = display
        self.oversell_ratio = oversell_ratio
        self.remain = remain
        self.reserve_disable = reserve_disable
        self.reserve_disable_total = reserve_disable_total
        self.reserved = reserved
        self.status_disable = status_disable
        self.status_disable_total = status_disable_total
        self.total = total
        self.type = type
        self.used = used
        self.used_ratio = used_ratio

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.oversell_ratio is not None:
            result['OversellRatio'] = self.oversell_ratio
        if self.remain is not None:
            result['Remain'] = self.remain
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.reserve_disable_total is not None:
            result['ReserveDisableTotal'] = self.reserve_disable_total
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.status_disable_total is not None:
            result['StatusDisableTotal'] = self.status_disable_total
        if self.total is not None:
            result['Total'] = self.total
        if self.type is not None:
            result['Type'] = self.type
        if self.used is not None:
            result['Used'] = self.used
        if self.used_ratio is not None:
            result['UsedRatio'] = self.used_ratio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('OversellRatio') is not None:
            self.oversell_ratio = m.get('OversellRatio')
        if m.get('Remain') is not None:
            self.remain = m.get('Remain')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('ReserveDisableTotal') is not None:
            self.reserve_disable_total = m.get('ReserveDisableTotal')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('StatusDisableTotal') is not None:
            self.status_disable_total = m.get('StatusDisableTotal')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UsedRatio') is not None:
            self.used_ratio = m.get('UsedRatio')
        return self


class DescribeRegionResourceResponseBodyDataNvme(TeaModel):
    def __init__(
        self,
        display: bool = None,
        oversell_ratio: int = None,
        remain: int = None,
        reserve_disable: bool = None,
        reserve_disable_total: int = None,
        reserved: int = None,
        status_disable: bool = None,
        status_disable_total: int = None,
        total: int = None,
        type: str = None,
        used: int = None,
        used_ratio: int = None,
    ):
        self.display = display
        self.oversell_ratio = oversell_ratio
        self.remain = remain
        self.reserve_disable = reserve_disable
        self.reserve_disable_total = reserve_disable_total
        self.reserved = reserved
        self.status_disable = status_disable
        self.status_disable_total = status_disable_total
        self.total = total
        self.type = type
        self.used = used
        self.used_ratio = used_ratio

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.oversell_ratio is not None:
            result['OversellRatio'] = self.oversell_ratio
        if self.remain is not None:
            result['Remain'] = self.remain
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.reserve_disable_total is not None:
            result['ReserveDisableTotal'] = self.reserve_disable_total
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.status_disable_total is not None:
            result['StatusDisableTotal'] = self.status_disable_total
        if self.total is not None:
            result['Total'] = self.total
        if self.type is not None:
            result['Type'] = self.type
        if self.used is not None:
            result['Used'] = self.used
        if self.used_ratio is not None:
            result['UsedRatio'] = self.used_ratio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('OversellRatio') is not None:
            self.oversell_ratio = m.get('OversellRatio')
        if m.get('Remain') is not None:
            self.remain = m.get('Remain')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('ReserveDisableTotal') is not None:
            self.reserve_disable_total = m.get('ReserveDisableTotal')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('StatusDisableTotal') is not None:
            self.status_disable_total = m.get('StatusDisableTotal')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UsedRatio') is not None:
            self.used_ratio = m.get('UsedRatio')
        return self


class DescribeRegionResourceResponseBodyDataOssStorage(TeaModel):
    def __init__(
        self,
        display: bool = None,
        oversell_ratio: int = None,
        remain: int = None,
        reserve_disable: bool = None,
        reserve_disable_total: int = None,
        reserved: int = None,
        status_disable: bool = None,
        status_disable_total: int = None,
        total: int = None,
        type: str = None,
        used: int = None,
        used_ratio: int = None,
    ):
        self.display = display
        self.oversell_ratio = oversell_ratio
        self.remain = remain
        self.reserve_disable = reserve_disable
        self.reserve_disable_total = reserve_disable_total
        self.reserved = reserved
        self.status_disable = status_disable
        self.status_disable_total = status_disable_total
        self.total = total
        self.type = type
        self.used = used
        self.used_ratio = used_ratio

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.oversell_ratio is not None:
            result['OversellRatio'] = self.oversell_ratio
        if self.remain is not None:
            result['Remain'] = self.remain
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.reserve_disable_total is not None:
            result['ReserveDisableTotal'] = self.reserve_disable_total
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.status_disable_total is not None:
            result['StatusDisableTotal'] = self.status_disable_total
        if self.total is not None:
            result['Total'] = self.total
        if self.type is not None:
            result['Type'] = self.type
        if self.used is not None:
            result['Used'] = self.used
        if self.used_ratio is not None:
            result['UsedRatio'] = self.used_ratio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('OversellRatio') is not None:
            self.oversell_ratio = m.get('OversellRatio')
        if m.get('Remain') is not None:
            self.remain = m.get('Remain')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('ReserveDisableTotal') is not None:
            self.reserve_disable_total = m.get('ReserveDisableTotal')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('StatusDisableTotal') is not None:
            self.status_disable_total = m.get('StatusDisableTotal')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UsedRatio') is not None:
            self.used_ratio = m.get('UsedRatio')
        return self


class DescribeRegionResourceResponseBodyDataPangu(TeaModel):
    def __init__(
        self,
        display: bool = None,
        oversell_ratio: int = None,
        remain: int = None,
        reserve_disable: bool = None,
        reserve_disable_total: int = None,
        reserved: int = None,
        status_disable: bool = None,
        status_disable_total: int = None,
        total: int = None,
        type: str = None,
        used: int = None,
        used_ratio: int = None,
    ):
        self.display = display
        self.oversell_ratio = oversell_ratio
        self.remain = remain
        self.reserve_disable = reserve_disable
        self.reserve_disable_total = reserve_disable_total
        self.reserved = reserved
        self.status_disable = status_disable
        self.status_disable_total = status_disable_total
        self.total = total
        self.type = type
        self.used = used
        self.used_ratio = used_ratio

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.oversell_ratio is not None:
            result['OversellRatio'] = self.oversell_ratio
        if self.remain is not None:
            result['Remain'] = self.remain
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.reserve_disable_total is not None:
            result['ReserveDisableTotal'] = self.reserve_disable_total
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.status_disable_total is not None:
            result['StatusDisableTotal'] = self.status_disable_total
        if self.total is not None:
            result['Total'] = self.total
        if self.type is not None:
            result['Type'] = self.type
        if self.used is not None:
            result['Used'] = self.used
        if self.used_ratio is not None:
            result['UsedRatio'] = self.used_ratio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('OversellRatio') is not None:
            self.oversell_ratio = m.get('OversellRatio')
        if m.get('Remain') is not None:
            self.remain = m.get('Remain')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('ReserveDisableTotal') is not None:
            self.reserve_disable_total = m.get('ReserveDisableTotal')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('StatusDisableTotal') is not None:
            self.status_disable_total = m.get('StatusDisableTotal')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UsedRatio') is not None:
            self.used_ratio = m.get('UsedRatio')
        return self


class DescribeRegionResourceResponseBodyDataPcfarmNum(TeaModel):
    def __init__(
        self,
        display: bool = None,
        oversell_ratio: int = None,
        remain: int = None,
        reserve_disable: bool = None,
        reserve_disable_total: int = None,
        reserved: int = None,
        status_disable: bool = None,
        status_disable_total: int = None,
        total: int = None,
        type: str = None,
        used: int = None,
        used_ratio: int = None,
    ):
        self.display = display
        self.oversell_ratio = oversell_ratio
        self.remain = remain
        self.reserve_disable = reserve_disable
        self.reserve_disable_total = reserve_disable_total
        self.reserved = reserved
        self.status_disable = status_disable
        self.status_disable_total = status_disable_total
        self.total = total
        self.type = type
        self.used = used
        self.used_ratio = used_ratio

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.oversell_ratio is not None:
            result['OversellRatio'] = self.oversell_ratio
        if self.remain is not None:
            result['Remain'] = self.remain
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.reserve_disable_total is not None:
            result['ReserveDisableTotal'] = self.reserve_disable_total
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.status_disable_total is not None:
            result['StatusDisableTotal'] = self.status_disable_total
        if self.total is not None:
            result['Total'] = self.total
        if self.type is not None:
            result['Type'] = self.type
        if self.used is not None:
            result['Used'] = self.used
        if self.used_ratio is not None:
            result['UsedRatio'] = self.used_ratio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('OversellRatio') is not None:
            self.oversell_ratio = m.get('OversellRatio')
        if m.get('Remain') is not None:
            self.remain = m.get('Remain')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('ReserveDisableTotal') is not None:
            self.reserve_disable_total = m.get('ReserveDisableTotal')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('StatusDisableTotal') is not None:
            self.status_disable_total = m.get('StatusDisableTotal')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UsedRatio') is not None:
            self.used_ratio = m.get('UsedRatio')
        return self


class DescribeRegionResourceResponseBodyDataSsd(TeaModel):
    def __init__(
        self,
        display: bool = None,
        oversell_ratio: int = None,
        remain: int = None,
        reserve_disable: bool = None,
        reserve_disable_total: int = None,
        reserved: int = None,
        status_disable: bool = None,
        status_disable_total: int = None,
        total: int = None,
        type: str = None,
        used: int = None,
        used_ratio: int = None,
    ):
        self.display = display
        self.oversell_ratio = oversell_ratio
        self.remain = remain
        self.reserve_disable = reserve_disable
        self.reserve_disable_total = reserve_disable_total
        self.reserved = reserved
        self.status_disable = status_disable
        self.status_disable_total = status_disable_total
        self.total = total
        self.type = type
        self.used = used
        self.used_ratio = used_ratio

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.oversell_ratio is not None:
            result['OversellRatio'] = self.oversell_ratio
        if self.remain is not None:
            result['Remain'] = self.remain
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.reserve_disable_total is not None:
            result['ReserveDisableTotal'] = self.reserve_disable_total
        if self.reserved is not None:
            result['Reserved'] = self.reserved
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.status_disable_total is not None:
            result['StatusDisableTotal'] = self.status_disable_total
        if self.total is not None:
            result['Total'] = self.total
        if self.type is not None:
            result['Type'] = self.type
        if self.used is not None:
            result['Used'] = self.used
        if self.used_ratio is not None:
            result['UsedRatio'] = self.used_ratio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('OversellRatio') is not None:
            self.oversell_ratio = m.get('OversellRatio')
        if m.get('Remain') is not None:
            self.remain = m.get('Remain')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('ReserveDisableTotal') is not None:
            self.reserve_disable_total = m.get('ReserveDisableTotal')
        if m.get('Reserved') is not None:
            self.reserved = m.get('Reserved')
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('StatusDisableTotal') is not None:
            self.status_disable_total = m.get('StatusDisableTotal')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Used') is not None:
            self.used = m.get('Used')
        if m.get('UsedRatio') is not None:
            self.used_ratio = m.get('UsedRatio')
        return self


class DescribeRegionResourceResponseBodyData(TeaModel):
    def __init__(
        self,
        area_code: str = None,
        area_name: str = None,
        arm_card: DescribeRegionResourceResponseBodyDataArmCard = None,
        attributes: List[str] = None,
        bandwidth: DescribeRegionResourceResponseBodyDataBandwidth = None,
        block_storage: DescribeRegionResourceResponseBodyDataBlockStorage = None,
        country_code: str = None,
        country_name: str = None,
        cpu: DescribeRegionResourceResponseBodyDataCpu = None,
        gpu: DescribeRegionResourceResponseBodyDataGpu = None,
        hdd: DescribeRegionResourceResponseBodyDataHdd = None,
        house_id: str = None,
        ipv_4s: List[DescribeRegionResourceResponseBodyDataIpv4s] = None,
        ipv_6s: List[DescribeRegionResourceResponseBodyDataIpv6s] = None,
        isp_types: List[str] = None,
        memory: DescribeRegionResourceResponseBodyDataMemory = None,
        name: str = None,
        nvme: DescribeRegionResourceResponseBodyDataNvme = None,
        oss_storage: DescribeRegionResourceResponseBodyDataOssStorage = None,
        pangu: DescribeRegionResourceResponseBodyDataPangu = None,
        pcfarm_num: DescribeRegionResourceResponseBodyDataPcfarmNum = None,
        poc: bool = None,
        province_code: str = None,
        province_name: str = None,
        reserve_disable: bool = None,
        ssd: DescribeRegionResourceResponseBodyDataSsd = None,
        status_disable: bool = None,
        type: str = None,
        uuid: str = None,
        virtual: str = None,
    ):
        self.area_code = area_code
        self.area_name = area_name
        self.arm_card = arm_card
        self.attributes = attributes
        self.bandwidth = bandwidth
        self.block_storage = block_storage
        self.country_code = country_code
        self.country_name = country_name
        self.cpu = cpu
        self.gpu = gpu
        self.hdd = hdd
        self.house_id = house_id
        self.ipv_4s = ipv_4s
        self.ipv_6s = ipv_6s
        self.isp_types = isp_types
        self.memory = memory
        self.name = name
        self.nvme = nvme
        self.oss_storage = oss_storage
        self.pangu = pangu
        self.pcfarm_num = pcfarm_num
        self.poc = poc
        self.province_code = province_code
        self.province_name = province_name
        self.reserve_disable = reserve_disable
        self.ssd = ssd
        self.status_disable = status_disable
        self.type = type
        self.uuid = uuid
        self.virtual = virtual

    def validate(self):
        if self.arm_card:
            self.arm_card.validate()
        if self.bandwidth:
            self.bandwidth.validate()
        if self.block_storage:
            self.block_storage.validate()
        if self.cpu:
            self.cpu.validate()
        if self.gpu:
            self.gpu.validate()
        if self.hdd:
            self.hdd.validate()
        if self.ipv_4s:
            for k in self.ipv_4s:
                if k:
                    k.validate()
        if self.ipv_6s:
            for k in self.ipv_6s:
                if k:
                    k.validate()
        if self.memory:
            self.memory.validate()
        if self.nvme:
            self.nvme.validate()
        if self.oss_storage:
            self.oss_storage.validate()
        if self.pangu:
            self.pangu.validate()
        if self.pcfarm_num:
            self.pcfarm_num.validate()
        if self.ssd:
            self.ssd.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.area_code is not None:
            result['AreaCode'] = self.area_code
        if self.area_name is not None:
            result['AreaName'] = self.area_name
        if self.arm_card is not None:
            result['ArmCard'] = self.arm_card.to_map()
        if self.attributes is not None:
            result['Attributes'] = self.attributes
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth.to_map()
        if self.block_storage is not None:
            result['BlockStorage'] = self.block_storage.to_map()
        if self.country_code is not None:
            result['CountryCode'] = self.country_code
        if self.country_name is not None:
            result['CountryName'] = self.country_name
        if self.cpu is not None:
            result['Cpu'] = self.cpu.to_map()
        if self.gpu is not None:
            result['Gpu'] = self.gpu.to_map()
        if self.hdd is not None:
            result['Hdd'] = self.hdd.to_map()
        if self.house_id is not None:
            result['HouseId'] = self.house_id
        result['Ipv4s'] = []
        if self.ipv_4s is not None:
            for k in self.ipv_4s:
                result['Ipv4s'].append(k.to_map() if k else None)
        result['Ipv6s'] = []
        if self.ipv_6s is not None:
            for k in self.ipv_6s:
                result['Ipv6s'].append(k.to_map() if k else None)
        if self.isp_types is not None:
            result['IspTypes'] = self.isp_types
        if self.memory is not None:
            result['Memory'] = self.memory.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.nvme is not None:
            result['Nvme'] = self.nvme.to_map()
        if self.oss_storage is not None:
            result['OssStorage'] = self.oss_storage.to_map()
        if self.pangu is not None:
            result['Pangu'] = self.pangu.to_map()
        if self.pcfarm_num is not None:
            result['PcfarmNum'] = self.pcfarm_num.to_map()
        if self.poc is not None:
            result['Poc'] = self.poc
        if self.province_code is not None:
            result['ProvinceCode'] = self.province_code
        if self.province_name is not None:
            result['ProvinceName'] = self.province_name
        if self.reserve_disable is not None:
            result['ReserveDisable'] = self.reserve_disable
        if self.ssd is not None:
            result['Ssd'] = self.ssd.to_map()
        if self.status_disable is not None:
            result['StatusDisable'] = self.status_disable
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.virtual is not None:
            result['Virtual'] = self.virtual
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AreaCode') is not None:
            self.area_code = m.get('AreaCode')
        if m.get('AreaName') is not None:
            self.area_name = m.get('AreaName')
        if m.get('ArmCard') is not None:
            temp_model = DescribeRegionResourceResponseBodyDataArmCard()
            self.arm_card = temp_model.from_map(m['ArmCard'])
        if m.get('Attributes') is not None:
            self.attributes = m.get('Attributes')
        if m.get('Bandwidth') is not None:
            temp_model = DescribeRegionResourceResponseBodyDataBandwidth()
            self.bandwidth = temp_model.from_map(m['Bandwidth'])
        if m.get('BlockStorage') is not None:
            temp_model = DescribeRegionResourceResponseBodyDataBlockStorage()
            self.block_storage = temp_model.from_map(m['BlockStorage'])
        if m.get('CountryCode') is not None:
            self.country_code = m.get('CountryCode')
        if m.get('CountryName') is not None:
            self.country_name = m.get('CountryName')
        if m.get('Cpu') is not None:
            temp_model = DescribeRegionResourceResponseBodyDataCpu()
            self.cpu = temp_model.from_map(m['Cpu'])
        if m.get('Gpu') is not None:
            temp_model = DescribeRegionResourceResponseBodyDataGpu()
            self.gpu = temp_model.from_map(m['Gpu'])
        if m.get('Hdd') is not None:
            temp_model = DescribeRegionResourceResponseBodyDataHdd()
            self.hdd = temp_model.from_map(m['Hdd'])
        if m.get('HouseId') is not None:
            self.house_id = m.get('HouseId')
        self.ipv_4s = []
        if m.get('Ipv4s') is not None:
            for k in m.get('Ipv4s'):
                temp_model = DescribeRegionResourceResponseBodyDataIpv4s()
                self.ipv_4s.append(temp_model.from_map(k))
        self.ipv_6s = []
        if m.get('Ipv6s') is not None:
            for k in m.get('Ipv6s'):
                temp_model = DescribeRegionResourceResponseBodyDataIpv6s()
                self.ipv_6s.append(temp_model.from_map(k))
        if m.get('IspTypes') is not None:
            self.isp_types = m.get('IspTypes')
        if m.get('Memory') is not None:
            temp_model = DescribeRegionResourceResponseBodyDataMemory()
            self.memory = temp_model.from_map(m['Memory'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Nvme') is not None:
            temp_model = DescribeRegionResourceResponseBodyDataNvme()
            self.nvme = temp_model.from_map(m['Nvme'])
        if m.get('OssStorage') is not None:
            temp_model = DescribeRegionResourceResponseBodyDataOssStorage()
            self.oss_storage = temp_model.from_map(m['OssStorage'])
        if m.get('Pangu') is not None:
            temp_model = DescribeRegionResourceResponseBodyDataPangu()
            self.pangu = temp_model.from_map(m['Pangu'])
        if m.get('PcfarmNum') is not None:
            temp_model = DescribeRegionResourceResponseBodyDataPcfarmNum()
            self.pcfarm_num = temp_model.from_map(m['PcfarmNum'])
        if m.get('Poc') is not None:
            self.poc = m.get('Poc')
        if m.get('ProvinceCode') is not None:
            self.province_code = m.get('ProvinceCode')
        if m.get('ProvinceName') is not None:
            self.province_name = m.get('ProvinceName')
        if m.get('ReserveDisable') is not None:
            self.reserve_disable = m.get('ReserveDisable')
        if m.get('Ssd') is not None:
            temp_model = DescribeRegionResourceResponseBodyDataSsd()
            self.ssd = temp_model.from_map(m['Ssd'])
        if m.get('StatusDisable') is not None:
            self.status_disable = m.get('StatusDisable')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('Virtual') is not None:
            self.virtual = m.get('Virtual')
        return self


class DescribeRegionResourceResponseBodyPager(TeaModel):
    def __init__(
        self,
        page: int = None,
        size: int = None,
        total: int = None,
    ):
        self.page = page
        self.size = size
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page is not None:
            result['Page'] = self.page
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeRegionResourceResponseBody(TeaModel):
    def __init__(
        self,
        data: List[DescribeRegionResourceResponseBodyData] = None,
        desc: str = None,
        msg: str = None,
        pager: DescribeRegionResourceResponseBodyPager = None,
        request_id: str = None,
    ):
        self.data = data
        self.desc = desc
        self.msg = msg
        self.pager = pager
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.pager:
            self.pager.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.pager is not None:
            result['Pager'] = self.pager.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeRegionResourceResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('Pager') is not None:
            temp_model = DescribeRegionResourceResponseBodyPager()
            self.pager = temp_model.from_map(m['Pager'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeRegionResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRegionResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRegionResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeReservedResourceResponseBodyImagesImage(TeaModel):
    def __init__(
        self,
        image_id: str = None,
        image_name: str = None,
    ):
        # The ID of the image.
        self.image_id = image_id
        # The name of the image.
        self.image_name = image_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        return self


class DescribeReservedResourceResponseBodyImages(TeaModel):
    def __init__(
        self,
        image: List[DescribeReservedResourceResponseBodyImagesImage] = None,
    ):
        self.image = image

    def validate(self):
        if self.image:
            for k in self.image:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Image'] = []
        if self.image is not None:
            for k in self.image:
                result['Image'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.image = []
        if m.get('Image') is not None:
            for k in m.get('Image'):
                temp_model = DescribeReservedResourceResponseBodyImagesImage()
                self.image.append(temp_model.from_map(k))
        return self


class DescribeReservedResourceResponseBodySupportResourcesSupportResourceDataDiskSizes(TeaModel):
    def __init__(
        self,
        data_disk_size: List[str] = None,
    ):
        self.data_disk_size = data_disk_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_disk_size is not None:
            result['DataDiskSize'] = self.data_disk_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataDiskSize') is not None:
            self.data_disk_size = m.get('DataDiskSize')
        return self


class DescribeReservedResourceResponseBodySupportResourcesSupportResourceSystemDiskSizes(TeaModel):
    def __init__(
        self,
        system_disk_size: List[str] = None,
    ):
        self.system_disk_size = system_disk_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.system_disk_size is not None:
            result['SystemDiskSize'] = self.system_disk_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SystemDiskSize') is not None:
            self.system_disk_size = m.get('SystemDiskSize')
        return self


class DescribeReservedResourceResponseBodySupportResourcesSupportResource(TeaModel):
    def __init__(
        self,
        data_disk_sizes: DescribeReservedResourceResponseBodySupportResourcesSupportResourceDataDiskSizes = None,
        ens_region_id: str = None,
        instance_spec: str = None,
        support_resources_count: str = None,
        system_disk_sizes: DescribeReservedResourceResponseBodySupportResourcesSupportResourceSystemDiskSizes = None,
    ):
        # The sizes of data disks.
        self.data_disk_sizes = data_disk_sizes
        # The ID of the node.
        self.ens_region_id = ens_region_id
        # The specifications of instances.
        self.instance_spec = instance_spec
        # The number of resources that you can purchase.
        self.support_resources_count = support_resources_count
        # The sizes of system disks.
        self.system_disk_sizes = system_disk_sizes

    def validate(self):
        if self.data_disk_sizes:
            self.data_disk_sizes.validate()
        if self.system_disk_sizes:
            self.system_disk_sizes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_disk_sizes is not None:
            result['DataDiskSizes'] = self.data_disk_sizes.to_map()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_spec is not None:
            result['InstanceSpec'] = self.instance_spec
        if self.support_resources_count is not None:
            result['SupportResourcesCount'] = self.support_resources_count
        if self.system_disk_sizes is not None:
            result['SystemDiskSizes'] = self.system_disk_sizes.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataDiskSizes') is not None:
            temp_model = DescribeReservedResourceResponseBodySupportResourcesSupportResourceDataDiskSizes()
            self.data_disk_sizes = temp_model.from_map(m['DataDiskSizes'])
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceSpec') is not None:
            self.instance_spec = m.get('InstanceSpec')
        if m.get('SupportResourcesCount') is not None:
            self.support_resources_count = m.get('SupportResourcesCount')
        if m.get('SystemDiskSizes') is not None:
            temp_model = DescribeReservedResourceResponseBodySupportResourcesSupportResourceSystemDiskSizes()
            self.system_disk_sizes = temp_model.from_map(m['SystemDiskSizes'])
        return self


class DescribeReservedResourceResponseBodySupportResources(TeaModel):
    def __init__(
        self,
        support_resource: List[DescribeReservedResourceResponseBodySupportResourcesSupportResource] = None,
    ):
        self.support_resource = support_resource

    def validate(self):
        if self.support_resource:
            for k in self.support_resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SupportResource'] = []
        if self.support_resource is not None:
            for k in self.support_resource:
                result['SupportResource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.support_resource = []
        if m.get('SupportResource') is not None:
            for k in m.get('SupportResource'):
                temp_model = DescribeReservedResourceResponseBodySupportResourcesSupportResource()
                self.support_resource.append(temp_model.from_map(k))
        return self


class DescribeReservedResourceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        images: DescribeReservedResourceResponseBodyImages = None,
        request_id: str = None,
        support_resources: DescribeReservedResourceResponseBodySupportResources = None,
    ):
        # The returned service code. 0 indicates that the request was successful.
        self.code = code
        # The information about the image.
        self.images = images
        # The request ID.
        self.request_id = request_id
        # The resources.
        self.support_resources = support_resources

    def validate(self):
        if self.images:
            self.images.validate()
        if self.support_resources:
            self.support_resources.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.images is not None:
            result['Images'] = self.images.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.support_resources is not None:
            result['SupportResources'] = self.support_resources.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Images') is not None:
            temp_model = DescribeReservedResourceResponseBodyImages()
            self.images = temp_model.from_map(m['Images'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SupportResources') is not None:
            temp_model = DescribeReservedResourceResponseBodySupportResources()
            self.support_resources = temp_model.from_map(m['SupportResources'])
        return self


class DescribeReservedResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeReservedResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeReservedResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeResourceTimelineRequest(TeaModel):
    def __init__(
        self,
        begin_time: str = None,
        end_time: str = None,
        uuid: str = None,
    ):
        self.begin_time = begin_time
        self.end_time = end_time
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_time is not None:
            result['BeginTime'] = self.begin_time
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BeginTime') is not None:
            self.begin_time = m.get('BeginTime')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeResourceTimelineResponseBodyAvailableEvents(TeaModel):
    def __init__(
        self,
        name: str = None,
        occurrence_time: str = None,
        reason: str = None,
        type: str = None,
    ):
        self.name = name
        self.occurrence_time = occurrence_time
        self.reason = reason
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.occurrence_time is not None:
            result['OccurrenceTime'] = self.occurrence_time
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OccurrenceTime') is not None:
            self.occurrence_time = m.get('OccurrenceTime')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeResourceTimelineResponseBodyBizEvents(TeaModel):
    def __init__(
        self,
        name: str = None,
        occurrence_time: str = None,
        reason: str = None,
        type: str = None,
    ):
        self.name = name
        self.occurrence_time = occurrence_time
        self.reason = reason
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.occurrence_time is not None:
            result['OccurrenceTime'] = self.occurrence_time
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OccurrenceTime') is not None:
            self.occurrence_time = m.get('OccurrenceTime')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeResourceTimelineResponseBodyInventoryEvents(TeaModel):
    def __init__(
        self,
        name: str = None,
        occurrence_time: str = None,
        reason: str = None,
        type: str = None,
    ):
        self.name = name
        self.occurrence_time = occurrence_time
        self.reason = reason
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.occurrence_time is not None:
            result['OccurrenceTime'] = self.occurrence_time
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OccurrenceTime') is not None:
            self.occurrence_time = m.get('OccurrenceTime')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeResourceTimelineResponseBodyReserveEvents(TeaModel):
    def __init__(
        self,
        name: str = None,
        occurrence_time: str = None,
        reason: str = None,
        type: str = None,
    ):
        self.name = name
        self.occurrence_time = occurrence_time
        self.reason = reason
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.occurrence_time is not None:
            result['OccurrenceTime'] = self.occurrence_time
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OccurrenceTime') is not None:
            self.occurrence_time = m.get('OccurrenceTime')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeResourceTimelineResponseBody(TeaModel):
    def __init__(
        self,
        available_events: List[DescribeResourceTimelineResponseBodyAvailableEvents] = None,
        biz_events: List[DescribeResourceTimelineResponseBodyBizEvents] = None,
        desc: str = None,
        inventory_events: List[DescribeResourceTimelineResponseBodyInventoryEvents] = None,
        msg: str = None,
        request_id: str = None,
        reserve_events: List[DescribeResourceTimelineResponseBodyReserveEvents] = None,
    ):
        self.available_events = available_events
        self.biz_events = biz_events
        self.desc = desc
        self.inventory_events = inventory_events
        self.msg = msg
        self.request_id = request_id
        self.reserve_events = reserve_events

    def validate(self):
        if self.available_events:
            for k in self.available_events:
                if k:
                    k.validate()
        if self.biz_events:
            for k in self.biz_events:
                if k:
                    k.validate()
        if self.inventory_events:
            for k in self.inventory_events:
                if k:
                    k.validate()
        if self.reserve_events:
            for k in self.reserve_events:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AvailableEvents'] = []
        if self.available_events is not None:
            for k in self.available_events:
                result['AvailableEvents'].append(k.to_map() if k else None)
        result['BizEvents'] = []
        if self.biz_events is not None:
            for k in self.biz_events:
                result['BizEvents'].append(k.to_map() if k else None)
        if self.desc is not None:
            result['Desc'] = self.desc
        result['InventoryEvents'] = []
        if self.inventory_events is not None:
            for k in self.inventory_events:
                result['InventoryEvents'].append(k.to_map() if k else None)
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['ReserveEvents'] = []
        if self.reserve_events is not None:
            for k in self.reserve_events:
                result['ReserveEvents'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.available_events = []
        if m.get('AvailableEvents') is not None:
            for k in m.get('AvailableEvents'):
                temp_model = DescribeResourceTimelineResponseBodyAvailableEvents()
                self.available_events.append(temp_model.from_map(k))
        self.biz_events = []
        if m.get('BizEvents') is not None:
            for k in m.get('BizEvents'):
                temp_model = DescribeResourceTimelineResponseBodyBizEvents()
                self.biz_events.append(temp_model.from_map(k))
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        self.inventory_events = []
        if m.get('InventoryEvents') is not None:
            for k in m.get('InventoryEvents'):
                temp_model = DescribeResourceTimelineResponseBodyInventoryEvents()
                self.inventory_events.append(temp_model.from_map(k))
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.reserve_events = []
        if m.get('ReserveEvents') is not None:
            for k in m.get('ReserveEvents'):
                temp_model = DescribeResourceTimelineResponseBodyReserveEvents()
                self.reserve_events.append(temp_model.from_map(k))
        return self


class DescribeResourceTimelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeResourceTimelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeResourceTimelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSDGRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        sdgids: List[str] = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries to return on each page.
        # 
        # Default value: 10.
        self.page_size = page_size
        # The IDs of SDGs that you want to query. By default, all SDGs are queried.
        self.sdgids = sdgids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sdgids is not None:
            result['SDGIds'] = self.sdgids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SDGIds') is not None:
            self.sdgids = m.get('SDGIds')
        return self


class DescribeSDGShrinkRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        sdgids_shrink: str = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries to return on each page.
        # 
        # Default value: 10.
        self.page_size = page_size
        # The IDs of SDGs that you want to query. By default, all SDGs are queried.
        self.sdgids_shrink = sdgids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sdgids_shrink is not None:
            result['SDGIds'] = self.sdgids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SDGIds') is not None:
            self.sdgids_shrink = m.get('SDGIds')
        return self


class DescribeSDGResponseBodySDGsAvaliableRegionIds(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        region_id: str = None,
        snapshot_id: str = None,
        status: str = None,
    ):
        # The time when the SDG was created on the node.
        self.creation_time = creation_time
        # The ID of the node.
        self.region_id = region_id
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id
        # The status of the SDG on the node. Valid values:
        # 
        # *   **sdg_making**\
        # *   **sdg_saving**\
        # *   **sdg_copying**\
        # *   **failed**\
        # *   **success**\
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeSDGResponseBodySDGsPreloadInfos(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        disk_type: str = None,
        namespace: str = None,
        redundant_num: int = None,
        region_id: str = None,
        update_time: str = None,
    ):
        # The time when the SDG was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.creation_time = creation_time
        self.disk_type = disk_type
        # The namespace.
        self.namespace = namespace
        # The number of redundant replicas to quickly respond to shared mounts.
        self.redundant_num = redundant_num
        # The ID of the node.
        self.region_id = region_id
        # The time when the status was last updated.
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.redundant_num is not None:
            result['RedundantNum'] = self.redundant_num
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RedundantNum') is not None:
            self.redundant_num = m.get('RedundantNum')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeSDGResponseBodySDGs(TeaModel):
    def __init__(
        self,
        avaliable_region_ids: List[DescribeSDGResponseBodySDGsAvaliableRegionIds] = None,
        billing_cycle: str = None,
        creation_disk_type: str = None,
        creation_instance_id: str = None,
        creation_region_id: str = None,
        creation_time: str = None,
        description: str = None,
        parent_sdgid: str = None,
        preload_infos: List[DescribeSDGResponseBodySDGsPreloadInfos] = None,
        sdgid: str = None,
        size: int = None,
        status: str = None,
        update_time: str = None,
    ):
        # SDGs that have snapshots.
        self.avaliable_region_ids = avaliable_region_ids
        self.billing_cycle = billing_cycle
        self.creation_disk_type = creation_disk_type
        # The ID of the instance on which the SDG is created.
        self.creation_instance_id = creation_instance_id
        # The ID of the node on which the SDG is created.
        self.creation_region_id = creation_region_id
        # The time when the first SDG in the node was created.
        self.creation_time = creation_time
        # The description of the SDG.
        self.description = description
        # The ID of the source SDG from which you want to create an SDG. The value of this parameter is the value of the **FromSDGId** parameter that you need to specify when you call the [CreateSDG](https://help.aliyun.com/document_detail/608128.html) operation.
        self.parent_sdgid = parent_sdgid
        # The preload information.
        self.preload_infos = preload_infos
        # The ID of the SDG.
        self.sdgid = sdgid
        # The size of the SDG. Unit: GB.
        self.size = size
        # The status of the SDG creation. Valid values:
        # 
        # *   **sdg_making**\
        # *   **sdg_saving**\
        # *   **failed**\
        # *   **success**\
        self.status = status
        # The time when the SDG was last updated.
        self.update_time = update_time

    def validate(self):
        if self.avaliable_region_ids:
            for k in self.avaliable_region_ids:
                if k:
                    k.validate()
        if self.preload_infos:
            for k in self.preload_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AvaliableRegionIds'] = []
        if self.avaliable_region_ids is not None:
            for k in self.avaliable_region_ids:
                result['AvaliableRegionIds'].append(k.to_map() if k else None)
        if self.billing_cycle is not None:
            result['BillingCycle'] = self.billing_cycle
        if self.creation_disk_type is not None:
            result['CreationDiskType'] = self.creation_disk_type
        if self.creation_instance_id is not None:
            result['CreationInstanceId'] = self.creation_instance_id
        if self.creation_region_id is not None:
            result['CreationRegionId'] = self.creation_region_id
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.parent_sdgid is not None:
            result['ParentSDGId'] = self.parent_sdgid
        result['PreloadInfos'] = []
        if self.preload_infos is not None:
            for k in self.preload_infos:
                result['PreloadInfos'].append(k.to_map() if k else None)
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        if self.size is not None:
            result['Size'] = self.size
        if self.status is not None:
            result['Status'] = self.status
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.avaliable_region_ids = []
        if m.get('AvaliableRegionIds') is not None:
            for k in m.get('AvaliableRegionIds'):
                temp_model = DescribeSDGResponseBodySDGsAvaliableRegionIds()
                self.avaliable_region_ids.append(temp_model.from_map(k))
        if m.get('BillingCycle') is not None:
            self.billing_cycle = m.get('BillingCycle')
        if m.get('CreationDiskType') is not None:
            self.creation_disk_type = m.get('CreationDiskType')
        if m.get('CreationInstanceId') is not None:
            self.creation_instance_id = m.get('CreationInstanceId')
        if m.get('CreationRegionId') is not None:
            self.creation_region_id = m.get('CreationRegionId')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ParentSDGId') is not None:
            self.parent_sdgid = m.get('ParentSDGId')
        self.preload_infos = []
        if m.get('PreloadInfos') is not None:
            for k in m.get('PreloadInfos'):
                temp_model = DescribeSDGResponseBodySDGsPreloadInfos()
                self.preload_infos.append(temp_model.from_map(k))
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeSDGResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        sdgs: List[DescribeSDGResponseBodySDGs] = None,
        total_count: int = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The information about the SDGs.
        self.sdgs = sdgs
        # The total number of returned entries.
        self.total_count = total_count

    def validate(self):
        if self.sdgs:
            for k in self.sdgs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SDGs'] = []
        if self.sdgs is not None:
            for k in self.sdgs:
                result['SDGs'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sdgs = []
        if m.get('SDGs') is not None:
            for k in m.get('SDGs'):
                temp_model = DescribeSDGResponseBodySDGs()
                self.sdgs.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSDGResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSDGResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSDGResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSDGDeploymentStatusRequest(TeaModel):
    def __init__(
        self,
        deployment_type: str = None,
        instance_ids: List[str] = None,
        page_number: int = None,
        page_size: int = None,
        region_ids: List[str] = None,
        sdgid: str = None,
        status: str = None,
    ):
        # The deployment type.
        self.deployment_type = deployment_type
        # IDs of Android in Container (AIC) instances.
        self.instance_ids = instance_ids
        # The number of the page to return. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries returned on each page.
        self.page_size = page_size
        # The IDs of the nodes.
        self.region_ids = region_ids
        # The ID of the SDG.
        # 
        # This parameter is required.
        self.sdgid = sdgid
        # The deployment status of the SDG.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deployment_type is not None:
            result['DeploymentType'] = self.deployment_type
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_ids is not None:
            result['RegionIds'] = self.region_ids
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeploymentType') is not None:
            self.deployment_type = m.get('DeploymentType')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionIds') is not None:
            self.region_ids = m.get('RegionIds')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeSDGDeploymentStatusShrinkRequest(TeaModel):
    def __init__(
        self,
        deployment_type: str = None,
        instance_ids_shrink: str = None,
        page_number: int = None,
        page_size: int = None,
        region_ids_shrink: str = None,
        sdgid: str = None,
        status: str = None,
    ):
        # The deployment type.
        self.deployment_type = deployment_type
        # IDs of Android in Container (AIC) instances.
        self.instance_ids_shrink = instance_ids_shrink
        # The number of the page to return. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries returned on each page.
        self.page_size = page_size
        # The IDs of the nodes.
        self.region_ids_shrink = region_ids_shrink
        # The ID of the SDG.
        # 
        # This parameter is required.
        self.sdgid = sdgid
        # The deployment status of the SDG.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deployment_type is not None:
            result['DeploymentType'] = self.deployment_type
        if self.instance_ids_shrink is not None:
            result['InstanceIds'] = self.instance_ids_shrink
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_ids_shrink is not None:
            result['RegionIds'] = self.region_ids_shrink
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeploymentType') is not None:
            self.deployment_type = m.get('DeploymentType')
        if m.get('InstanceIds') is not None:
            self.instance_ids_shrink = m.get('InstanceIds')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionIds') is not None:
            self.region_ids_shrink = m.get('RegionIds')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeSDGDeploymentStatusResponseBodyDeploymentStatus(TeaModel):
    def __init__(
        self,
        block_rw_split_size: int = None,
        cache_size: int = None,
        disk_access_protocol: str = None,
        disk_type: str = None,
        instance_id: str = None,
        mount_type: str = None,
        phase: str = None,
        region_id: str = None,
        status: str = None,
        update_time: str = None,
    ):
        self.block_rw_split_size = block_rw_split_size
        self.cache_size = cache_size
        self.disk_access_protocol = disk_access_protocol
        self.disk_type = disk_type
        # The ID of the AIC instance.
        self.instance_id = instance_id
        # The deployment type.
        # 
        # Valid values:
        # 
        # *   overlay: read/write splitting.
        # *   common: common deployment.
        self.mount_type = mount_type
        # The deployment phase of the SDG.
        self.phase = phase
        # The ID of the edge node.
        self.region_id = region_id
        # The deployment status of the SDG.
        # 
        # Valid values:
        # 
        # *   sdg_deploying
        # *   success
        # *   failed
        self.status = status
        # The time when the status was last updated.
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.block_rw_split_size is not None:
            result['BlockRwSplitSize'] = self.block_rw_split_size
        if self.cache_size is not None:
            result['CacheSize'] = self.cache_size
        if self.disk_access_protocol is not None:
            result['DiskAccessProtocol'] = self.disk_access_protocol
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.mount_type is not None:
            result['MountType'] = self.mount_type
        if self.phase is not None:
            result['Phase'] = self.phase
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BlockRwSplitSize') is not None:
            self.block_rw_split_size = m.get('BlockRwSplitSize')
        if m.get('CacheSize') is not None:
            self.cache_size = m.get('CacheSize')
        if m.get('DiskAccessProtocol') is not None:
            self.disk_access_protocol = m.get('DiskAccessProtocol')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MountType') is not None:
            self.mount_type = m.get('MountType')
        if m.get('Phase') is not None:
            self.phase = m.get('Phase')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeSDGDeploymentStatusResponseBody(TeaModel):
    def __init__(
        self,
        deployment_status: List[DescribeSDGDeploymentStatusResponseBodyDeploymentStatus] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The list of SDG deployment information.
        self.deployment_status = deployment_status
        # The page number. Pages start from page 1. Default value: 1
        self.page_number = page_number
        # The number of entries to return on each page. Default value: **10**.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of queried deployment records.
        self.total_count = total_count

    def validate(self):
        if self.deployment_status:
            for k in self.deployment_status:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeploymentStatus'] = []
        if self.deployment_status is not None:
            for k in self.deployment_status:
                result['DeploymentStatus'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.deployment_status = []
        if m.get('DeploymentStatus') is not None:
            for k in m.get('DeploymentStatus'):
                temp_model = DescribeSDGDeploymentStatusResponseBodyDeploymentStatus()
                self.deployment_status.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSDGDeploymentStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSDGDeploymentStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSDGDeploymentStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSDGsRequest(TeaModel):
    def __init__(
        self,
        instance_ids: List[str] = None,
        sdgids: List[str] = None,
    ):
        # The AIC instance ID to be queried.
        self.instance_ids = instance_ids
        # The IDs of SDGs that you want to query. By default, all SDGs are queried.
        self.sdgids = sdgids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.sdgids is not None:
            result['SDGIds'] = self.sdgids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('SDGIds') is not None:
            self.sdgids = m.get('SDGIds')
        return self


class DescribeSDGsShrinkRequest(TeaModel):
    def __init__(
        self,
        instance_ids_shrink: str = None,
        sdgids_shrink: str = None,
    ):
        # The AIC instance ID to be queried.
        self.instance_ids_shrink = instance_ids_shrink
        # The IDs of SDGs that you want to query. By default, all SDGs are queried.
        self.sdgids_shrink = sdgids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids_shrink is not None:
            result['InstanceIds'] = self.instance_ids_shrink
        if self.sdgids_shrink is not None:
            result['SDGIds'] = self.sdgids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids_shrink = m.get('InstanceIds')
        if m.get('SDGIds') is not None:
            self.sdgids_shrink = m.get('SDGIds')
        return self


class DescribeSDGsResponseBodySDGsAvaliableRegionIds(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        region_id: str = None,
        snapshot_id: str = None,
        status: str = None,
    ):
        # The time when the SDG was created on the node.
        self.creation_time = creation_time
        # The ID of the edge node.
        self.region_id = region_id
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id
        # The status of the SDG on the node. Valid values:
        # 
        # *   **sdg_making**\
        # *   **sdg_saving**\
        # *   **sdg_copying**\
        # *   **failed**\
        # *   **success**\
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeSDGsResponseBodySDGsDeployedInstanceIds(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        deployment_type: str = None,
        instance_id: str = None,
        status: str = None,
    ):
        # The time when the SDG was deployed on the instance.
        self.creation_time = creation_time
        # The deployment type of the SDG. Valid values:
        # 
        # *   common: common deployment.
        # *   overlay: read/write splitting deployment.
        self.deployment_type = deployment_type
        # The ID of the instance.
        self.instance_id = instance_id
        # The deployment status. Valid values:
        # 
        # *   **sdg_deploying**\
        # *   **failed**\
        # *   **success**\
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.deployment_type is not None:
            result['DeploymentType'] = self.deployment_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DeploymentType') is not None:
            self.deployment_type = m.get('DeploymentType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeSDGsResponseBodySDGs(TeaModel):
    def __init__(
        self,
        avaliable_region_ids: List[DescribeSDGsResponseBodySDGsAvaliableRegionIds] = None,
        billing_cycle: str = None,
        creation_disk_type: str = None,
        creation_instance_id: str = None,
        creation_region_id: str = None,
        creation_time: str = None,
        deployed_instance_ids: List[DescribeSDGsResponseBodySDGsDeployedInstanceIds] = None,
        description: str = None,
        parent_sdgid: str = None,
        sdgid: str = None,
        size: int = None,
        status: str = None,
        update_time: str = None,
    ):
        # The IDs of available edge nodes.
        self.avaliable_region_ids = avaliable_region_ids
        self.billing_cycle = billing_cycle
        self.creation_disk_type = creation_disk_type
        # The ID of the instance on which the SDG is created.
        self.creation_instance_id = creation_instance_id
        # The ID of the node on which the SDG is created.
        self.creation_region_id = creation_region_id
        # The time when the SDG was first created.
        self.creation_time = creation_time
        # The deployment information.
        self.deployed_instance_ids = deployed_instance_ids
        # The description of the SDG.
        self.description = description
        # The ID of the source SDG from which you want to create an SDG. The value of this parameter is the value of the **FromSDGId** parameter that you need to specify when you call the [CreateSDG](https://help.aliyun.com/document_detail/608128.html) operation.
        self.parent_sdgid = parent_sdgid
        # The ID of the SDG.
        self.sdgid = sdgid
        # The size of the SDG. Unit: GB.
        self.size = size
        # The status of the SDG creation. Valid values:
        # 
        # *   **sdg_making**\
        # *   **sdg_saving**\
        # *   **failed**\
        # *   **success**\
        self.status = status
        # The time when the SDG was last updated.
        self.update_time = update_time

    def validate(self):
        if self.avaliable_region_ids:
            for k in self.avaliable_region_ids:
                if k:
                    k.validate()
        if self.deployed_instance_ids:
            for k in self.deployed_instance_ids:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AvaliableRegionIds'] = []
        if self.avaliable_region_ids is not None:
            for k in self.avaliable_region_ids:
                result['AvaliableRegionIds'].append(k.to_map() if k else None)
        if self.billing_cycle is not None:
            result['BillingCycle'] = self.billing_cycle
        if self.creation_disk_type is not None:
            result['CreationDiskType'] = self.creation_disk_type
        if self.creation_instance_id is not None:
            result['CreationInstanceId'] = self.creation_instance_id
        if self.creation_region_id is not None:
            result['CreationRegionId'] = self.creation_region_id
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        result['DeployedInstanceIds'] = []
        if self.deployed_instance_ids is not None:
            for k in self.deployed_instance_ids:
                result['DeployedInstanceIds'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.parent_sdgid is not None:
            result['ParentSDGId'] = self.parent_sdgid
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        if self.size is not None:
            result['Size'] = self.size
        if self.status is not None:
            result['Status'] = self.status
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.avaliable_region_ids = []
        if m.get('AvaliableRegionIds') is not None:
            for k in m.get('AvaliableRegionIds'):
                temp_model = DescribeSDGsResponseBodySDGsAvaliableRegionIds()
                self.avaliable_region_ids.append(temp_model.from_map(k))
        if m.get('BillingCycle') is not None:
            self.billing_cycle = m.get('BillingCycle')
        if m.get('CreationDiskType') is not None:
            self.creation_disk_type = m.get('CreationDiskType')
        if m.get('CreationInstanceId') is not None:
            self.creation_instance_id = m.get('CreationInstanceId')
        if m.get('CreationRegionId') is not None:
            self.creation_region_id = m.get('CreationRegionId')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        self.deployed_instance_ids = []
        if m.get('DeployedInstanceIds') is not None:
            for k in m.get('DeployedInstanceIds'):
                temp_model = DescribeSDGsResponseBodySDGsDeployedInstanceIds()
                self.deployed_instance_ids.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ParentSDGId') is not None:
            self.parent_sdgid = m.get('ParentSDGId')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeSDGsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        sdgs: List[DescribeSDGsResponseBodySDGs] = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The information about the SDGs.
        self.sdgs = sdgs

    def validate(self):
        if self.sdgs:
            for k in self.sdgs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SDGs'] = []
        if self.sdgs is not None:
            for k in self.sdgs:
                result['SDGs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sdgs = []
        if m.get('SDGs') is not None:
            for k in m.get('SDGs'):
                temp_model = DescribeSDGsResponseBodySDGs()
                self.sdgs.append(temp_model.from_map(k))
        return self


class DescribeSDGsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSDGsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSDGsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecondaryPublicIpAddressesRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        ens_region_ids: List[str] = None,
        isp: str = None,
        page_number: int = None,
        page_size: int = None,
        secondary_public_ip_address: str = None,
        secondary_public_ip_id: str = None,
    ):
        # The ID of the edge node.
        self.ens_region_id = ens_region_id
        self.ens_region_ids = ens_region_ids
        # The Internet service provider. Valid values:
        # 
        # *   cmcc: China Mobile.
        # *   unicom: China Unicom.
        # *   telecom: China Telecom.
        self.isp = isp
        # The number of the page to return. Default value: 1.
        self.page_number = page_number
        # The number of entries to return on each page. Valid values: 1 to 100. Default value: 10.
        self.page_size = page_size
        # The secondary IP address.
        self.secondary_public_ip_address = secondary_public_ip_address
        # The ID of the secondary public IP address.
        self.secondary_public_ip_id = secondary_public_ip_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.ens_region_ids is not None:
            result['EnsRegionIds'] = self.ens_region_ids
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.secondary_public_ip_address is not None:
            result['SecondaryPublicIpAddress'] = self.secondary_public_ip_address
        if self.secondary_public_ip_id is not None:
            result['SecondaryPublicIpId'] = self.secondary_public_ip_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('EnsRegionIds') is not None:
            self.ens_region_ids = m.get('EnsRegionIds')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SecondaryPublicIpAddress') is not None:
            self.secondary_public_ip_address = m.get('SecondaryPublicIpAddress')
        if m.get('SecondaryPublicIpId') is not None:
            self.secondary_public_ip_id = m.get('SecondaryPublicIpId')
        return self


class DescribeSecondaryPublicIpAddressesResponseBodySecondaryPublicIpAddresses(TeaModel):
    def __init__(
        self,
        cidr_mask: int = None,
        creation_time: str = None,
        ens_region_id: str = None,
        gateway: str = None,
        ip_version: str = None,
        isp: str = None,
        secondary_public_ip_address: str = None,
        secondary_public_ip_id: str = None,
    ):
        # The subnet mask of the CIDR block.
        self.cidr_mask = cidr_mask
        # The time when the secondary public IP address was created. The time is displayed in UTC.
        self.creation_time = creation_time
        # The ID of the edge node.
        self.ens_region_id = ens_region_id
        # The gateway.
        self.gateway = gateway
        # The version of the IP address. Valid values:
        # 
        # *   **ipv4**\
        # *   **ipv6**\
        self.ip_version = ip_version
        # The Internet service provider. Valid values:
        # 
        # *   cmcc: China Mobile.
        # *   unicom: China Unicom.
        # *   telecom: China Telecom.
        self.isp = isp
        # The secondary public IP address.
        self.secondary_public_ip_address = secondary_public_ip_address
        # The ID of the secondary public IP address.
        self.secondary_public_ip_id = secondary_public_ip_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_mask is not None:
            result['CidrMask'] = self.cidr_mask
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.gateway is not None:
            result['Gateway'] = self.gateway
        if self.ip_version is not None:
            result['IpVersion'] = self.ip_version
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.secondary_public_ip_address is not None:
            result['SecondaryPublicIpAddress'] = self.secondary_public_ip_address
        if self.secondary_public_ip_id is not None:
            result['SecondaryPublicIpId'] = self.secondary_public_ip_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CidrMask') is not None:
            self.cidr_mask = m.get('CidrMask')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('Gateway') is not None:
            self.gateway = m.get('Gateway')
        if m.get('IpVersion') is not None:
            self.ip_version = m.get('IpVersion')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('SecondaryPublicIpAddress') is not None:
            self.secondary_public_ip_address = m.get('SecondaryPublicIpAddress')
        if m.get('SecondaryPublicIpId') is not None:
            self.secondary_public_ip_id = m.get('SecondaryPublicIpId')
        return self


class DescribeSecondaryPublicIpAddressesResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        secondary_public_ip_addresses: List[DescribeSecondaryPublicIpAddressesResponseBodySecondaryPublicIpAddresses] = None,
        total_count: int = None,
    ):
        # The page number returned.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The array of returned secondary IP addresses.
        self.secondary_public_ip_addresses = secondary_public_ip_addresses
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.secondary_public_ip_addresses:
            for k in self.secondary_public_ip_addresses:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SecondaryPublicIpAddresses'] = []
        if self.secondary_public_ip_addresses is not None:
            for k in self.secondary_public_ip_addresses:
                result['SecondaryPublicIpAddresses'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.secondary_public_ip_addresses = []
        if m.get('SecondaryPublicIpAddresses') is not None:
            for k in m.get('SecondaryPublicIpAddresses'):
                temp_model = DescribeSecondaryPublicIpAddressesResponseBodySecondaryPublicIpAddresses()
                self.secondary_public_ip_addresses.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSecondaryPublicIpAddressesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSecondaryPublicIpAddressesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecondaryPublicIpAddressesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecurityGroupAttributeRequest(TeaModel):
    def __init__(
        self,
        security_group_id: str = None,
    ):
        # The ID of the security group.
        # 
        # This parameter is required.
        self.security_group_id = security_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class DescribeSecurityGroupAttributeResponseBodyPermissionsPermission(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        description: str = None,
        dest_cidr_ip: str = None,
        direction: str = None,
        ip_protocol: str = None,
        policy: str = None,
        port_range: str = None,
        priority: int = None,
        source_cidr_ip: str = None,
        source_port_range: str = None,
    ):
        # The time at which the security group rule was created. The time is displayed in UTC.
        self.creation_time = creation_time
        # The description.
        self.description = description
        # The range of destination IP addresses for outbound access control.
        self.dest_cidr_ip = dest_cidr_ip
        # The direction in which the security group rule is applied.
        self.direction = direction
        # The transport layer protocol.
        self.ip_protocol = ip_protocol
        # The policy.
        self.policy = policy
        # The source port range.
        self.port_range = port_range
        # The priority of the rule.
        self.priority = priority
        # The range of source IP addresses for inbound access control.
        self.source_cidr_ip = source_cidr_ip
        # The source port number range for the security group.
        self.source_port_range = source_port_range

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.dest_cidr_ip is not None:
            result['DestCidrIp'] = self.dest_cidr_ip
        if self.direction is not None:
            result['Direction'] = self.direction
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.source_cidr_ip is not None:
            result['SourceCidrIp'] = self.source_cidr_ip
        if self.source_port_range is not None:
            result['SourcePortRange'] = self.source_port_range
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestCidrIp') is not None:
            self.dest_cidr_ip = m.get('DestCidrIp')
        if m.get('Direction') is not None:
            self.direction = m.get('Direction')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('SourceCidrIp') is not None:
            self.source_cidr_ip = m.get('SourceCidrIp')
        if m.get('SourcePortRange') is not None:
            self.source_port_range = m.get('SourcePortRange')
        return self


class DescribeSecurityGroupAttributeResponseBodyPermissions(TeaModel):
    def __init__(
        self,
        permission: List[DescribeSecurityGroupAttributeResponseBodyPermissionsPermission] = None,
    ):
        self.permission = permission

    def validate(self):
        if self.permission:
            for k in self.permission:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Permission'] = []
        if self.permission is not None:
            for k in self.permission:
                result['Permission'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.permission = []
        if m.get('Permission') is not None:
            for k in m.get('Permission'):
                temp_model = DescribeSecurityGroupAttributeResponseBodyPermissionsPermission()
                self.permission.append(temp_model.from_map(k))
        return self


class DescribeSecurityGroupAttributeResponseBody(TeaModel):
    def __init__(
        self,
        description: str = None,
        permissions: DescribeSecurityGroupAttributeResponseBodyPermissions = None,
        request_id: str = None,
        security_group_id: str = None,
        security_group_name: str = None,
    ):
        # The description of the security group.
        self.description = description
        # Details about the rules.
        self.permissions = permissions
        # The request ID.
        self.request_id = request_id
        # The ID of the destination security group.
        self.security_group_id = security_group_id
        # The name of the destination security group.
        self.security_group_name = security_group_name

    def validate(self):
        if self.permissions:
            self.permissions.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.permissions is not None:
            result['Permissions'] = self.permissions.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_name is not None:
            result['SecurityGroupName'] = self.security_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Permissions') is not None:
            temp_model = DescribeSecurityGroupAttributeResponseBodyPermissions()
            self.permissions = temp_model.from_map(m['Permissions'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupName') is not None:
            self.security_group_name = m.get('SecurityGroupName')
        return self


class DescribeSecurityGroupAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSecurityGroupAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecurityGroupAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecurityGroupsRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        security_group_id: str = None,
        security_group_name: str = None,
    ):
        # The page number.
        # 
        # *   Pages start from page 1.
        # *   Default value: 1
        self.page_number = page_number
        # The number of entries per page.
        # 
        # *   Maximum value: 50.
        # *   Default value: 10
        self.page_size = page_size
        # The ID of the security group.
        self.security_group_id = security_group_id
        # The name of the security group.
        self.security_group_name = security_group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_name is not None:
            result['SecurityGroupName'] = self.security_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupName') is not None:
            self.security_group_name = m.get('SecurityGroupName')
        return self


class DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupInstanceIds(TeaModel):
    def __init__(
        self,
        instance_id: List[str] = None,
    ):
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupNetworkInterfaceIds(TeaModel):
    def __init__(
        self,
        network_interface_id: List[str] = None,
    ):
        self.network_interface_id = network_interface_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        return self


class DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        description: str = None,
        instance_count: int = None,
        instance_ids: DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupInstanceIds = None,
        network_interface_ids: DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupNetworkInterfaceIds = None,
        security_group_id: str = None,
        security_group_name: str = None,
    ):
        # The creation time. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
        self.creation_time = creation_time
        # The description of the security group.
        self.description = description
        # The number of associated instances.
        self.instance_count = instance_count
        # The IDs of the instances that are associated with the security group.
        self.instance_ids = instance_ids
        # The IDs of the ENIs that are associated with the security group.
        self.network_interface_ids = network_interface_ids
        # The ID of the security group.
        self.security_group_id = security_group_id
        # The name of the security group.
        self.security_group_name = security_group_name

    def validate(self):
        if self.instance_ids:
            self.instance_ids.validate()
        if self.network_interface_ids:
            self.network_interface_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids.to_map()
        if self.network_interface_ids is not None:
            result['NetworkInterfaceIds'] = self.network_interface_ids.to_map()
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_name is not None:
            result['SecurityGroupName'] = self.security_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('InstanceIds') is not None:
            temp_model = DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupInstanceIds()
            self.instance_ids = temp_model.from_map(m['InstanceIds'])
        if m.get('NetworkInterfaceIds') is not None:
            temp_model = DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupNetworkInterfaceIds()
            self.network_interface_ids = temp_model.from_map(m['NetworkInterfaceIds'])
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupName') is not None:
            self.security_group_name = m.get('SecurityGroupName')
        return self


class DescribeSecurityGroupsResponseBodySecurityGroups(TeaModel):
    def __init__(
        self,
        security_group: List[DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup] = None,
    ):
        self.security_group = security_group

    def validate(self):
        if self.security_group:
            for k in self.security_group:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SecurityGroup'] = []
        if self.security_group is not None:
            for k in self.security_group:
                result['SecurityGroup'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.security_group = []
        if m.get('SecurityGroup') is not None:
            for k in m.get('SecurityGroup'):
                temp_model = DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup()
                self.security_group.append(temp_model.from_map(k))
        return self


class DescribeSecurityGroupsResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        security_groups: DescribeSecurityGroupsResponseBodySecurityGroups = None,
        total_count: int = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # Details about security groups.
        self.security_groups = security_groups
        # The total number of returned pages.
        self.total_count = total_count

    def validate(self):
        if self.security_groups:
            self.security_groups.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_groups is not None:
            result['SecurityGroups'] = self.security_groups.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityGroups') is not None:
            temp_model = DescribeSecurityGroupsResponseBodySecurityGroups()
            self.security_groups = temp_model.from_map(m['SecurityGroups'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSecurityGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSecurityGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecurityGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSelfImagesRequest(TeaModel):
    def __init__(
        self,
        image_id: str = None,
        image_name: str = None,
        page_number: int = None,
        page_size: int = None,
        snapshot_id: str = None,
    ):
        # The ID of the image. Fuzzy search is supported.
        self.image_id = image_id
        # The name of the image. Fuzzy search is supported.
        self.image_name = image_name
        # The page number to return. Pages start from page **1**. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page.
        # 
        # Default value: 10.
        self.page_size = page_size
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        return self


class DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping(TeaModel):
    def __init__(
        self,
        format: str = None,
        size: str = None,
        type: str = None,
        image_id: str = None,
    ):
        # The format of the image.
        self.format = format
        # The size of the disk. Unit: GiB.
        self.size = size
        # The type of the disk. Valid values:
        # 
        # *   system: system disk.
        # *   data: data disk.
        self.type = type
        # The ID of image.
        self.image_id = image_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        if self.size is not None:
            result['Size'] = self.size
        if self.type is not None:
            result['Type'] = self.type
        if self.image_id is not None:
            result['imageId'] = self.image_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('imageId') is not None:
            self.image_id = m.get('imageId')
        return self


class DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappings(TeaModel):
    def __init__(
        self,
        disk_device_mapping: List[DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping] = None,
    ):
        self.disk_device_mapping = disk_device_mapping

    def validate(self):
        if self.disk_device_mapping:
            for k in self.disk_device_mapping:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DiskDeviceMapping'] = []
        if self.disk_device_mapping is not None:
            for k in self.disk_device_mapping:
                result['DiskDeviceMapping'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.disk_device_mapping = []
        if m.get('DiskDeviceMapping') is not None:
            for k in m.get('DiskDeviceMapping'):
                temp_model = DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping()
                self.disk_device_mapping.append(temp_model.from_map(k))
        return self


class DescribeSelfImagesResponseBodyImagesImage(TeaModel):
    def __init__(
        self,
        architecture: str = None,
        compute_type: str = None,
        creation_time: str = None,
        disk_device_mappings: DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappings = None,
        image_id: str = None,
        image_name: str = None,
        image_owner_alias: str = None,
        image_size: str = None,
        image_storage_size: str = None,
        instance_id: str = None,
        os_version: str = None,
        platform: str = None,
        region_id: str = None,
        snapshot_id: str = None,
        status: str = None,
    ):
        # The image architecture. Valid values:
        # 
        # *   i386
        # *   x86_64
        self.architecture = architecture
        # Computing type. ens_vm/ens: x86 computing. bare_metal: x86 bare machine or x86 bare metal. arm_vm: ARM computing. arm_bare_metal: ARM bare machine or ARM bare metal. pcfarm: heterogeneous computing.
        self.compute_type = compute_type
        # The image creation time. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.creation_time = creation_time
        # The mappings between the disk and the snapshot in the image.
        self.disk_device_mappings = disk_device_mappings
        # The ID of the image.
        self.image_id = image_id
        # The name of the image.
        self.image_name = image_name
        # The source of the image. Valid values:
        # 
        # *   **others**: a custom image that is shared by other Alibaba Cloud accounts.
        # *   **self**: your own custom image.
        self.image_owner_alias = image_owner_alias
        # The size of the image. Unit: GiB.
        self.image_size = image_size
        # The size of the image storage.
        self.image_storage_size = image_storage_size
        # The ID of the instance.
        self.instance_id = instance_id
        # The operating system version.
        self.os_version = os_version
        # The platform.
        # 
        # *   centos
        # *   ubuntu
        # *   alios
        # *   debian
        # *   rhel
        # *   windows
        self.platform = platform
        # The ID of the region.
        self.region_id = region_id
        # The snapshot ID.
        self.snapshot_id = snapshot_id
        # The state of the image.
        # 
        # *   Creating.
        # *   Packing.
        # *   Uploading.
        # *   Pack_failed.
        # *   Upload_failed.
        # *   Available: Only images in the Available state can be used and operated.
        # *   Unavailable.
        # *   Copying.
        self.status = status

    def validate(self):
        if self.disk_device_mappings:
            self.disk_device_mappings.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.architecture is not None:
            result['Architecture'] = self.architecture
        if self.compute_type is not None:
            result['ComputeType'] = self.compute_type
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.disk_device_mappings is not None:
            result['DiskDeviceMappings'] = self.disk_device_mappings.to_map()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.image_owner_alias is not None:
            result['ImageOwnerAlias'] = self.image_owner_alias
        if self.image_size is not None:
            result['ImageSize'] = self.image_size
        if self.image_storage_size is not None:
            result['ImageStorageSize'] = self.image_storage_size
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.os_version is not None:
            result['OsVersion'] = self.os_version
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Architecture') is not None:
            self.architecture = m.get('Architecture')
        if m.get('ComputeType') is not None:
            self.compute_type = m.get('ComputeType')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DiskDeviceMappings') is not None:
            temp_model = DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappings()
            self.disk_device_mappings = temp_model.from_map(m['DiskDeviceMappings'])
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('ImageOwnerAlias') is not None:
            self.image_owner_alias = m.get('ImageOwnerAlias')
        if m.get('ImageSize') is not None:
            self.image_size = m.get('ImageSize')
        if m.get('ImageStorageSize') is not None:
            self.image_storage_size = m.get('ImageStorageSize')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OsVersion') is not None:
            self.os_version = m.get('OsVersion')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeSelfImagesResponseBodyImages(TeaModel):
    def __init__(
        self,
        image: List[DescribeSelfImagesResponseBodyImagesImage] = None,
    ):
        self.image = image

    def validate(self):
        if self.image:
            for k in self.image:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Image'] = []
        if self.image is not None:
            for k in self.image:
                result['Image'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.image = []
        if m.get('Image') is not None:
            for k in m.get('Image'):
                temp_model = DescribeSelfImagesResponseBodyImagesImage()
                self.image.append(temp_model.from_map(k))
        return self


class DescribeSelfImagesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        images: DescribeSelfImagesResponseBodyImages = None,
        page_number: str = None,
        page_size: str = None,
        request_id: str = None,
        total_count: str = None,
    ):
        # The HTTP status code that is returned.
        self.code = code
        # The image information.
        self.images = images
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Maximum value: 50. Default value: 10.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.images:
            self.images.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.images is not None:
            result['Images'] = self.images.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Images') is not None:
            temp_model = DescribeSelfImagesResponseBodyImages()
            self.images = temp_model.from_map(m['Images'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSelfImagesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSelfImagesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSelfImagesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeServcieScheduleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        pod_config_name: str = None,
        uuid: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter does not take effect.
        self.pod_config_name = pod_config_name
        # The unique ID of the device.
        # 
        # This parameter is required.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.pod_config_name is not None:
            result['PodConfigName'] = self.pod_config_name
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('PodConfigName') is not None:
            self.pod_config_name = m.get('PodConfigName')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatusesContainerStatus(TeaModel):
    def __init__(
        self,
        container_id: str = None,
        name: str = None,
    ):
        # The ID of the container.
        self.container_id = container_id
        # The name of the container.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatuses(TeaModel):
    def __init__(
        self,
        container_status: List[DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatusesContainerStatus] = None,
    ):
        self.container_status = container_status

    def validate(self):
        if self.container_status:
            for k in self.container_status:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ContainerStatus'] = []
        if self.container_status is not None:
            for k in self.container_status:
                result['ContainerStatus'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.container_status = []
        if m.get('ContainerStatus') is not None:
            for k in m.get('ContainerStatus'):
                temp_model = DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatusesContainerStatus()
                self.container_status.append(temp_model.from_map(k))
        return self


class DescribeServcieScheduleResponseBodyPodAbstractInfo(TeaModel):
    def __init__(
        self,
        container_service: bool = None,
        container_statuses: DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatuses = None,
        name: bool = None,
        namespace: bool = None,
        resource_scope: bool = None,
        status: bool = None,
    ):
        # The name of the container service.
        self.container_service = container_service
        # The information about the container.
        self.container_statuses = container_statuses
        # The name of the pod.
        self.name = name
        # The name of the namespace.
        self.namespace = namespace
        # The pod scope.
        self.resource_scope = resource_scope
        # The status of the pod.
        self.status = status

    def validate(self):
        if self.container_statuses:
            self.container_statuses.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_service is not None:
            result['ContainerService'] = self.container_service
        if self.container_statuses is not None:
            result['ContainerStatuses'] = self.container_statuses.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.resource_scope is not None:
            result['ResourceScope'] = self.resource_scope
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContainerService') is not None:
            self.container_service = m.get('ContainerService')
        if m.get('ContainerStatuses') is not None:
            temp_model = DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatuses()
            self.container_statuses = temp_model.from_map(m['ContainerStatuses'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('ResourceScope') is not None:
            self.resource_scope = m.get('ResourceScope')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeServcieScheduleResponseBody(TeaModel):
    def __init__(
        self,
        index: int = None,
        instance_id: str = None,
        instance_ip: str = None,
        instance_port: int = None,
        pod_abstract_info: DescribeServcieScheduleResponseBodyPodAbstractInfo = None,
        request_id: str = None,
        request_repeated: bool = None,
        tcp_ports: str = None,
    ):
        # The index number of the scheduled virtual device (pod).
        self.index = index
        # The ID of the scheduled instance.
        self.instance_id = instance_id
        # The ID of the scheduled instance.
        self.instance_ip = instance_ip
        # The start port of the scheduled instance.
        self.instance_port = instance_port
        # The summary information about the scheduled virtual device.
        self.pod_abstract_info = pod_abstract_info
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is repeated.
        self.request_repeated = request_repeated
        # The TCP port range of the scheduled instance or container. The value is in the ${from}-$-{to} format. Example: 80-88.
        self.tcp_ports = tcp_ports

    def validate(self):
        if self.pod_abstract_info:
            self.pod_abstract_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['Index'] = self.index
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_ip is not None:
            result['InstanceIp'] = self.instance_ip
        if self.instance_port is not None:
            result['InstancePort'] = self.instance_port
        if self.pod_abstract_info is not None:
            result['PodAbstractInfo'] = self.pod_abstract_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.request_repeated is not None:
            result['RequestRepeated'] = self.request_repeated
        if self.tcp_ports is not None:
            result['TcpPorts'] = self.tcp_ports
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceIp') is not None:
            self.instance_ip = m.get('InstanceIp')
        if m.get('InstancePort') is not None:
            self.instance_port = m.get('InstancePort')
        if m.get('PodAbstractInfo') is not None:
            temp_model = DescribeServcieScheduleResponseBodyPodAbstractInfo()
            self.pod_abstract_info = temp_model.from_map(m['PodAbstractInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RequestRepeated') is not None:
            self.request_repeated = m.get('RequestRepeated')
        if m.get('TcpPorts') is not None:
            self.tcp_ports = m.get('TcpPorts')
        return self


class DescribeServcieScheduleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeServcieScheduleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeServcieScheduleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeServerLoadBalancerListenMonitorRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        load_balancer_id: str = None,
        proto: str = None,
        start_time: str = None,
        vport: str = None,
    ):
        # The end of the time range to query. The maximum range between StartTime and EndTime is 24 hours.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The ID of the ELB instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id
        # The request protocol, such as http, https, or tcp.
        self.proto = proto
        # The beginning of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The virtual IP address (VIP) port, such as 80, 8080, or 443.
        self.vport = vport

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.proto is not None:
            result['Proto'] = self.proto
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.vport is not None:
            result['VPort'] = self.vport
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('Proto') is not None:
            self.proto = m.get('Proto')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('VPort') is not None:
            self.vport = m.get('VPort')
        return self


class DescribeServerLoadBalancerListenMonitorResponseBodyServerLoadBalancerMonitorData(TeaModel):
    def __init__(
        self,
        acc: int = None,
        biz_time: str = None,
        ens_region_id: str = None,
        load_balancer_id: str = None,
        load_balancer_name: str = None,
        load_balancer_spec: str = None,
        proto: str = None,
        reqs_2xx: int = None,
        reqs_3xx: int = None,
        reqs_4xx: int = None,
        reqs_5xx: int = None,
        rt_avg: int = None,
        vip: str = None,
        vni: int = None,
        vport: int = None,
    ):
        # The total number of requests.
        self.acc = acc
        # The business time of the log. Logs are collected every minute.
        self.biz_time = biz_time
        # The ID of the node to which the ELB instance belongs.
        self.ens_region_id = ens_region_id
        # The ID of the ELB instance.
        self.load_balancer_id = load_balancer_id
        # The name of the ELB instance.
        self.load_balancer_name = load_balancer_name
        # The specification of the ELB instance.
        self.load_balancer_spec = load_balancer_spec
        # The request protocol, such as http, https, or tcp.
        self.proto = proto
        # The number of requests with HTTP 2xx status code returned.
        self.reqs_2xx = reqs_2xx
        # The number of requests with HTTP 3xx status code returned.
        self.reqs_3xx = reqs_3xx
        # The number of requests with HTTP 4xx status code returned.
        self.reqs_4xx = reqs_4xx
        # The number of requests with HTTP 5xx status code returned.
        self.reqs_5xx = reqs_5xx
        # The average response time. Unit: milliseconds.
        self.rt_avg = rt_avg
        # The VIP of the instance.
        self.vip = vip
        # The ID of the tunnel.
        self.vni = vni
        # The VIP port, such as 80, 8080, or 443.
        self.vport = vport

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acc is not None:
            result['Acc'] = self.acc
        if self.biz_time is not None:
            result['BizTime'] = self.biz_time
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.load_balancer_name is not None:
            result['LoadBalancerName'] = self.load_balancer_name
        if self.load_balancer_spec is not None:
            result['LoadBalancerSpec'] = self.load_balancer_spec
        if self.proto is not None:
            result['Proto'] = self.proto
        if self.reqs_2xx is not None:
            result['Reqs2xx'] = self.reqs_2xx
        if self.reqs_3xx is not None:
            result['Reqs3xx'] = self.reqs_3xx
        if self.reqs_4xx is not None:
            result['Reqs4xx'] = self.reqs_4xx
        if self.reqs_5xx is not None:
            result['Reqs5xx'] = self.reqs_5xx
        if self.rt_avg is not None:
            result['RtAvg'] = self.rt_avg
        if self.vip is not None:
            result['Vip'] = self.vip
        if self.vni is not None:
            result['Vni'] = self.vni
        if self.vport is not None:
            result['Vport'] = self.vport
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Acc') is not None:
            self.acc = m.get('Acc')
        if m.get('BizTime') is not None:
            self.biz_time = m.get('BizTime')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('LoadBalancerName') is not None:
            self.load_balancer_name = m.get('LoadBalancerName')
        if m.get('LoadBalancerSpec') is not None:
            self.load_balancer_spec = m.get('LoadBalancerSpec')
        if m.get('Proto') is not None:
            self.proto = m.get('Proto')
        if m.get('Reqs2xx') is not None:
            self.reqs_2xx = m.get('Reqs2xx')
        if m.get('Reqs3xx') is not None:
            self.reqs_3xx = m.get('Reqs3xx')
        if m.get('Reqs4xx') is not None:
            self.reqs_4xx = m.get('Reqs4xx')
        if m.get('Reqs5xx') is not None:
            self.reqs_5xx = m.get('Reqs5xx')
        if m.get('RtAvg') is not None:
            self.rt_avg = m.get('RtAvg')
        if m.get('Vip') is not None:
            self.vip = m.get('Vip')
        if m.get('Vni') is not None:
            self.vni = m.get('Vni')
        if m.get('Vport') is not None:
            self.vport = m.get('Vport')
        return self


class DescribeServerLoadBalancerListenMonitorResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        server_load_balancer_monitor_data: List[DescribeServerLoadBalancerListenMonitorResponseBodyServerLoadBalancerMonitorData] = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The array of the monitoring data.
        self.server_load_balancer_monitor_data = server_load_balancer_monitor_data

    def validate(self):
        if self.server_load_balancer_monitor_data:
            for k in self.server_load_balancer_monitor_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['ServerLoadBalancerMonitorData'] = []
        if self.server_load_balancer_monitor_data is not None:
            for k in self.server_load_balancer_monitor_data:
                result['ServerLoadBalancerMonitorData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.server_load_balancer_monitor_data = []
        if m.get('ServerLoadBalancerMonitorData') is not None:
            for k in m.get('ServerLoadBalancerMonitorData'):
                temp_model = DescribeServerLoadBalancerListenMonitorResponseBodyServerLoadBalancerMonitorData()
                self.server_load_balancer_monitor_data.append(temp_model.from_map(k))
        return self


class DescribeServerLoadBalancerListenMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeServerLoadBalancerListenMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeServerLoadBalancerListenMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeServerLoadBalancerMonitorRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        load_balancer_id: str = None,
        start_time: str = None,
    ):
        # The end of the time range to query. The maximum range between StartTime and EndTime is 24 hours.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The ID of the ELB instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id
        # The beginning of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeServerLoadBalancerMonitorResponseBodyServerLoadBalancerMonitorData(TeaModel):
    def __init__(
        self,
        acc: int = None,
        biz_time: str = None,
        ens_region_id: str = None,
        load_balancer_id: str = None,
        load_balancer_name: str = None,
        load_balancer_spec: str = None,
        reqs_2xx: int = None,
        reqs_3xx: int = None,
        reqs_4xx: int = None,
        reqs_5xx: int = None,
        rt_avg: int = None,
        vip: str = None,
        vni: int = None,
    ):
        # The total number of requests.
        self.acc = acc
        # The business time of the log. Logs are collected every minute.
        self.biz_time = biz_time
        # The ID of the node to which the ELB instance belongs.
        self.ens_region_id = ens_region_id
        # The ID of the ELB instance.
        self.load_balancer_id = load_balancer_id
        # The name of the ELB instance.
        self.load_balancer_name = load_balancer_name
        # The specification of the ELB instance.
        self.load_balancer_spec = load_balancer_spec
        # The number of requests with HTTP 2xx status code returned.
        self.reqs_2xx = reqs_2xx
        # The number of requests with HTTP 3xx status code returned.
        self.reqs_3xx = reqs_3xx
        # The number of requests with HTTP 4xx status code returned.
        self.reqs_4xx = reqs_4xx
        # The number of requests with HTTP 5xx status code returned.
        self.reqs_5xx = reqs_5xx
        # The average response time. Unit: milliseconds.
        self.rt_avg = rt_avg
        # The virtual IP address (VIP) of the instance.
        self.vip = vip
        # The ID of the tunnel.
        self.vni = vni

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acc is not None:
            result['Acc'] = self.acc
        if self.biz_time is not None:
            result['BizTime'] = self.biz_time
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.load_balancer_name is not None:
            result['LoadBalancerName'] = self.load_balancer_name
        if self.load_balancer_spec is not None:
            result['LoadBalancerSpec'] = self.load_balancer_spec
        if self.reqs_2xx is not None:
            result['Reqs2xx'] = self.reqs_2xx
        if self.reqs_3xx is not None:
            result['Reqs3xx'] = self.reqs_3xx
        if self.reqs_4xx is not None:
            result['Reqs4xx'] = self.reqs_4xx
        if self.reqs_5xx is not None:
            result['Reqs5xx'] = self.reqs_5xx
        if self.rt_avg is not None:
            result['RtAvg'] = self.rt_avg
        if self.vip is not None:
            result['Vip'] = self.vip
        if self.vni is not None:
            result['Vni'] = self.vni
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Acc') is not None:
            self.acc = m.get('Acc')
        if m.get('BizTime') is not None:
            self.biz_time = m.get('BizTime')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('LoadBalancerName') is not None:
            self.load_balancer_name = m.get('LoadBalancerName')
        if m.get('LoadBalancerSpec') is not None:
            self.load_balancer_spec = m.get('LoadBalancerSpec')
        if m.get('Reqs2xx') is not None:
            self.reqs_2xx = m.get('Reqs2xx')
        if m.get('Reqs3xx') is not None:
            self.reqs_3xx = m.get('Reqs3xx')
        if m.get('Reqs4xx') is not None:
            self.reqs_4xx = m.get('Reqs4xx')
        if m.get('Reqs5xx') is not None:
            self.reqs_5xx = m.get('Reqs5xx')
        if m.get('RtAvg') is not None:
            self.rt_avg = m.get('RtAvg')
        if m.get('Vip') is not None:
            self.vip = m.get('Vip')
        if m.get('Vni') is not None:
            self.vni = m.get('Vni')
        return self


class DescribeServerLoadBalancerMonitorResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        server_load_balancer_monitor_data: List[DescribeServerLoadBalancerMonitorResponseBodyServerLoadBalancerMonitorData] = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The array of the monitoring data.
        self.server_load_balancer_monitor_data = server_load_balancer_monitor_data

    def validate(self):
        if self.server_load_balancer_monitor_data:
            for k in self.server_load_balancer_monitor_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['ServerLoadBalancerMonitorData'] = []
        if self.server_load_balancer_monitor_data is not None:
            for k in self.server_load_balancer_monitor_data:
                result['ServerLoadBalancerMonitorData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.server_load_balancer_monitor_data = []
        if m.get('ServerLoadBalancerMonitorData') is not None:
            for k in m.get('ServerLoadBalancerMonitorData'):
                temp_model = DescribeServerLoadBalancerMonitorResponseBodyServerLoadBalancerMonitorData()
                self.server_load_balancer_monitor_data.append(temp_model.from_map(k))
        return self


class DescribeServerLoadBalancerMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeServerLoadBalancerMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeServerLoadBalancerMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSnapshotsRequest(TeaModel):
    def __init__(
        self,
        disk_id: str = None,
        ens_region_id: str = None,
        ens_region_ids: str = None,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        snapshot_id: str = None,
        snapshot_name: str = None,
    ):
        # The ID of the disk.
        self.disk_id = disk_id
        # The ID of the ENS node. You can query the node ID by calling the [DescribeEnsRegions](https://help.aliyun.com/document_detail/2637662.html) operation.
        self.ens_region_id = ens_region_id
        # The node information.
        self.ens_region_ids = ens_region_ids
        # The ID of the instance.
        self.instance_id = instance_id
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the snapshot. The value can be a JSON array that consists of up to 100 snapshot IDs. Separate the snapshot IDs with commas (,).
        self.snapshot_id = snapshot_id
        # The name of the snapshot. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (_), and hyphens (-).
        self.snapshot_name = snapshot_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.ens_region_ids is not None:
            result['EnsRegionIds'] = self.ens_region_ids
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.snapshot_name is not None:
            result['SnapshotName'] = self.snapshot_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('EnsRegionIds') is not None:
            self.ens_region_ids = m.get('EnsRegionIds')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('SnapshotName') is not None:
            self.snapshot_name = m.get('SnapshotName')
        return self


class DescribeSnapshotsResponseBodySnapshots(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        description: str = None,
        ens_region_id: str = None,
        size: str = None,
        snapshot_id: str = None,
        snapshot_name: str = None,
        source_disk_category: str = None,
        source_disk_id: str = None,
        source_disk_type: str = None,
        source_ens_region_id: str = None,
        source_snapshot_id: str = None,
        status: str = None,
    ):
        # The creation time. The time follows the [ISO 8601](https://help.aliyun.com/document_detail/25696.html) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.creation_time = creation_time
        # The description of the snapshot.
        self.description = description
        # The ID of the edge node.
        self.ens_region_id = ens_region_id
        # The capacity of the disk. Unit: MiB.
        self.size = size
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id
        # The name of the snapshot. This parameter is returned only if a snapshot name was specified when the snapshot was created.
        self.snapshot_name = snapshot_name
        # The type of the disk. Valid value:
        # 
        # *   cloud_efficiency: ultra disk
        # *   cloud_ssd: all-flash disk
        # *   local_hdd: local HDD
        # *   local_ssd: local SSD
        self.source_disk_category = source_disk_category
        # The ID of the source disk. This parameter is retained even after the source disk for which the snapshot was created is released.
        self.source_disk_id = source_disk_id
        # The type of the disk. Valid value:
        # 
        # *   1: system disk
        # *   2: data disk
        self.source_disk_type = source_disk_type
        # The ID of the source edge node.
        self.source_ens_region_id = source_ens_region_id
        # The ID of the source snapshot.
        self.source_snapshot_id = source_snapshot_id
        # The status of the snapshot. Valid value:
        # 
        # *   creating: The snapshot is being created.
        # *   Available: The snapshot is available.
        # *   deleting: The snapshot is being deleted.
        # *   error: An error occurred on the snapshot.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.size is not None:
            result['Size'] = self.size
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.snapshot_name is not None:
            result['SnapshotName'] = self.snapshot_name
        if self.source_disk_category is not None:
            result['SourceDiskCategory'] = self.source_disk_category
        if self.source_disk_id is not None:
            result['SourceDiskId'] = self.source_disk_id
        if self.source_disk_type is not None:
            result['SourceDiskType'] = self.source_disk_type
        if self.source_ens_region_id is not None:
            result['SourceEnsRegionId'] = self.source_ens_region_id
        if self.source_snapshot_id is not None:
            result['SourceSnapshotId'] = self.source_snapshot_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('SnapshotName') is not None:
            self.snapshot_name = m.get('SnapshotName')
        if m.get('SourceDiskCategory') is not None:
            self.source_disk_category = m.get('SourceDiskCategory')
        if m.get('SourceDiskId') is not None:
            self.source_disk_id = m.get('SourceDiskId')
        if m.get('SourceDiskType') is not None:
            self.source_disk_type = m.get('SourceDiskType')
        if m.get('SourceEnsRegionId') is not None:
            self.source_ens_region_id = m.get('SourceEnsRegionId')
        if m.get('SourceSnapshotId') is not None:
            self.source_snapshot_id = m.get('SourceSnapshotId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeSnapshotsResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        snapshots: List[DescribeSnapshotsResponseBodySnapshots] = None,
        total_count: int = None,
    ):
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The information about the snapshots.
        self.snapshots = snapshots
        # The total number of snapshots.
        self.total_count = total_count

    def validate(self):
        if self.snapshots:
            for k in self.snapshots:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Snapshots'] = []
        if self.snapshots is not None:
            for k in self.snapshots:
                result['Snapshots'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.snapshots = []
        if m.get('Snapshots') is not None:
            for k in m.get('Snapshots'):
                temp_model = DescribeSnapshotsResponseBodySnapshots()
                self.snapshots.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSnapshotsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSnapshotsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSnapshotsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSnatAttributeRequest(TeaModel):
    def __init__(
        self,
        snat_entry_id: str = None,
    ):
        # The ID of the SNAT entry.
        # 
        # This parameter is required.
        self.snat_entry_id = snat_entry_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.snat_entry_id is not None:
            result['SnatEntryId'] = self.snat_entry_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SnatEntryId') is not None:
            self.snat_entry_id = m.get('SnatEntryId')
        return self


class DescribeSnatAttributeResponseBodySnatIps(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        ip: str = None,
        status: str = None,
    ):
        # The time when the IP address was created. The time is displayed in UTC.
        self.creation_time = creation_time
        # The IP address.
        self.ip = ip
        # The status of the IP address.
        # 
        # *   Running
        # *   Stopping
        # *   Stopped
        # *   Starting
        # *   Releasing
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeSnatAttributeResponseBody(TeaModel):
    def __init__(
        self,
        creation_time: str = None,
        dest_cidr: str = None,
        eip_affinity: bool = None,
        idle_timeout: int = None,
        isp_affinity: bool = None,
        nat_gateway_id: str = None,
        request_id: str = None,
        snat_entry_id: str = None,
        snat_entry_name: str = None,
        snat_ip: str = None,
        snat_ips: List[DescribeSnatAttributeResponseBodySnatIps] = None,
        source_cidr: str = None,
        standby_snat_ip: str = None,
        standby_status: str = None,
        status: str = None,
        type: str = None,
    ):
        # The time when the entry was created. The time is displayed in UTC.
        self.creation_time = creation_time
        # The destination CIDR block. The rule takes effect only on requests that access the destination CIDR block.
        self.dest_cidr = dest_cidr
        # Specifies whether to enable IP affinity. Valid values:
        # 
        # *   **false**\
        # *   **true**\
        # 
        # >  After you enable IP affinity, if multiple EIPs are associated with an SNAT entry, one client uses the same EIP to for communication. If IP affinity is disabled, the client uses a random EIP for communication.
        self.eip_affinity = eip_affinity
        # The timeout period. Unit: seconds.
        self.idle_timeout = idle_timeout
        # Whether to enable operator affinity. Value taking:
        # - false:Do not open.
        # - true:Open.
        self.isp_affinity = isp_affinity
        # The ID of the Network Address Translation (NAT) gateway.
        self.nat_gateway_id = nat_gateway_id
        # The ID of the request.
        self.request_id = request_id
        # The ID of the SNAT entry.
        self.snat_entry_id = snat_entry_id
        # The name of the SNAT entry.
        self.snat_entry_name = snat_entry_name
        # The EIP specified in the SNAT entry. Multiple EIPs are separated by commas (,).
        self.snat_ip = snat_ip
        # The information about the EIP specified in the SNAT entry.
        self.snat_ips = snat_ips
        # The source CIDR block specified in the SNAT entry.
        self.source_cidr = source_cidr
        # The secondary EIP specified in the SNAT entry. Multiple secondary EIPs are separated by commas (,).
        self.standby_snat_ip = standby_snat_ip
        # The status of the secondary EIP.
        # 
        # *   Running
        # *   Stopping
        # *   Stopped
        # *   Starting
        self.standby_status = standby_status
        # The status of the SNAT entry.
        # 
        # *   Pending: The SNAT entry is being created or modified.
        # *   Available: The SNAT entry is available.
        # *   Deleting: The SNAT entry is being deleted.
        self.status = status
        # The type of the NAT.
        # 
        # *   Empty: symmetric NAT.
        # *   FullCone: full cone NAT.
        self.type = type

    def validate(self):
        if self.snat_ips:
            for k in self.snat_ips:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.dest_cidr is not None:
            result['DestCIDR'] = self.dest_cidr
        if self.eip_affinity is not None:
            result['EipAffinity'] = self.eip_affinity
        if self.idle_timeout is not None:
            result['IdleTimeout'] = self.idle_timeout
        if self.isp_affinity is not None:
            result['IspAffinity'] = self.isp_affinity
        if self.nat_gateway_id is not None:
            result['NatGatewayId'] = self.nat_gateway_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snat_entry_id is not None:
            result['SnatEntryId'] = self.snat_entry_id
        if self.snat_entry_name is not None:
            result['SnatEntryName'] = self.snat_entry_name
        if self.snat_ip is not None:
            result['SnatIp'] = self.snat_ip
        result['SnatIps'] = []
        if self.snat_ips is not None:
            for k in self.snat_ips:
                result['SnatIps'].append(k.to_map() if k else None)
        if self.source_cidr is not None:
            result['SourceCIDR'] = self.source_cidr
        if self.standby_snat_ip is not None:
            result['StandbySnatIp'] = self.standby_snat_ip
        if self.standby_status is not None:
            result['StandbyStatus'] = self.standby_status
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DestCIDR') is not None:
            self.dest_cidr = m.get('DestCIDR')
        if m.get('EipAffinity') is not None:
            self.eip_affinity = m.get('EipAffinity')
        if m.get('IdleTimeout') is not None:
            self.idle_timeout = m.get('IdleTimeout')
        if m.get('IspAffinity') is not None:
            self.isp_affinity = m.get('IspAffinity')
        if m.get('NatGatewayId') is not None:
            self.nat_gateway_id = m.get('NatGatewayId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnatEntryId') is not None:
            self.snat_entry_id = m.get('SnatEntryId')
        if m.get('SnatEntryName') is not None:
            self.snat_entry_name = m.get('SnatEntryName')
        if m.get('SnatIp') is not None:
            self.snat_ip = m.get('SnatIp')
        self.snat_ips = []
        if m.get('SnatIps') is not None:
            for k in m.get('SnatIps'):
                temp_model = DescribeSnatAttributeResponseBodySnatIps()
                self.snat_ips.append(temp_model.from_map(k))
        if m.get('SourceCIDR') is not None:
            self.source_cidr = m.get('SourceCIDR')
        if m.get('StandbySnatIp') is not None:
            self.standby_snat_ip = m.get('StandbySnatIp')
        if m.get('StandbyStatus') is not None:
            self.standby_status = m.get('StandbyStatus')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeSnatAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSnatAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSnatAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSnatTableEntriesRequest(TeaModel):
    def __init__(
        self,
        nat_gateway_id: str = None,
        page_number: int = None,
        page_size: int = None,
        snat_entry_id: str = None,
        snat_entry_name: str = None,
        snat_ip: str = None,
        snat_ips: List[str] = None,
        source_cidr: str = None,
    ):
        # The ID of the Network Address Translation (NAT) gateway.
        # 
        # This parameter is required.
        self.nat_gateway_id = nat_gateway_id
        # The page number. Pages start from page **1**.
        # 
        # Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. The maximum value is **100**.
        # 
        # Default value: **10**.
        self.page_size = page_size
        # The ID of the SNAT entry.
        self.snat_entry_id = snat_entry_id
        # The name of the SNAT entry.
        self.snat_entry_name = snat_entry_name
        # The elastic IP address (EIP) specified in the SNAT entry.
        self.snat_ip = snat_ip
        # The information about the EIP specified in the SNAT entry.
        self.snat_ips = snat_ips
        # The source CIDR block specified in the SNAT entry.
        self.source_cidr = source_cidr

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nat_gateway_id is not None:
            result['NatGatewayId'] = self.nat_gateway_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.snat_entry_id is not None:
            result['SnatEntryId'] = self.snat_entry_id
        if self.snat_entry_name is not None:
            result['SnatEntryName'] = self.snat_entry_name
        if self.snat_ip is not None:
            result['SnatIp'] = self.snat_ip
        if self.snat_ips is not None:
            result['SnatIps'] = self.snat_ips
        if self.source_cidr is not None:
            result['SourceCIDR'] = self.source_cidr
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NatGatewayId') is not None:
            self.nat_gateway_id = m.get('NatGatewayId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SnatEntryId') is not None:
            self.snat_entry_id = m.get('SnatEntryId')
        if m.get('SnatEntryName') is not None:
            self.snat_entry_name = m.get('SnatEntryName')
        if m.get('SnatIp') is not None:
            self.snat_ip = m.get('SnatIp')
        if m.get('SnatIps') is not None:
            self.snat_ips = m.get('SnatIps')
        if m.get('SourceCIDR') is not None:
            self.source_cidr = m.get('SourceCIDR')
        return self


class DescribeSnatTableEntriesResponseBodySnatTableEntries(TeaModel):
    def __init__(
        self,
        eip_affinity: bool = None,
        idle_timeout: int = None,
        isp_affinity: bool = None,
        nat_gateway_id: str = None,
        snat_entry_id: str = None,
        snat_entry_name: str = None,
        snat_ip: str = None,
        source_cidr: str = None,
        standby_snat_ip: str = None,
        standby_status: str = None,
        status: str = None,
    ):
        # Specifies whether to enable EIP affinity. Valid values:
        # 
        # *   **0**: no
        # *   **1**: yes
        # 
        # **\
        # 
        # **Description** After you enable EIP affinity, if multiple EIPs are associated with an SNAT entry, each client uses one EIP to access the Internet. If EIP affinity is disabled, each client uses a random EIP to access the Internet.
        self.eip_affinity = eip_affinity
        # The timeout period for idle connections. Valid values: **1** to **86400**. Unit: seconds.
        self.idle_timeout = idle_timeout
        # Whether to enable operator affinity. Value taking:
        # 
        # - false:Do not open.
        # 
        # - true:Open.
        self.isp_affinity = isp_affinity
        # The ID of the NAT gateway.
        self.nat_gateway_id = nat_gateway_id
        # The ID of the SNAT entry.
        self.snat_entry_id = snat_entry_id
        # The name of the SNAT entry.
        self.snat_entry_name = snat_entry_name
        # The EIP specified in the SNAT entry.
        self.snat_ip = snat_ip
        # The source CIDR block specified in the SNAT entry.
        self.source_cidr = source_cidr
        # The secondary EIP. Multiple EIPs are separated by commas (,).
        self.standby_snat_ip = standby_snat_ip
        # The status of the secondary EIP. Valid values:
        # 
        # *   Running
        # *   Stopping
        # *   Stopped
        # *   Starting
        self.standby_status = standby_status
        # The status of the SNAT entry. Valid values:
        # 
        # *   Pending: The SNAT entry is being created or modified.
        # *   Available: The SNAT entry is available.
        # *   Deleting: The SNAT entry is being deleted.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.eip_affinity is not None:
            result['EipAffinity'] = self.eip_affinity
        if self.idle_timeout is not None:
            result['IdleTimeout'] = self.idle_timeout
        if self.isp_affinity is not None:
            result['IspAffinity'] = self.isp_affinity
        if self.nat_gateway_id is not None:
            result['NatGatewayId'] = self.nat_gateway_id
        if self.snat_entry_id is not None:
            result['SnatEntryId'] = self.snat_entry_id
        if self.snat_entry_name is not None:
            result['SnatEntryName'] = self.snat_entry_name
        if self.snat_ip is not None:
            result['SnatIp'] = self.snat_ip
        if self.source_cidr is not None:
            result['SourceCIDR'] = self.source_cidr
        if self.standby_snat_ip is not None:
            result['StandbySnatIp'] = self.standby_snat_ip
        if self.standby_status is not None:
            result['StandbyStatus'] = self.standby_status
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EipAffinity') is not None:
            self.eip_affinity = m.get('EipAffinity')
        if m.get('IdleTimeout') is not None:
            self.idle_timeout = m.get('IdleTimeout')
        if m.get('IspAffinity') is not None:
            self.isp_affinity = m.get('IspAffinity')
        if m.get('NatGatewayId') is not None:
            self.nat_gateway_id = m.get('NatGatewayId')
        if m.get('SnatEntryId') is not None:
            self.snat_entry_id = m.get('SnatEntryId')
        if m.get('SnatEntryName') is not None:
            self.snat_entry_name = m.get('SnatEntryName')
        if m.get('SnatIp') is not None:
            self.snat_ip = m.get('SnatIp')
        if m.get('SourceCIDR') is not None:
            self.source_cidr = m.get('SourceCIDR')
        if m.get('StandbySnatIp') is not None:
            self.standby_snat_ip = m.get('StandbySnatIp')
        if m.get('StandbyStatus') is not None:
            self.standby_status = m.get('StandbyStatus')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeSnatTableEntriesResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        snat_table_entries: List[DescribeSnatTableEntriesResponseBodySnatTableEntries] = None,
        total_count: int = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The details of the SNAT entries.
        self.snat_table_entries = snat_table_entries
        # The number of SNAT entries that are returned.
        self.total_count = total_count

    def validate(self):
        if self.snat_table_entries:
            for k in self.snat_table_entries:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SnatTableEntries'] = []
        if self.snat_table_entries is not None:
            for k in self.snat_table_entries:
                result['SnatTableEntries'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.snat_table_entries = []
        if m.get('SnatTableEntries') is not None:
            for k in m.get('SnatTableEntries'):
                temp_model = DescribeSnatTableEntriesResponseBodySnatTableEntries()
                self.snat_table_entries.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSnatTableEntriesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSnatTableEntriesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSnatTableEntriesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeStorageGatewayRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        gateway_id: str = None,
        gateway_type: str = None,
        page_number: str = None,
        page_size: str = None,
        vpc_id: str = None,
    ):
        # The ID of the node.
        self.ens_region_id = ens_region_id
        # The ID of the gateway.
        self.gateway_id = gateway_id
        # The type of the gateway. Set this parameter to **1**. **1** indicates iSCSI.
        self.gateway_type = gateway_type
        # The page number. Default value: 1.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.gateway_id is not None:
            result['GatewayId'] = self.gateway_id
        if self.gateway_type is not None:
            result['GatewayType'] = self.gateway_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('GatewayId') is not None:
            self.gateway_id = m.get('GatewayId')
        if m.get('GatewayType') is not None:
            self.gateway_type = m.get('GatewayType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeStorageGatewayResponseBodyStorageGateways(TeaModel):
    def __init__(
        self,
        cidr_block: str = None,
        creation_time: str = None,
        description: str = None,
        ens_region_id: str = None,
        service_ip: str = None,
        status: str = None,
        storage_gateway_id: str = None,
        storage_gateway_name: str = None,
        storage_gateway_type: int = None,
        vpc_id: str = None,
    ):
        # The internal CIDR block.
        self.cidr_block = cidr_block
        # The time when the storage gateway was created. The time is displayed in UTC.
        self.creation_time = creation_time
        # The description of the storage gateway.
        self.description = description
        # The ID of the node.
        self.ens_region_id = ens_region_id
        # The IP address of the service.
        self.service_ip = service_ip
        # The status of the storage gateway. Valid values:
        # 
        # *   creating
        # *   available
        # *   deleting
        # *   deleted
        self.status = status
        # The ID of the storage gateway.
        self.storage_gateway_id = storage_gateway_id
        # The name of the storage gateway.
        self.storage_gateway_name = storage_gateway_name
        # The type of the storage gateway. Default value: 1, which indicates iSCSI.
        self.storage_gateway_type = storage_gateway_type
        # The ID of the VPC.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.service_ip is not None:
            result['ServiceIp'] = self.service_ip
        if self.status is not None:
            result['Status'] = self.status
        if self.storage_gateway_id is not None:
            result['StorageGatewayId'] = self.storage_gateway_id
        if self.storage_gateway_name is not None:
            result['StorageGatewayName'] = self.storage_gateway_name
        if self.storage_gateway_type is not None:
            result['StorageGatewayType'] = self.storage_gateway_type
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('ServiceIp') is not None:
            self.service_ip = m.get('ServiceIp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StorageGatewayId') is not None:
            self.storage_gateway_id = m.get('StorageGatewayId')
        if m.get('StorageGatewayName') is not None:
            self.storage_gateway_name = m.get('StorageGatewayName')
        if m.get('StorageGatewayType') is not None:
            self.storage_gateway_type = m.get('StorageGatewayType')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeStorageGatewayResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        storage_gateways: List[DescribeStorageGatewayResponseBodyStorageGateways] = None,
        total_count: int = None,
    ):
        # The page number. Default value: 1.
        self.page_number = page_number
        # The number of entries per page.
        # 
        # Default value: 10.
        self.page_size = page_size
        # Id of the request
        self.request_id = request_id
        # The list information.
        self.storage_gateways = storage_gateways
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.storage_gateways:
            for k in self.storage_gateways:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['StorageGateways'] = []
        if self.storage_gateways is not None:
            for k in self.storage_gateways:
                result['StorageGateways'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.storage_gateways = []
        if m.get('StorageGateways') is not None:
            for k in m.get('StorageGateways'):
                temp_model = DescribeStorageGatewayResponseBodyStorageGateways()
                self.storage_gateways.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeStorageGatewayResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeStorageGatewayResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeStorageGatewayResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeStorageVolumeRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        gateway_id: str = None,
        is_enable: int = None,
        page_number: int = None,
        page_size: int = None,
        storage_id: str = None,
        volume_id: str = None,
    ):
        # The ID of the node.
        self.ens_region_id = ens_region_id
        # The ID of the gateway.
        self.gateway_id = gateway_id
        # Specifies whether to enable the volume. Valid values:
        # 
        # *   **1** (default): enables the volume.
        # *   **0**: disables the volume.
        self.is_enable = is_enable
        # The page number. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the storage medium.
        self.storage_id = storage_id
        # The ID of the volume.
        self.volume_id = volume_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.gateway_id is not None:
            result['GatewayId'] = self.gateway_id
        if self.is_enable is not None:
            result['IsEnable'] = self.is_enable
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.storage_id is not None:
            result['StorageId'] = self.storage_id
        if self.volume_id is not None:
            result['VolumeId'] = self.volume_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('GatewayId') is not None:
            self.gateway_id = m.get('GatewayId')
        if m.get('IsEnable') is not None:
            self.is_enable = m.get('IsEnable')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StorageId') is not None:
            self.storage_id = m.get('StorageId')
        if m.get('VolumeId') is not None:
            self.volume_id = m.get('VolumeId')
        return self


class DescribeStorageVolumeResponseBodyStorageVolumes(TeaModel):
    def __init__(
        self,
        auth_protocol: str = None,
        creation_time: str = None,
        description: str = None,
        ens_region_id: str = None,
        is_auth: int = None,
        is_enable: int = None,
        status: str = None,
        storage_gateway_id: str = None,
        storage_id: str = None,
        storage_volume_id: str = None,
        storage_volume_name: str = None,
        target_name: str = None,
    ):
        # The authentication protocol. The value is set to **CHAP**.
        self.auth_protocol = auth_protocol
        # The time when the volume was created. The time is displayed in UTC.
        self.creation_time = creation_time
        # The description of the volume.
        self.description = description
        # The ID of the node.
        self.ens_region_id = ens_region_id
        # Indicates whether authentication is enabled. Valid values:
        # 
        # *   **1**: Authentication is enabled.
        # *   **0** (default): Authentication is disabled.
        self.is_auth = is_auth
        # Indicates whether the volume is enabled. Valid values:
        # 
        # *   **1** (default): The volume is enabled.
        # *   **0**: The volume is disabled.
        self.is_enable = is_enable
        # The status of the volume. Valid values:
        # 
        # *   creating
        # *   available
        # *   deleting
        # *   deleted
        self.status = status
        # The ID of the storage gateway.
        self.storage_gateway_id = storage_gateway_id
        # The ID of the storage medium.
        self.storage_id = storage_id
        # The ID of the volume.
        self.storage_volume_id = storage_volume_id
        # The name of the volume.
        self.storage_volume_name = storage_volume_name
        # The destination of the volume.
        self.target_name = target_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_protocol is not None:
            result['AuthProtocol'] = self.auth_protocol
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.is_auth is not None:
            result['IsAuth'] = self.is_auth
        if self.is_enable is not None:
            result['IsEnable'] = self.is_enable
        if self.status is not None:
            result['Status'] = self.status
        if self.storage_gateway_id is not None:
            result['StorageGatewayId'] = self.storage_gateway_id
        if self.storage_id is not None:
            result['StorageId'] = self.storage_id
        if self.storage_volume_id is not None:
            result['StorageVolumeId'] = self.storage_volume_id
        if self.storage_volume_name is not None:
            result['StorageVolumeName'] = self.storage_volume_name
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthProtocol') is not None:
            self.auth_protocol = m.get('AuthProtocol')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('IsAuth') is not None:
            self.is_auth = m.get('IsAuth')
        if m.get('IsEnable') is not None:
            self.is_enable = m.get('IsEnable')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StorageGatewayId') is not None:
            self.storage_gateway_id = m.get('StorageGatewayId')
        if m.get('StorageId') is not None:
            self.storage_id = m.get('StorageId')
        if m.get('StorageVolumeId') is not None:
            self.storage_volume_id = m.get('StorageVolumeId')
        if m.get('StorageVolumeName') is not None:
            self.storage_volume_name = m.get('StorageVolumeName')
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        return self


class DescribeStorageVolumeResponseBody(TeaModel):
    def __init__(
        self,
        page_number: str = None,
        page_size: str = None,
        request_id: str = None,
        storage_volumes: List[DescribeStorageVolumeResponseBodyStorageVolumes] = None,
        total_count: str = None,
    ):
        # The page number. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The list of returned results.
        self.storage_volumes = storage_volumes
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.storage_volumes:
            for k in self.storage_volumes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['StorageVolumes'] = []
        if self.storage_volumes is not None:
            for k in self.storage_volumes:
                result['StorageVolumes'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.storage_volumes = []
        if m.get('StorageVolumes') is not None:
            for k in m.get('StorageVolumes'):
                temp_model = DescribeStorageVolumeResponseBodyStorageVolumes()
                self.storage_volumes.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeStorageVolumeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeStorageVolumeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeStorageVolumeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUserBandWidthDataRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        ens_region_id: str = None,
        instance_id: str = None,
        isp: str = None,
        period: str = None,
        start_time: str = None,
    ):
        # The end of the time range to query.
        # 
        # *   Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # *   If the value of the seconds place is not 00, the start time is automatically set to the next minute.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The ID of the node. You can specify only one node ID. By default, all nodes are queried.
        self.ens_region_id = ens_region_id
        # The ID of the instance for which you want to query the data. You can specify only one instance ID. By default, all instances are queried.
        self.instance_id = instance_id
        # The Internet service provider (ISP). Valid values:
        # 
        # *   cmcc: China Mobile
        # *   telecom: China Telecom
        # *   unicom: China Unicom
        # *   multiCarrier: multi-line ISP
        self.isp = isp
        # The precision of the monitoring data that you want to obtain. Valid values: 300, 1200, 3600, and 14400. Default value: 300. Unit: seconds.
        # 
        # This parameter is required.
        self.period = period
        # The beginning of the time range to query.
        # 
        # *   Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # *   If the value of the seconds place is not 00, the start time is automatically set to the next minute.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.period is not None:
            result['Period'] = self.period
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeUserBandWidthDataResponseBodyMonitorDataBandWidthMonitorData(TeaModel):
    def __init__(
        self,
        down_band_width: int = None,
        internet_rx: int = None,
        internet_tx: int = None,
        time_stamp: str = None,
        up_band_width: int = None,
    ):
        # The outbound bandwidth. Unit: bit/s.
        self.down_band_width = down_band_width
        # The Internet traffic to the instance. Unit: bytes.
        self.internet_rx = internet_rx
        # The Internet traffic from the instance. Unit: bytes.
        self.internet_tx = internet_tx
        # The timestamp when the monitoring data was queried. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.time_stamp = time_stamp
        # The inbound bandwidth. Unit: bit/s.
        self.up_band_width = up_band_width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.down_band_width is not None:
            result['DownBandWidth'] = self.down_band_width
        if self.internet_rx is not None:
            result['InternetRX'] = self.internet_rx
        if self.internet_tx is not None:
            result['InternetTX'] = self.internet_tx
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        if self.up_band_width is not None:
            result['UpBandWidth'] = self.up_band_width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DownBandWidth') is not None:
            self.down_band_width = m.get('DownBandWidth')
        if m.get('InternetRX') is not None:
            self.internet_rx = m.get('InternetRX')
        if m.get('InternetTX') is not None:
            self.internet_tx = m.get('InternetTX')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        if m.get('UpBandWidth') is not None:
            self.up_band_width = m.get('UpBandWidth')
        return self


class DescribeUserBandWidthDataResponseBodyMonitorData(TeaModel):
    def __init__(
        self,
        band_width_monitor_data: List[DescribeUserBandWidthDataResponseBodyMonitorDataBandWidthMonitorData] = None,
        max_down_band_width: str = None,
        max_up_band_width: str = None,
    ):
        # The bandwidth data.
        self.band_width_monitor_data = band_width_monitor_data
        # The maximum outbound bandwidth within the queried time range. Unit: bit/s.
        self.max_down_band_width = max_down_band_width
        # The maximum inbound bandwidth within the queried time range. Unit: bit/s.
        self.max_up_band_width = max_up_band_width

    def validate(self):
        if self.band_width_monitor_data:
            for k in self.band_width_monitor_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BandWidthMonitorData'] = []
        if self.band_width_monitor_data is not None:
            for k in self.band_width_monitor_data:
                result['BandWidthMonitorData'].append(k.to_map() if k else None)
        if self.max_down_band_width is not None:
            result['MaxDownBandWidth'] = self.max_down_band_width
        if self.max_up_band_width is not None:
            result['MaxUpBandWidth'] = self.max_up_band_width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.band_width_monitor_data = []
        if m.get('BandWidthMonitorData') is not None:
            for k in m.get('BandWidthMonitorData'):
                temp_model = DescribeUserBandWidthDataResponseBodyMonitorDataBandWidthMonitorData()
                self.band_width_monitor_data.append(temp_model.from_map(k))
        if m.get('MaxDownBandWidth') is not None:
            self.max_down_band_width = m.get('MaxDownBandWidth')
        if m.get('MaxUpBandWidth') is not None:
            self.max_up_band_width = m.get('MaxUpBandWidth')
        return self


class DescribeUserBandWidthDataResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        monitor_data: DescribeUserBandWidthDataResponseBodyMonitorData = None,
        request_id: str = None,
    ):
        # The returned service code. 0 indicates that the request was successful.
        self.code = code
        # The monitoring data.
        self.monitor_data = monitor_data
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.monitor_data:
            self.monitor_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.monitor_data is not None:
            result['MonitorData'] = self.monitor_data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('MonitorData') is not None:
            temp_model = DescribeUserBandWidthDataResponseBodyMonitorData()
            self.monitor_data = temp_model.from_map(m['MonitorData'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeUserBandWidthDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUserBandWidthDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUserBandWidthDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVSwitchAttributesRequest(TeaModel):
    def __init__(
        self,
        v_switch_id: str = None,
    ):
        # This parameter is required.
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeVSwitchAttributesResponseBodyHaVipIds(TeaModel):
    def __init__(
        self,
        ha_vip_id: List[str] = None,
    ):
        self.ha_vip_id = ha_vip_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ha_vip_id is not None:
            result['HaVipId'] = self.ha_vip_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HaVipId') is not None:
            self.ha_vip_id = m.get('HaVipId')
        return self


class DescribeVSwitchAttributesResponseBodyInstanceIds(TeaModel):
    def __init__(
        self,
        instance_id: List[str] = None,
    ):
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeVSwitchAttributesResponseBodyLoadBalancerIds(TeaModel):
    def __init__(
        self,
        load_balancer_id: List[str] = None,
    ):
        self.load_balancer_id = load_balancer_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        return self


class DescribeVSwitchAttributesResponseBodyNatGatewayIds(TeaModel):
    def __init__(
        self,
        nat_gateway_id: List[str] = None,
    ):
        self.nat_gateway_id = nat_gateway_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nat_gateway_id is not None:
            result['NatGatewayId'] = self.nat_gateway_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NatGatewayId') is not None:
            self.nat_gateway_id = m.get('NatGatewayId')
        return self


class DescribeVSwitchAttributesResponseBodyNetworkInterfaceIds(TeaModel):
    def __init__(
        self,
        network_interface_id: List[str] = None,
    ):
        self.network_interface_id = network_interface_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        return self


class DescribeVSwitchAttributesResponseBody(TeaModel):
    def __init__(
        self,
        available_ip_address_count: int = None,
        cidr_block: str = None,
        created_time: str = None,
        description: str = None,
        ens_region_id: str = None,
        ha_vip_ids: DescribeVSwitchAttributesResponseBodyHaVipIds = None,
        instance_ids: DescribeVSwitchAttributesResponseBodyInstanceIds = None,
        load_balancer_ids: DescribeVSwitchAttributesResponseBodyLoadBalancerIds = None,
        nat_gateway_ids: DescribeVSwitchAttributesResponseBodyNatGatewayIds = None,
        network_id: str = None,
        network_interface_ids: DescribeVSwitchAttributesResponseBodyNetworkInterfaceIds = None,
        request_id: str = None,
        status: str = None,
        v_switch_id: str = None,
        v_switch_name: str = None,
    ):
        self.available_ip_address_count = available_ip_address_count
        self.cidr_block = cidr_block
        self.created_time = created_time
        self.description = description
        self.ens_region_id = ens_region_id
        self.ha_vip_ids = ha_vip_ids
        self.instance_ids = instance_ids
        self.load_balancer_ids = load_balancer_ids
        self.nat_gateway_ids = nat_gateway_ids
        self.network_id = network_id
        self.network_interface_ids = network_interface_ids
        self.request_id = request_id
        self.status = status
        self.v_switch_id = v_switch_id
        self.v_switch_name = v_switch_name

    def validate(self):
        if self.ha_vip_ids:
            self.ha_vip_ids.validate()
        if self.instance_ids:
            self.instance_ids.validate()
        if self.load_balancer_ids:
            self.load_balancer_ids.validate()
        if self.nat_gateway_ids:
            self.nat_gateway_ids.validate()
        if self.network_interface_ids:
            self.network_interface_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_ip_address_count is not None:
            result['AvailableIpAddressCount'] = self.available_ip_address_count
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.description is not None:
            result['Description'] = self.description
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.ha_vip_ids is not None:
            result['HaVipIds'] = self.ha_vip_ids.to_map()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids.to_map()
        if self.load_balancer_ids is not None:
            result['LoadBalancerIds'] = self.load_balancer_ids.to_map()
        if self.nat_gateway_ids is not None:
            result['NatGatewayIds'] = self.nat_gateway_ids.to_map()
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.network_interface_ids is not None:
            result['NetworkInterfaceIds'] = self.network_interface_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status is not None:
            result['Status'] = self.status
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.v_switch_name is not None:
            result['VSwitchName'] = self.v_switch_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvailableIpAddressCount') is not None:
            self.available_ip_address_count = m.get('AvailableIpAddressCount')
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('HaVipIds') is not None:
            temp_model = DescribeVSwitchAttributesResponseBodyHaVipIds()
            self.ha_vip_ids = temp_model.from_map(m['HaVipIds'])
        if m.get('InstanceIds') is not None:
            temp_model = DescribeVSwitchAttributesResponseBodyInstanceIds()
            self.instance_ids = temp_model.from_map(m['InstanceIds'])
        if m.get('LoadBalancerIds') is not None:
            temp_model = DescribeVSwitchAttributesResponseBodyLoadBalancerIds()
            self.load_balancer_ids = temp_model.from_map(m['LoadBalancerIds'])
        if m.get('NatGatewayIds') is not None:
            temp_model = DescribeVSwitchAttributesResponseBodyNatGatewayIds()
            self.nat_gateway_ids = temp_model.from_map(m['NatGatewayIds'])
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('NetworkInterfaceIds') is not None:
            temp_model = DescribeVSwitchAttributesResponseBodyNetworkInterfaceIds()
            self.network_interface_ids = temp_model.from_map(m['NetworkInterfaceIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VSwitchName') is not None:
            self.v_switch_name = m.get('VSwitchName')
        return self


class DescribeVSwitchAttributesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVSwitchAttributesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVSwitchAttributesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVSwitchesRequest(TeaModel):
    def __init__(
        self,
        ens_region_id: str = None,
        ens_region_ids: List[str] = None,
        network_id: str = None,
        page_number: int = None,
        page_size: int = None,
        v_switch_id: str = None,
        v_switch_ids: List[str] = None,
        v_switch_name: str = None,
    ):
        # The ID of the ENS node.
        self.ens_region_id = ens_region_id
        # The IDs of edge nodes. You can specify 1 to 100 IDs.
        self.ens_region_ids = ens_region_ids
        # The ID of the VPC to which the vSwitch belongs.
        self.network_id = network_id
        # The page number. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Maximum value: **50**. Default value: **10**.
        self.page_size = page_size
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id
        # The IDs of vSwitches. You can specify 1 to 100 IDs.
        self.v_switch_ids = v_switch_ids
        # The name of the vSwitch.
        self.v_switch_name = v_switch_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.ens_region_ids is not None:
            result['EnsRegionIds'] = self.ens_region_ids
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.v_switch_ids is not None:
            result['VSwitchIds'] = self.v_switch_ids
        if self.v_switch_name is not None:
            result['VSwitchName'] = self.v_switch_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('EnsRegionIds') is not None:
            self.ens_region_ids = m.get('EnsRegionIds')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VSwitchIds') is not None:
            self.v_switch_ids = m.get('VSwitchIds')
        if m.get('VSwitchName') is not None:
            self.v_switch_name = m.get('VSwitchName')
        return self


class DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        tag_key: str = None,
        tag_value: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        self.tag_key = tag_key
        self.tag_value = tag_value
        # The request error rate.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeVSwitchesResponseBodyVSwitchesVSwitchTags(TeaModel):
    def __init__(
        self,
        tag: List[DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag] = None,
    ):
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeVSwitchesResponseBodyVSwitchesVSwitch(TeaModel):
    def __init__(
        self,
        cidr_block: str = None,
        created_time: str = None,
        description: str = None,
        ens_region_id: str = None,
        free_ip_count: int = None,
        network_id: str = None,
        status: str = None,
        tags: DescribeVSwitchesResponseBodyVSwitchesVSwitchTags = None,
        v_switch_id: str = None,
        v_switch_name: str = None,
    ):
        # The IPv4 CIDR block of the vSwitch.
        self.cidr_block = cidr_block
        # The time when the VPC was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
        self.created_time = created_time
        # The description of the vSwitch.
        self.description = description
        # The ID of the ENS node.
        self.ens_region_id = ens_region_id
        # The number of available IP addresses.
        self.free_ip_count = free_ip_count
        # The ID of the virtual private cloud (VPC).
        self.network_id = network_id
        # The status of the vSwitch. Valid values:
        # 
        # *   Pending
        # *   Available
        self.status = status
        self.tags = tags
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id
        # The name of the vSwitch.
        self.v_switch_name = v_switch_name

    def validate(self):
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.description is not None:
            result['Description'] = self.description
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.free_ip_count is not None:
            result['FreeIpCount'] = self.free_ip_count
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.status is not None:
            result['Status'] = self.status
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.v_switch_name is not None:
            result['VSwitchName'] = self.v_switch_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('FreeIpCount') is not None:
            self.free_ip_count = m.get('FreeIpCount')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tags') is not None:
            temp_model = DescribeVSwitchesResponseBodyVSwitchesVSwitchTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VSwitchName') is not None:
            self.v_switch_name = m.get('VSwitchName')
        return self


class DescribeVSwitchesResponseBodyVSwitches(TeaModel):
    def __init__(
        self,
        v_switch: List[DescribeVSwitchesResponseBodyVSwitchesVSwitch] = None,
    ):
        self.v_switch = v_switch

    def validate(self):
        if self.v_switch:
            for k in self.v_switch:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VSwitch'] = []
        if self.v_switch is not None:
            for k in self.v_switch:
                result['VSwitch'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.v_switch = []
        if m.get('VSwitch') is not None:
            for k in m.get('VSwitch'):
                temp_model = DescribeVSwitchesResponseBodyVSwitchesVSwitch()
                self.v_switch.append(temp_model.from_map(k))
        return self


class DescribeVSwitchesResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
        v_switches: DescribeVSwitchesResponseBodyVSwitches = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries returned on each page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count
        # The information about the vSwitches. For more information, see the array of vSwitches in the response examples in the JSON format.
        self.v_switches = v_switches

    def validate(self):
        if self.v_switches:
            self.v_switches.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.v_switches is not None:
            result['VSwitches'] = self.v_switches.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('VSwitches') is not None:
            temp_model = DescribeVSwitchesResponseBodyVSwitches()
            self.v_switches = temp_model.from_map(m['VSwitches'])
        return self


class DescribeVSwitchesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeVSwitchesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVSwitchesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DetachDiskRequest(TeaModel):
    def __init__(
        self,
        disk_id: str = None,
        instance_id: str = None,
    ):
        # The ID of the disk.
        # 
        # This parameter is required.
        self.disk_id = disk_id
        # The ID of the instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DetachDiskResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        request_id: str = None,
    ):
        # The returned service code. 0 indicates that the request was successful.
        self.code = code
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DetachDiskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DetachDiskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DetachDiskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DetachInstanceSDGRequest(TeaModel):
    def __init__(
        self,
        instance_ids: List[str] = None,
        sdgid: str = None,
    ):
        # The IDs of the instances.
        # 
        # This parameter is required.
        self.instance_ids = instance_ids
        # The ID of the SDG.
        # 
        # This parameter is required.
        self.sdgid = sdgid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class DetachInstanceSDGShrinkRequest(TeaModel):
    def __init__(
        self,
        instance_ids_shrink: str = None,
        sdgid: str = None,
    ):
        # The IDs of the instances.
        # 
        # This parameter is required.
        self.instance_ids_shrink = instance_ids_shrink
        # The ID of the SDG.
        # 
        # This parameter is required.
        self.sdgid = sdgid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids_shrink is not None:
            result['InstanceIds'] = self.instance_ids_shrink
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids_shrink = m.get('InstanceIds')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class DetachInstanceSDGResponseBodyDataResultFailedItems(TeaModel):
    def __init__(
        self,
        err_message: str = None,
        instance_id: str = None,
    ):
        # The error message.
        self.err_message = err_message
        # The ID of the instance.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.err_message is not None:
            result['ErrMessage'] = self.err_message
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrMessage') is not None:
            self.err_message = m.get('ErrMessage')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DetachInstanceSDGResponseBodyDataResult(TeaModel):
    def __init__(
        self,
        failed_count: int = None,
        failed_items: List[DetachInstanceSDGResponseBodyDataResultFailedItems] = None,
        success_count: str = None,
    ):
        # The number of failed tasks.
        self.failed_count = failed_count
        # Details about failed tasks.
        self.failed_items = failed_items
        # The number of successful tasks.
        self.success_count = success_count

    def validate(self):
        if self.failed_items:
            for k in self.failed_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failed_count is not None:
            result['FailedCount'] = self.failed_count
        result['FailedItems'] = []
        if self.failed_items is not None:
            for k in self.failed_items:
                result['FailedItems'].append(k.to_map() if k else None)
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailedCount') is not None:
            self.failed_count = m.get('FailedCount')
        self.failed_items = []
        if m.get('FailedItems') is not None:
            for k in m.get('FailedItems'):
                temp_model = DetachInstanceSDGResponseBodyDataResultFailedItems()
                self.failed_items.append(temp_model.from_map(k))
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        return self


class DetachInstanceSDGResponseBodyData(TeaModel):
    def __init__(
        self,
        message: str = None,
        result: DetachInstanceSDGResponseBodyDataResult = None,
        success: bool = None,
    ):
        # The response message. Success is returned for a successful request.
        self.message = message
        # The execution result of the synchronization request.
        self.result = result
        # Indicates whether all tasks are successful. Valid values:
        # 
        # *   true: All tasks are successful.
        # *   false: Failed tasks exist.
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.result is not None:
            result['Result'] = self.result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Result') is not None:
            temp_model = DetachInstanceSDGResponseBodyDataResult()
            self.result = temp_model.from_map(m['Result'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DetachInstanceSDGResponseBody(TeaModel):
    def __init__(
        self,
        data: DetachInstanceSDGResponseBodyData = None,
        request_id: str = None,
    ):
        # The returned data object.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = DetachInstanceSDGResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DetachInstanceSDGResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DetachInstanceSDGResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DetachInstanceSDGResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DetachNetworkInterfaceRequest(TeaModel):
    def __init__(
        self,
        network_interface_id: str = None,
    ):
        # The ID of the ENI.
        # 
        # This parameter is required.
        self.network_interface_id = network_interface_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        return self


class DetachNetworkInterfaceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DetachNetworkInterfaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DetachNetworkInterfaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DetachNetworkInterfaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DistApplicationDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data: str = None,
        dist_strategy: str = None,
    ):
        # The ID of the application. To obtain the application ID, call the ListApplications operation.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The list of data files that you want to distribute. The value must be a JSON string.
        # 
        # This parameter is required.
        self.data = data
        # The canary release policy. The value must be a JSON string. You can specify multiple distribution policies. By default, all data files are distributed.
        self.dist_strategy = dist_strategy

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data is not None:
            result['Data'] = self.data
        if self.dist_strategy is not None:
            result['DistStrategy'] = self.dist_strategy
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('DistStrategy') is not None:
            self.dist_strategy = m.get('DistStrategy')
        return self


class DistApplicationDataResponseBodyDistInstanceIds(TeaModel):
    def __init__(
        self,
        dist_instance_id: List[str] = None,
    ):
        self.dist_instance_id = dist_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dist_instance_id is not None:
            result['DistInstanceId'] = self.dist_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DistInstanceId') is not None:
            self.dist_instance_id = m.get('DistInstanceId')
        return self


class DistApplicationDataResponseBodyDistResultsDistResult(TeaModel):
    def __init__(
        self,
        name: str = None,
        result_code: int = None,
        result_descrip: str = None,
        version: str = None,
    ):
        # The name of the data file.
        self.name = name
        # The error code. The value is of the enumerated data type.
        self.result_code = result_code
        # The description of the distribution result.
        self.result_descrip = result_descrip
        # The version number of the data file.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.result_code is not None:
            result['ResultCode'] = self.result_code
        if self.result_descrip is not None:
            result['ResultDescrip'] = self.result_descrip
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ResultCode') is not None:
            self.result_code = m.get('ResultCode')
        if m.get('ResultDescrip') is not None:
            self.result_descrip = m.get('ResultDescrip')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DistApplicationDataResponseBodyDistResults(TeaModel):
    def __init__(
        self,
        dist_result: List[DistApplicationDataResponseBodyDistResultsDistResult] = None,
    ):
        self.dist_result = dist_result

    def validate(self):
        if self.dist_result:
            for k in self.dist_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DistResult'] = []
        if self.dist_result is not None:
            for k in self.dist_result:
                result['DistResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dist_result = []
        if m.get('DistResult') is not None:
            for k in m.get('DistResult'):
                temp_model = DistApplicationDataResponseBodyDistResultsDistResult()
                self.dist_result.append(temp_model.from_map(k))
        return self


class DistApplicationDataResponseBody(TeaModel):
    def __init__(
        self,
        dist_instance_ids: DistApplicationDataResponseBodyDistInstanceIds = None,
        dist_instance_total_count: int = None,
        dist_results: DistApplicationDataResponseBodyDistResults = None,
        request_id: str = None,
    ):
        # The list of ENS instance IDs.
        self.dist_instance_ids = dist_instance_ids
        # The total number of ENS instance IDs.
        self.dist_instance_total_count = dist_instance_total_count
        # The distribution result of the data file.
        self.dist_results = dist_results
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.dist_instance_ids:
            self.dist_instance_ids.validate()
        if self.dist_results:
            self.dist_results.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dist_instance_ids is not None:
            result['DistInstanceIds'] = self.dist_instance_ids.to_map()
        if self.dist_instance_total_count is not None:
            result['DistInstanceTotalCount'] = self.dist_instance_total_count
        if self.dist_results is not None:
            result['DistResults'] = self.dist_results.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DistInstanceIds') is not None:
            temp_model = DistApplicationDataResponseBodyDistInstanceIds()
            self.dist_instance_ids = temp_model.from_map(m['DistInstanceIds'])
        if m.get('DistInstanceTotalCount') is not None:
            self.dist_instance_total_count = m.get('DistInstanceTotalCount')
        if m.get('DistResults') is not None:
            temp_model = DistApplicationDataResponseBodyDistResults()
            self.dist_results = temp_model.from_map(m['DistResults'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DistApplicationDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DistApplicationDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DistApplicationDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportBillDetailDataRequest(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        start_date: str = None,
    ):
        # The end of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_date = end_date
        # The beginning of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        return self


class ExportBillDetailDataResponseBody(TeaModel):
    def __init__(
        self,
        file_path: str = None,
        request_id: str = None,
    ):
        # The download path of the exported file.
        self.file_path = file_path
        # The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use the ID to troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ExportBillDetailDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportBillDetailDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportBillDetailDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportImageRequest(TeaModel):
    def __init__(
        self,
        image_id: str = None,
        ossbucket: str = None,
        ossprefix: str = None,
        ossregion_id: str = None,
        role_name: str = None,
    ):
        # The ID of the image.
        # 
        # This parameter is required.
        self.image_id = image_id
        # The OSS bucket to which you want to export the image.
        # 
        # This parameter is required.
        self.ossbucket = ossbucket
        # The prefix of the object as which you want to store the image in the OSS bucket. The prefix must be 1 to 30 characters in length and can contain digits and letters.
        self.ossprefix = ossprefix
        # The region ID.
        # 
        # This parameter is required.
        self.ossregion_id = ossregion_id
        # The name of the Resource Access Management (RAM) role.
        self.role_name = role_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.ossbucket is not None:
            result['OSSBucket'] = self.ossbucket
        if self.ossprefix is not None:
            result['OSSPrefix'] = self.ossprefix
        if self.ossregion_id is not None:
            result['OSSRegionId'] = self.ossregion_id
        if self.role_name is not None:
            result['RoleName'] = self.role_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('OSSBucket') is not None:
            self.ossbucket = m.get('OSSBucket')
        if m.get('OSSPrefix') is not None:
            self.ossprefix = m.get('OSSPrefix')
        if m.get('OSSRegionId') is not None:
            self.ossregion_id = m.get('OSSRegionId')
        if m.get('RoleName') is not None:
            self.role_name = m.get('RoleName')
        return self


class ExportImageResponseBody(TeaModel):
    def __init__(
        self,
        exported_image_url: str = None,
        request_id: str = None,
    ):
        # The URL that points to the exported image.
        self.exported_image_url = exported_image_url
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exported_image_url is not None:
            result['ExportedImageURL'] = self.exported_image_url
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExportedImageURL') is not None:
            self.exported_image_url = m.get('ExportedImageURL')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ExportImageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportImageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportMeasurementDataRequest(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        start_date: str = None,
    ):
        # The end of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_date = end_date
        # The beginning of the time range to query. Specify the time in the yyyy-mm-ddthh:mm:ssz format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        return self


class ExportMeasurementDataResponseBody(TeaModel):
    def __init__(
        self,
        file_path: str = None,
        request_id: str = None,
    ):
        # The download path of the exported file.
        self.file_path = file_path
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ExportMeasurementDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportMeasurementDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportMeasurementDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetBucketAclRequest(TeaModel):
    def __init__(
        self,
        bucket_name: str = None,
    ):
        # The name of the bucket.
        # 
        # This parameter is required.
        self.bucket_name = bucket_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        return self


class GetBucketAclResponseBody(TeaModel):
    def __init__(
        self,
        bucket_acl: str = None,
        request_id: str = None,
    ):
        # The ACL of the bucket.
        self.bucket_acl = bucket_acl
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_acl is not None:
            result['BucketAcl'] = self.bucket_acl
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketAcl') is not None:
            self.bucket_acl = m.get('BucketAcl')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetBucketAclResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetBucketAclResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetBucketAclResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetBucketInfoRequest(TeaModel):
    def __init__(
        self,
        bucket_name: str = None,
    ):
        # The name of the bucket.
        # 
        # This parameter is required.
        self.bucket_name = bucket_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        return self


class GetBucketInfoResponseBodyBucketInfo(TeaModel):
    def __init__(
        self,
        bucket_acl: str = None,
        bucket_name: str = None,
        comment: str = None,
        create_time: str = None,
        logical_bucket_type: str = None,
        modify_time: str = None,
    ):
        # The ACL of the bucket.
        # 
        # *   **public-read-write**\
        # *   **public-read**\
        # *   **private** (default)
        self.bucket_acl = bucket_acl
        # The name of the bucket.
        self.bucket_name = bucket_name
        # The remarks.
        self.comment = comment
        # The time when the bucket was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # Single-node storage. Set the value to sink.
        self.logical_bucket_type = logical_bucket_type
        # The time when the bucket was modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.modify_time = modify_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_acl is not None:
            result['BucketAcl'] = self.bucket_acl
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.logical_bucket_type is not None:
            result['LogicalBucketType'] = self.logical_bucket_type
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketAcl') is not None:
            self.bucket_acl = m.get('BucketAcl')
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LogicalBucketType') is not None:
            self.logical_bucket_type = m.get('LogicalBucketType')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        return self


class GetBucketInfoResponseBody(TeaModel):
    def __init__(
        self,
        bucket_info: GetBucketInfoResponseBodyBucketInfo = None,
        request_id: str = None,
    ):
        # The list of bucket information.
        self.bucket_info = bucket_info
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.bucket_info:
            self.bucket_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_info is not None:
            result['BucketInfo'] = self.bucket_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketInfo') is not None:
            temp_model = GetBucketInfoResponseBodyBucketInfo()
            self.bucket_info = temp_model.from_map(m['BucketInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetBucketInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetBucketInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetBucketInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetBucketLifecycleRequest(TeaModel):
    def __init__(
        self,
        bucket_name: str = None,
        rule_id: str = None,
    ):
        # The name of the bucket.
        # 
        # This parameter is required.
        self.bucket_name = bucket_name
        # The ID of the rule that you want to query. If this parameter is not specified, all rules are returned.
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class GetBucketLifecycleResponseBodyRuleExpiration(TeaModel):
    def __init__(
        self,
        created_before_date: str = None,
        days: str = None,
    ):
        # The expiration date.
        self.created_before_date = created_before_date
        # The validity period, in days.
        self.days = days

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_before_date is not None:
            result['CreatedBeforeDate'] = self.created_before_date
        if self.days is not None:
            result['Days'] = self.days
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatedBeforeDate') is not None:
            self.created_before_date = m.get('CreatedBeforeDate')
        if m.get('Days') is not None:
            self.days = m.get('Days')
        return self


class GetBucketLifecycleResponseBodyRule(TeaModel):
    def __init__(
        self,
        expiration: GetBucketLifecycleResponseBodyRuleExpiration = None,
        id: str = None,
        prefix: str = None,
        status: str = None,
    ):
        # The expiration time.
        self.expiration = expiration
        # The unique ID of the rule.
        self.id = id
        # The prefix that is applied to the rule.
        self.prefix = prefix
        # The status of the rule. Valid values:
        # 
        # *   **Enabled**: The rule is periodically executed.
        # *   **Disabled**: The rule is ignored.
        self.status = status

    def validate(self):
        if self.expiration:
            self.expiration.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expiration is not None:
            result['Expiration'] = self.expiration.to_map()
        if self.id is not None:
            result['ID'] = self.id
        if self.prefix is not None:
            result['Prefix'] = self.prefix
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expiration') is not None:
            temp_model = GetBucketLifecycleResponseBodyRuleExpiration()
            self.expiration = temp_model.from_map(m['Expiration'])
        if m.get('ID') is not None:
            self.id = m.get('ID')
        if m.get('Prefix') is not None:
            self.prefix = m.get('Prefix')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetBucketLifecycleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        rule: List[GetBucketLifecycleResponseBodyRule] = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The detailed information about the rule.
        self.rule = rule

    def validate(self):
        if self.rule:
            for k in self.rule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Rule'] = []
        if self.rule is not None:
            for k in self.rule:
                result['Rule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.rule = []
        if m.get('Rule') is not None:
            for k in m.get('Rule'):
                temp_model = GetBucketLifecycleResponseBodyRule()
                self.rule.append(temp_model.from_map(k))
        return self


class GetBucketLifecycleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetBucketLifecycleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetBucketLifecycleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOssStorageAndAccByBucketsRequest(TeaModel):
    def __init__(
        self,
        bucket_list: str = None,
    ):
        # The information about the bucket.
        self.bucket_list = bucket_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_list is not None:
            result['BucketList'] = self.bucket_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketList') is not None:
            self.bucket_list = m.get('BucketList')
        return self


class GetOssStorageAndAccByBucketsResponseBodyBucketList(TeaModel):
    def __init__(
        self,
        acc: int = None,
        bucket: str = None,
        storage_usage_byte: int = None,
    ):
        # The number of times that the bucket is accessed.
        self.acc = acc
        # The name of the bucket.
        self.bucket = bucket
        # The storage usage of the bucket. Unit: bytes.
        self.storage_usage_byte = storage_usage_byte

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acc is not None:
            result['Acc'] = self.acc
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.storage_usage_byte is not None:
            result['StorageUsageByte'] = self.storage_usage_byte
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Acc') is not None:
            self.acc = m.get('Acc')
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('StorageUsageByte') is not None:
            self.storage_usage_byte = m.get('StorageUsageByte')
        return self


class GetOssStorageAndAccByBucketsResponseBody(TeaModel):
    def __init__(
        self,
        bucket_list: List[GetOssStorageAndAccByBucketsResponseBodyBucketList] = None,
        request_id: str = None,
    ):
        # The information about the bucket.
        self.bucket_list = bucket_list
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.bucket_list:
            for k in self.bucket_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BucketList'] = []
        if self.bucket_list is not None:
            for k in self.bucket_list:
                result['BucketList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.bucket_list = []
        if m.get('BucketList') is not None:
            for k in m.get('BucketList'):
                temp_model = GetOssStorageAndAccByBucketsResponseBodyBucketList()
                self.bucket_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetOssStorageAndAccByBucketsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOssStorageAndAccByBucketsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOssStorageAndAccByBucketsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOssUsageDataRequest(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        end_time: str = None,
        period: str = None,
        start_time: str = None,
    ):
        # The name of the logical Object Storage Service (OSS) bucket.
        self.bucket = bucket
        # The end of the time range to query. The time must be in UTC. Format: 2010-01-21T09:50:23Z.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The aggregation granularity. Unit: minutes.
        # 
        # Default value: 5. Valid values: 5 to 1440.
        self.period = period
        # The beginning of the time range to query. The time must be in UTC. Format: 2010-01-21T09:50:23Z.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.period is not None:
            result['Period'] = self.period
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetOssUsageDataResponseBodyUsageList(TeaModel):
    def __init__(
        self,
        lan_rx_bw: int = None,
        lan_tx_bw: int = None,
        point: int = None,
        point_ts: str = None,
        storage_usage_byte: int = None,
        wan_rx_bw: int = None,
        wan_tx_bw: int = None,
    ):
        # The inbound bandwidth over the internal network. Unit: bit/s.
        self.lan_rx_bw = lan_rx_bw
        # The outbound bandwidth over the internal network. Unit: bit/s.
        self.lan_tx_bw = lan_tx_bw
        # The number of time points within a day.
        self.point = point
        # The point in time, in UTC. Format: 2010-01-21T09:50:23Z.
        self.point_ts = point_ts
        # The storage usage. Unit: bytes.
        self.storage_usage_byte = storage_usage_byte
        # The outbound bandwidth over the Internet. Unit: bit/s.
        self.wan_rx_bw = wan_rx_bw
        # The outbound bandwidth over the Internet. Unit: bit/s.
        self.wan_tx_bw = wan_tx_bw

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lan_rx_bw is not None:
            result['LanRxBw'] = self.lan_rx_bw
        if self.lan_tx_bw is not None:
            result['LanTxBw'] = self.lan_tx_bw
        if self.point is not None:
            result['Point'] = self.point
        if self.point_ts is not None:
            result['PointTs'] = self.point_ts
        if self.storage_usage_byte is not None:
            result['StorageUsageByte'] = self.storage_usage_byte
        if self.wan_rx_bw is not None:
            result['WanRxBw'] = self.wan_rx_bw
        if self.wan_tx_bw is not None:
            result['WanTxBw'] = self.wan_tx_bw
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LanRxBw') is not None:
            self.lan_rx_bw = m.get('LanRxBw')
        if m.get('LanTxBw') is not None:
            self.lan_tx_bw = m.get('LanTxBw')
        if m.get('Point') is not None:
            self.point = m.get('Point')
        if m.get('PointTs') is not None:
            self.point_ts = m.get('PointTs')
        if m.get('StorageUsageByte') is not None:
            self.storage_usage_byte = m.get('StorageUsageByte')
        if m.get('WanRxBw') is not None:
            self.wan_rx_bw = m.get('WanRxBw')
        if m.get('WanTxBw') is not None:
            self.wan_tx_bw = m.get('WanTxBw')
        return self


class GetOssUsageDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        usage_list: List[GetOssUsageDataResponseBodyUsageList] = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The array of usage data.
        self.usage_list = usage_list

    def validate(self):
        if self.usage_list:
            for k in self.usage_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['UsageList'] = []
        if self.usage_list is not None:
            for k in self.usage_list:
                result['UsageList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.usage_list = []
        if m.get('UsageList') is not None:
            for k in m.get('UsageList'):
                temp_model = GetOssUsageDataResponseBodyUsageList()
                self.usage_list.append(temp_model.from_map(k))
        return self


class GetOssUsageDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOssUsageDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOssUsageDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportImageRequestDiskDeviceMapping(TeaModel):
    def __init__(
        self,
        ossbucket: str = None,
        ossobject: str = None,
        ossregion: str = None,
    ):
        self.ossbucket = ossbucket
        self.ossobject = ossobject
        self.ossregion = ossregion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ossbucket is not None:
            result['OSSBucket'] = self.ossbucket
        if self.ossobject is not None:
            result['OSSObject'] = self.ossobject
        if self.ossregion is not None:
            result['OSSRegion'] = self.ossregion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OSSBucket') is not None:
            self.ossbucket = m.get('OSSBucket')
        if m.get('OSSObject') is not None:
            self.ossobject = m.get('OSSObject')
        if m.get('OSSRegion') is not None:
            self.ossregion = m.get('OSSRegion')
        return self


class ImportImageRequest(TeaModel):
    def __init__(
        self,
        architecture: str = None,
        compute_type: str = None,
        disk_device_mapping: List[ImportImageRequestDiskDeviceMapping] = None,
        image_format: str = None,
        image_name: str = None,
        license_type: str = None,
        ossbucket: str = None,
        ossobject: str = None,
        ossregion: str = None,
        ostype: str = None,
        osversion: str = None,
        platform: str = None,
        target_ossregion_id: str = None,
    ):
        # This parameter is required.
        self.architecture = architecture
        # This parameter is required.
        self.compute_type = compute_type
        self.disk_device_mapping = disk_device_mapping
        # This parameter is required.
        self.image_format = image_format
        # This parameter is required.
        self.image_name = image_name
        self.license_type = license_type
        self.ossbucket = ossbucket
        self.ossobject = ossobject
        self.ossregion = ossregion
        # This parameter is required.
        self.ostype = ostype
        self.osversion = osversion
        self.platform = platform
        self.target_ossregion_id = target_ossregion_id

    def validate(self):
        if self.disk_device_mapping:
            for k in self.disk_device_mapping:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.architecture is not None:
            result['Architecture'] = self.architecture
        if self.compute_type is not None:
            result['ComputeType'] = self.compute_type
        result['DiskDeviceMapping'] = []
        if self.disk_device_mapping is not None:
            for k in self.disk_device_mapping:
                result['DiskDeviceMapping'].append(k.to_map() if k else None)
        if self.image_format is not None:
            result['ImageFormat'] = self.image_format
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.license_type is not None:
            result['LicenseType'] = self.license_type
        if self.ossbucket is not None:
            result['OSSBucket'] = self.ossbucket
        if self.ossobject is not None:
            result['OSSObject'] = self.ossobject
        if self.ossregion is not None:
            result['OSSRegion'] = self.ossregion
        if self.ostype is not None:
            result['OSType'] = self.ostype
        if self.osversion is not None:
            result['OSVersion'] = self.osversion
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.target_ossregion_id is not None:
            result['TargetOSSRegionId'] = self.target_ossregion_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Architecture') is not None:
            self.architecture = m.get('Architecture')
        if m.get('ComputeType') is not None:
            self.compute_type = m.get('ComputeType')
        self.disk_device_mapping = []
        if m.get('DiskDeviceMapping') is not None:
            for k in m.get('DiskDeviceMapping'):
                temp_model = ImportImageRequestDiskDeviceMapping()
                self.disk_device_mapping.append(temp_model.from_map(k))
        if m.get('ImageFormat') is not None:
            self.image_format = m.get('ImageFormat')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('LicenseType') is not None:
            self.license_type = m.get('LicenseType')
        if m.get('OSSBucket') is not None:
            self.ossbucket = m.get('OSSBucket')
        if m.get('OSSObject') is not None:
            self.ossobject = m.get('OSSObject')
        if m.get('OSSRegion') is not None:
            self.ossregion = m.get('OSSRegion')
        if m.get('OSType') is not None:
            self.ostype = m.get('OSType')
        if m.get('OSVersion') is not None:
            self.osversion = m.get('OSVersion')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('TargetOSSRegionId') is not None:
            self.target_ossregion_id = m.get('TargetOSSRegionId')
        return self


class ImportImageShrinkRequest(TeaModel):
    def __init__(
        self,
        architecture: str = None,
        compute_type: str = None,
        disk_device_mapping_shrink: str = None,
        image_format: str = None,
        image_name: str = None,
        license_type: str = None,
        ossbucket: str = None,
        ossobject: str = None,
        ossregion: str = None,
        ostype: str = None,
        osversion: str = None,
        platform: str = None,
        target_ossregion_id: str = None,
    ):
        # This parameter is required.
        self.architecture = architecture
        # This parameter is required.
        self.compute_type = compute_type
        self.disk_device_mapping_shrink = disk_device_mapping_shrink
        # This parameter is required.
        self.image_format = image_format
        # This parameter is required.
        self.image_name = image_name
        self.license_type = license_type
        self.ossbucket = ossbucket
        self.ossobject = ossobject
        self.ossregion = ossregion
        # This parameter is required.
        self.ostype = ostype
        self.osversion = osversion
        self.platform = platform
        self.target_ossregion_id = target_ossregion_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.architecture is not None:
            result['Architecture'] = self.architecture
        if self.compute_type is not None:
            result['ComputeType'] = self.compute_type
        if self.disk_device_mapping_shrink is not None:
            result['DiskDeviceMapping'] = self.disk_device_mapping_shrink
        if self.image_format is not None:
            result['ImageFormat'] = self.image_format
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.license_type is not None:
            result['LicenseType'] = self.license_type
        if self.ossbucket is not None:
            result['OSSBucket'] = self.ossbucket
        if self.ossobject is not None:
            result['OSSObject'] = self.ossobject
        if self.ossregion is not None:
            result['OSSRegion'] = self.ossregion
        if self.ostype is not None:
            result['OSType'] = self.ostype
        if self.osversion is not None:
            result['OSVersion'] = self.osversion
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.target_ossregion_id is not None:
            result['TargetOSSRegionId'] = self.target_ossregion_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Architecture') is not None:
            self.architecture = m.get('Architecture')
        if m.get('ComputeType') is not None:
            self.compute_type = m.get('ComputeType')
        if m.get('DiskDeviceMapping') is not None:
            self.disk_device_mapping_shrink = m.get('DiskDeviceMapping')
        if m.get('ImageFormat') is not None:
            self.image_format = m.get('ImageFormat')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('LicenseType') is not None:
            self.license_type = m.get('LicenseType')
        if m.get('OSSBucket') is not None:
            self.ossbucket = m.get('OSSBucket')
        if m.get('OSSObject') is not None:
            self.ossobject = m.get('OSSObject')
        if m.get('OSSRegion') is not None:
            self.ossregion = m.get('OSSRegion')
        if m.get('OSType') is not None:
            self.ostype = m.get('OSType')
        if m.get('OSVersion') is not None:
            self.osversion = m.get('OSVersion')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('TargetOSSRegionId') is not None:
            self.target_ossregion_id = m.get('TargetOSSRegionId')
        return self


class ImportImageResponseBody(TeaModel):
    def __init__(
        self,
        image_id: str = None,
        request_id: str = None,
    ):
        self.image_id = image_id
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ImportImageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportImageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportKeyPairRequest(TeaModel):
    def __init__(
        self,
        key_pair_name: str = None,
        public_key_body: str = None,
    ):
        # The name of the key pair. The name must conform to the following naming conventions:
        # 
        # *   The name must be 2 to 128 characters in length.
        # *   The name must start with a letter but cannot start with `http://` or `https://`.
        # *   The name can contain letters, digits, colons (:), underscores (_), and hyphens (-).
        # 
        # You can specify the name of only one key pair.
        # 
        # This parameter is required.
        self.key_pair_name = key_pair_name
        # The public key of the key pair. You can specify only one public key.
        # 
        # This parameter is required.
        self.public_key_body = public_key_body

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.public_key_body is not None:
            result['PublicKeyBody'] = self.public_key_body
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('PublicKeyBody') is not None:
            self.public_key_body = m.get('PublicKeyBody')
        return self


class ImportKeyPairResponseBody(TeaModel):
    def __init__(
        self,
        key_pair_finger_print: str = None,
        key_pair_name: str = None,
        request_id: str = None,
    ):
        # The fingerprint of the key pair. The message-digest algorithm 5 (MD5) is used based on the public key fingerprint format defined in RFC 4716.
        self.key_pair_finger_print = key_pair_finger_print
        # The name of the key pair.
        self.key_pair_name = key_pair_name
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_pair_finger_print is not None:
            result['KeyPairFingerPrint'] = self.key_pair_finger_print
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('KeyPairFingerPrint') is not None:
            self.key_pair_finger_print = m.get('KeyPairFingerPrint')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ImportKeyPairResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportKeyPairResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportKeyPairResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class JoinPublicIpsToEpnInstanceRequest(TeaModel):
    def __init__(
        self,
        epninstance_id: str = None,
        instance_infos: str = None,
    ):
        # The ID of the EPN instance.
        # 
        # This parameter is required.
        self.epninstance_id = epninstance_id
        # The information about the public IP address that you want to add to the EPN instance.
        # 
        # This parameter is required.
        self.instance_infos = instance_infos

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.epninstance_id is not None:
            result['EPNInstanceId'] = self.epninstance_id
        if self.instance_infos is not None:
            result['InstanceInfos'] = self.instance_infos
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EPNInstanceId') is not None:
            self.epninstance_id = m.get('EPNInstanceId')
        if m.get('InstanceInfos') is not None:
            self.instance_infos = m.get('InstanceInfos')
        return self


class JoinPublicIpsToEpnInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class JoinPublicIpsToEpnInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: JoinPublicIpsToEpnInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = JoinPublicIpsToEpnInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class JoinSecurityGroupRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        network_interface_id: str = None,
        security_group_id: str = None,
    ):
        # The ID of the instance.
        self.instance_id = instance_id
        # The ID of the ENI.
        self.network_interface_id = network_interface_id
        # The ID of the security group.
        # 
        # This parameter is required.
        self.security_group_id = security_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class JoinSecurityGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class JoinSecurityGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: JoinSecurityGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = JoinSecurityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class JoinVSwitchesToEpnInstanceRequest(TeaModel):
    def __init__(
        self,
        epninstance_id: str = None,
        v_switches_info: str = None,
    ):
        # The ID of the edge network instance.
        # 
        # This parameter is required.
        self.epninstance_id = epninstance_id
        # The information about the internal networking to which you want to add the edge network instance.
        # 
        # This parameter is required.
        self.v_switches_info = v_switches_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.epninstance_id is not None:
            result['EPNInstanceId'] = self.epninstance_id
        if self.v_switches_info is not None:
            result['VSwitchesInfo'] = self.v_switches_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EPNInstanceId') is not None:
            self.epninstance_id = m.get('EPNInstanceId')
        if m.get('VSwitchesInfo') is not None:
            self.v_switches_info = m.get('VSwitchesInfo')
        return self


class JoinVSwitchesToEpnInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class JoinVSwitchesToEpnInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: JoinVSwitchesToEpnInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = JoinVSwitchesToEpnInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class LeaveSecurityGroupRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        network_interface_id: str = None,
        security_group_id: str = None,
    ):
        # The instance ID.
        self.instance_id = instance_id
        # The ID of the ENI.
        self.network_interface_id = network_interface_id
        # The ID of the security group.
        # 
        # This parameter is required.
        self.security_group_id = security_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class LeaveSecurityGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class LeaveSecurityGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: LeaveSecurityGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = LeaveSecurityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListApplicationsRequest(TeaModel):
    def __init__(
        self,
        app_versions: str = None,
        cluster_names: str = None,
        level: str = None,
        max_date: str = None,
        min_date: str = None,
        out_app_info_params: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The version number of the application. Separate multiple version numbers with commas (,). If you want to query data of all versions of applications, specify All for this parameter. By default, only data of applications in the stable versions are queried.
        self.app_versions = app_versions
        # The name of the application cluster. Separate multiple names with commas (,). If you want to query applications of all clusters in your account, specify All for this parameter. Default value: All.
        self.cluster_names = cluster_names
        # The region level by which edge resources of the application are collected. The value is of the enumeration type. Valid values:
        # 
        # *   National: Chinese mainland
        # *   Big: area
        # *   Middle: province
        # *   Small: city
        # *   RegionId: edge node
        # 
        # Default value: National.
        self.level = level
        # The end of the time range to query. Specify the time in the 2006-01-02 format. By default, the time range to query is not restricted.
        self.max_date = max_date
        # The beginning of the time range to query. Specify the time in the 2006-01-02 format. By default, the time range to query is not restricted.
        self.min_date = min_date
        # Specifies whether to return other information about the application, such as statistics on resource instances and pods. The value must be a JSON string. By default, all information is returned.
        self.out_app_info_params = out_app_info_params
        # The page number. Pages start from page 1. This parameter is optional if you want to return the push status of all data files.
        self.page_number = page_number
        # The number of entries per page. This parameter is optional if you want to return all information about the applications.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_versions is not None:
            result['AppVersions'] = self.app_versions
        if self.cluster_names is not None:
            result['ClusterNames'] = self.cluster_names
        if self.level is not None:
            result['Level'] = self.level
        if self.max_date is not None:
            result['MaxDate'] = self.max_date
        if self.min_date is not None:
            result['MinDate'] = self.min_date
        if self.out_app_info_params is not None:
            result['OutAppInfoParams'] = self.out_app_info_params
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppVersions') is not None:
            self.app_versions = m.get('AppVersions')
        if m.get('ClusterNames') is not None:
            self.cluster_names = m.get('ClusterNames')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('MaxDate') is not None:
            self.max_date = m.get('MaxDate')
        if m.get('MinDate') is not None:
            self.min_date = m.get('MinDate')
        if m.get('OutAppInfoParams') is not None:
            self.out_app_info_params = m.get('OutAppInfoParams')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListApplicationsResponseBodyApplicationsApplicationAppListApp(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_info: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The information about the application, such as the resource specification, parameter configuration, and resources.
        self.app_info = app_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_info is not None:
            result['AppInfo'] = self.app_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppInfo') is not None:
            self.app_info = m.get('AppInfo')
        return self


class ListApplicationsResponseBodyApplicationsApplicationAppList(TeaModel):
    def __init__(
        self,
        app: List[ListApplicationsResponseBodyApplicationsApplicationAppListApp] = None,
    ):
        self.app = app

    def validate(self):
        if self.app:
            for k in self.app:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['App'] = []
        if self.app is not None:
            for k in self.app:
                result['App'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.app = []
        if m.get('App') is not None:
            for k in m.get('App'):
                temp_model = ListApplicationsResponseBodyApplicationsApplicationAppListApp()
                self.app.append(temp_model.from_map(k))
        return self


class ListApplicationsResponseBodyApplicationsApplication(TeaModel):
    def __init__(
        self,
        app_list: ListApplicationsResponseBodyApplicationsApplicationAppList = None,
        cluster_name: str = None,
    ):
        # Details about the application.
        self.app_list = app_list
        # The name of the cluster.
        self.cluster_name = cluster_name

    def validate(self):
        if self.app_list:
            self.app_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_list is not None:
            result['AppList'] = self.app_list.to_map()
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppList') is not None:
            temp_model = ListApplicationsResponseBodyApplicationsApplicationAppList()
            self.app_list = temp_model.from_map(m['AppList'])
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        return self


class ListApplicationsResponseBodyApplications(TeaModel):
    def __init__(
        self,
        application: List[ListApplicationsResponseBodyApplicationsApplication] = None,
    ):
        self.application = application

    def validate(self):
        if self.application:
            for k in self.application:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Application'] = []
        if self.application is not None:
            for k in self.application:
                result['Application'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.application = []
        if m.get('Application') is not None:
            for k in m.get('Application'):
                temp_model = ListApplicationsResponseBodyApplicationsApplication()
                self.application.append(temp_model.from_map(k))
        return self


class ListApplicationsResponseBody(TeaModel):
    def __init__(
        self,
        applications: ListApplicationsResponseBodyApplications = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # Details about applications.
        self.applications = applications
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.applications:
            self.applications.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.applications is not None:
            result['Applications'] = self.applications.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Applications') is not None:
            temp_model = ListApplicationsResponseBodyApplications()
            self.applications = temp_model.from_map(m['Applications'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListApplicationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListApplicationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListApplicationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListBucketsRequest(TeaModel):
    def __init__(
        self,
        page_number: str = None,
        page_size: str = None,
        prefix: str = None,
    ):
        # The page number. Pages start from page 1.
        self.page_number = page_number
        # The maximum number of returned buckets. You can leave this parameter empty. The default value is 10. The value cannot be greater than 100.
        self.page_size = page_size
        # The prefix that returned bucket names must contain. If this parameter is not specified, prefix information will not be used as a filter.
        self.prefix = prefix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.prefix is not None:
            result['Prefix'] = self.prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Prefix') is not None:
            self.prefix = m.get('Prefix')
        return self


class ListBucketsResponseBodyBucketInfos(TeaModel):
    def __init__(
        self,
        bucket_acl: str = None,
        bucket_name: str = None,
        comment: str = None,
        create_time: str = None,
        ens_region_id: str = None,
        logical_bucket_type: str = None,
        modify_time: str = None,
    ):
        # The access control list (ACL) of the bucket.
        # 
        # *   **public-read-write**\
        # *   **public-read**\
        # *   **private** (default)
        self.bucket_acl = bucket_acl
        # The name of the bucket.
        self.bucket_name = bucket_name
        # The remarks.
        self.comment = comment
        # The time when the bucket was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.create_time = create_time
        # The ID of the region where the node is located.
        self.ens_region_id = ens_region_id
        # The type of the single-node storage. Set the value to sink.
        self.logical_bucket_type = logical_bucket_type
        # The time when the bucket was modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.modify_time = modify_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_acl is not None:
            result['BucketAcl'] = self.bucket_acl
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.logical_bucket_type is not None:
            result['LogicalBucketType'] = self.logical_bucket_type
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketAcl') is not None:
            self.bucket_acl = m.get('BucketAcl')
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('LogicalBucketType') is not None:
            self.logical_bucket_type = m.get('LogicalBucketType')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        return self


class ListBucketsResponseBody(TeaModel):
    def __init__(
        self,
        bucket_infos: List[ListBucketsResponseBodyBucketInfos] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The list of bucket information.
        self.bucket_infos = bucket_infos
        # The ID of the request.
        self.request_id = request_id
        # The total number of buckets that match the conditions.
        self.total_count = total_count

    def validate(self):
        if self.bucket_infos:
            for k in self.bucket_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BucketInfos'] = []
        if self.bucket_infos is not None:
            for k in self.bucket_infos:
                result['BucketInfos'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.bucket_infos = []
        if m.get('BucketInfos') is not None:
            for k in m.get('BucketInfos'):
                temp_model = ListBucketsResponseBodyBucketInfos()
                self.bucket_infos.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListBucketsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListBucketsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListBucketsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListObjectsRequest(TeaModel):
    def __init__(
        self,
        bucket_name: str = None,
        continuation_token: str = None,
        encoding_type: str = None,
        marker: str = None,
        max_keys: int = None,
        prefix: str = None,
        start_after: str = None,
    ):
        # The name of the bucket.
        # 
        # This parameter is required.
        self.bucket_name = bucket_name
        # The token used in this list operation. If the number of objects exceeds the value of MaxKeys, the NextContinuationToken is included in the response as the token for the next list operation.
        self.continuation_token = continuation_token
        # The encoding type of the object names in the response. Only URL encoding is supported.
        self.encoding_type = encoding_type
        # The position from which the list operation starts. If this parameter is specified, objects whose names are alphabetically greater than value of Marker are returned. The Marker parameter is used to list the returned objects by page, and its value must be smaller than 1,024 bytes in length.
        # 
        # Even if the value specified for Marker does not exist in the list during a conditional query, the list starts from the object whose name is alphabetically greater than the value of Marker.
        self.marker = marker
        # The maximum number of objects to return. Valid values: 0 to 1000. Default value: 100.
        self.max_keys = max_keys
        # The prefix that must be included in the names of objects you want to list. If you specify a prefix to query objects, the returned object names contain the prefix.
        # 
        # The value of the parameter must be less than 1,000 bytes in length.
        self.prefix = prefix
        # The position from which the list operation starts. If this parameter is specified, objects whose names are alphabetically greater than the value of StartAfter are returned. The StartAfter parameter is used to list the returned objects by page, and its value must be less than 1,000 bytes in length. Even if the value specified for StartAfter does not exist in the list during a conditional query, the list starts from the object whose name is alphabetically greater than the value of StartAfter.
        self.start_after = start_after

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        if self.continuation_token is not None:
            result['ContinuationToken'] = self.continuation_token
        if self.encoding_type is not None:
            result['EncodingType'] = self.encoding_type
        if self.marker is not None:
            result['Marker'] = self.marker
        if self.max_keys is not None:
            result['MaxKeys'] = self.max_keys
        if self.prefix is not None:
            result['Prefix'] = self.prefix
        if self.start_after is not None:
            result['StartAfter'] = self.start_after
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        if m.get('ContinuationToken') is not None:
            self.continuation_token = m.get('ContinuationToken')
        if m.get('EncodingType') is not None:
            self.encoding_type = m.get('EncodingType')
        if m.get('Marker') is not None:
            self.marker = m.get('Marker')
        if m.get('MaxKeys') is not None:
            self.max_keys = m.get('MaxKeys')
        if m.get('Prefix') is not None:
            self.prefix = m.get('Prefix')
        if m.get('StartAfter') is not None:
            self.start_after = m.get('StartAfter')
        return self


class ListObjectsResponseBodyContents(TeaModel):
    def __init__(
        self,
        etag: str = None,
        key: str = None,
        last_modified: str = None,
        size: int = None,
    ):
        # The entity tag (ETag). When an object is created, an ETag is created to identify the content of the object.
        # 
        # *   For an object that is created by calling the PutObject operation, the ETag value of the object is the MD5 hash of the object content.
        # *   For an object that is not created by calling the PutObject operation, the ETag value of the object is the UUID of the object content.
        # *   The ETag of an object can be used to check whether the object content is modified. However, we recommend that you use the MD5 hash of an object rather than the ETag value of the object to verify data integrity.
        self.etag = etag
        # The name of the object.
        self.key = key
        # The time when the object was last modified.
        self.last_modified = last_modified
        # The size of the returned object. Unit: bytes.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.etag is not None:
            result['ETag'] = self.etag
        if self.key is not None:
            result['Key'] = self.key
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ETag') is not None:
            self.etag = m.get('ETag')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class ListObjectsResponseBody(TeaModel):
    def __init__(
        self,
        bucket_name: str = None,
        common_prefixes: List[str] = None,
        contents: List[ListObjectsResponseBodyContents] = None,
        continuation_token: str = None,
        delimiter: str = None,
        encoding_type: str = None,
        is_truncated: bool = None,
        key_count: int = None,
        marker: str = None,
        max_keys: int = None,
        next_continuation_token: str = None,
        next_marker: str = None,
        prefix: str = None,
        request_id: str = None,
    ):
        # The name of the bucket.
        self.bucket_name = bucket_name
        # If the delimiter parameter is specified in the request, the response contains CommonPrefixes. Objects whose names contain the same string from the prefix to the next occurrence of the delimiter are grouped as a single result element in CommonPrefixes.
        self.common_prefixes = common_prefixes
        # The list of object metadata.
        self.contents = contents
        # The token used in this list operation.
        self.continuation_token = continuation_token
        # The character used to group objects by name.
        self.delimiter = delimiter
        # The encoding type of the object names in the response.
        self.encoding_type = encoding_type
        # Indicates whether the listed objects are truncated. Valid values:
        # 
        # *   **false**\
        # *   **true**\
        self.is_truncated = is_truncated
        # The number of keys returned for this request.
        self.key_count = key_count
        # The position from which the list operation starts.
        self.marker = marker
        # The maximum number of objects returned.
        self.max_keys = max_keys
        # The token used in the next list operation.
        self.next_continuation_token = next_continuation_token
        # The position from which the next list operation starts.
        self.next_marker = next_marker
        # The prefix contained in the names of returned objects.
        self.prefix = prefix
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.contents:
            for k in self.contents:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        if self.common_prefixes is not None:
            result['CommonPrefixes'] = self.common_prefixes
        result['Contents'] = []
        if self.contents is not None:
            for k in self.contents:
                result['Contents'].append(k.to_map() if k else None)
        if self.continuation_token is not None:
            result['ContinuationToken'] = self.continuation_token
        if self.delimiter is not None:
            result['Delimiter'] = self.delimiter
        if self.encoding_type is not None:
            result['EncodingType'] = self.encoding_type
        if self.is_truncated is not None:
            result['IsTruncated'] = self.is_truncated
        if self.key_count is not None:
            result['KeyCount'] = self.key_count
        if self.marker is not None:
            result['Marker'] = self.marker
        if self.max_keys is not None:
            result['MaxKeys'] = self.max_keys
        if self.next_continuation_token is not None:
            result['NextContinuationToken'] = self.next_continuation_token
        if self.next_marker is not None:
            result['NextMarker'] = self.next_marker
        if self.prefix is not None:
            result['Prefix'] = self.prefix
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        if m.get('CommonPrefixes') is not None:
            self.common_prefixes = m.get('CommonPrefixes')
        self.contents = []
        if m.get('Contents') is not None:
            for k in m.get('Contents'):
                temp_model = ListObjectsResponseBodyContents()
                self.contents.append(temp_model.from_map(k))
        if m.get('ContinuationToken') is not None:
            self.continuation_token = m.get('ContinuationToken')
        if m.get('Delimiter') is not None:
            self.delimiter = m.get('Delimiter')
        if m.get('EncodingType') is not None:
            self.encoding_type = m.get('EncodingType')
        if m.get('IsTruncated') is not None:
            self.is_truncated = m.get('IsTruncated')
        if m.get('KeyCount') is not None:
            self.key_count = m.get('KeyCount')
        if m.get('Marker') is not None:
            self.marker = m.get('Marker')
        if m.get('MaxKeys') is not None:
            self.max_keys = m.get('MaxKeys')
        if m.get('NextContinuationToken') is not None:
            self.next_continuation_token = m.get('NextContinuationToken')
        if m.get('NextMarker') is not None:
            self.next_marker = m.get('NextMarker')
        if m.get('Prefix') is not None:
            self.prefix = m.get('Prefix')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListObjectsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListObjectsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListObjectsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProductAbilitiesResponseBody(TeaModel):
    def __init__(
        self,
        product_abilities: List[str] = None,
        request_id: str = None,
    ):
        # Products supported by the edge node.
        self.product_abilities = product_abilities
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.product_abilities is not None:
            result['ProductAbilities'] = self.product_abilities
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProductAbilities') is not None:
            self.product_abilities = m.get('ProductAbilities')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListProductAbilitiesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProductAbilitiesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProductAbilitiesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTagResourcesRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of tag N of the instance. Valid values of N: **1** to **20**.
        # 
        # *   The key cannot start with `aliyun`, `acs:`, `http://`, or `https://`.
        # *   The key must be up to 64 characters in length.
        # *   The tag key cannot be an empty string.
        self.key = key
        # The value of a tag that is attached to the topics you want to query. This parameter is not required. If you configure this parameter, you must also configure the **Key** parameter.**** If you include the Key and Value parameters in a request, this operation queries only the topics that use the specified tags. If you do not include these parameters in a request, this operation queries all topics that you can access.
        # 
        # *   Valid values of N: 1 to 20.
        # *   The value of this parameter can be an empty string.
        # *   The tag key can be up to 128 characters in length and cannot contain http:// or https://. The tag key cannot start with acs: or aliyun.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListTagResourcesRequest(TeaModel):
    def __init__(
        self,
        next_token: str = None,
        resource_id: List[str] = None,
        resource_type: str = None,
        tag: List[ListTagResourcesRequestTag] = None,
    ):
        # The token of the first page to query.
        self.next_token = next_token
        # The IDs of resources. Valid values of N: 1 to 50.
        self.resource_id = resource_id
        # The resource type. Set the value to instance.
        # 
        # This parameter is required.
        self.resource_type = resource_type
        # The tags.
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = ListTagResourcesRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class ListTagResourcesResponseBodyTagResources(TeaModel):
    def __init__(
        self,
        resource_id: str = None,
        resource_type: str = None,
        tag_key: str = None,
        tag_value: str = None,
    ):
        # The ID of the associated resources.
        self.resource_id = resource_id
        # The type of the resource.
        self.resource_type = resource_type
        # The tag key of the instance.
        self.tag_key = tag_key
        # The value of the tag.
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class ListTagResourcesResponseBody(TeaModel):
    def __init__(
        self,
        next_token: str = None,
        request_id: str = None,
        tag_resources: List[ListTagResourcesResponseBodyTagResources] = None,
    ):
        # The token of the first page to query.
        self.next_token = next_token
        # The ID of the request.
        self.request_id = request_id
        # The tags that are added to specified one or more resources.
        self.tag_resources = tag_resources

    def validate(self):
        if self.tag_resources:
            for k in self.tag_resources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TagResources'] = []
        if self.tag_resources is not None:
            for k in self.tag_resources:
                result['TagResources'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.tag_resources = []
        if m.get('TagResources') is not None:
            for k in m.get('TagResources'):
                temp_model = ListTagResourcesResponseBodyTagResources()
                self.tag_resources.append(temp_model.from_map(k))
        return self


class ListTagResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTagResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyEnsEipAddressAttributeRequest(TeaModel):
    def __init__(
        self,
        allocation_id: str = None,
        bandwidth: int = None,
        description: str = None,
        name: str = None,
    ):
        # The ID of the EIP.
        # 
        # This parameter is required.
        self.allocation_id = allocation_id
        # The peak bandwidth of the EIP. Default value: 5. Valid values: **5** to **10000**. Unit: Mbit/s.
        self.bandwidth = bandwidth
        # The new description of the EIP. The description must be 2 to 256 characters in length and cannot start with http:// or https://.
        self.description = description
        # The new name of the EIP. The name must be 2 to 128 characters in length and cannot start with http:// or https://.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ModifyEnsEipAddressAttributeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyEnsEipAddressAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyEnsEipAddressAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyEnsEipAddressAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyEnsRouteEntryRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        route_entry_id: str = None,
        route_entry_name: str = None,
    ):
        self.description = description
        # This parameter is required.
        self.route_entry_id = route_entry_id
        self.route_entry_name = route_entry_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.route_entry_id is not None:
            result['RouteEntryId'] = self.route_entry_id
        if self.route_entry_name is not None:
            result['RouteEntryName'] = self.route_entry_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RouteEntryId') is not None:
            self.route_entry_id = m.get('RouteEntryId')
        if m.get('RouteEntryName') is not None:
            self.route_entry_name = m.get('RouteEntryName')
        return self


class ModifyEnsRouteEntryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyEnsRouteEntryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyEnsRouteEntryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyEnsRouteEntryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyEpnInstanceRequest(TeaModel):
    def __init__(
        self,
        epninstance_id: str = None,
        epninstance_name: str = None,
        internet_max_bandwidth_out: int = None,
        networking_model: str = None,
    ):
        # The ID of the EPN instance.
        # 
        # This parameter is required.
        self.epninstance_id = epninstance_id
        # The name of the EPN instance.
        self.epninstance_name = epninstance_name
        # The maximum outbound public bandwidth. Unit: Mbit/s. Valid values: 1 Mbit/s to 100 Mbit/s.
        self.internet_max_bandwidth_out = internet_max_bandwidth_out
        # The networking mode. Valid values:
        # 
        # *   **SpeedUp**: Intelligent acceleration network (Internet).
        # *   **Connection**: Internal network.
        # *   **SpeedUpAndConnection**: Intelligent acceleration network and internal network.
        # 
        # >  The internal network supports only **Connection** and **SpeedUpAndConnection**.
        self.networking_model = networking_model

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.epninstance_id is not None:
            result['EPNInstanceId'] = self.epninstance_id
        if self.epninstance_name is not None:
            result['EPNInstanceName'] = self.epninstance_name
        if self.internet_max_bandwidth_out is not None:
            result['InternetMaxBandwidthOut'] = self.internet_max_bandwidth_out
        if self.networking_model is not None:
            result['NetworkingModel'] = self.networking_model
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EPNInstanceId') is not None:
            self.epninstance_id = m.get('EPNInstanceId')
        if m.get('EPNInstanceName') is not None:
            self.epninstance_name = m.get('EPNInstanceName')
        if m.get('InternetMaxBandwidthOut') is not None:
            self.internet_max_bandwidth_out = m.get('InternetMaxBandwidthOut')
        if m.get('NetworkingModel') is not None:
            self.networking_model = m.get('NetworkingModel')
        return self


class ModifyEpnInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyEpnInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyEpnInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyEpnInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyFileSystemRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        ens_region_id: str = None,
        file_system_id: str = None,
    ):
        # The description of the file system.
        # 
        # This parameter is required.
        self.description = description
        # The ID of the edge node.
        # 
        # This parameter is required.
        self.ens_region_id = ens_region_id
        # The ID of the file system.
        # 
        # This parameter is required.
        self.file_system_id = file_system_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.file_system_id is not None:
            result['FileSystemId'] = self.file_system_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('FileSystemId') is not None:
            self.file_system_id = m.get('FileSystemId')
        return self


class ModifyFileSystemResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyFileSystemResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyFileSystemResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyFileSystemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyForwardEntryRequest(TeaModel):
    def __init__(
        self,
        external_ip: str = None,
        external_port: str = None,
        forward_entry_id: str = None,
        forward_entry_name: str = None,
        health_check_port: int = None,
        internal_ip: str = None,
        internal_port: str = None,
        ip_protocol: str = None,
    ):
        # The EIP in the DNAT entry. The public IP address is used to access the Internet.
        self.external_ip = external_ip
        # The external port or port range that is used for port forwarding.
        # 
        # *   Valid values: 1 to 65535.
        # *   To specify a port range, separate the first port and the last port with a forward slash (/), such as 10/20. The first port and the last port are included.
        # *   If you set ExternalPort to a port range, you must also set InternalPort to a port range. The number of ports in the port ranges must be the same. For example, if you set ExternalPort to 10/20, you can set InternalPort to 80/90.
        # *   The maximum port range is 1000.
        self.external_port = external_port
        # The ID of the DNAT entry.
        # 
        # This parameter is required.
        self.forward_entry_id = forward_entry_id
        # The name of the DNAT entry. The name must be 2 to 128 characters in length. It cannot start with `http://` or `https://`.
        self.forward_entry_name = forward_entry_name
        # The probe port. The port must be within the internal port range. By default, this parameter is left empty.
        self.health_check_port = health_check_port
        # The private IP address of the instance that uses the DNAT entry for Internet communication.
        self.internal_ip = internal_ip
        # The private port or port range that is used in port forwarding.
        # 
        # *   Valid values: 1 to 65535.
        # *   To specify a port range, separate the first port and the last port with a forward slash (/), such as 10/20. The first port and the last port are included.
        # *   If you set InternalPort to a port range, you must also set ExternalPort to a port range. The number of ports in the port ranges must be the same. For example, if you set ExternalPort to 10/20, you can set InternalPort to 80/90.
        # *   The maximum port range is 1000.
        self.internal_port = internal_port
        # The protocol. Valid values:
        # 
        # *   **TCP**: forwards TCP packets.
        # *   **UDP**: forwards UDP packets.
        # *   **Any** (default): forwards all packets.
        self.ip_protocol = ip_protocol

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.external_ip is not None:
            result['ExternalIp'] = self.external_ip
        if self.external_port is not None:
            result['ExternalPort'] = self.external_port
        if self.forward_entry_id is not None:
            result['ForwardEntryId'] = self.forward_entry_id
        if self.forward_entry_name is not None:
            result['ForwardEntryName'] = self.forward_entry_name
        if self.health_check_port is not None:
            result['HealthCheckPort'] = self.health_check_port
        if self.internal_ip is not None:
            result['InternalIp'] = self.internal_ip
        if self.internal_port is not None:
            result['InternalPort'] = self.internal_port
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExternalIp') is not None:
            self.external_ip = m.get('ExternalIp')
        if m.get('ExternalPort') is not None:
            self.external_port = m.get('ExternalPort')
        if m.get('ForwardEntryId') is not None:
            self.forward_entry_id = m.get('ForwardEntryId')
        if m.get('ForwardEntryName') is not None:
            self.forward_entry_name = m.get('ForwardEntryName')
        if m.get('HealthCheckPort') is not None:
            self.health_check_port = m.get('HealthCheckPort')
        if m.get('InternalIp') is not None:
            self.internal_ip = m.get('InternalIp')
        if m.get('InternalPort') is not None:
            self.internal_port = m.get('InternalPort')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        return self


class ModifyForwardEntryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyForwardEntryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyForwardEntryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyForwardEntryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyHaVipAttributeRequest(TeaModel):
    def __init__(
        self,
        ha_vip_id: str = None,
        name: str = None,
    ):
        # The ID of the HAVIP that you want to modify.
        # 
        # This parameter is required.
        self.ha_vip_id = ha_vip_id
        # The name of the HAVIP. The name must be 1 to 128 characters in length and cannot start with http:// or https://.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ha_vip_id is not None:
            result['HaVipId'] = self.ha_vip_id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HaVipId') is not None:
            self.ha_vip_id = m.get('HaVipId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ModifyHaVipAttributeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyHaVipAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyHaVipAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyHaVipAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyImageAttributeRequest(TeaModel):
    def __init__(
        self,
        image_id: str = None,
        image_name: str = None,
    ):
        # The ID of the image.
        # 
        # This parameter is required.
        self.image_id = image_id
        # The name of the image.
        # 
        # This parameter is required.
        self.image_name = image_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        return self


class ModifyImageAttributeResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        request_id: str = None,
    ):
        # The service code. 0 is returned for a successful request. An error code is returned for a failed request.
        self.code = code
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyImageAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyImageAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyImageAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyImageSharePermissionRequest(TeaModel):
    def __init__(
        self,
        add_accounts: str = None,
        image_id: str = None,
        remove_accounts: str = None,
    ):
        # The ID of the Alibaba Cloud account with which you want to share the image. You can specify multiple Alibaba Cloud IDs. Separate multiple IDs with commas (,).
        self.add_accounts = add_accounts
        # The ID of the image. You can specify only one image ID. Custom images and public images are supported.
        # 
        # This parameter is required.
        self.image_id = image_id
        # The ID of the Alibaba Cloud account from which you want to unshare the image. You can specify only one Alibaba Cloud account ID.
        self.remove_accounts = remove_accounts

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.add_accounts is not None:
            result['AddAccounts'] = self.add_accounts
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.remove_accounts is not None:
            result['RemoveAccounts'] = self.remove_accounts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddAccounts') is not None:
            self.add_accounts = m.get('AddAccounts')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('RemoveAccounts') is not None:
            self.remove_accounts = m.get('RemoveAccounts')
        return self


class ModifyImageSharePermissionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyImageSharePermissionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyImageSharePermissionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyImageSharePermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceAttributeRequest(TeaModel):
    def __init__(
        self,
        deletion_protection: bool = None,
        host_name: str = None,
        instance_id: str = None,
        instance_name: str = None,
        password: str = None,
        user_data: str = None,
    ):
        self.deletion_protection = deletion_protection
        # The hostname of the Elastic Compute Service (ECS) instance. The value can be 2 to 64 characters in length. You can use periods (.) to separate the value into multiple segments. Each segment can contain letters, digits, hyphens (-), and periods. Consecutive periods or hyphens are not allowed. The name cannot start or end with a period (.) or a hyphen (-).
        self.host_name = host_name
        # The ID of the instance for which you want to modify attributes. You can specify only one ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The name of the instance.
        # 
        # The name must be 2 to 128 characters in length. It must start with a letter but cannot start with `http://` or `https://`. The name can contain letters, digits, colons (:), underscores (_), and hyphens (-).
        self.instance_name = instance_name
        # The password of the instance.
        self.password = password
        # The user data of the instance. User data must be encoded in Base64.
        # 
        # The size of your UserData cannot exceed 16 KB. We recommend that you do not pass in confidential information such as passwords and private keys in the plaintext format. If you must pass in confidential information, we recommend that you encrypt and Base64-encode the information before you pass it in. Then you can decode and decrypt the information in the same way within the instance.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deletion_protection is not None:
            result['DeletionProtection'] = self.deletion_protection
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.password is not None:
            result['Password'] = self.password
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeletionProtection') is not None:
            self.deletion_protection = m.get('DeletionProtection')
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class ModifyInstanceAttributeResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        request_id: str = None,
    ):
        # The returned service code. 0 indicates that the request was successful.
        self.code = code
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyInstanceAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceAutoRenewAttributeRequest(TeaModel):
    def __init__(
        self,
        auto_renew: str = None,
        duration: str = None,
        instance_ids: str = None,
        owner_id: str = None,
        renewal_status: str = None,
    ):
        # Specifies whether to enable the auto-renewal feature. Valid values: **True and False**. Default value: False.
        # 
        # This parameter is required.
        self.auto_renew = auto_renew
        # The auto-renewal period of the instance. Unit: months. Valid values: 1 to 9 and 12. This parameter is required if the AutoRenew parameter is set to true.
        self.duration = duration
        # The IDs of the instances. Separate IDs with semicolons (;).
        # 
        # This parameter is required.
        self.instance_ids = instance_ids
        self.owner_id = owner_id
        # Specifies whether to renew the instance. The **RenewalStatus** parameter has a higher priority than the **AutoRenew** parameter. If you do not specify **RenewalStatus**, the **AutoRenew** parameter is used by default.
        # 
        # *   AutoRenewal: Auto-renewal is enabled for the instance.
        # *   Normal: Auto-renewal is disabled for the instance.
        # *   NotRenewal: The instance is not renewed.
        # 
        # The system no longer sends an expiration notification but sends only a renewal notification three days before the instance expires. To renew the instance, you can change the value of this parameter from NotRenewal to Normal and then manually renew the instance, or change the value of this parameter from NotRenewal to AutoRenewal.
        self.renewal_status = renewal_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.renewal_status is not None:
            result['RenewalStatus'] = self.renewal_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RenewalStatus') is not None:
            self.renewal_status = m.get('RenewalStatus')
        return self


class ModifyInstanceAutoRenewAttributeResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        request_id: str = None,
    ):
        # The returned service code. 0 indicates that the request was successful.
        self.code = code
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceAutoRenewAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyInstanceAutoRenewAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceAutoRenewAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceBootConfigurationRequest(TeaModel):
    def __init__(
        self,
        boot_set: str = None,
        boot_type: str = None,
        disk_set: str = None,
        instance_id: str = None,
    ):
        self.boot_set = boot_set
        # This parameter is required.
        self.boot_type = boot_type
        self.disk_set = disk_set
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.boot_set is not None:
            result['BootSet'] = self.boot_set
        if self.boot_type is not None:
            result['BootType'] = self.boot_type
        if self.disk_set is not None:
            result['DiskSet'] = self.disk_set
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BootSet') is not None:
            self.boot_set = m.get('BootSet')
        if m.get('BootType') is not None:
            self.boot_type = m.get('BootType')
        if m.get('DiskSet') is not None:
            self.disk_set = m.get('DiskSet')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ModifyInstanceBootConfigurationResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceBootConfigurationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyInstanceBootConfigurationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceBootConfigurationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceChargeTypeRequest(TeaModel):
    def __init__(
        self,
        auto_pay: bool = None,
        auto_renew: bool = None,
        billing_cycle: str = None,
        include_data_disks: bool = None,
        instance_charge_type: str = None,
        instance_ids: List[str] = None,
        period: str = None,
        period_unit: str = None,
    ):
        # Specifies whether to enable auto-payment when you change the billing method from pay-as-you-go to subscription. Valid values:
        # 
        # true: enables auto-payment. Make sure that your account has sufficient balance.
        # 
        # false (default): does not enable auto-payment. The order is generated but not paid.
        self.auto_pay = auto_pay
        # Specifies whether to enable auto-renewal when you change the billing method from pay-as-you-go to subscription. Valid values:
        # 
        # true: enables auto-renewal for the instance.
        # 
        # false
        self.auto_renew = auto_renew
        self.billing_cycle = billing_cycle
        # Specifies whether to change the billing method of all data disks that are created with the instance to subscription when you change the billing method of the instance from pay-as-you-go to subscription. Valid values:
        # 
        # true
        # 
        # false (default)
        self.include_data_disks = include_data_disks
        # The new billing method. Valid values:
        # 
        # PrePaid
        # 
        # PostPaid (default)
        # 
        # This parameter is required.
        self.instance_charge_type = instance_charge_type
        # The IDs of the instances.
        # 
        # This parameter is required.
        self.instance_ids = instance_ids
        # The subscription duration. This parameter is required if you set the InstanceChargeType parameter to PrePaid. Valid values:
        # 
        # If the PeriodUnit parameter is set to Day, Period can only be set to 3.
        # 
        # If PeriodUnit is Month, Period can be set to 1 to 9 or 12.
        self.period = period
        # The unit of the subscription duration. This parameter is required if you set the InstanceChargeType parameter to PrePaid. Valid values:
        # 
        # Month
        # 
        # Day
        self.period_unit = period_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_pay is not None:
            result['AutoPay'] = self.auto_pay
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.billing_cycle is not None:
            result['BillingCycle'] = self.billing_cycle
        if self.include_data_disks is not None:
            result['IncludeDataDisks'] = self.include_data_disks
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoPay') is not None:
            self.auto_pay = m.get('AutoPay')
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('BillingCycle') is not None:
            self.billing_cycle = m.get('BillingCycle')
        if m.get('IncludeDataDisks') is not None:
            self.include_data_disks = m.get('IncludeDataDisks')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        return self


class ModifyInstanceChargeTypeShrinkRequest(TeaModel):
    def __init__(
        self,
        auto_pay: bool = None,
        auto_renew: bool = None,
        billing_cycle: str = None,
        include_data_disks: bool = None,
        instance_charge_type: str = None,
        instance_ids_shrink: str = None,
        period: str = None,
        period_unit: str = None,
    ):
        # Specifies whether to enable auto-payment when you change the billing method from pay-as-you-go to subscription. Valid values:
        # 
        # true: enables auto-payment. Make sure that your account has sufficient balance.
        # 
        # false (default): does not enable auto-payment. The order is generated but not paid.
        self.auto_pay = auto_pay
        # Specifies whether to enable auto-renewal when you change the billing method from pay-as-you-go to subscription. Valid values:
        # 
        # true: enables auto-renewal for the instance.
        # 
        # false
        self.auto_renew = auto_renew
        self.billing_cycle = billing_cycle
        # Specifies whether to change the billing method of all data disks that are created with the instance to subscription when you change the billing method of the instance from pay-as-you-go to subscription. Valid values:
        # 
        # true
        # 
        # false (default)
        self.include_data_disks = include_data_disks
        # The new billing method. Valid values:
        # 
        # PrePaid
        # 
        # PostPaid (default)
        # 
        # This parameter is required.
        self.instance_charge_type = instance_charge_type
        # The IDs of the instances.
        # 
        # This parameter is required.
        self.instance_ids_shrink = instance_ids_shrink
        # The subscription duration. This parameter is required if you set the InstanceChargeType parameter to PrePaid. Valid values:
        # 
        # If the PeriodUnit parameter is set to Day, Period can only be set to 3.
        # 
        # If PeriodUnit is Month, Period can be set to 1 to 9 or 12.
        self.period = period
        # The unit of the subscription duration. This parameter is required if you set the InstanceChargeType parameter to PrePaid. Valid values:
        # 
        # Month
        # 
        # Day
        self.period_unit = period_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_pay is not None:
            result['AutoPay'] = self.auto_pay
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.billing_cycle is not None:
            result['BillingCycle'] = self.billing_cycle
        if self.include_data_disks is not None:
            result['IncludeDataDisks'] = self.include_data_disks
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_ids_shrink is not None:
            result['InstanceIds'] = self.instance_ids_shrink
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoPay') is not None:
            self.auto_pay = m.get('AutoPay')
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('BillingCycle') is not None:
            self.billing_cycle = m.get('BillingCycle')
        if m.get('IncludeDataDisks') is not None:
            self.include_data_disks = m.get('IncludeDataDisks')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceIds') is not None:
            self.instance_ids_shrink = m.get('InstanceIds')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        return self


class ModifyInstanceChargeTypeResponseBody(TeaModel):
    def __init__(
        self,
        instance_ids: List[str] = None,
        order_id: int = None,
        request_id: str = None,
    ):
        # The IDs of the instances.
        self.instance_ids = instance_ids
        # The ID of the order.
        self.order_id = order_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceChargeTypeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyInstanceChargeTypeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceChargeTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyLoadBalancerAttributeRequest(TeaModel):
    def __init__(
        self,
        load_balancer_id: str = None,
        load_balancer_name: str = None,
    ):
        # The ID of the ELB instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id
        # The name of the ELB instance. The name must be **2** to **128** characters in length.
        # 
        # >  The value cannot start with `http://` or `https://`.
        # 
        # This parameter is required.
        self.load_balancer_name = load_balancer_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.load_balancer_name is not None:
            result['LoadBalancerName'] = self.load_balancer_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('LoadBalancerName') is not None:
            self.load_balancer_name = m.get('LoadBalancerName')
        return self


class ModifyLoadBalancerAttributeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyLoadBalancerAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyLoadBalancerAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyLoadBalancerAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyNetworkAttributeRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        network_id: str = None,
        network_name: str = None,
    ):
        # The description of the network.
        # 
        # The description must be 2 to 256 characters in length. It must start with a letter but cannot start with http:// or https://.
        self.description = description
        # The ID of the network.
        # 
        # This parameter is required.
        self.network_id = network_id
        # The name of the network. The name must meet the following requirements:
        # 
        # *   The name must be 2 to 128 characters in length
        # *   It must start with a letter but cannot start with http:// or https://.
        # *   The name can contain letters, digits, colons (:), underscores (_), and hyphens (-).
        self.network_name = network_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.network_name is not None:
            result['NetworkName'] = self.network_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('NetworkName') is not None:
            self.network_name = m.get('NetworkName')
        return self


class ModifyNetworkAttributeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyNetworkAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyNetworkAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyNetworkAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyNetworkInterfaceAttributeRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        network_interface_id: str = None,
        network_interface_name: str = None,
    ):
        # The description. The description must be 1 to 256 characters in length and cannot start with http:// or https://.
        self.description = description
        # The ID of the ENI.
        # 
        # This parameter is required.
        self.network_interface_id = network_interface_id
        # The name of the ENI. The name must be 1 to 128 characters in length, The name cannot start with http:// or https://.
        self.network_interface_name = network_interface_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.network_interface_name is not None:
            result['NetworkInterfaceName'] = self.network_interface_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('NetworkInterfaceName') is not None:
            self.network_interface_name = m.get('NetworkInterfaceName')
        return self


class ModifyNetworkInterfaceAttributeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyNetworkInterfaceAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyNetworkInterfaceAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyNetworkInterfaceAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyPrepayInstanceSpecRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        instance_type: str = None,
    ):
        # The ID of the instance that you want to upgrade or downgrade.
        self.instance_id = instance_id
        # The updated configuration.
        self.instance_type = instance_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        return self


class ModifyPrepayInstanceSpecResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyPrepayInstanceSpecResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyPrepayInstanceSpecResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyPrepayInstanceSpecResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifySecurityGroupAttributeRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        security_group_id: str = None,
        security_group_name: str = None,
    ):
        # The description of the security group.
        self.description = description
        # The ID of the security group.
        # 
        # This parameter is required.
        self.security_group_id = security_group_id
        # The name of the security group. The name of a bucket must meet the following requirements:
        # 
        # *   The name must be 2 to 128 characters in length.
        # *   The name must start with a letter but cannot start with http:// or https://.
        # *   The name can contain letters, digits, colons (:), underscores (_), and hyphens (-).
        self.security_group_name = security_group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_name is not None:
            result['SecurityGroupName'] = self.security_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupName') is not None:
            self.security_group_name = m.get('SecurityGroupName')
        return self


class ModifySecurityGroupAttributeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifySecurityGroupAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifySecurityGroupAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifySecurityGroupAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifySnapshotAttributeRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        snapshot_id: str = None,
        snapshot_name: str = None,
    ):
        # The description of the snapshot. The description must be 2 to 256 characters in length. It cannot start with `http://` or `https://`.
        self.description = description
        # The ID of the snapshot.
        # 
        # This parameter is required.
        self.snapshot_id = snapshot_id
        # The name of the snapshot. The name must be 2 to 128 characters in length. It must start with a letter but cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (_), and hyphens (-).
        # 
        # The name cannot start with **auto** because snapshots whose names start with auto are recognized as automatic snapshots.
        self.snapshot_name = snapshot_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.snapshot_name is not None:
            result['SnapshotName'] = self.snapshot_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('SnapshotName') is not None:
            self.snapshot_name = m.get('SnapshotName')
        return self


class ModifySnapshotAttributeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifySnapshotAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifySnapshotAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifySnapshotAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifySnatEntryRequest(TeaModel):
    def __init__(
        self,
        eip_affinity: bool = None,
        isp_affinity: bool = None,
        snat_entry_id: str = None,
        snat_entry_name: str = None,
        snat_ip: str = None,
    ):
        # Specifies whether to enable IP affinity. Default value: true. Valid values:
        # 
        # *   **false**\
        # *   **true**\
        # 
        # >  Description After you enable IP affinity, if multiple EIPs are associated with an SNAT entry, one client uses the same EIP to for communication. If IP affinity is disabled, the client uses a random EIP for communication.
        self.eip_affinity = eip_affinity
        self.isp_affinity = isp_affinity
        # This parameter is required.
        self.snat_entry_id = snat_entry_id
        self.snat_entry_name = snat_entry_name
        # Separate multiple EIPs in the SNAT entry with commas (,).
        self.snat_ip = snat_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.eip_affinity is not None:
            result['EipAffinity'] = self.eip_affinity
        if self.isp_affinity is not None:
            result['IspAffinity'] = self.isp_affinity
        if self.snat_entry_id is not None:
            result['SnatEntryId'] = self.snat_entry_id
        if self.snat_entry_name is not None:
            result['SnatEntryName'] = self.snat_entry_name
        if self.snat_ip is not None:
            result['SnatIp'] = self.snat_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EipAffinity') is not None:
            self.eip_affinity = m.get('EipAffinity')
        if m.get('IspAffinity') is not None:
            self.isp_affinity = m.get('IspAffinity')
        if m.get('SnatEntryId') is not None:
            self.snat_entry_id = m.get('SnatEntryId')
        if m.get('SnatEntryName') is not None:
            self.snat_entry_name = m.get('SnatEntryName')
        if m.get('SnatIp') is not None:
            self.snat_ip = m.get('SnatIp')
        return self


class ModifySnatEntryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifySnatEntryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifySnatEntryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifySnatEntryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyVSwitchAttributeRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        v_switch_id: str = None,
        v_switch_name: str = None,
    ):
        # The description of the listener.
        # 
        # *   The description must be 2 to 256 characters in length.
        # *   It must start with a letter but cannot start with http:// or https://.
        self.description = description
        # The ID of the vSwitch.
        # 
        # This parameter is required.
        self.v_switch_id = v_switch_id
        # The name of the vSwitch.
        # 
        # *   The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (_), and hyphens (-).
        # *   It must start with a letter but cannot start with http:// or https://.
        self.v_switch_name = v_switch_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.v_switch_name is not None:
            result['VSwitchName'] = self.v_switch_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VSwitchName') is not None:
            self.v_switch_name = m.get('VSwitchName')
        return self


class ModifyVSwitchAttributeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyVSwitchAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyVSwitchAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyVSwitchAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MountInstanceSDGRequest(TeaModel):
    def __init__(
        self,
        instance_ids: List[str] = None,
        sdgid: str = None,
    ):
        # The IDs of the instances.
        # 
        # This parameter is required.
        self.instance_ids = instance_ids
        # The ID of the SDG.
        # 
        # This parameter is required.
        self.sdgid = sdgid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class MountInstanceSDGShrinkRequest(TeaModel):
    def __init__(
        self,
        instance_ids_shrink: str = None,
        sdgid: str = None,
    ):
        # The IDs of the instances.
        # 
        # This parameter is required.
        self.instance_ids_shrink = instance_ids_shrink
        # The ID of the SDG.
        # 
        # This parameter is required.
        self.sdgid = sdgid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids_shrink is not None:
            result['InstanceIds'] = self.instance_ids_shrink
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids_shrink = m.get('InstanceIds')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class MountInstanceSDGResponseBodyDataResultFailedItems(TeaModel):
    def __init__(
        self,
        err_message: str = None,
        instance_id: str = None,
    ):
        # The error message.
        self.err_message = err_message
        # The ID of the instance.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.err_message is not None:
            result['ErrMessage'] = self.err_message
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrMessage') is not None:
            self.err_message = m.get('ErrMessage')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class MountInstanceSDGResponseBodyDataResult(TeaModel):
    def __init__(
        self,
        failed_count: int = None,
        failed_items: List[MountInstanceSDGResponseBodyDataResultFailedItems] = None,
        success_count: int = None,
    ):
        # The number of failed tasks.
        self.failed_count = failed_count
        # Details about failed tasks.
        self.failed_items = failed_items
        # The number of successful tasks.
        self.success_count = success_count

    def validate(self):
        if self.failed_items:
            for k in self.failed_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failed_count is not None:
            result['FailedCount'] = self.failed_count
        result['FailedItems'] = []
        if self.failed_items is not None:
            for k in self.failed_items:
                result['FailedItems'].append(k.to_map() if k else None)
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailedCount') is not None:
            self.failed_count = m.get('FailedCount')
        self.failed_items = []
        if m.get('FailedItems') is not None:
            for k in m.get('FailedItems'):
                temp_model = MountInstanceSDGResponseBodyDataResultFailedItems()
                self.failed_items.append(temp_model.from_map(k))
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        return self


class MountInstanceSDGResponseBodyData(TeaModel):
    def __init__(
        self,
        message: str = None,
        result: MountInstanceSDGResponseBodyDataResult = None,
        success: bool = None,
    ):
        # The response message. Success is returned for a successful request.
        self.message = message
        # The execution result of the synchronization request.
        self.result = result
        # Indicates whether all tasks are successful. Valid values:
        # 
        # *   **true**: All tasks are successful.
        # *   **false**: Failed tasks exist.
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.result is not None:
            result['Result'] = self.result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Result') is not None:
            temp_model = MountInstanceSDGResponseBodyDataResult()
            self.result = temp_model.from_map(m['Result'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class MountInstanceSDGResponseBody(TeaModel):
    def __init__(
        self,
        data: MountInstanceSDGResponseBodyData = None,
        request_id: str = None,
    ):
        # The returned data object.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = MountInstanceSDGResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class MountInstanceSDGResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MountInstanceSDGResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MountInstanceSDGResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PreloadRegionSDGRequest(TeaModel):
    def __init__(
        self,
        destination_region_ids: List[str] = None,
        disk_type: str = None,
        namespaces: List[str] = None,
        redundant_num: int = None,
        sdgid: str = None,
    ):
        # The IDs of the destination nodes.
        # 
        # This parameter is required.
        self.destination_region_ids = destination_region_ids
        self.disk_type = disk_type
        # An array that consists of queried namespaces.
        self.namespaces = namespaces
        # The number of redundant replicas to support rapid deployment.
        # 
        # This parameter is required.
        self.redundant_num = redundant_num
        # The ID of the SDG for which data is preloaded.
        # 
        # This parameter is required.
        self.sdgid = sdgid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_region_ids is not None:
            result['DestinationRegionIds'] = self.destination_region_ids
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.namespaces is not None:
            result['Namespaces'] = self.namespaces
        if self.redundant_num is not None:
            result['RedundantNum'] = self.redundant_num
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationRegionIds') is not None:
            self.destination_region_ids = m.get('DestinationRegionIds')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('Namespaces') is not None:
            self.namespaces = m.get('Namespaces')
        if m.get('RedundantNum') is not None:
            self.redundant_num = m.get('RedundantNum')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class PreloadRegionSDGShrinkRequest(TeaModel):
    def __init__(
        self,
        destination_region_ids_shrink: str = None,
        disk_type: str = None,
        namespaces_shrink: str = None,
        redundant_num: int = None,
        sdgid: str = None,
    ):
        # The IDs of the destination nodes.
        # 
        # This parameter is required.
        self.destination_region_ids_shrink = destination_region_ids_shrink
        self.disk_type = disk_type
        # An array that consists of queried namespaces.
        self.namespaces_shrink = namespaces_shrink
        # The number of redundant replicas to support rapid deployment.
        # 
        # This parameter is required.
        self.redundant_num = redundant_num
        # The ID of the SDG for which data is preloaded.
        # 
        # This parameter is required.
        self.sdgid = sdgid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_region_ids_shrink is not None:
            result['DestinationRegionIds'] = self.destination_region_ids_shrink
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.namespaces_shrink is not None:
            result['Namespaces'] = self.namespaces_shrink
        if self.redundant_num is not None:
            result['RedundantNum'] = self.redundant_num
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationRegionIds') is not None:
            self.destination_region_ids_shrink = m.get('DestinationRegionIds')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('Namespaces') is not None:
            self.namespaces_shrink = m.get('Namespaces')
        if m.get('RedundantNum') is not None:
            self.redundant_num = m.get('RedundantNum')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class PreloadRegionSDGResponseBodyDataResultFailedItems(TeaModel):
    def __init__(
        self,
        destination_region_id: str = None,
        error_message: str = None,
    ):
        # The ID of the destination node.
        self.destination_region_id = destination_region_id
        # The error message that is returned.
        self.error_message = error_message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_region_id is not None:
            result['DestinationRegionId'] = self.destination_region_id
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationRegionId') is not None:
            self.destination_region_id = m.get('DestinationRegionId')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        return self


class PreloadRegionSDGResponseBodyDataResult(TeaModel):
    def __init__(
        self,
        failed_count: int = None,
        failed_items: List[PreloadRegionSDGResponseBodyDataResultFailedItems] = None,
        success_count: int = None,
    ):
        # The number of failed tasks.
        self.failed_count = failed_count
        # Details about the failed tasks.
        self.failed_items = failed_items
        # The number of successful tasks.
        self.success_count = success_count

    def validate(self):
        if self.failed_items:
            for k in self.failed_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failed_count is not None:
            result['FailedCount'] = self.failed_count
        result['FailedItems'] = []
        if self.failed_items is not None:
            for k in self.failed_items:
                result['FailedItems'].append(k.to_map() if k else None)
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailedCount') is not None:
            self.failed_count = m.get('FailedCount')
        self.failed_items = []
        if m.get('FailedItems') is not None:
            for k in m.get('FailedItems'):
                temp_model = PreloadRegionSDGResponseBodyDataResultFailedItems()
                self.failed_items.append(temp_model.from_map(k))
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        return self


class PreloadRegionSDGResponseBodyData(TeaModel):
    def __init__(
        self,
        message: str = None,
        result: PreloadRegionSDGResponseBodyDataResult = None,
        success: bool = None,
    ):
        # The message returned.
        self.message = message
        # The execution result of the synchronization request.
        self.result = result
        # Indicates whether all tasks are successful. Valid values:
        # 
        # *   true: All tasks are successful.
        # *   false: Failed tasks exist.
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.result is not None:
            result['Result'] = self.result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Result') is not None:
            temp_model = PreloadRegionSDGResponseBodyDataResult()
            self.result = temp_model.from_map(m['Result'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PreloadRegionSDGResponseBody(TeaModel):
    def __init__(
        self,
        data: PreloadRegionSDGResponseBodyData = None,
        request_id: str = None,
    ):
        # The returned data object.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = PreloadRegionSDGResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PreloadRegionSDGResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PreloadRegionSDGResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PreloadRegionSDGResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PrepareUploadRequest(TeaModel):
    def __init__(
        self,
        bucket_name: str = None,
        client_ip: str = None,
    ):
        # The name of the bucket.
        # 
        # This parameter is required.
        self.bucket_name = bucket_name
        # The specified IP address. This parameter is applicable to scenarios where the user IP address is inconsistent with the operation calling IP address, such as the scenario where the server obtains authorization and sends the authorization to the client.
        self.client_ip = client_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        if self.client_ip is not None:
            result['ClientIp'] = self.client_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        if m.get('ClientIp') is not None:
            self.client_ip = m.get('ClientIp')
        return self


class PrepareUploadResponseBody(TeaModel):
    def __init__(
        self,
        bucket_name: str = None,
        endpoint: str = None,
        request_id: str = None,
    ):
        # The name of the bucket. This parameter is available only when the OSS SDK is used.
        self.bucket_name = bucket_name
        # The endpoint. This parameter is available only when the OSS SDK is used.
        self.endpoint = endpoint
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PrepareUploadResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PrepareUploadResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PrepareUploadResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PushApplicationDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data: str = None,
        push_strategy: str = None,
        timeout: int = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data files that you want to push. The value must be a JSON string.
        # 
        # This parameter is required.
        self.data = data
        # The push policy in the canary release environment. The value must be a JSON string. You can specify multiple push policies. By default, all data files are pushed.
        self.push_strategy = push_strategy
        # This parameter does not take effect.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data is not None:
            result['Data'] = self.data
        if self.push_strategy is not None:
            result['PushStrategy'] = self.push_strategy
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('PushStrategy') is not None:
            self.push_strategy = m.get('PushStrategy')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class PushApplicationDataResponseBodyPushResultsPushResult(TeaModel):
    def __init__(
        self,
        name: str = None,
        result_code: int = None,
        result_descrip: str = None,
        version: str = None,
    ):
        # The name of the data file.
        self.name = name
        # The push result. The value is of the enumeration type. Valid values:
        # 
        # *   0: The push operation is successful.
        # *   100: The push operation has been performed and the file is pushed.
        # *   200: The push operation has been performed and the file is being pushed to specific file servers.
        # *   300: The push operation failed. You must trigger the push operation again. The ResultDescrip parameter indicates the error description.
        self.result_code = result_code
        # The description of the push status.
        self.result_descrip = result_descrip
        # The version number of the data file.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.result_code is not None:
            result['ResultCode'] = self.result_code
        if self.result_descrip is not None:
            result['ResultDescrip'] = self.result_descrip
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ResultCode') is not None:
            self.result_code = m.get('ResultCode')
        if m.get('ResultDescrip') is not None:
            self.result_descrip = m.get('ResultDescrip')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class PushApplicationDataResponseBodyPushResults(TeaModel):
    def __init__(
        self,
        push_result: List[PushApplicationDataResponseBodyPushResultsPushResult] = None,
    ):
        self.push_result = push_result

    def validate(self):
        if self.push_result:
            for k in self.push_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PushResult'] = []
        if self.push_result is not None:
            for k in self.push_result:
                result['PushResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.push_result = []
        if m.get('PushResult') is not None:
            for k in m.get('PushResult'):
                temp_model = PushApplicationDataResponseBodyPushResultsPushResult()
                self.push_result.append(temp_model.from_map(k))
        return self


class PushApplicationDataResponseBody(TeaModel):
    def __init__(
        self,
        push_results: PushApplicationDataResponseBodyPushResults = None,
        request_id: str = None,
    ):
        # The push results of data files.
        self.push_results = push_results
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.push_results:
            self.push_results.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.push_results is not None:
            result['PushResults'] = self.push_results.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PushResults') is not None:
            temp_model = PushApplicationDataResponseBodyPushResults()
            self.push_results = temp_model.from_map(m['PushResults'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PushApplicationDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PushApplicationDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PushApplicationDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutBucketRequest(TeaModel):
    def __init__(
        self,
        bucket_acl: str = None,
        bucket_name: str = None,
        comment: str = None,
        dispatch_scope: str = None,
        ens_region_id: str = None,
        logical_bucket_type: str = None,
    ):
        self.bucket_acl = bucket_acl
        # This parameter is required.
        self.bucket_name = bucket_name
        self.comment = comment
        self.dispatch_scope = dispatch_scope
        self.ens_region_id = ens_region_id
        self.logical_bucket_type = logical_bucket_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_acl is not None:
            result['BucketAcl'] = self.bucket_acl
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.dispatch_scope is not None:
            result['DispatchScope'] = self.dispatch_scope
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.logical_bucket_type is not None:
            result['LogicalBucketType'] = self.logical_bucket_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketAcl') is not None:
            self.bucket_acl = m.get('BucketAcl')
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('DispatchScope') is not None:
            self.dispatch_scope = m.get('DispatchScope')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('LogicalBucketType') is not None:
            self.logical_bucket_type = m.get('LogicalBucketType')
        return self


class PutBucketResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PutBucketResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PutBucketResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutBucketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutBucketAclRequest(TeaModel):
    def __init__(
        self,
        bucket_acl: str = None,
        bucket_name: str = None,
    ):
        # The access control list (ACL) of the bucket.
        # 
        # *   **public-read-write**\
        # *   **public-read**\
        # *   **private** (default)
        # 
        # This parameter is required.
        self.bucket_acl = bucket_acl
        # The name of the bucket.
        # 
        # This parameter is required.
        self.bucket_name = bucket_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_acl is not None:
            result['BucketAcl'] = self.bucket_acl
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketAcl') is not None:
            self.bucket_acl = m.get('BucketAcl')
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        return self


class PutBucketAclResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PutBucketAclResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PutBucketAclResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutBucketAclResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutBucketLifecycleRequest(TeaModel):
    def __init__(
        self,
        allow_same_action_overlap: str = None,
        bucket_name: str = None,
        created_before_date: str = None,
        expiration_days: int = None,
        prefix: str = None,
        rule_id: str = None,
        status: str = None,
    ):
        # Specifies whether to allow overlapped prefixes. Valid values:
        # 
        # *   **true**\
        # *   **false** (default)
        self.allow_same_action_overlap = allow_same_action_overlap
        # The name of the bucket.
        # 
        # This parameter is required.
        self.bucket_name = bucket_name
        # The expiration time. EOS executes a lifecycle rule for objects that were last updated before the expiration time.
        # 
        # Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # >  ExpirationDays and CreateBeforeDate are mutually exclusive.
        self.created_before_date = created_before_date
        # The number of days from when the objects were last modified to when the lifecycle rule takes effect. The value must be a positive integer that is greater than 0.
        # 
        # >  ExpirationDays and CreateBeforeDate are mutually exclusive.
        self.expiration_days = expiration_days
        # The prefix of a object name. The prefix must be unique.
        # 
        # *   If you specify a prefix, the rule applies only to objects in the bucket that match the prefix.
        # *   If you do not specify a prefix, the rule applies to all objects in the bucket.
        self.prefix = prefix
        # The unique ID of the rule. The ID of a lifecycle rule can be up to 255 bytes in length.
        # 
        # *   You do not need to configure this parameter when you create a rule. The system automatically generates a unique ID.
        # *   When you update a rule, you need to specify this parameter. Make sure that the rule specified by RuleId exists. Otherwise, an error occurs.
        self.rule_id = rule_id
        # The status of the rule. Valid values:
        # 
        # *   **Enabled**\
        # *   **Disabled**\
        # 
        # This parameter is required.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_same_action_overlap is not None:
            result['AllowSameActionOverlap'] = self.allow_same_action_overlap
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        if self.created_before_date is not None:
            result['CreatedBeforeDate'] = self.created_before_date
        if self.expiration_days is not None:
            result['ExpirationDays'] = self.expiration_days
        if self.prefix is not None:
            result['Prefix'] = self.prefix
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllowSameActionOverlap') is not None:
            self.allow_same_action_overlap = m.get('AllowSameActionOverlap')
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        if m.get('CreatedBeforeDate') is not None:
            self.created_before_date = m.get('CreatedBeforeDate')
        if m.get('ExpirationDays') is not None:
            self.expiration_days = m.get('ExpirationDays')
        if m.get('Prefix') is not None:
            self.prefix = m.get('Prefix')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class PutBucketLifecycleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        rule_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The ID of the rule.
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class PutBucketLifecycleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PutBucketLifecycleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutBucketLifecycleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReInitDiskRequest(TeaModel):
    def __init__(
        self,
        disk_id: str = None,
        image_id: str = None,
    ):
        # The ID of the disk to be initialized. You can initialize only one disk at a time.
        # 
        # This parameter is required.
        self.disk_id = disk_id
        # The ID of the image to use to create the instance.
        # 
        # This parameter is required.
        self.image_id = image_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        return self


class ReInitDiskResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        request_id: str = None,
    ):
        # The returned service code. A value of 0 indicates that the operation was successful.
        self.code = code
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ReInitDiskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReInitDiskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReInitDiskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RebootAICInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        instance_ids: List[str] = None,
        server_id: str = None,
    ):
        # The ID of the AIC instance.
        self.instance_id = instance_id
        # The IDs of the AIC instance groups.
        self.instance_ids = instance_ids
        # The ID of the server.
        self.server_id = server_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.server_id is not None:
            result['ServerId'] = self.server_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('ServerId') is not None:
            self.server_id = m.get('ServerId')
        return self


class RebootAICInstanceShrinkRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        instance_ids_shrink: str = None,
        server_id: str = None,
    ):
        # The ID of the AIC instance.
        self.instance_id = instance_id
        # The IDs of the AIC instance groups.
        self.instance_ids_shrink = instance_ids_shrink
        # The ID of the server.
        self.server_id = server_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_ids_shrink is not None:
            result['InstanceIds'] = self.instance_ids_shrink
        if self.server_id is not None:
            result['ServerId'] = self.server_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceIds') is not None:
            self.instance_ids_shrink = m.get('InstanceIds')
        if m.get('ServerId') is not None:
            self.server_id = m.get('ServerId')
        return self


class RebootAICInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RebootAICInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RebootAICInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RebootAICInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RebootARMServerInstanceRequest(TeaModel):
    def __init__(
        self,
        server_id: str = None,
    ):
        # The ID of the server.
        self.server_id = server_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.server_id is not None:
            result['ServerId'] = self.server_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ServerId') is not None:
            self.server_id = m.get('ServerId')
        return self


class RebootARMServerInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RebootARMServerInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RebootARMServerInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RebootARMServerInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RebootInstanceRequest(TeaModel):
    def __init__(
        self,
        force_stop: str = None,
        instance_id: str = None,
    ):
        # Specifies whether to forcefully stop the instance before you restart it.
        # 
        # *   **true**\
        # *   **false** (default)
        self.force_stop = force_stop
        # The ID of the instance that you want to reboot. You can specify only one instance ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.force_stop is not None:
            result['ForceStop'] = self.force_stop
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ForceStop') is not None:
            self.force_stop = m.get('ForceStop')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class RebootInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        request_id: str = None,
    ):
        # The returned service code. 0 indicates that the request was successful.
        self.code = code
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RebootInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RebootInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RebootInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RebootInstancesRequest(TeaModel):
    def __init__(
        self,
        instance_ids: List[str] = None,
    ):
        self.instance_ids = instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        return self


class RebootInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        instance_ids_shrink: str = None,
    ):
        self.instance_ids_shrink = instance_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids_shrink is not None:
            result['InstanceIds'] = self.instance_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids_shrink = m.get('InstanceIds')
        return self


class RebootInstancesResponseBody(TeaModel):
    def __init__(
        self,
        instance_responses: List[InstanceOperateResponse] = None,
        request_id: str = None,
    ):
        self.instance_responses = instance_responses
        self.request_id = request_id

    def validate(self):
        if self.instance_responses:
            for k in self.instance_responses:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceResponses'] = []
        if self.instance_responses is not None:
            for k in self.instance_responses:
                result['InstanceResponses'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_responses = []
        if m.get('InstanceResponses') is not None:
            for k in m.get('InstanceResponses'):
                temp_model = InstanceOperateResponse()
                self.instance_responses.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RebootInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RebootInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RebootInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RecoverAICInstanceRequest(TeaModel):
    def __init__(
        self,
        server_id: str = None,
    ):
        # The ID of the server.
        # 
        # This parameter is required.
        self.server_id = server_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.server_id is not None:
            result['ServerId'] = self.server_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ServerId') is not None:
            self.server_id = m.get('ServerId')
        return self


class RecoverAICInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RecoverAICInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RecoverAICInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RecoverAICInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReinitInstanceRequest(TeaModel):
    def __init__(
        self,
        image_id: str = None,
        instance_id: str = None,
        password: str = None,
    ):
        # The ID of the image file that is used to reset the instance.
        # 
        # This parameter is required.
        self.image_id = image_id
        # The ID of the instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The password of the instance.
        # 
        # It must be 8 to 30 characters in length. It must include at least three of the following characters types: uppercase letters, lowercase letters, digits, and special characters. The following special character are supported: `()\\"~! @#$%^&*-_+={}[]:;\\"<>,.?/`
        self.password = password

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.password is not None:
            result['Password'] = self.password
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        return self


class ReinitInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ReinitInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReinitInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReinitInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReinitInstancesRequest(TeaModel):
    def __init__(
        self,
        image_id: str = None,
        instance_ids: List[str] = None,
        password: str = None,
    ):
        self.image_id = image_id
        self.instance_ids = instance_ids
        self.password = password

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.password is not None:
            result['Password'] = self.password
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        return self


class ReinitInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        image_id: str = None,
        instance_ids_shrink: str = None,
        password: str = None,
    ):
        self.image_id = image_id
        self.instance_ids_shrink = instance_ids_shrink
        self.password = password

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.instance_ids_shrink is not None:
            result['InstanceIds'] = self.instance_ids_shrink
        if self.password is not None:
            result['Password'] = self.password
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InstanceIds') is not None:
            self.instance_ids_shrink = m.get('InstanceIds')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        return self


class ReinitInstancesResponseBody(TeaModel):
    def __init__(
        self,
        instance_responses: List[InstanceOperateResponse] = None,
        request_id: str = None,
    ):
        self.instance_responses = instance_responses
        self.request_id = request_id

    def validate(self):
        if self.instance_responses:
            for k in self.instance_responses:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceResponses'] = []
        if self.instance_responses is not None:
            for k in self.instance_responses:
                result['InstanceResponses'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_responses = []
        if m.get('InstanceResponses') is not None:
            for k in m.get('InstanceResponses'):
                temp_model = InstanceOperateResponse()
                self.instance_responses.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ReinitInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReinitInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReinitInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReleaseAICInstanceRequest(TeaModel):
    def __init__(
        self,
        server_id: str = None,
    ):
        # The ID of the server.
        # 
        # This parameter is required.
        self.server_id = server_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.server_id is not None:
            result['ServerId'] = self.server_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ServerId') is not None:
            self.server_id = m.get('ServerId')
        return self


class ReleaseAICInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ReleaseAICInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReleaseAICInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReleaseAICInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReleaseARMServerInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # The ID of the server.
        # 
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ReleaseARMServerInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ReleaseARMServerInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReleaseARMServerInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReleaseARMServerInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReleaseInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # The ID of the EIP.
        # 
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ReleaseInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        resource_type: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The type of the resource.
        # 
        # Valid values:
        # 
        # *   instance
        # *   eip
        # *   disk
        # *   network
        # *   natgateway
        # *   vswitch
        self.resource_type = resource_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class ReleaseInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReleaseInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReleaseInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReleasePostPaidInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # The ID of the instance to be deleted. You can specify only one instance ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ReleasePostPaidInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ReleasePostPaidInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReleasePostPaidInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReleasePostPaidInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReleasePrePaidInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # The ID of the instance to be deleted. You can specify only one instance ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ReleasePrePaidInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ReleasePrePaidInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReleasePrePaidInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReleasePrePaidInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveBackendServersRequestBackendServers(TeaModel):
    def __init__(
        self,
        ip: str = None,
        port: int = None,
        server_id: str = None,
        type: str = None,
        weight: int = None,
    ):
        # The IP address of the backend server.
        self.ip = ip
        # The backend port that is used by the Edge Load Balancer (ELB) instance.
        self.port = port
        # The instance ID of the backend server.
        # 
        # This parameter is required.
        self.server_id = server_id
        # The type of backend server. Valid values:
        # 
        # *   **ens**: an Edge Node Service (ENS) instance.
        # *   **eni**: an Elastic Network Interface (ENI).
        self.type = type
        # The weight of the backend server.
        self.weight = weight

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.port is not None:
            result['Port'] = self.port
        if self.server_id is not None:
            result['ServerId'] = self.server_id
        if self.type is not None:
            result['Type'] = self.type
        if self.weight is not None:
            result['Weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('ServerId') is not None:
            self.server_id = m.get('ServerId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        return self


class RemoveBackendServersRequest(TeaModel):
    def __init__(
        self,
        backend_servers: List[RemoveBackendServersRequestBackendServers] = None,
        load_balancer_id: str = None,
    ):
        # The list of backend servers that you want to remove. You can remove up to 20 backend servers at a time.
        # 
        # This parameter is required.
        self.backend_servers = backend_servers
        # The ID of the Edge Load Balancer (ELB) instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id

    def validate(self):
        if self.backend_servers:
            for k in self.backend_servers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BackendServers'] = []
        if self.backend_servers is not None:
            for k in self.backend_servers:
                result['BackendServers'].append(k.to_map() if k else None)
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.backend_servers = []
        if m.get('BackendServers') is not None:
            for k in m.get('BackendServers'):
                temp_model = RemoveBackendServersRequestBackendServers()
                self.backend_servers.append(temp_model.from_map(k))
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        return self


class RemoveBackendServersShrinkRequest(TeaModel):
    def __init__(
        self,
        backend_servers_shrink: str = None,
        load_balancer_id: str = None,
    ):
        # The list of backend servers that you want to remove. You can remove up to 20 backend servers at a time.
        # 
        # This parameter is required.
        self.backend_servers_shrink = backend_servers_shrink
        # The ID of the Edge Load Balancer (ELB) instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backend_servers_shrink is not None:
            result['BackendServers'] = self.backend_servers_shrink
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackendServers') is not None:
            self.backend_servers_shrink = m.get('BackendServers')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        return self


class RemoveBackendServersResponseBodyBackendServersBackendServer(TeaModel):
    def __init__(
        self,
        ip: str = None,
        port: int = None,
        server_id: str = None,
        type: str = None,
        weight: int = None,
    ):
        # The IP address of the backend server.
        self.ip = ip
        # The backend port that is used by the ELB instance.
        self.port = port
        # The instance ID of the backend server.
        self.server_id = server_id
        # The type of the backend server. Valid values:
        # 
        # *   **ens**: an ENS instance.
        # *   **eni**: an ENI.
        self.type = type
        # The weight of the backend server.
        # 
        # >  The value 0 indicates that requests are not forwarded to the backend server.
        self.weight = weight

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.port is not None:
            result['Port'] = self.port
        if self.server_id is not None:
            result['ServerId'] = self.server_id
        if self.type is not None:
            result['Type'] = self.type
        if self.weight is not None:
            result['Weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('ServerId') is not None:
            self.server_id = m.get('ServerId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        return self


class RemoveBackendServersResponseBodyBackendServers(TeaModel):
    def __init__(
        self,
        backend_server: List[RemoveBackendServersResponseBodyBackendServersBackendServer] = None,
    ):
        self.backend_server = backend_server

    def validate(self):
        if self.backend_server:
            for k in self.backend_server:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BackendServer'] = []
        if self.backend_server is not None:
            for k in self.backend_server:
                result['BackendServer'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.backend_server = []
        if m.get('BackendServer') is not None:
            for k in m.get('BackendServer'):
                temp_model = RemoveBackendServersResponseBodyBackendServersBackendServer()
                self.backend_server.append(temp_model.from_map(k))
        return self


class RemoveBackendServersResponseBody(TeaModel):
    def __init__(
        self,
        backend_servers: RemoveBackendServersResponseBodyBackendServers = None,
        request_id: str = None,
    ):
        # The list of backend servers that you want to add to the SLB instance.
        self.backend_servers = backend_servers
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.backend_servers:
            self.backend_servers.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backend_servers is not None:
            result['BackendServers'] = self.backend_servers.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackendServers') is not None:
            temp_model = RemoveBackendServersResponseBodyBackendServers()
            self.backend_servers = temp_model.from_map(m['BackendServers'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveBackendServersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveBackendServersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveBackendServersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveInstanceSDGRequest(TeaModel):
    def __init__(
        self,
        instance_ids: List[str] = None,
    ):
        # The IDs of the instances. The value is a JSON array that consists of up to 100 IDs.
        # 
        # This parameter is required.
        self.instance_ids = instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        return self


class RemoveInstanceSDGShrinkRequest(TeaModel):
    def __init__(
        self,
        instance_ids_shrink: str = None,
    ):
        # The IDs of the instances. The value is a JSON array that consists of up to 100 IDs.
        # 
        # This parameter is required.
        self.instance_ids_shrink = instance_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids_shrink is not None:
            result['InstanceIds'] = self.instance_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids_shrink = m.get('InstanceIds')
        return self


class RemoveInstanceSDGResponseBodyDataResultFailedItems(TeaModel):
    def __init__(
        self,
        err_message: str = None,
        instance_id: str = None,
    ):
        # The error message that is returned.
        self.err_message = err_message
        # The ID of the instance.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.err_message is not None:
            result['ErrMessage'] = self.err_message
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrMessage') is not None:
            self.err_message = m.get('ErrMessage')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class RemoveInstanceSDGResponseBodyDataResult(TeaModel):
    def __init__(
        self,
        failed_count: int = None,
        failed_items: List[RemoveInstanceSDGResponseBodyDataResultFailedItems] = None,
        success_count: int = None,
    ):
        # The number of failed tasks.
        self.failed_count = failed_count
        # Details about the failed tasks.
        self.failed_items = failed_items
        # The number of successful tasks.
        self.success_count = success_count

    def validate(self):
        if self.failed_items:
            for k in self.failed_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failed_count is not None:
            result['FailedCount'] = self.failed_count
        result['FailedItems'] = []
        if self.failed_items is not None:
            for k in self.failed_items:
                result['FailedItems'].append(k.to_map() if k else None)
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailedCount') is not None:
            self.failed_count = m.get('FailedCount')
        self.failed_items = []
        if m.get('FailedItems') is not None:
            for k in m.get('FailedItems'):
                temp_model = RemoveInstanceSDGResponseBodyDataResultFailedItems()
                self.failed_items.append(temp_model.from_map(k))
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        return self


class RemoveInstanceSDGResponseBodyData(TeaModel):
    def __init__(
        self,
        message: str = None,
        result: RemoveInstanceSDGResponseBodyDataResult = None,
        success: bool = None,
    ):
        # The response message. Success is returned for a successful request.
        self.message = message
        # The execution result of the synchronization request.
        self.result = result
        # Indicates whether all tasks are successful. Valid values:
        # 
        # *   **true**: All tasks are successful.
        # *   **false**: Failed tasks exist.
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.result is not None:
            result['Result'] = self.result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Result') is not None:
            temp_model = RemoveInstanceSDGResponseBodyDataResult()
            self.result = temp_model.from_map(m['Result'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RemoveInstanceSDGResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: RemoveInstanceSDGResponseBodyData = None,
        request_id: str = None,
    ):
        # The returned service code. 0 indicates that the request was successful.
        self.code = code
        # The returned data object.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = RemoveInstanceSDGResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveInstanceSDGResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveInstanceSDGResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveInstanceSDGResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemovePublicIpsFromEpnInstanceRequest(TeaModel):
    def __init__(
        self,
        epninstance_id: str = None,
        instance_infos: str = None,
    ):
        # The ID of the EPN instance.
        # 
        # This parameter is required.
        self.epninstance_id = epninstance_id
        # The information about the public IP addresses that you want to delete.
        # 
        # This parameter is required.
        self.instance_infos = instance_infos

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.epninstance_id is not None:
            result['EPNInstanceId'] = self.epninstance_id
        if self.instance_infos is not None:
            result['InstanceInfos'] = self.instance_infos
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EPNInstanceId') is not None:
            self.epninstance_id = m.get('EPNInstanceId')
        if m.get('InstanceInfos') is not None:
            self.instance_infos = m.get('InstanceInfos')
        return self


class RemovePublicIpsFromEpnInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemovePublicIpsFromEpnInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemovePublicIpsFromEpnInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemovePublicIpsFromEpnInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveSDGRequest(TeaModel):
    def __init__(
        self,
        instance_ids: List[str] = None,
    ):
        # IDs of Android in Container (AIC) instances.
        # 
        # This parameter is required.
        self.instance_ids = instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        return self


class RemoveSDGShrinkRequest(TeaModel):
    def __init__(
        self,
        instance_ids_shrink: str = None,
    ):
        # IDs of Android in Container (AIC) instances.
        # 
        # This parameter is required.
        self.instance_ids_shrink = instance_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids_shrink is not None:
            result['InstanceIds'] = self.instance_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids_shrink = m.get('InstanceIds')
        return self


class RemoveSDGResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveSDGResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveSDGResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveSDGResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveSDGsRequest(TeaModel):
    def __init__(
        self,
        instance_ids: List[str] = None,
        sdg_ids: List[str] = None,
    ):
        # This parameter is required.
        self.instance_ids = instance_ids
        self.sdg_ids = sdg_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.sdg_ids is not None:
            result['SdgIds'] = self.sdg_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('SdgIds') is not None:
            self.sdg_ids = m.get('SdgIds')
        return self


class RemoveSDGsShrinkRequest(TeaModel):
    def __init__(
        self,
        instance_ids_shrink: str = None,
        sdg_ids_shrink: str = None,
    ):
        # This parameter is required.
        self.instance_ids_shrink = instance_ids_shrink
        self.sdg_ids_shrink = sdg_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids_shrink is not None:
            result['InstanceIds'] = self.instance_ids_shrink
        if self.sdg_ids_shrink is not None:
            result['SdgIds'] = self.sdg_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids_shrink = m.get('InstanceIds')
        if m.get('SdgIds') is not None:
            self.sdg_ids_shrink = m.get('SdgIds')
        return self


class RemoveSDGsResponseBodyDataResultFailedItems(TeaModel):
    def __init__(
        self,
        err_message: str = None,
        instance_id: str = None,
    ):
        self.err_message = err_message
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.err_message is not None:
            result['ErrMessage'] = self.err_message
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrMessage') is not None:
            self.err_message = m.get('ErrMessage')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class RemoveSDGsResponseBodyDataResult(TeaModel):
    def __init__(
        self,
        failed_count: int = None,
        failed_items: List[RemoveSDGsResponseBodyDataResultFailedItems] = None,
        success_count: int = None,
    ):
        self.failed_count = failed_count
        self.failed_items = failed_items
        self.success_count = success_count

    def validate(self):
        if self.failed_items:
            for k in self.failed_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failed_count is not None:
            result['FailedCount'] = self.failed_count
        result['FailedItems'] = []
        if self.failed_items is not None:
            for k in self.failed_items:
                result['FailedItems'].append(k.to_map() if k else None)
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailedCount') is not None:
            self.failed_count = m.get('FailedCount')
        self.failed_items = []
        if m.get('FailedItems') is not None:
            for k in m.get('FailedItems'):
                temp_model = RemoveSDGsResponseBodyDataResultFailedItems()
                self.failed_items.append(temp_model.from_map(k))
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        return self


class RemoveSDGsResponseBodyData(TeaModel):
    def __init__(
        self,
        message: str = None,
        result: RemoveSDGsResponseBodyDataResult = None,
        success: bool = None,
    ):
        self.message = message
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.result is not None:
            result['Result'] = self.result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Result') is not None:
            temp_model = RemoveSDGsResponseBodyDataResult()
            self.result = temp_model.from_map(m['Result'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RemoveSDGsResponseBody(TeaModel):
    def __init__(
        self,
        data: RemoveSDGsResponseBodyData = None,
        request_id: str = None,
    ):
        self.data = data
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = RemoveSDGsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveSDGsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveSDGsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveSDGsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveVSwitchesFromEpnInstanceRequest(TeaModel):
    def __init__(
        self,
        epninstance_id: str = None,
        v_switches_info: str = None,
    ):
        # The ID of theEPN instance.
        # 
        # This parameter is required.
        self.epninstance_id = epninstance_id
        # The internal networking information that you want to delete.
        # 
        # This parameter is required.
        self.v_switches_info = v_switches_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.epninstance_id is not None:
            result['EPNInstanceId'] = self.epninstance_id
        if self.v_switches_info is not None:
            result['VSwitchesInfo'] = self.v_switches_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EPNInstanceId') is not None:
            self.epninstance_id = m.get('EPNInstanceId')
        if m.get('VSwitchesInfo') is not None:
            self.v_switches_info = m.get('VSwitchesInfo')
        return self


class RemoveVSwitchesFromEpnInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveVSwitchesFromEpnInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveVSwitchesFromEpnInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveVSwitchesFromEpnInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RenewARMServerInstanceRequest(TeaModel):
    def __init__(
        self,
        auto_renew: bool = None,
        instance_id: str = None,
        period: int = None,
        period_unit: str = None,
    ):
        # Specifies whether to enable auto-renewal for the premium bandwidth plan. Valid values:
        # 
        # *   **true**.
        # *   **false** (default).
        self.auto_renew = auto_renew
        # The ID of the instance that you want to renew.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The renewal period. By default, instances are renewed on a monthly basis. Valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, and 12.
        # 
        # This parameter is required.
        self.period = period
        # The unit of the renewal period. Valid values:
        # 
        # *   Month (default)
        # *   Year
        # 
        # This parameter is required.
        self.period_unit = period_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        return self


class RenewARMServerInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RenewARMServerInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RenewARMServerInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RenewARMServerInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RenewInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        period: int = None,
    ):
        # The ID of the instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The renewal duration of the subscription instance.
        # 
        # This parameter is required.
        self.period = period

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.period is not None:
            result['Period'] = self.period
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        return self


class RenewInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use the ID to troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RenewInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RenewInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RenewInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RescaleApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        rescale_level: str = None,
        rescale_type: str = None,
        resource_selector: str = None,
        timeout: int = None,
        to_app_version: str = None,
    ):
        # The ID of the application. You can query the application ID by calling the ListApplications operation.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The level of resource scaling. The value is of the enumeration type. Valid values:
        # 
        # *   AreaIspCode (default): scales resources based on the Internet service provider (ISP).
        # *   RegionId: scales resources based on the edge node.
        # *   InstanceId: scales resources based on the instance ID. Resource scale-out specifies resource hosting and scale-in specifies resource release.
        # 
        # Default value: AreaIspCode.
        self.rescale_level = rescale_level
        # The scaling operation. The value must be of the enumerated data type. Valid values:
        # 
        # *   Add: adds new resources.
        # *   Del: releases resources.
        # 
        # This parameter is required.
        self.rescale_type = rescale_type
        # The required resources. The value must be a JSON string.
        # 
        # This parameter is required.
        self.resource_selector = resource_selector
        # The timeout period for asynchronous scaling. Unit: seconds. Default value: 300.
        self.timeout = timeout
        # The version number of the application deployment package. By default, the stable version number is used. This parameter takes effect only when you perform resource scale-out.
        self.to_app_version = to_app_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.rescale_level is not None:
            result['RescaleLevel'] = self.rescale_level
        if self.rescale_type is not None:
            result['RescaleType'] = self.rescale_type
        if self.resource_selector is not None:
            result['ResourceSelector'] = self.resource_selector
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.to_app_version is not None:
            result['ToAppVersion'] = self.to_app_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('RescaleLevel') is not None:
            self.rescale_level = m.get('RescaleLevel')
        if m.get('RescaleType') is not None:
            self.rescale_type = m.get('RescaleType')
        if m.get('ResourceSelector') is not None:
            self.resource_selector = m.get('ResourceSelector')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('ToAppVersion') is not None:
            self.to_app_version = m.get('ToAppVersion')
        return self


class RescaleApplicationResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RescaleApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RescaleApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RescaleApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RescaleDeviceServiceRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        image_id: str = None,
        ip_type: int = None,
        rescale_level: str = None,
        rescale_type: str = None,
        resource_info: str = None,
        resource_selector: str = None,
        resource_spec: str = None,
        service_id: str = None,
        timeout: int = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The ID of the image.
        self.image_id = image_id
        # The type of the network. The value must be of the enumerated data type. Valid values:
        # 
        # *   **1** (default): Internet
        # *   **2**: internal network
        self.ip_type = ip_type
        # The region level of the scale-out. Set the value to RegionId. RegionId specifies that resource scale-out is performed based on the ID of the edge node.
        # 
        # This parameter is required.
        self.rescale_level = rescale_level
        # The scaling operation. Set the value to Add to add new resources.
        # 
        # This parameter is required.
        self.rescale_type = rescale_type
        # The information about the resource specification template. The value must be a JSON string.
        self.resource_info = resource_info
        # The required resources. The value must be a JSON string.
        # 
        # This parameter is required.
        self.resource_selector = resource_selector
        # The resource specification.
        self.resource_spec = resource_spec
        # The ID of the service.
        self.service_id = service_id
        # The timeout period for asynchronous scale-out. Unit: seconds. Default value: 300.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.ip_type is not None:
            result['IpType'] = self.ip_type
        if self.rescale_level is not None:
            result['RescaleLevel'] = self.rescale_level
        if self.rescale_type is not None:
            result['RescaleType'] = self.rescale_type
        if self.resource_info is not None:
            result['ResourceInfo'] = self.resource_info
        if self.resource_selector is not None:
            result['ResourceSelector'] = self.resource_selector
        if self.resource_spec is not None:
            result['ResourceSpec'] = self.resource_spec
        if self.service_id is not None:
            result['ServiceId'] = self.service_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('IpType') is not None:
            self.ip_type = m.get('IpType')
        if m.get('RescaleLevel') is not None:
            self.rescale_level = m.get('RescaleLevel')
        if m.get('RescaleType') is not None:
            self.rescale_type = m.get('RescaleType')
        if m.get('ResourceInfo') is not None:
            self.resource_info = m.get('ResourceInfo')
        if m.get('ResourceSelector') is not None:
            self.resource_selector = m.get('ResourceSelector')
        if m.get('ResourceSpec') is not None:
            self.resource_spec = m.get('ResourceSpec')
        if m.get('ServiceId') is not None:
            self.service_id = m.get('ServiceId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class RescaleDeviceServiceResponseBodyResourceDetailInfos(TeaModel):
    def __init__(
        self,
        id: str = None,
        ip: str = None,
        isp: str = None,
        mac: str = None,
        region_id: str = None,
        server: str = None,
        status: str = None,
        type: str = None,
    ):
        # The ID of the device.
        self.id = id
        # The IP address of the device.
        self.ip = ip
        # The Internet service provider (ISP) to which the device belongs.
        self.isp = isp
        # The media access control (MAC) address of the device.
        self.mac = mac
        # The ID of the edge node to which the device belongs.
        self.region_id = region_id
        # The name of the server on which the device is deployed.
        self.server = server
        # The status of the device.
        self.status = status
        # The type of the instance.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['ID'] = self.id
        if self.ip is not None:
            result['IP'] = self.ip
        if self.isp is not None:
            result['ISP'] = self.isp
        if self.mac is not None:
            result['Mac'] = self.mac
        if self.region_id is not None:
            result['RegionID'] = self.region_id
        if self.server is not None:
            result['Server'] = self.server
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ID') is not None:
            self.id = m.get('ID')
        if m.get('IP') is not None:
            self.ip = m.get('IP')
        if m.get('ISP') is not None:
            self.isp = m.get('ISP')
        if m.get('Mac') is not None:
            self.mac = m.get('Mac')
        if m.get('RegionID') is not None:
            self.region_id = m.get('RegionID')
        if m.get('Server') is not None:
            self.server = m.get('Server')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class RescaleDeviceServiceResponseBody(TeaModel):
    def __init__(
        self,
        device_ids: List[str] = None,
        order_id: str = None,
        request_id: str = None,
        resource_detail_infos: List[RescaleDeviceServiceResponseBodyResourceDetailInfos] = None,
    ):
        # The IDs of the devices.
        self.device_ids = device_ids
        # The ID of the order.
        self.order_id = order_id
        # The ID of the request.
        self.request_id = request_id
        # The key properties of the device.
        self.resource_detail_infos = resource_detail_infos

    def validate(self):
        if self.resource_detail_infos:
            for k in self.resource_detail_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_ids is not None:
            result['DeviceIds'] = self.device_ids
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['ResourceDetailInfos'] = []
        if self.resource_detail_infos is not None:
            for k in self.resource_detail_infos:
                result['ResourceDetailInfos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceIds') is not None:
            self.device_ids = m.get('DeviceIds')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.resource_detail_infos = []
        if m.get('ResourceDetailInfos') is not None:
            for k in m.get('ResourceDetailInfos'):
                temp_model = RescaleDeviceServiceResponseBodyResourceDetailInfos()
                self.resource_detail_infos.append(temp_model.from_map(k))
        return self


class RescaleDeviceServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RescaleDeviceServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RescaleDeviceServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResetAICInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        server_id: str = None,
    ):
        # The ID of the AIC instance.
        self.instance_id = instance_id
        # The ID of the server.
        self.server_id = server_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.server_id is not None:
            result['ServerId'] = self.server_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ServerId') is not None:
            self.server_id = m.get('ServerId')
        return self


class ResetAICInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ResetAICInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResetAICInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResetAICInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResetDiskRequest(TeaModel):
    def __init__(
        self,
        disk_id: str = None,
        snapshot_id: str = None,
    ):
        # The ID of the disk that you want to roll back.
        # 
        # This parameter is required.
        self.disk_id = disk_id
        # The ID of the snapshot that you want to use to roll back the disk.
        # 
        # This parameter is required.
        self.snapshot_id = snapshot_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        return self


class ResetDiskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ResetDiskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResetDiskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResetDiskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResizeDiskRequest(TeaModel):
    def __init__(
        self,
        disk_id: str = None,
        new_size: str = None,
    ):
        # The ID of the disk that you want to resize.
        # 
        # This parameter is required.
        self.disk_id = disk_id
        # The size of the disk that you want to resize. Unit: GiB.
        # 
        # This parameter is required.
        self.new_size = new_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.new_size is not None:
            result['NewSize'] = self.new_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('NewSize') is not None:
            self.new_size = m.get('NewSize')
        return self


class ResizeDiskResponseBody(TeaModel):
    def __init__(
        self,
        order_id: str = None,
        request_id: str = None,
    ):
        # The order ID.
        self.order_id = order_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ResizeDiskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResizeDiskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResizeDiskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RevokeSecurityGroupRequest(TeaModel):
    def __init__(
        self,
        ip_protocol: str = None,
        policy: str = None,
        port_range: str = None,
        priority: int = None,
        security_group_id: str = None,
        source_cidr_ip: str = None,
        source_port_range: str = None,
    ):
        # The transport layer protocol. The value of this parameter is case-sensitive. Valid values:
        # 
        # *   tcp
        # *   udp
        # *   icmp
        # *   gre
        # *   all: all protocols.
        # 
        # This parameter is required.
        self.ip_protocol = ip_protocol
        # The authorization policy. Valid values:
        # 
        # *   accept: allows access. This is the default value.
        # *   drop: denies access and does not return responses.
        self.policy = policy
        # The range of destination ports that correspond to the transport layer protocol for the security group rule. Valid values:
        # 
        # *   When the IpProtocol parameter is set to tcp or udp, the port number range is **1** to **65535**. The start port number and the end port number are separated by a forward slash (/). Correct example: **1/200**. Incorrect example: **200/1**.
        # *   When the IpProtocol parameter is set to icmp, the port number range is **-1/-1**, which indicates all ports.
        # *   When the IpProtocol parameter is set to gre, the port number range is **-1/-1**, which indicates all ports.
        # *   When the IpProtocol parameter is set to all, the port number range is **-1/-1**, which indicates all ports.
        # 
        # This parameter is required.
        self.port_range = port_range
        # The priority of the security group rule. Valid values: **1** to **100**. Default value: **1**.
        self.priority = priority
        # The ID of the security group.
        # 
        # This parameter is required.
        self.security_group_id = security_group_id
        # The source CIDR block. CIDR blocks and IPv4 addresses are supported. Default value: 0.0.XX.XX/0.
        # 
        # This parameter is required.
        self.source_cidr_ip = source_cidr_ip
        # The range of source ports that correspond to the transport layer protocol for the security group rule. Valid values:
        # 
        # *   When the IpProtocol parameter is set to tcp or udp, the port number range is **1** to **65535**. The start port number and the end port number are separated by a forward slash (/). Correct example: **1/200**. Incorrect example: **200/1**.
        # *   When the IpProtocol parameter is set to icmp, the port number range is **-1/-1**, which indicates all ports.
        # *   When the IpProtocol parameter is set to gre, the port number range is **-1/-1**, which indicates all ports.
        # *   When the IpProtocol parameter is set to all, the port number range is **-1/-1**, which indicates all ports.
        self.source_port_range = source_port_range

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.source_cidr_ip is not None:
            result['SourceCidrIp'] = self.source_cidr_ip
        if self.source_port_range is not None:
            result['SourcePortRange'] = self.source_port_range
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SourceCidrIp') is not None:
            self.source_cidr_ip = m.get('SourceCidrIp')
        if m.get('SourcePortRange') is not None:
            self.source_port_range = m.get('SourcePortRange')
        return self


class RevokeSecurityGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RevokeSecurityGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RevokeSecurityGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RevokeSecurityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RevokeSecurityGroupEgressRequest(TeaModel):
    def __init__(
        self,
        dest_cidr_ip: str = None,
        ip_protocol: str = None,
        policy: str = None,
        port_range: str = None,
        priority: int = None,
        security_group_id: str = None,
        source_port_range: str = None,
    ):
        # The destination IP addresses. CIDR blocks and IPv4 addresses are supported.
        # 
        # By default, this parameter is empty.
        # 
        # This parameter is required.
        self.dest_cidr_ip = dest_cidr_ip
        # The transport layer protocol. The value of this parameter is case-sensitive. Valid values:
        # 
        # *   tcp
        # *   udp
        # *   icmp
        # *   gre
        # *   all: All protocols are supported.
        # 
        # This parameter is required.
        self.ip_protocol = ip_protocol
        # The action of the security group rule. Valid values:
        # 
        # *   **accept**: allows access.
        # *   **drop**: denies access and returns no responses.
        # 
        # Default value: **accept**.
        self.policy = policy
        # The range of destination ports that correspond to the transport layer protocol for the security group rule. Valid values:
        # 
        # *   If you set the IpProtocol parameter to tcp or udp, the port number ranges from **1** to **65535**. The start port number and the end port number are separated by a forward slash (/). Correct example: **1/200**. Incorrect example: **200/1**.
        # *   When the IpProtocol parameter is set to icmp, the port number range is **-1/-1**, which indicates all ports.
        # *   When the IpProtocol parameter is set to gre, the port number range is **-1/-1**, which indicates all ports.
        # *   When the IpProtocol parameter is set to all, the port number range is **-1/-1**, which indicates all ports.
        # 
        # This parameter is required.
        self.port_range = port_range
        # The priority of the security group rule. Valid values: **1** to **100**. A smaller value indicates a higher priority.
        # 
        # Default value: **1**.
        self.priority = priority
        # The ID of the security group.
        # 
        # This parameter is required.
        self.security_group_id = security_group_id
        # The range of port numbers that correspond to the transport layer protocol for the source security group. Valid values:
        # 
        # *   If you set the IpProtocol parameter to tcp or udp, the port number ranges from **1** to **65535**. The start port number and the end port number are separated by a forward slash (/). Correct example: **1/200**. Incorrect example: **200/1**.
        # *   When the IpProtocol parameter is set to icmp, the port number range is **-1/-1**, which indicates all ports.
        # *   When the IpProtocol parameter is set to gre, the port number range is **-1/-1**, which indicates all ports.
        # *   When the IpProtocol parameter is set to all, the port number range is **-1/-1**, which indicates all ports.
        self.source_port_range = source_port_range

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dest_cidr_ip is not None:
            result['DestCidrIp'] = self.dest_cidr_ip
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.source_port_range is not None:
            result['SourcePortRange'] = self.source_port_range
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestCidrIp') is not None:
            self.dest_cidr_ip = m.get('DestCidrIp')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SourcePortRange') is not None:
            self.source_port_range = m.get('SourcePortRange')
        return self


class RevokeSecurityGroupEgressResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RevokeSecurityGroupEgressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RevokeSecurityGroupEgressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RevokeSecurityGroupEgressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RollbackApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        from_app_version: str = None,
        timeout: int = None,
        to_app_version: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The current version number.
        # 
        # This parameter is required.
        self.from_app_version = from_app_version
        # The timeout period of the asynchronous rollback operation. Unit: seconds. Default value: 300.
        self.timeout = timeout
        # The target version number. By default, the system automatically rolls back the container version to the previous version.
        self.to_app_version = to_app_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.from_app_version is not None:
            result['FromAppVersion'] = self.from_app_version
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.to_app_version is not None:
            result['ToAppVersion'] = self.to_app_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('FromAppVersion') is not None:
            self.from_app_version = m.get('FromAppVersion')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('ToAppVersion') is not None:
            self.to_app_version = m.get('ToAppVersion')
        return self


class RollbackApplicationResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RollbackApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RollbackApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RollbackApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunInstancesRequestDataDisk(TeaModel):
    def __init__(
        self,
        category: str = None,
        encrypted: bool = None,
        kmskey_id: str = None,
        size: int = None,
    ):
        # The category of the disk. Valid values:
        # 
        # *   **cloud_efficiency**: ultra disk.
        # *   **cloud_ssd**: all-flash disk.
        # *   **local_hdd**: local HDD.
        # *   **local_ssd**: local SSD.
        self.category = category
        # Specifies whether to encrypt the disk. Valid values:
        # 
        # *   true.
        # *   false (default).
        self.encrypted = encrypted
        # The ID of the Key Management Service (KMS) key that is used for the disk. Valid values:
        # 
        # *   true.
        # *   false (default).
        # 
        # >  If you set the Encrypted parameter to true, the default service key is used when the KMSKeyId parameter is empty.
        self.kmskey_id = kmskey_id
        # The size of a data disk. Unit: GiB.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.kmskey_id is not None:
            result['KMSKeyId'] = self.kmskey_id
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('KMSKeyId') is not None:
            self.kmskey_id = m.get('KMSKeyId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class RunInstancesRequestSystemDisk(TeaModel):
    def __init__(
        self,
        category: str = None,
        size: int = None,
    ):
        # The category of the system disk.
        self.category = category
        # The size of the system disk. Unit: GiB.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class RunInstancesRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class RunInstancesRequest(TeaModel):
    def __init__(
        self,
        amount: int = None,
        auto_release_time: str = None,
        auto_renew: bool = None,
        auto_use_coupon: str = None,
        billing_cycle: str = None,
        carrier: str = None,
        data_disk: List[RunInstancesRequestDataDisk] = None,
        deletion_protection: bool = None,
        ens_region_id: str = None,
        host_name: str = None,
        image_id: str = None,
        instance_charge_strategy: str = None,
        instance_charge_type: str = None,
        instance_name: str = None,
        instance_type: str = None,
        internet_charge_type: str = None,
        internet_max_bandwidth_out: int = None,
        ip_type: str = None,
        ipv_6address_count: int = None,
        key_pair_name: str = None,
        net_district_code: str = None,
        net_work_id: str = None,
        password: str = None,
        password_inherit: bool = None,
        period: int = None,
        period_unit: str = None,
        private_ip_address: str = None,
        public_ip_identification: bool = None,
        schedule_area_level: str = None,
        scheduling_price_strategy: str = None,
        scheduling_strategy: str = None,
        security_id: str = None,
        spot_duration: int = None,
        spot_strategy: str = None,
        system_disk: RunInstancesRequestSystemDisk = None,
        tag: List[RunInstancesRequestTag] = None,
        unique_suffix: bool = None,
        user_data: str = None,
        v_switch_id: str = None,
    ):
        # The number of instances that you want to create. Valid values: 1 to 100.
        # 
        # This parameter is required.
        self.amount = amount
        # The time when to automatically release the pay-as-you-go instance. Specify the time in the [ISO 8601](https://help.aliyun.com/document_detail/25696.html) standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time must be in Coordinated Universal Time (UTC).
        # 
        # *   If the value of `ss` is not `00`, the start time is automatically rounded down to the nearest minute based on the value of `mm`.
        # *   The specified time must be at least one hour later than the current time.
        # 
        # Use the UTC time format: yyyy-MM-ddTHH:mmZ
        self.auto_release_time = auto_release_time
        # Specifies whether to enable auto-renewal for the premium bandwidth plan. Valid values:
        # 
        # *   **true**.
        # *   **false** (default).
        # 
        # >  This parameter is not available when InstanceChargeType is set to PostPaid.
        self.auto_renew = auto_renew
        # Specifies whether to use coupons. Default value: true.
        self.auto_use_coupon = auto_use_coupon
        # The billing cycle of computing resources of the instance. Only pay-as-you-go instances are supported. Valid values:
        # 
        # *   **Day**.
        # *   **Month**.
        self.billing_cycle = billing_cycle
        # The Internet service provider (ISP).
        # 
        # >  This parameter required if ScheduleAreaLevel is set to Region.\\
        # If you set ScheduleAreaLevel to Region, a node has multiple ISPs, and you do not specify an ISP, then the create instance uses the ISP of the node. If the node has two ISPs, such as China Mobile and China Unicom, the created instance has two ISPs.\\
        # You can call the DescribeRegionIsps operation to query ISPs of the edge node.[](~~2637461~~)
        self.carrier = carrier
        # The specifications of data disks.
        self.data_disk = data_disk
        self.deletion_protection = deletion_protection
        # The ID of the node.
        # 
        # >  This parameter is required if ScheduleAreaLevel is set to Region and is not available if ScheduleAreaLevel is set to other values.
        self.ens_region_id = ens_region_id
        # The name of the host.
        self.host_name = host_name
        # The ID of the image. For ARM PCB-based server instances, leave this parameter empty. For other instances, this parameter is required.
        self.image_id = image_id
        # The billing policy of the instance. Valid values:
        # 
        # *   **instance**: Bills are generated based on instances.
        # *   If you do not specify this parameter, bills are generated based on users.
        self.instance_charge_strategy = instance_charge_strategy
        # The billing method of the instance. Valid values:
        # 
        # *   **PrePaid**: subscription.
        # *   **PostPaid:** pay-as-you-go.
        # 
        # This parameter is required.
        self.instance_charge_type = instance_charge_type
        # The name of the instance. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (_), periods (.), and hyphens (-).
        # 
        # The default value of this parameter is the value of the InstanceId parameter.
        self.instance_name = instance_name
        # The instance type.
        # 
        # This parameter is required.
        self.instance_type = instance_type
        # The bandwidth billing method. Valid values:
        # 
        # *   **BandwidthByDay**: pay by daily peak bandwidth
        # *   **95BandwidthByMonth**: pay by monthly 95th percentile bandwidth
        # 
        # >  This parameter is required if you purchase an ENS instance for the first time. The value that you specified is used as the default value for subsequent purchases.
        self.internet_charge_type = internet_charge_type
        # The maximum public bandwidth. If the value of this parameter is greater than 0, a public IP address is assigned to the instance.
        # 
        # This parameter is required.
        self.internet_max_bandwidth_out = internet_max_bandwidth_out
        # The type of the IP address. Valid values:
        # 
        # *   **ipv4** (default).
        # *   **ipv6**.
        # *   **ipv4Andipv6** (single stack).
        # *   **ipv4Withipv6** (dual stack).
        self.ip_type = ip_type
        self.ipv_6address_count = ipv_6address_count
        # The name of the key pair.
        # 
        # >  You need to specify at least one of **Password**, **KeyPairName**, and **PasswordInherit**.
        self.key_pair_name = key_pair_name
        # The code of the region.
        # 
        # >  This parameter is not available if ScheduleAreaLevel is set to Region and is required if ScheduleAreaLevel is set to other values.
        self.net_district_code = net_district_code
        # The ID of the network.
        # 
        # >  This parameter is available only if ScheduleAreaLevel is set to Region and cannot be configured if ScheduleAreaLevel is set to other values. Otherwise, an error occurs.
        self.net_work_id = net_work_id
        # The password that is used to connect to the instance.
        # 
        # >  You need to specify at least one of **Password**, **KeyPairName**, and **PasswordInherit**.
        self.password = password
        # Specifies whether to use the preset password of the image. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # 
        # >  You need to specify at least one of **Password**, **KeyPairName**, and **PasswordInherit**.
        self.password_inherit = password_inherit
        # The unit of the subscription period.
        # 
        # *   If **PeriodUnit** is set to **Day**, **Period** can only be set to **3**.
        # *   If **PeriodUnit** is **Month**, **Period** can be set to **1 to 9** or **12**.
        self.period = period
        # The unit of the subscription period. Valid values:
        # 
        # *   **Month** (default).
        # *   **Day**.
        self.period_unit = period_unit
        # The private IP address.
        # 
        # >  This parameter is available only if ScheduleAreaLevel is set to Region and cannot be configured if ScheduleAreaLevel is set to other values. Otherwise, an error occurs. If you specify a private IP address, the number of instances must be 1. The private IP address takes effect only when the private IP address and the vSwitch ID are not empty.
        self.private_ip_address = private_ip_address
        # Specifies whether to enable public IP address identification. Valid values: true and false. Default value: false.
        self.public_ip_identification = public_ip_identification
        # The scheduling level. This parameter specifies area-level scheduling or node-level scheduling. Valid values:
        # 
        # *   **Big**: greater area
        # *   **Middle**: province
        # *   **Small**: city
        # *   **Region**: node
        # 
        # This parameter is required.
        self.schedule_area_level = schedule_area_level
        # The scheduling price policy. Valid values:
        # 
        # *   **PriceHighPriority**: The high price prevails.
        # *   **PriceLowPriority**: The low price prevails.
        self.scheduling_price_strategy = scheduling_price_strategy
        # The scheduling policy of the taint. Valid values:
        # 
        # *   **Concentrate**\
        # *   **Disperse**\
        # 
        # >  If ScheduleAreaLevel is set to Region, set this parameter to **Concentrate**. If ScheduleAreaLevel is set to other values, set this parameter to Concentrate or Disperse based on your business requirements.
        self.scheduling_strategy = scheduling_strategy
        # The ID of security group.
        self.security_id = security_id
        # The protection period of the preemptible instance. Unit: hours. Default value: 1. Valid values:
        # 
        # *   1: After a preemptible instance is created, Alibaba Cloud ensures that the instance is not automatically released within 1 hour. After the 1-hour protection period ends, the system compares the bid price with the market price and checks the resource inventory to determine whether to retain or release the instance.
        # *   0: After a preemptible instance is created, Alibaba Cloud does not ensure that the instance runs for 1 hour. The system compares the bid price with the market price and checks the resource inventory to determine whether to retain or release the instance.
        # 
        # Alibaba Cloud sends an ECS system event to notify you 5 minutes before the instance is released. Preemptible instances are billed by second. We recommend that you specify an appropriate protection period based on your business requirements.
        self.spot_duration = spot_duration
        # The bidding policy for the pay-as-you-go instance. This parameter is valid only when the `InstanceChargeType` parameter is set to `PostPaid`. Valid values:
        # 
        # *   NoSpot: The elastic container instances are pay-as-you-go instances.
        # *   SpotAsPriceGo: The instance is a preemptible instance for which the market price at the time of purchase is automatically used as the bidding price.
        # 
        # Default value: NoSpot.
        self.spot_strategy = spot_strategy
        # The specification of the system disk.
        self.system_disk = system_disk
        # The tags.
        self.tag = tag
        # Specifies whether to append sequential suffixes to the hostname specified by the **HostName** parameter and to the instance name specified by the **InstanceName** parameter. The sequential suffixes range from 001 to 999.
        self.unique_suffix = unique_suffix
        # The custom data. The maximum data size is 16 KB. You can specify **UserData**. **UserData** must be Base64-encoded.
        self.user_data = user_data
        # The ID of the vSwitch.
        # 
        # >  This parameter is available only if ScheduleAreaLevel is set to Region and cannot be configured if ScheduleAreaLevel is set to other values. Otherwise, an error occurs.
        self.v_switch_id = v_switch_id

    def validate(self):
        if self.data_disk:
            for k in self.data_disk:
                if k:
                    k.validate()
        if self.system_disk:
            self.system_disk.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amount is not None:
            result['Amount'] = self.amount
        if self.auto_release_time is not None:
            result['AutoReleaseTime'] = self.auto_release_time
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.auto_use_coupon is not None:
            result['AutoUseCoupon'] = self.auto_use_coupon
        if self.billing_cycle is not None:
            result['BillingCycle'] = self.billing_cycle
        if self.carrier is not None:
            result['Carrier'] = self.carrier
        result['DataDisk'] = []
        if self.data_disk is not None:
            for k in self.data_disk:
                result['DataDisk'].append(k.to_map() if k else None)
        if self.deletion_protection is not None:
            result['DeletionProtection'] = self.deletion_protection
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.instance_charge_strategy is not None:
            result['InstanceChargeStrategy'] = self.instance_charge_strategy
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.internet_max_bandwidth_out is not None:
            result['InternetMaxBandwidthOut'] = self.internet_max_bandwidth_out
        if self.ip_type is not None:
            result['IpType'] = self.ip_type
        if self.ipv_6address_count is not None:
            result['Ipv6AddressCount'] = self.ipv_6address_count
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.net_district_code is not None:
            result['NetDistrictCode'] = self.net_district_code
        if self.net_work_id is not None:
            result['NetWorkId'] = self.net_work_id
        if self.password is not None:
            result['Password'] = self.password
        if self.password_inherit is not None:
            result['PasswordInherit'] = self.password_inherit
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        if self.public_ip_identification is not None:
            result['PublicIpIdentification'] = self.public_ip_identification
        if self.schedule_area_level is not None:
            result['ScheduleAreaLevel'] = self.schedule_area_level
        if self.scheduling_price_strategy is not None:
            result['SchedulingPriceStrategy'] = self.scheduling_price_strategy
        if self.scheduling_strategy is not None:
            result['SchedulingStrategy'] = self.scheduling_strategy
        if self.security_id is not None:
            result['SecurityId'] = self.security_id
        if self.spot_duration is not None:
            result['SpotDuration'] = self.spot_duration
        if self.spot_strategy is not None:
            result['SpotStrategy'] = self.spot_strategy
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.unique_suffix is not None:
            result['UniqueSuffix'] = self.unique_suffix
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Amount') is not None:
            self.amount = m.get('Amount')
        if m.get('AutoReleaseTime') is not None:
            self.auto_release_time = m.get('AutoReleaseTime')
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('AutoUseCoupon') is not None:
            self.auto_use_coupon = m.get('AutoUseCoupon')
        if m.get('BillingCycle') is not None:
            self.billing_cycle = m.get('BillingCycle')
        if m.get('Carrier') is not None:
            self.carrier = m.get('Carrier')
        self.data_disk = []
        if m.get('DataDisk') is not None:
            for k in m.get('DataDisk'):
                temp_model = RunInstancesRequestDataDisk()
                self.data_disk.append(temp_model.from_map(k))
        if m.get('DeletionProtection') is not None:
            self.deletion_protection = m.get('DeletionProtection')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InstanceChargeStrategy') is not None:
            self.instance_charge_strategy = m.get('InstanceChargeStrategy')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('InternetMaxBandwidthOut') is not None:
            self.internet_max_bandwidth_out = m.get('InternetMaxBandwidthOut')
        if m.get('IpType') is not None:
            self.ip_type = m.get('IpType')
        if m.get('Ipv6AddressCount') is not None:
            self.ipv_6address_count = m.get('Ipv6AddressCount')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('NetDistrictCode') is not None:
            self.net_district_code = m.get('NetDistrictCode')
        if m.get('NetWorkId') is not None:
            self.net_work_id = m.get('NetWorkId')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('PasswordInherit') is not None:
            self.password_inherit = m.get('PasswordInherit')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        if m.get('PublicIpIdentification') is not None:
            self.public_ip_identification = m.get('PublicIpIdentification')
        if m.get('ScheduleAreaLevel') is not None:
            self.schedule_area_level = m.get('ScheduleAreaLevel')
        if m.get('SchedulingPriceStrategy') is not None:
            self.scheduling_price_strategy = m.get('SchedulingPriceStrategy')
        if m.get('SchedulingStrategy') is not None:
            self.scheduling_strategy = m.get('SchedulingStrategy')
        if m.get('SecurityId') is not None:
            self.security_id = m.get('SecurityId')
        if m.get('SpotDuration') is not None:
            self.spot_duration = m.get('SpotDuration')
        if m.get('SpotStrategy') is not None:
            self.spot_strategy = m.get('SpotStrategy')
        if m.get('SystemDisk') is not None:
            temp_model = RunInstancesRequestSystemDisk()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = RunInstancesRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('UniqueSuffix') is not None:
            self.unique_suffix = m.get('UniqueSuffix')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class RunInstancesShrinkRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class RunInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        amount: int = None,
        auto_release_time: str = None,
        auto_renew: bool = None,
        auto_use_coupon: str = None,
        billing_cycle: str = None,
        carrier: str = None,
        data_disk_shrink: str = None,
        deletion_protection: bool = None,
        ens_region_id: str = None,
        host_name: str = None,
        image_id: str = None,
        instance_charge_strategy: str = None,
        instance_charge_type: str = None,
        instance_name: str = None,
        instance_type: str = None,
        internet_charge_type: str = None,
        internet_max_bandwidth_out: int = None,
        ip_type: str = None,
        ipv_6address_count: int = None,
        key_pair_name: str = None,
        net_district_code: str = None,
        net_work_id: str = None,
        password: str = None,
        password_inherit: bool = None,
        period: int = None,
        period_unit: str = None,
        private_ip_address: str = None,
        public_ip_identification: bool = None,
        schedule_area_level: str = None,
        scheduling_price_strategy: str = None,
        scheduling_strategy: str = None,
        security_id: str = None,
        spot_duration: int = None,
        spot_strategy: str = None,
        system_disk_shrink: str = None,
        tag: List[RunInstancesShrinkRequestTag] = None,
        unique_suffix: bool = None,
        user_data: str = None,
        v_switch_id: str = None,
    ):
        # The number of instances that you want to create. Valid values: 1 to 100.
        # 
        # This parameter is required.
        self.amount = amount
        # The time when to automatically release the pay-as-you-go instance. Specify the time in the [ISO 8601](https://help.aliyun.com/document_detail/25696.html) standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time must be in Coordinated Universal Time (UTC).
        # 
        # *   If the value of `ss` is not `00`, the start time is automatically rounded down to the nearest minute based on the value of `mm`.
        # *   The specified time must be at least one hour later than the current time.
        # 
        # Use the UTC time format: yyyy-MM-ddTHH:mmZ
        self.auto_release_time = auto_release_time
        # Specifies whether to enable auto-renewal for the premium bandwidth plan. Valid values:
        # 
        # *   **true**.
        # *   **false** (default).
        # 
        # >  This parameter is not available when InstanceChargeType is set to PostPaid.
        self.auto_renew = auto_renew
        # Specifies whether to use coupons. Default value: true.
        self.auto_use_coupon = auto_use_coupon
        # The billing cycle of computing resources of the instance. Only pay-as-you-go instances are supported. Valid values:
        # 
        # *   **Day**.
        # *   **Month**.
        self.billing_cycle = billing_cycle
        # The Internet service provider (ISP).
        # 
        # >  This parameter required if ScheduleAreaLevel is set to Region.\\
        # If you set ScheduleAreaLevel to Region, a node has multiple ISPs, and you do not specify an ISP, then the create instance uses the ISP of the node. If the node has two ISPs, such as China Mobile and China Unicom, the created instance has two ISPs.\\
        # You can call the DescribeRegionIsps operation to query ISPs of the edge node.[](~~2637461~~)
        self.carrier = carrier
        # The specifications of data disks.
        self.data_disk_shrink = data_disk_shrink
        self.deletion_protection = deletion_protection
        # The ID of the node.
        # 
        # >  This parameter is required if ScheduleAreaLevel is set to Region and is not available if ScheduleAreaLevel is set to other values.
        self.ens_region_id = ens_region_id
        # The name of the host.
        self.host_name = host_name
        # The ID of the image. For ARM PCB-based server instances, leave this parameter empty. For other instances, this parameter is required.
        self.image_id = image_id
        # The billing policy of the instance. Valid values:
        # 
        # *   **instance**: Bills are generated based on instances.
        # *   If you do not specify this parameter, bills are generated based on users.
        self.instance_charge_strategy = instance_charge_strategy
        # The billing method of the instance. Valid values:
        # 
        # *   **PrePaid**: subscription.
        # *   **PostPaid:** pay-as-you-go.
        # 
        # This parameter is required.
        self.instance_charge_type = instance_charge_type
        # The name of the instance. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (_), periods (.), and hyphens (-).
        # 
        # The default value of this parameter is the value of the InstanceId parameter.
        self.instance_name = instance_name
        # The instance type.
        # 
        # This parameter is required.
        self.instance_type = instance_type
        # The bandwidth billing method. Valid values:
        # 
        # *   **BandwidthByDay**: pay by daily peak bandwidth
        # *   **95BandwidthByMonth**: pay by monthly 95th percentile bandwidth
        # 
        # >  This parameter is required if you purchase an ENS instance for the first time. The value that you specified is used as the default value for subsequent purchases.
        self.internet_charge_type = internet_charge_type
        # The maximum public bandwidth. If the value of this parameter is greater than 0, a public IP address is assigned to the instance.
        # 
        # This parameter is required.
        self.internet_max_bandwidth_out = internet_max_bandwidth_out
        # The type of the IP address. Valid values:
        # 
        # *   **ipv4** (default).
        # *   **ipv6**.
        # *   **ipv4Andipv6** (single stack).
        # *   **ipv4Withipv6** (dual stack).
        self.ip_type = ip_type
        self.ipv_6address_count = ipv_6address_count
        # The name of the key pair.
        # 
        # >  You need to specify at least one of **Password**, **KeyPairName**, and **PasswordInherit**.
        self.key_pair_name = key_pair_name
        # The code of the region.
        # 
        # >  This parameter is not available if ScheduleAreaLevel is set to Region and is required if ScheduleAreaLevel is set to other values.
        self.net_district_code = net_district_code
        # The ID of the network.
        # 
        # >  This parameter is available only if ScheduleAreaLevel is set to Region and cannot be configured if ScheduleAreaLevel is set to other values. Otherwise, an error occurs.
        self.net_work_id = net_work_id
        # The password that is used to connect to the instance.
        # 
        # >  You need to specify at least one of **Password**, **KeyPairName**, and **PasswordInherit**.
        self.password = password
        # Specifies whether to use the preset password of the image. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # 
        # >  You need to specify at least one of **Password**, **KeyPairName**, and **PasswordInherit**.
        self.password_inherit = password_inherit
        # The unit of the subscription period.
        # 
        # *   If **PeriodUnit** is set to **Day**, **Period** can only be set to **3**.
        # *   If **PeriodUnit** is **Month**, **Period** can be set to **1 to 9** or **12**.
        self.period = period
        # The unit of the subscription period. Valid values:
        # 
        # *   **Month** (default).
        # *   **Day**.
        self.period_unit = period_unit
        # The private IP address.
        # 
        # >  This parameter is available only if ScheduleAreaLevel is set to Region and cannot be configured if ScheduleAreaLevel is set to other values. Otherwise, an error occurs. If you specify a private IP address, the number of instances must be 1. The private IP address takes effect only when the private IP address and the vSwitch ID are not empty.
        self.private_ip_address = private_ip_address
        # Specifies whether to enable public IP address identification. Valid values: true and false. Default value: false.
        self.public_ip_identification = public_ip_identification
        # The scheduling level. This parameter specifies area-level scheduling or node-level scheduling. Valid values:
        # 
        # *   **Big**: greater area
        # *   **Middle**: province
        # *   **Small**: city
        # *   **Region**: node
        # 
        # This parameter is required.
        self.schedule_area_level = schedule_area_level
        # The scheduling price policy. Valid values:
        # 
        # *   **PriceHighPriority**: The high price prevails.
        # *   **PriceLowPriority**: The low price prevails.
        self.scheduling_price_strategy = scheduling_price_strategy
        # The scheduling policy of the taint. Valid values:
        # 
        # *   **Concentrate**\
        # *   **Disperse**\
        # 
        # >  If ScheduleAreaLevel is set to Region, set this parameter to **Concentrate**. If ScheduleAreaLevel is set to other values, set this parameter to Concentrate or Disperse based on your business requirements.
        self.scheduling_strategy = scheduling_strategy
        # The ID of security group.
        self.security_id = security_id
        # The protection period of the preemptible instance. Unit: hours. Default value: 1. Valid values:
        # 
        # *   1: After a preemptible instance is created, Alibaba Cloud ensures that the instance is not automatically released within 1 hour. After the 1-hour protection period ends, the system compares the bid price with the market price and checks the resource inventory to determine whether to retain or release the instance.
        # *   0: After a preemptible instance is created, Alibaba Cloud does not ensure that the instance runs for 1 hour. The system compares the bid price with the market price and checks the resource inventory to determine whether to retain or release the instance.
        # 
        # Alibaba Cloud sends an ECS system event to notify you 5 minutes before the instance is released. Preemptible instances are billed by second. We recommend that you specify an appropriate protection period based on your business requirements.
        self.spot_duration = spot_duration
        # The bidding policy for the pay-as-you-go instance. This parameter is valid only when the `InstanceChargeType` parameter is set to `PostPaid`. Valid values:
        # 
        # *   NoSpot: The elastic container instances are pay-as-you-go instances.
        # *   SpotAsPriceGo: The instance is a preemptible instance for which the market price at the time of purchase is automatically used as the bidding price.
        # 
        # Default value: NoSpot.
        self.spot_strategy = spot_strategy
        # The specification of the system disk.
        self.system_disk_shrink = system_disk_shrink
        # The tags.
        self.tag = tag
        # Specifies whether to append sequential suffixes to the hostname specified by the **HostName** parameter and to the instance name specified by the **InstanceName** parameter. The sequential suffixes range from 001 to 999.
        self.unique_suffix = unique_suffix
        # The custom data. The maximum data size is 16 KB. You can specify **UserData**. **UserData** must be Base64-encoded.
        self.user_data = user_data
        # The ID of the vSwitch.
        # 
        # >  This parameter is available only if ScheduleAreaLevel is set to Region and cannot be configured if ScheduleAreaLevel is set to other values. Otherwise, an error occurs.
        self.v_switch_id = v_switch_id

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amount is not None:
            result['Amount'] = self.amount
        if self.auto_release_time is not None:
            result['AutoReleaseTime'] = self.auto_release_time
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.auto_use_coupon is not None:
            result['AutoUseCoupon'] = self.auto_use_coupon
        if self.billing_cycle is not None:
            result['BillingCycle'] = self.billing_cycle
        if self.carrier is not None:
            result['Carrier'] = self.carrier
        if self.data_disk_shrink is not None:
            result['DataDisk'] = self.data_disk_shrink
        if self.deletion_protection is not None:
            result['DeletionProtection'] = self.deletion_protection
        if self.ens_region_id is not None:
            result['EnsRegionId'] = self.ens_region_id
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.instance_charge_strategy is not None:
            result['InstanceChargeStrategy'] = self.instance_charge_strategy
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.internet_max_bandwidth_out is not None:
            result['InternetMaxBandwidthOut'] = self.internet_max_bandwidth_out
        if self.ip_type is not None:
            result['IpType'] = self.ip_type
        if self.ipv_6address_count is not None:
            result['Ipv6AddressCount'] = self.ipv_6address_count
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.net_district_code is not None:
            result['NetDistrictCode'] = self.net_district_code
        if self.net_work_id is not None:
            result['NetWorkId'] = self.net_work_id
        if self.password is not None:
            result['Password'] = self.password
        if self.password_inherit is not None:
            result['PasswordInherit'] = self.password_inherit
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        if self.public_ip_identification is not None:
            result['PublicIpIdentification'] = self.public_ip_identification
        if self.schedule_area_level is not None:
            result['ScheduleAreaLevel'] = self.schedule_area_level
        if self.scheduling_price_strategy is not None:
            result['SchedulingPriceStrategy'] = self.scheduling_price_strategy
        if self.scheduling_strategy is not None:
            result['SchedulingStrategy'] = self.scheduling_strategy
        if self.security_id is not None:
            result['SecurityId'] = self.security_id
        if self.spot_duration is not None:
            result['SpotDuration'] = self.spot_duration
        if self.spot_strategy is not None:
            result['SpotStrategy'] = self.spot_strategy
        if self.system_disk_shrink is not None:
            result['SystemDisk'] = self.system_disk_shrink
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.unique_suffix is not None:
            result['UniqueSuffix'] = self.unique_suffix
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Amount') is not None:
            self.amount = m.get('Amount')
        if m.get('AutoReleaseTime') is not None:
            self.auto_release_time = m.get('AutoReleaseTime')
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('AutoUseCoupon') is not None:
            self.auto_use_coupon = m.get('AutoUseCoupon')
        if m.get('BillingCycle') is not None:
            self.billing_cycle = m.get('BillingCycle')
        if m.get('Carrier') is not None:
            self.carrier = m.get('Carrier')
        if m.get('DataDisk') is not None:
            self.data_disk_shrink = m.get('DataDisk')
        if m.get('DeletionProtection') is not None:
            self.deletion_protection = m.get('DeletionProtection')
        if m.get('EnsRegionId') is not None:
            self.ens_region_id = m.get('EnsRegionId')
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InstanceChargeStrategy') is not None:
            self.instance_charge_strategy = m.get('InstanceChargeStrategy')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('InternetMaxBandwidthOut') is not None:
            self.internet_max_bandwidth_out = m.get('InternetMaxBandwidthOut')
        if m.get('IpType') is not None:
            self.ip_type = m.get('IpType')
        if m.get('Ipv6AddressCount') is not None:
            self.ipv_6address_count = m.get('Ipv6AddressCount')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('NetDistrictCode') is not None:
            self.net_district_code = m.get('NetDistrictCode')
        if m.get('NetWorkId') is not None:
            self.net_work_id = m.get('NetWorkId')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('PasswordInherit') is not None:
            self.password_inherit = m.get('PasswordInherit')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        if m.get('PublicIpIdentification') is not None:
            self.public_ip_identification = m.get('PublicIpIdentification')
        if m.get('ScheduleAreaLevel') is not None:
            self.schedule_area_level = m.get('ScheduleAreaLevel')
        if m.get('SchedulingPriceStrategy') is not None:
            self.scheduling_price_strategy = m.get('SchedulingPriceStrategy')
        if m.get('SchedulingStrategy') is not None:
            self.scheduling_strategy = m.get('SchedulingStrategy')
        if m.get('SecurityId') is not None:
            self.security_id = m.get('SecurityId')
        if m.get('SpotDuration') is not None:
            self.spot_duration = m.get('SpotDuration')
        if m.get('SpotStrategy') is not None:
            self.spot_strategy = m.get('SpotStrategy')
        if m.get('SystemDisk') is not None:
            self.system_disk_shrink = m.get('SystemDisk')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = RunInstancesShrinkRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('UniqueSuffix') is not None:
            self.unique_suffix = m.get('UniqueSuffix')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class RunInstancesResponseBody(TeaModel):
    def __init__(
        self,
        instance_ids: List[str] = None,
        order_id: str = None,
        request_id: str = None,
    ):
        # The IDs of instances.
        self.instance_ids = instance_ids
        # The order ID.
        self.order_id = order_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunServiceScheduleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        client_ip: str = None,
        directorys: str = None,
        pod_config_name: str = None,
        pre_locked_timeout: int = None,
        schedule_strategy: str = None,
        service_action: str = None,
        service_commands: str = None,
        uuid: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The IP address of the client.
        # 
        # This parameter is required.
        self.client_ip = client_ip
        # The directory to which the data file is mounted. The value must be a full path and cannot be \\"/../\\". Example: ["/data/app01", "/data/user"]. Specify the relative path of the virtual device for this parameter. For example, specify /data for this parameter when the actual path of the virtual device is /data/{input path}.
        self.directorys = directorys
        # The parameter does not take effect.
        self.pod_config_name = pod_config_name
        # The maximum duration for locking an idle device. Unit: seconds. This parameter takes effect only if you set ServiceAction to PreSchedule. Default value: 300.
        self.pre_locked_timeout = pre_locked_timeout
        # The scheduling policy of the device. The value must be a JSON string.
        self.schedule_strategy = schedule_strategy
        # The scheduling operation. The value must be of the enumeration type. Valid values:
        # 
        # Container scenario:
        # 
        # *   Start: selects and activates an idle cloud device.
        # *   Stop: stops and releases the cloud device.
        # *   Console: performs the scheduling operation when the device is in the scheduling state.
        # 
        # Bare metal instance or virtual machine scenario:
        # 
        # *   PreSchedule: locks a virtual machine instance for scheduling.
        # *   Confirm: confirms the scheduling operation.
        # *   Cancel: cancels the scheduling operation.
        # *   Console: performs the scheduling operation when the device is in the scheduling state.
        # 
        # This parameter is required.
        self.service_action = service_action
        # The service commands. The value must be a JSON string.
        self.service_commands = service_commands
        # The UUID of the device.
        # 
        # This parameter is required.
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.client_ip is not None:
            result['ClientIp'] = self.client_ip
        if self.directorys is not None:
            result['Directorys'] = self.directorys
        if self.pod_config_name is not None:
            result['PodConfigName'] = self.pod_config_name
        if self.pre_locked_timeout is not None:
            result['PreLockedTimeout'] = self.pre_locked_timeout
        if self.schedule_strategy is not None:
            result['ScheduleStrategy'] = self.schedule_strategy
        if self.service_action is not None:
            result['ServiceAction'] = self.service_action
        if self.service_commands is not None:
            result['ServiceCommands'] = self.service_commands
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClientIp') is not None:
            self.client_ip = m.get('ClientIp')
        if m.get('Directorys') is not None:
            self.directorys = m.get('Directorys')
        if m.get('PodConfigName') is not None:
            self.pod_config_name = m.get('PodConfigName')
        if m.get('PreLockedTimeout') is not None:
            self.pre_locked_timeout = m.get('PreLockedTimeout')
        if m.get('ScheduleStrategy') is not None:
            self.schedule_strategy = m.get('ScheduleStrategy')
        if m.get('ServiceAction') is not None:
            self.service_action = m.get('ServiceAction')
        if m.get('ServiceCommands') is not None:
            self.service_commands = m.get('ServiceCommands')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class RunServiceScheduleResponseBodyCommandResultsCommandResult(TeaModel):
    def __init__(
        self,
        command: str = None,
        container_name: str = None,
        result_msg: str = None,
    ):
        # The command.
        self.command = command
        # The name of the container.
        self.container_name = container_name
        # The execution result of the command.
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['Command'] = self.command
        if self.container_name is not None:
            result['ContainerName'] = self.container_name
        if self.result_msg is not None:
            result['ResultMsg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('ContainerName') is not None:
            self.container_name = m.get('ContainerName')
        if m.get('ResultMsg') is not None:
            self.result_msg = m.get('ResultMsg')
        return self


class RunServiceScheduleResponseBodyCommandResults(TeaModel):
    def __init__(
        self,
        command_result: List[RunServiceScheduleResponseBodyCommandResultsCommandResult] = None,
    ):
        self.command_result = command_result

    def validate(self):
        if self.command_result:
            for k in self.command_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CommandResult'] = []
        if self.command_result is not None:
            for k in self.command_result:
                result['CommandResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.command_result = []
        if m.get('CommandResult') is not None:
            for k in m.get('CommandResult'):
                temp_model = RunServiceScheduleResponseBodyCommandResultsCommandResult()
                self.command_result.append(temp_model.from_map(k))
        return self


class RunServiceScheduleResponseBody(TeaModel):
    def __init__(
        self,
        command_results: RunServiceScheduleResponseBodyCommandResults = None,
        index: int = None,
        instance_id: str = None,
        instance_ip: str = None,
        instance_port: int = None,
        request_id: str = None,
        request_repeated: str = None,
        tcp_ports: bool = None,
    ):
        # The execution results of the commands.
        self.command_results = command_results
        # The index number of the scheduled virtual device (pod).
        self.index = index
        # The ID of the scheduled instance.
        self.instance_id = instance_id
        # The IP address of the scheduled instance.
        self.instance_ip = instance_ip
        # The start port of the scheduled instance.
        self.instance_port = instance_port
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is repeated. This parameter is not returned if ServcieAction is set to Console.
        self.request_repeated = request_repeated
        # The TCP port range of the scheduled instance or container. The value is in the ${from}-$-{to} format. Example: 80-88.
        self.tcp_ports = tcp_ports

    def validate(self):
        if self.command_results:
            self.command_results.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command_results is not None:
            result['CommandResults'] = self.command_results.to_map()
        if self.index is not None:
            result['Index'] = self.index
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_ip is not None:
            result['InstanceIp'] = self.instance_ip
        if self.instance_port is not None:
            result['InstancePort'] = self.instance_port
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.request_repeated is not None:
            result['RequestRepeated'] = self.request_repeated
        if self.tcp_ports is not None:
            result['TcpPorts'] = self.tcp_ports
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommandResults') is not None:
            temp_model = RunServiceScheduleResponseBodyCommandResults()
            self.command_results = temp_model.from_map(m['CommandResults'])
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceIp') is not None:
            self.instance_ip = m.get('InstanceIp')
        if m.get('InstancePort') is not None:
            self.instance_port = m.get('InstancePort')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RequestRepeated') is not None:
            self.request_repeated = m.get('RequestRepeated')
        if m.get('TcpPorts') is not None:
            self.tcp_ports = m.get('TcpPorts')
        return self


class RunServiceScheduleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunServiceScheduleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunServiceScheduleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveSDGRequest(TeaModel):
    def __init__(
        self,
        sdgid: str = None,
    ):
        # The ID of the SDG to be saved.
        self.sdgid = sdgid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class SaveSDGResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SaveSDGResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SaveSDGResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveSDGResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetBackendServersRequestBackendServers(TeaModel):
    def __init__(
        self,
        server_id: str = None,
        type: str = None,
        weight: int = None,
    ):
        # The ID of the instance that you use as the backend server.
        # 
        # This parameter is required.
        self.server_id = server_id
        # The type of the backend server. Valid values:
        # 
        # *   **ens**: ENS instance
        # *   **eni**: elastic network interface (ENI)
        self.type = type
        # The weight of the backend server. Default value: 100. Valid values: **0** to **100**.
        # 
        # >  The value 0 indicates that requests are not forwarded to the backend server.
        # 
        # This parameter is required.
        self.weight = weight

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.server_id is not None:
            result['ServerId'] = self.server_id
        if self.type is not None:
            result['Type'] = self.type
        if self.weight is not None:
            result['Weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ServerId') is not None:
            self.server_id = m.get('ServerId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        return self


class SetBackendServersRequest(TeaModel):
    def __init__(
        self,
        backend_servers: List[SetBackendServersRequestBackendServers] = None,
        load_balancer_id: str = None,
    ):
        # The list of backend servers that you added. You can modify the weights of up to 20 backend servers in each request.
        # 
        # This parameter is required.
        self.backend_servers = backend_servers
        # The ID of the Edge Load Balancer (ELB) instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id

    def validate(self):
        if self.backend_servers:
            for k in self.backend_servers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BackendServers'] = []
        if self.backend_servers is not None:
            for k in self.backend_servers:
                result['BackendServers'].append(k.to_map() if k else None)
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.backend_servers = []
        if m.get('BackendServers') is not None:
            for k in m.get('BackendServers'):
                temp_model = SetBackendServersRequestBackendServers()
                self.backend_servers.append(temp_model.from_map(k))
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        return self


class SetBackendServersShrinkRequest(TeaModel):
    def __init__(
        self,
        backend_servers_shrink: str = None,
        load_balancer_id: str = None,
    ):
        # The list of backend servers that you added. You can modify the weights of up to 20 backend servers in each request.
        # 
        # This parameter is required.
        self.backend_servers_shrink = backend_servers_shrink
        # The ID of the Edge Load Balancer (ELB) instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backend_servers_shrink is not None:
            result['BackendServers'] = self.backend_servers_shrink
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackendServers') is not None:
            self.backend_servers_shrink = m.get('BackendServers')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        return self


class SetBackendServersResponseBodyBackendServersBackendServer(TeaModel):
    def __init__(
        self,
        ip: str = None,
        port: int = None,
        server_id: str = None,
        type: str = None,
        weight: int = None,
    ):
        # The IP address of the backend server.
        self.ip = ip
        # The backend port that is used by the ELB instance.
        self.port = port
        # The ID of the instance that you want to use as the backend server.
        self.server_id = server_id
        # The type of the backend server. Valid values:
        # 
        # *   **ens**: ENS instance.
        # *   **eni**: ENI instance.
        self.type = type
        # The weight of the backend server. Default value: 100. Valid values: **0** to **100**.
        # 
        # >  The value 0 indicates that requests are not forwarded to the backend server.
        self.weight = weight

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.port is not None:
            result['Port'] = self.port
        if self.server_id is not None:
            result['ServerId'] = self.server_id
        if self.type is not None:
            result['Type'] = self.type
        if self.weight is not None:
            result['Weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('ServerId') is not None:
            self.server_id = m.get('ServerId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        return self


class SetBackendServersResponseBodyBackendServers(TeaModel):
    def __init__(
        self,
        backend_server: List[SetBackendServersResponseBodyBackendServersBackendServer] = None,
    ):
        self.backend_server = backend_server

    def validate(self):
        if self.backend_server:
            for k in self.backend_server:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BackendServer'] = []
        if self.backend_server is not None:
            for k in self.backend_server:
                result['BackendServer'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.backend_server = []
        if m.get('BackendServer') is not None:
            for k in m.get('BackendServer'):
                temp_model = SetBackendServersResponseBodyBackendServersBackendServer()
                self.backend_server.append(temp_model.from_map(k))
        return self


class SetBackendServersResponseBody(TeaModel):
    def __init__(
        self,
        backend_servers: SetBackendServersResponseBodyBackendServers = None,
        request_id: str = None,
    ):
        # The backend servers.
        self.backend_servers = backend_servers
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.backend_servers:
            self.backend_servers.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backend_servers is not None:
            result['BackendServers'] = self.backend_servers.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackendServers') is not None:
            temp_model = SetBackendServersResponseBodyBackendServers()
            self.backend_servers = temp_model.from_map(m['BackendServers'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetBackendServersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetBackendServersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetBackendServersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetLoadBalancerHTTPListenerAttributeRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        health_check: str = None,
        health_check_connect_port: int = None,
        health_check_domain: str = None,
        health_check_http_code: str = None,
        health_check_interval: int = None,
        health_check_method: str = None,
        health_check_timeout: int = None,
        health_check_uri: str = None,
        healthy_threshold: int = None,
        idle_timeout: int = None,
        listener_port: int = None,
        load_balancer_id: str = None,
        request_timeout: int = None,
        scheduler: str = None,
        unhealthy_threshold: int = None,
        xforwarded_for: str = None,
    ):
        # The name of the listener. The value must be **1** to **80** characters in length.
        # 
        # >  The value cannot start with `http://` or `https://`.
        self.description = description
        # Specifies whether to enable the health check feature. Valid values:
        # 
        # *   **on**\
        # *   **off**\
        self.health_check = health_check
        # The port that is used for health checks. Valid values: **1** to **65535**. If you leave this parameter empty, the port specified by BackendServerPort is used for health checks.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.health_check_connect_port = health_check_connect_port
        # The domain name that is used for health checks.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.health_check_domain = health_check_domain
        # The HTTP status code for a successful health check. Valid values:
        # 
        # *   **http_2xx** (default)
        # *   **http_3xx**.
        # *   **http_4xx**\
        # *   **http_5xx**\
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.health_check_http_code = health_check_http_code
        # The interval at which health checks are performed. Valid values: **1** to **50**. Unit: seconds.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.health_check_interval = health_check_interval
        # The HTTP request method for health checks. Valid values:
        # 
        # *   **head**\
        # *   **get**\
        # 
        # >  This parameter takes effect only if the HealthCheck parameter is set to on.
        self.health_check_method = health_check_method
        # The timeout period of a health check response. If a backend server does not respond within the specified timeout period, the server fails to pass the health check.
        # 
        # *   Default value: 5.
        # *   Valid values: **1** to **300**.
        # *   Unit: seconds.
        # 
        # > 
        # 
        # *   This parameter takes effect only if the HealthCheck parameter is set to on.
        # 
        # *   If the value of HealthCheckTimeout is smaller than the value of HealthCheckInterval, the timeout period specified by HealthCheckTimeout becomes invalid, and the value of HealthCheckInterval is used as the timeout period.
        self.health_check_timeout = health_check_timeout
        # The URI used for health checks. The URI must be **1** to **80** characters in length.
        # 
        # > 
        # 
        # *   A URL must start with a forward slash (`/`) but cannot contain only forward slashes (`/`).
        # 
        # *   This parameter takes effect only if the HealthCheck parameter is set to on.
        self.health_check_uri = health_check_uri
        # The number of consecutive successful health checks that must occur before an unhealthy and inaccessible backend server is declared healthy and accessible. Valid values: **2** to **10**.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.healthy_threshold = healthy_threshold
        # The timeout period for idle connections. Default value: 15. Valid values: **1** to **60**. Unit: seconds.
        # 
        # >  If no request is received within the specified timeout period, ELB closes the connection. When another request is received, CLB establishes a new connection.
        self.idle_timeout = idle_timeout
        # The listener port whose attributes are to be modified. Valid values: **1** to **65535**.
        # 
        # This parameter is required.
        self.listener_port = listener_port
        # The ID of the Edge Load Balancer (ELB) instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id
        # The timeout period of requests. Default value: 60. Valid values: **1** to **180**. Unit: seconds.
        # 
        # >  If no response is received from the backend server within the specified timeout period, ELB returns an HTTP 504 error code to the client.
        self.request_timeout = request_timeout
        # The scheduling algorithm. Valid values:
        # 
        # *   **wrr**: Backend servers with higher weights receive more requests than those with lower weights.
        # *   **wlc**: Requests are distributed based on the weights and number of connections to backend servers. If two backend servers have the same weight, the backend server that has fewer connections receives more requests.
        # *   **rr**: Requests are distributed to backend servers in sequence.
        # *   **sch**: consistent hashing based on source IP addresses. Requests from the same source IP address are distributed to the same backend server.
        # *   **qch**: consistent hashing based on QUIC connection IDs (CIDs). Requests that contain the same QUIC CID are distributed to the same backend server.
        # *   **iqch**: consistent hashing based on three specific bytes of iQUIC CIDs. Requests with the same second, third, and fourth bytes are distributed to the same backend server.
        self.scheduler = scheduler
        # The number of consecutive failed health checks that must occur before a healthy and accessible backend server is declared unhealthy and inaccessible. Valid values: **2** to **10**.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.unhealthy_threshold = unhealthy_threshold
        # Specifies whether to use the X-Forwarded-For header to obtain the real IP address of the client. Valid values:
        # 
        # *   **on** (default)
        # *   **off**\
        self.xforwarded_for = xforwarded_for

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.health_check is not None:
            result['HealthCheck'] = self.health_check
        if self.health_check_connect_port is not None:
            result['HealthCheckConnectPort'] = self.health_check_connect_port
        if self.health_check_domain is not None:
            result['HealthCheckDomain'] = self.health_check_domain
        if self.health_check_http_code is not None:
            result['HealthCheckHttpCode'] = self.health_check_http_code
        if self.health_check_interval is not None:
            result['HealthCheckInterval'] = self.health_check_interval
        if self.health_check_method is not None:
            result['HealthCheckMethod'] = self.health_check_method
        if self.health_check_timeout is not None:
            result['HealthCheckTimeout'] = self.health_check_timeout
        if self.health_check_uri is not None:
            result['HealthCheckURI'] = self.health_check_uri
        if self.healthy_threshold is not None:
            result['HealthyThreshold'] = self.healthy_threshold
        if self.idle_timeout is not None:
            result['IdleTimeout'] = self.idle_timeout
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.request_timeout is not None:
            result['RequestTimeout'] = self.request_timeout
        if self.scheduler is not None:
            result['Scheduler'] = self.scheduler
        if self.unhealthy_threshold is not None:
            result['UnhealthyThreshold'] = self.unhealthy_threshold
        if self.xforwarded_for is not None:
            result['XForwardedFor'] = self.xforwarded_for
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('HealthCheck') is not None:
            self.health_check = m.get('HealthCheck')
        if m.get('HealthCheckConnectPort') is not None:
            self.health_check_connect_port = m.get('HealthCheckConnectPort')
        if m.get('HealthCheckDomain') is not None:
            self.health_check_domain = m.get('HealthCheckDomain')
        if m.get('HealthCheckHttpCode') is not None:
            self.health_check_http_code = m.get('HealthCheckHttpCode')
        if m.get('HealthCheckInterval') is not None:
            self.health_check_interval = m.get('HealthCheckInterval')
        if m.get('HealthCheckMethod') is not None:
            self.health_check_method = m.get('HealthCheckMethod')
        if m.get('HealthCheckTimeout') is not None:
            self.health_check_timeout = m.get('HealthCheckTimeout')
        if m.get('HealthCheckURI') is not None:
            self.health_check_uri = m.get('HealthCheckURI')
        if m.get('HealthyThreshold') is not None:
            self.healthy_threshold = m.get('HealthyThreshold')
        if m.get('IdleTimeout') is not None:
            self.idle_timeout = m.get('IdleTimeout')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('RequestTimeout') is not None:
            self.request_timeout = m.get('RequestTimeout')
        if m.get('Scheduler') is not None:
            self.scheduler = m.get('Scheduler')
        if m.get('UnhealthyThreshold') is not None:
            self.unhealthy_threshold = m.get('UnhealthyThreshold')
        if m.get('XForwardedFor') is not None:
            self.xforwarded_for = m.get('XForwardedFor')
        return self


class SetLoadBalancerHTTPListenerAttributeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetLoadBalancerHTTPListenerAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetLoadBalancerHTTPListenerAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetLoadBalancerHTTPListenerAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetLoadBalancerHTTPSListenerAttributeRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        health_check: str = None,
        health_check_connect_port: int = None,
        health_check_domain: str = None,
        health_check_http_code: str = None,
        health_check_interval: int = None,
        health_check_method: str = None,
        health_check_timeout: int = None,
        health_check_uri: str = None,
        healthy_threshold: int = None,
        idle_timeout: int = None,
        listener_port: int = None,
        load_balancer_id: str = None,
        request_timeout: int = None,
        scheduler: str = None,
        server_certificate_id: str = None,
        unhealthy_threshold: int = None,
    ):
        # The name of the listener. The value must be **1** to **80** characters in length.
        # 
        # >  The value cannot start with `http://` or `https://`.
        self.description = description
        # Specifies whether to enable the health check feature. Valid values:
        # 
        # *   **on**\
        # *   **off**\
        self.health_check = health_check
        # The port that is used for health checks. Valid values: **1** to **65535**. If you leave this parameter empty, the port specified by BackendServerPort is used for health checks.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.health_check_connect_port = health_check_connect_port
        # The domain name that you want to use for health checks.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.health_check_domain = health_check_domain
        # The HTTP status code for a successful health check. Valid values:
        # 
        # *   **http_2xx** (default)
        # *   **http_3xx**.
        # *   **http_4xx**\
        # *   **http_5xx**\
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.health_check_http_code = health_check_http_code
        # The interval at which health checks are performed. Valid values: **1** to **50**. Unit: seconds.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.health_check_interval = health_check_interval
        # The HTTP request method for health checks. Valid values:
        # 
        # *   **head** (default): requests the head of the page.
        # *   **get**: requests the specified part of the page and returns the entity body.
        # 
        # >  This parameter takes effect only if the HealthCheck parameter is set to on.
        self.health_check_method = health_check_method
        # The timeout period of a health check response. If the backend ENS does not respond within the specified time, the health check fails.
        # 
        # *   Default value: 5.
        # *   Valid values: **1** to **300**.
        # *   Unit: seconds.
        # 
        # > 
        # 
        # *   This parameter takes effect only if the HealthCheck parameter is set to on.
        # 
        # *   If the value of the HealthCheckTimeout property is smaller than the value of the HealthCheckInterval property, the timeout period specified by the HealthCheckTimeout property becomes invalid and the value of the HealthCheckInterval property is used as the timeout period.
        self.health_check_timeout = health_check_timeout
        # The URI used for health checks. The URI must be **1** to **80** characters in length.
        # 
        # > 
        # 
        # *   A URL must start with a forward slash (`/`) but cannot contain only forward slashes (`/`).
        # 
        # *   This parameter takes effect only if the HealthCheck parameter is set to on.
        self.health_check_uri = health_check_uri
        # The number of consecutive successful health checks that must occur before an unhealthy and inaccessible backend server is declared healthy and accessible. Valid values: **2** to **10**.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.healthy_threshold = healthy_threshold
        # The timeout period for idle connections. Default value: 15. Valid values: **1** to **60**. Unit: seconds.
        # 
        # >  If no request is received within the specified timeout period, ELB closes the connection. When another request is received, ELB establishes a new connection.
        self.idle_timeout = idle_timeout
        # The listener port whose attributes are to be modified. Valid values: **1** to **65535**.
        # 
        # This parameter is required.
        self.listener_port = listener_port
        # The ID of the Edge Load Balancer (ELB) instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id
        # The timeout period of requests. Default value: 60. Valid values: **1** to **180**. Unit: seconds.
        # 
        # >  If no response is received from the backend server within the specified timeout period, ELB returns an HTTP 504 error code to the client.
        self.request_timeout = request_timeout
        # The scheduling algorithm. Valid values:
        # 
        # *   **wrr**: Backend servers with higher weights receive more requests than those with lower weights.
        # *   **wlc**: Requests are distributed based on the weights and number of connections to backend servers. If two backend servers have the same weight, the backend server that has fewer connections receives more requests.
        # *   **rr**: Requests are distributed to backend servers in sequence.
        # *   **sch**: consistent hashing based on source IP addresses. Requests from the same source IP address are distributed to the same backend server.
        # *   **qch**: consistent hashing based on QUIC connection IDs (CIDs). Requests that contain the same QUIC CID are distributed to the same backend server.
        # *   **iqch**: consistent hashing based on three specific bytes of iQUIC CIDs. Requests with the same second, third, and fourth bytes are distributed to the same backend server.
        self.scheduler = scheduler
        # The ID of the server certificate.
        self.server_certificate_id = server_certificate_id
        # The number of consecutive failed health checks that must occur before a healthy and accessible backend server is declared unhealthy and inaccessible. Valid values: **2** to **10**.
        # 
        # >  This parameter takes effect only if you set HealthCheck to on.
        self.unhealthy_threshold = unhealthy_threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.health_check is not None:
            result['HealthCheck'] = self.health_check
        if self.health_check_connect_port is not None:
            result['HealthCheckConnectPort'] = self.health_check_connect_port
        if self.health_check_domain is not None:
            result['HealthCheckDomain'] = self.health_check_domain
        if self.health_check_http_code is not None:
            result['HealthCheckHttpCode'] = self.health_check_http_code
        if self.health_check_interval is not None:
            result['HealthCheckInterval'] = self.health_check_interval
        if self.health_check_method is not None:
            result['HealthCheckMethod'] = self.health_check_method
        if self.health_check_timeout is not None:
            result['HealthCheckTimeout'] = self.health_check_timeout
        if self.health_check_uri is not None:
            result['HealthCheckURI'] = self.health_check_uri
        if self.healthy_threshold is not None:
            result['HealthyThreshold'] = self.healthy_threshold
        if self.idle_timeout is not None:
            result['IdleTimeout'] = self.idle_timeout
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.request_timeout is not None:
            result['RequestTimeout'] = self.request_timeout
        if self.scheduler is not None:
            result['Scheduler'] = self.scheduler
        if self.server_certificate_id is not None:
            result['ServerCertificateId'] = self.server_certificate_id
        if self.unhealthy_threshold is not None:
            result['UnhealthyThreshold'] = self.unhealthy_threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('HealthCheck') is not None:
            self.health_check = m.get('HealthCheck')
        if m.get('HealthCheckConnectPort') is not None:
            self.health_check_connect_port = m.get('HealthCheckConnectPort')
        if m.get('HealthCheckDomain') is not None:
            self.health_check_domain = m.get('HealthCheckDomain')
        if m.get('HealthCheckHttpCode') is not None:
            self.health_check_http_code = m.get('HealthCheckHttpCode')
        if m.get('HealthCheckInterval') is not None:
            self.health_check_interval = m.get('HealthCheckInterval')
        if m.get('HealthCheckMethod') is not None:
            self.health_check_method = m.get('HealthCheckMethod')
        if m.get('HealthCheckTimeout') is not None:
            self.health_check_timeout = m.get('HealthCheckTimeout')
        if m.get('HealthCheckURI') is not None:
            self.health_check_uri = m.get('HealthCheckURI')
        if m.get('HealthyThreshold') is not None:
            self.healthy_threshold = m.get('HealthyThreshold')
        if m.get('IdleTimeout') is not None:
            self.idle_timeout = m.get('IdleTimeout')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('RequestTimeout') is not None:
            self.request_timeout = m.get('RequestTimeout')
        if m.get('Scheduler') is not None:
            self.scheduler = m.get('Scheduler')
        if m.get('ServerCertificateId') is not None:
            self.server_certificate_id = m.get('ServerCertificateId')
        if m.get('UnhealthyThreshold') is not None:
            self.unhealthy_threshold = m.get('UnhealthyThreshold')
        return self


class SetLoadBalancerHTTPSListenerAttributeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetLoadBalancerHTTPSListenerAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetLoadBalancerHTTPSListenerAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetLoadBalancerHTTPSListenerAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetLoadBalancerStatusRequest(TeaModel):
    def __init__(
        self,
        load_balancer_id: str = None,
        load_balancer_status: str = None,
    ):
        # The ID of the ELB instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id
        # The new instance status. Valid values:
        # 
        # *   **Active**\
        # *   **InActive**\
        # 
        # This parameter is required.
        self.load_balancer_status = load_balancer_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.load_balancer_status is not None:
            result['LoadBalancerStatus'] = self.load_balancer_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('LoadBalancerStatus') is not None:
            self.load_balancer_status = m.get('LoadBalancerStatus')
        return self


class SetLoadBalancerStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetLoadBalancerStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetLoadBalancerStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetLoadBalancerStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetLoadBalancerTCPListenerAttributeRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        eip_transmit: str = None,
        established_timeout: int = None,
        health_check_connect_port: int = None,
        health_check_connect_timeout: int = None,
        health_check_domain: str = None,
        health_check_http_code: str = None,
        health_check_interval: int = None,
        health_check_type: str = None,
        health_check_uri: str = None,
        healthy_threshold: int = None,
        listener_port: int = None,
        load_balancer_id: str = None,
        persistence_timeout: int = None,
        scheduler: str = None,
        unhealthy_threshold: int = None,
    ):
        # The description of the listener. The description must be **1** to **80** characters in length.
        # 
        # >  The value cannot start with `http://` or `https://`.
        self.description = description
        # Specifies whether to enable elastic IP address (EIP) pass-through. Valid values:
        # 
        # *   **on**\
        # *   **off** (default)
        self.eip_transmit = eip_transmit
        # The timeout period of a connection. Valid values: **10** to **900**. Unit: seconds.
        self.established_timeout = established_timeout
        # The port that is used for health checks. Valid values: **1** to **65535**. If you leave this parameter empty, the port specified by BackendServerPort is used for health checks.
        self.health_check_connect_port = health_check_connect_port
        # The timeout period for a health check response. If the value of HealthCheckTimeout is smaller than the value of HealthCheckInterval, the timeout period specified by HealthCheckTimeout becomes invalid, and the value of HealthCheckInterval is used as the timeout period.
        # 
        # *   Default value: 5.
        # *   Valid values: **1** to **300**.
        # *   Unit: seconds.
        # 
        # >  If the value of the HealthCheckConnectTimeout parameter is smaller than that of the HealthCheckInterval parameter, the timeout period specified by the HealthCheckConnectTimeout parameter is ignored and the period of time specified by the HealthCheckInterval parameter is used as the timeout period.
        self.health_check_connect_timeout = health_check_connect_timeout
        # The domain name that you want to use for health checks.
        self.health_check_domain = health_check_domain
        # The HTTP status code for a successful health check. Valid values:
        # 
        # *   **http_2xx** (default)
        # *   **http_3xx**.
        # *   **http_4xx**\
        # *   **http_5xx**\
        self.health_check_http_code = health_check_http_code
        # The interval at which health checks are performed. Valid values: **1** to **50**. Unit: seconds.
        self.health_check_interval = health_check_interval
        # The type of health checks. Valid values:
        # 
        # *   **tcp** (default)
        # *   **http**\
        self.health_check_type = health_check_type
        # The Uniform Resource Identifier (URI) that you want to use for health checks. The URI must be **1** to **80** characters in length.
        # 
        # >  The URL must start with `/` and contain characters other than `/`.
        self.health_check_uri = health_check_uri
        # The number of consecutive successful health checks that must occur before an unhealthy and inaccessible backend server is declared healthy and accessible. Valid values: **2** to **10**.
        self.healthy_threshold = healthy_threshold
        # The listener port whose attributes are to be modified. Valid values: **1** to **65535**.
        # 
        # This parameter is required.
        self.listener_port = listener_port
        # The ID of the Edge Load Balancer (ELB) instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id
        # The timeout period of session persistence.
        # 
        # *   Default value: 0. If the default value is used, the system disables session persistence.
        # *   Valid values: **0** to **3600**.
        # *   Unit: seconds.
        self.persistence_timeout = persistence_timeout
        # The scheduling algorithm. Valid values:
        # 
        # *   **wrr**: Backend servers with higher weights receive more requests than those with lower weights.
        # *   **wlc**: Requests are distributed based on the weights and number of connections to backend servers. If two backend servers have the same weight, the backend server that has fewer connections receives more requests.
        # *   **rr**: Requests are distributed to backend servers in sequence.
        # *   **sch**: consistent hashing based on source IP addresses. Requests from the same source IP address are distributed to the same backend server.
        # *   **qch**: consistent hashing based on QUIC connection IDs (CIDs). Requests that contain the same QUIC CID are distributed to the same backend server.
        # *   **iqch**: consistent hashing based on three specific bytes of iQUIC CIDs. Requests with the same second, third, and fourth bytes are distributed to the same backend server.
        self.scheduler = scheduler
        # The number of consecutive failed health checks that must occur before a healthy and accessible backend server is declared unhealthy and inaccessible. Valid values: **2** to **10**.
        self.unhealthy_threshold = unhealthy_threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.eip_transmit is not None:
            result['EipTransmit'] = self.eip_transmit
        if self.established_timeout is not None:
            result['EstablishedTimeout'] = self.established_timeout
        if self.health_check_connect_port is not None:
            result['HealthCheckConnectPort'] = self.health_check_connect_port
        if self.health_check_connect_timeout is not None:
            result['HealthCheckConnectTimeout'] = self.health_check_connect_timeout
        if self.health_check_domain is not None:
            result['HealthCheckDomain'] = self.health_check_domain
        if self.health_check_http_code is not None:
            result['HealthCheckHttpCode'] = self.health_check_http_code
        if self.health_check_interval is not None:
            result['HealthCheckInterval'] = self.health_check_interval
        if self.health_check_type is not None:
            result['HealthCheckType'] = self.health_check_type
        if self.health_check_uri is not None:
            result['HealthCheckURI'] = self.health_check_uri
        if self.healthy_threshold is not None:
            result['HealthyThreshold'] = self.healthy_threshold
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.persistence_timeout is not None:
            result['PersistenceTimeout'] = self.persistence_timeout
        if self.scheduler is not None:
            result['Scheduler'] = self.scheduler
        if self.unhealthy_threshold is not None:
            result['UnhealthyThreshold'] = self.unhealthy_threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EipTransmit') is not None:
            self.eip_transmit = m.get('EipTransmit')
        if m.get('EstablishedTimeout') is not None:
            self.established_timeout = m.get('EstablishedTimeout')
        if m.get('HealthCheckConnectPort') is not None:
            self.health_check_connect_port = m.get('HealthCheckConnectPort')
        if m.get('HealthCheckConnectTimeout') is not None:
            self.health_check_connect_timeout = m.get('HealthCheckConnectTimeout')
        if m.get('HealthCheckDomain') is not None:
            self.health_check_domain = m.get('HealthCheckDomain')
        if m.get('HealthCheckHttpCode') is not None:
            self.health_check_http_code = m.get('HealthCheckHttpCode')
        if m.get('HealthCheckInterval') is not None:
            self.health_check_interval = m.get('HealthCheckInterval')
        if m.get('HealthCheckType') is not None:
            self.health_check_type = m.get('HealthCheckType')
        if m.get('HealthCheckURI') is not None:
            self.health_check_uri = m.get('HealthCheckURI')
        if m.get('HealthyThreshold') is not None:
            self.healthy_threshold = m.get('HealthyThreshold')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('PersistenceTimeout') is not None:
            self.persistence_timeout = m.get('PersistenceTimeout')
        if m.get('Scheduler') is not None:
            self.scheduler = m.get('Scheduler')
        if m.get('UnhealthyThreshold') is not None:
            self.unhealthy_threshold = m.get('UnhealthyThreshold')
        return self


class SetLoadBalancerTCPListenerAttributeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetLoadBalancerTCPListenerAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetLoadBalancerTCPListenerAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetLoadBalancerTCPListenerAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetLoadBalancerUDPListenerAttributeRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        eip_transmit: str = None,
        established_timeout: int = None,
        health_check_connect_port: int = None,
        health_check_connect_timeout: int = None,
        health_check_exp: str = None,
        health_check_interval: int = None,
        health_check_req: str = None,
        healthy_threshold: int = None,
        listener_port: int = None,
        load_balancer_id: str = None,
        scheduler: str = None,
        unhealthy_threshold: int = None,
    ):
        # The name of the listener. The valuemust be **1** to **80** characters in length.
        # 
        # >  The value cannot start with `http://` or `https://`.
        self.description = description
        # Specifies whether to enable elastic IP address (EIP) pass-through. Valid values:
        # 
        # *   **on**\
        # *   **off** (default)
        self.eip_transmit = eip_transmit
        # The timeout period of a connection. Valid values: **10** to **900**. Default value: **900**. Unit: seconds.
        self.established_timeout = established_timeout
        # The port that is used for health checks. Valid values: **1** to **65535**. If you leave this parameter empty, the port specified for BackendServerPort is used for health checks.
        self.health_check_connect_port = health_check_connect_port
        # The timeout period of a health check response. If the backend ENS does not respond within the specified time, the health check fails.
        # 
        # *   Default value: 5.
        # *   Valid values: **1** to **300**.
        # *   Unit: seconds.
        # 
        # >  If the value of the HealthCheckTimeout property is smaller than the value of the HealthCheckInterval property, the timeout period specified by the HealthCheckTimeout property becomes invalid and the value of the HealthCheckInterval property is used as the timeout period.
        self.health_check_connect_timeout = health_check_connect_timeout
        # The response string for UDP listener health checks. The string can be up to 64 characters in length and can contain only letters and digits.
        self.health_check_exp = health_check_exp
        # The interval at which health checks are performed. Valid values: **1** to **50**. Unit: seconds.
        self.health_check_interval = health_check_interval
        # The request string for UDP listener health checks. The string can be up to 64 characters in length and can contain only letters and digits.
        self.health_check_req = health_check_req
        # The number of consecutive successful health checks that must occur before an unhealthy and inaccessible backend server is declared healthy and accessible. Valid values: **2** to **10**.
        self.healthy_threshold = healthy_threshold
        # The listener port whose attributes are to be modified. Valid values: **1** to **65535**.
        # 
        # This parameter is required.
        self.listener_port = listener_port
        # The ID of the Edge Load Balancer (ELB) instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id
        # The scheduling algorithm. Valid values:
        # 
        # *   **wrr**: Backend servers with higher weights receive more requests than those with lower weights.
        # *   **wlc**: Requests are distributed based on the weights and number of connections to backend servers. If two backend servers have the same weight, the backend server that has fewer connections receives more requests.
        # *   **rr**: Requests are distributed to backend servers in sequence.
        # *   **sch**: consistent hashing based on source IP addresses. Requests from the same source IP address are distributed to the same backend server.
        # *   **qch**: consistent hashing based on QUIC connection IDs (CIDs). Requests that contain the same QUIC CID are distributed to the same backend server.
        # *   **iqch**: consistent hashing based on three specific bytes of iQUIC CIDs. Requests with the same second, third, and fourth bytes are distributed to the same backend server.
        self.scheduler = scheduler
        # The number of consecutive failed health checks that must occur before a healthy and accessible backend server is declared unhealthy and inaccessible. Valid values: **2** to **10**.
        self.unhealthy_threshold = unhealthy_threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.eip_transmit is not None:
            result['EipTransmit'] = self.eip_transmit
        if self.established_timeout is not None:
            result['EstablishedTimeout'] = self.established_timeout
        if self.health_check_connect_port is not None:
            result['HealthCheckConnectPort'] = self.health_check_connect_port
        if self.health_check_connect_timeout is not None:
            result['HealthCheckConnectTimeout'] = self.health_check_connect_timeout
        if self.health_check_exp is not None:
            result['HealthCheckExp'] = self.health_check_exp
        if self.health_check_interval is not None:
            result['HealthCheckInterval'] = self.health_check_interval
        if self.health_check_req is not None:
            result['HealthCheckReq'] = self.health_check_req
        if self.healthy_threshold is not None:
            result['HealthyThreshold'] = self.healthy_threshold
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        if self.scheduler is not None:
            result['Scheduler'] = self.scheduler
        if self.unhealthy_threshold is not None:
            result['UnhealthyThreshold'] = self.unhealthy_threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EipTransmit') is not None:
            self.eip_transmit = m.get('EipTransmit')
        if m.get('EstablishedTimeout') is not None:
            self.established_timeout = m.get('EstablishedTimeout')
        if m.get('HealthCheckConnectPort') is not None:
            self.health_check_connect_port = m.get('HealthCheckConnectPort')
        if m.get('HealthCheckConnectTimeout') is not None:
            self.health_check_connect_timeout = m.get('HealthCheckConnectTimeout')
        if m.get('HealthCheckExp') is not None:
            self.health_check_exp = m.get('HealthCheckExp')
        if m.get('HealthCheckInterval') is not None:
            self.health_check_interval = m.get('HealthCheckInterval')
        if m.get('HealthCheckReq') is not None:
            self.health_check_req = m.get('HealthCheckReq')
        if m.get('HealthyThreshold') is not None:
            self.healthy_threshold = m.get('HealthyThreshold')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        if m.get('Scheduler') is not None:
            self.scheduler = m.get('Scheduler')
        if m.get('UnhealthyThreshold') is not None:
            self.unhealthy_threshold = m.get('UnhealthyThreshold')
        return self


class SetLoadBalancerUDPListenerAttributeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetLoadBalancerUDPListenerAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetLoadBalancerUDPListenerAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetLoadBalancerUDPListenerAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartEpnInstanceRequest(TeaModel):
    def __init__(
        self,
        epninstance_id: str = None,
    ):
        # The ID of the EPN instance.
        # 
        # This parameter is required.
        self.epninstance_id = epninstance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.epninstance_id is not None:
            result['EPNInstanceId'] = self.epninstance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EPNInstanceId') is not None:
            self.epninstance_id = m.get('EPNInstanceId')
        return self


class StartEpnInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartEpnInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartEpnInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartEpnInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # The ID of the instance. You can start only one instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class StartInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        request_id: str = None,
    ):
        # The returned service code. 0 indicates that the request was successful.
        self.code = code
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartInstancesRequest(TeaModel):
    def __init__(
        self,
        instance_ids: List[str] = None,
    ):
        self.instance_ids = instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        return self


class StartInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        instance_ids_shrink: str = None,
    ):
        self.instance_ids_shrink = instance_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids_shrink is not None:
            result['InstanceIds'] = self.instance_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids_shrink = m.get('InstanceIds')
        return self


class StartInstancesResponseBody(TeaModel):
    def __init__(
        self,
        instance_responses: List[InstanceOperateResponse] = None,
        request_id: str = None,
    ):
        self.instance_responses = instance_responses
        self.request_id = request_id

    def validate(self):
        if self.instance_responses:
            for k in self.instance_responses:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceResponses'] = []
        if self.instance_responses is not None:
            for k in self.instance_responses:
                result['InstanceResponses'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_responses = []
        if m.get('InstanceResponses') is not None:
            for k in m.get('InstanceResponses'):
                temp_model = InstanceOperateResponse()
                self.instance_responses.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartLoadBalancerListenerRequest(TeaModel):
    def __init__(
        self,
        listener_port: int = None,
        listener_protocol: str = None,
        load_balancer_id: str = None,
    ):
        # The listener port to be enabled. Valid values: **1** to **65535**.
        # 
        # This parameter is required.
        self.listener_port = listener_port
        # The frontend protocol that is used by the ELB instance. Valid values:
        # 
        # *   tcp
        # *   udp
        # *   http
        # *   https
        # 
        # >  This parameter is required if the same port is used by listeners that use different protocols.
        self.listener_protocol = listener_protocol
        # The ID of the ELB instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.listener_protocol is not None:
            result['ListenerProtocol'] = self.listener_protocol
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('ListenerProtocol') is not None:
            self.listener_protocol = m.get('ListenerProtocol')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        return self


class StartLoadBalancerListenerResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartLoadBalancerListenerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartLoadBalancerListenerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartLoadBalancerListenerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartSnatIpForSnatEntryRequest(TeaModel):
    def __init__(
        self,
        snat_entry_id: str = None,
        snat_ip: str = None,
    ):
        # The ID of the SNAT entry.
        # 
        # This parameter is required.
        self.snat_entry_id = snat_entry_id
        # The EIP specified in the SNAT entry.
        # 
        # This parameter is required.
        self.snat_ip = snat_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.snat_entry_id is not None:
            result['SnatEntryId'] = self.snat_entry_id
        if self.snat_ip is not None:
            result['SnatIp'] = self.snat_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SnatEntryId') is not None:
            self.snat_entry_id = m.get('SnatEntryId')
        if m.get('SnatIp') is not None:
            self.snat_ip = m.get('SnatIp')
        return self


class StartSnatIpForSnatEntryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartSnatIpForSnatEntryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartSnatIpForSnatEntryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartSnatIpForSnatEntryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopEpnInstanceRequest(TeaModel):
    def __init__(
        self,
        epninstance_id: str = None,
    ):
        # The ID of the EPN instance.
        # 
        # This parameter is required.
        self.epninstance_id = epninstance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.epninstance_id is not None:
            result['EPNInstanceId'] = self.epninstance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EPNInstanceId') is not None:
            self.epninstance_id = m.get('EPNInstanceId')
        return self


class StopEpnInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopEpnInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopEpnInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopEpnInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopInstanceRequest(TeaModel):
    def __init__(
        self,
        force_stop: str = None,
        instance_id: str = None,
    ):
        # Specifies whether to forcibly stop the instance.
        # 
        # *   **true**\
        # *   **false** (default)
        self.force_stop = force_stop
        # The ID of the instance that you want to stop. You can specify only one instance ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.force_stop is not None:
            result['ForceStop'] = self.force_stop
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ForceStop') is not None:
            self.force_stop = m.get('ForceStop')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class StopInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        request_id: str = None,
    ):
        # The returned service code. 0 indicates that the request was successful.
        self.code = code
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopInstancesRequest(TeaModel):
    def __init__(
        self,
        instance_ids: List[str] = None,
    ):
        self.instance_ids = instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        return self


class StopInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        instance_ids_shrink: str = None,
    ):
        self.instance_ids_shrink = instance_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids_shrink is not None:
            result['InstanceIds'] = self.instance_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids_shrink = m.get('InstanceIds')
        return self


class StopInstancesResponseBody(TeaModel):
    def __init__(
        self,
        instance_responses: List[InstanceOperateResponse] = None,
        request_id: str = None,
    ):
        self.instance_responses = instance_responses
        self.request_id = request_id

    def validate(self):
        if self.instance_responses:
            for k in self.instance_responses:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceResponses'] = []
        if self.instance_responses is not None:
            for k in self.instance_responses:
                result['InstanceResponses'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_responses = []
        if m.get('InstanceResponses') is not None:
            for k in m.get('InstanceResponses'):
                temp_model = InstanceOperateResponse()
                self.instance_responses.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopLoadBalancerListenerRequest(TeaModel):
    def __init__(
        self,
        listener_port: int = None,
        listener_protocol: str = None,
        load_balancer_id: str = None,
    ):
        # The listener port that you want to disable. Valid values: **1** to **65535**.
        # 
        # This parameter is required.
        self.listener_port = listener_port
        # The frontend protocol that is used by the ELB instance.
        # 
        # >  This parameter is required if the same port is used by listeners that use different protocols.
        self.listener_protocol = listener_protocol
        # The ID of the ELB instance.
        # 
        # This parameter is required.
        self.load_balancer_id = load_balancer_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.listener_protocol is not None:
            result['ListenerProtocol'] = self.listener_protocol
        if self.load_balancer_id is not None:
            result['LoadBalancerId'] = self.load_balancer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('ListenerProtocol') is not None:
            self.listener_protocol = m.get('ListenerProtocol')
        if m.get('LoadBalancerId') is not None:
            self.load_balancer_id = m.get('LoadBalancerId')
        return self


class StopLoadBalancerListenerResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopLoadBalancerListenerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopLoadBalancerListenerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopLoadBalancerListenerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopSnatIpForSnatEntryRequest(TeaModel):
    def __init__(
        self,
        snat_entry_id: str = None,
        snat_ip: str = None,
    ):
        # The ID of the SNAT entry.
        # 
        # This parameter is required.
        self.snat_entry_id = snat_entry_id
        # The EIP specified in the SNAT entry.
        # 
        # This parameter is required.
        self.snat_ip = snat_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.snat_entry_id is not None:
            result['SnatEntryId'] = self.snat_entry_id
        if self.snat_ip is not None:
            result['SnatIp'] = self.snat_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SnatEntryId') is not None:
            self.snat_entry_id = m.get('SnatEntryId')
        if m.get('SnatIp') is not None:
            self.snat_ip = m.get('SnatIp')
        return self


class StopSnatIpForSnatEntryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopSnatIpForSnatEntryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopSnatIpForSnatEntryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopSnatIpForSnatEntryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TagResourcesRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of tag N that is added to the resource. Valid values of N: 1 to 20. The tag value cannot be an empty string. The tag value can be up to 128 characters in length. It cannot start with aliyun or acs: and cannot contain http:// or https://.
        # 
        # This parameter is required.
        self.key = key
        # The value of tag N that is added to the resource. Valid values of N: 1 to 20. The tag value can be an empty string. The tag value can be up to 128 characters in length. It cannot start with acs: or contain http:// or https://.
        # 
        # This parameter is required.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class TagResourcesRequest(TeaModel):
    def __init__(
        self,
        resource_id: List[str] = None,
        resource_type: str = None,
        tag: List[TagResourcesRequestTag] = None,
    ):
        # The resource IDs. You can add up to 50 resource IDs in a call.
        # 
        # This parameter is required.
        self.resource_id = resource_id
        # The type of the resource. Set the value to instance.
        # 
        # This parameter is required.
        self.resource_type = resource_type
        # The tag that is bound to the instance.
        # 
        # This parameter is required.
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = TagResourcesRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class TagResourcesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class TagResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TagResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnAssociateEnsEipAddressRequest(TeaModel):
    def __init__(
        self,
        allocation_id: str = None,
        force: bool = None,
    ):
        # The ID of the EIP.
        # 
        # This parameter is required.
        self.allocation_id = allocation_id
        # Specifies whether to disassociate the EIP from a NAT gateway if a DNAT or SNAT entry is added to the NAT gateway. Valid values:
        # 
        # *   **false** (default): does not disassociate the EIP from a NAT gateway if a DNAT or SNAT entry is added to the NAT gateway.
        # *   **true**: disassociates the EIP from a NAT gateway if a DNAT or SNAT entry is added to the NAT gateway.
        self.force = force

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.force is not None:
            result['Force'] = self.force
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('Force') is not None:
            self.force = m.get('Force')
        return self


class UnAssociateEnsEipAddressResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnAssociateEnsEipAddressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnAssociateEnsEipAddressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnAssociateEnsEipAddressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnassignPrivateIpAddressesRequest(TeaModel):
    def __init__(
        self,
        network_interface_id: str = None,
        private_ip_address: List[str] = None,
    ):
        # The ID of the ENI.
        # 
        # This parameter is required.
        self.network_interface_id = network_interface_id
        # The secondary private IP addresses to unassign.
        # 
        # This parameter is required.
        self.private_ip_address = private_ip_address

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        return self


class UnassignPrivateIpAddressesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnassignPrivateIpAddressesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnassignPrivateIpAddressesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnassignPrivateIpAddressesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnassociateHaVipRequest(TeaModel):
    def __init__(
        self,
        ha_vip_id: str = None,
        instance_id: str = None,
    ):
        # The ID of the HAVIP that you want to disassociate.
        # 
        # This parameter is required.
        self.ha_vip_id = ha_vip_id
        # The ID of the ENS instance or ENI that you want to disassociate from the HAVIP.
        # 
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ha_vip_id is not None:
            result['HaVipId'] = self.ha_vip_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HaVipId') is not None:
            self.ha_vip_id = m.get('HaVipId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class UnassociateHaVipResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnassociateHaVipResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnassociateHaVipResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnassociateHaVipResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnassociateNetworkAclRequestResource(TeaModel):
    def __init__(
        self,
        resource_id: str = None,
        resource_type: str = None,
    ):
        # The ID of the resource that you want to disassociate.
        # 
        # This parameter is required.
        self.resource_id = resource_id
        # The type of the resource that you want to disassociate. Valid values:
        # 
        # *   Network
        # 
        # This parameter is required.
        self.resource_type = resource_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class UnassociateNetworkAclRequest(TeaModel):
    def __init__(
        self,
        network_acl_id: str = None,
        resource: List[UnassociateNetworkAclRequestResource] = None,
    ):
        # The ID of the network ACL that you want to disassociate from a resource.
        # 
        # This parameter is required.
        self.network_acl_id = network_acl_id
        # Resources that you want to disassociate. Valid values of **N**: 0 to 29. A maximum of 30 resources can be unbound.
        # 
        # This parameter is required.
        self.resource = resource

    def validate(self):
        if self.resource:
            for k in self.resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_acl_id is not None:
            result['NetworkAclId'] = self.network_acl_id
        result['Resource'] = []
        if self.resource is not None:
            for k in self.resource:
                result['Resource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkAclId') is not None:
            self.network_acl_id = m.get('NetworkAclId')
        self.resource = []
        if m.get('Resource') is not None:
            for k in m.get('Resource'):
                temp_model = UnassociateNetworkAclRequestResource()
                self.resource.append(temp_model.from_map(k))
        return self


class UnassociateNetworkAclResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnassociateNetworkAclResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnassociateNetworkAclResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnassociateNetworkAclResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnloadRegionSDGRequest(TeaModel):
    def __init__(
        self,
        destination_region_ids: List[str] = None,
        namespaces: List[str] = None,
        sdgid: str = None,
    ):
        # The destination nodes.
        # 
        # This parameter is required.
        self.destination_region_ids = destination_region_ids
        # An array that consists of queried namespaces.
        self.namespaces = namespaces
        # Deletes the shared data group (SDG) ID of the preloaded data.
        # 
        # This parameter is required.
        self.sdgid = sdgid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_region_ids is not None:
            result['DestinationRegionIds'] = self.destination_region_ids
        if self.namespaces is not None:
            result['Namespaces'] = self.namespaces
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationRegionIds') is not None:
            self.destination_region_ids = m.get('DestinationRegionIds')
        if m.get('Namespaces') is not None:
            self.namespaces = m.get('Namespaces')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class UnloadRegionSDGShrinkRequest(TeaModel):
    def __init__(
        self,
        destination_region_ids_shrink: str = None,
        namespaces_shrink: str = None,
        sdgid: str = None,
    ):
        # The destination nodes.
        # 
        # This parameter is required.
        self.destination_region_ids_shrink = destination_region_ids_shrink
        # An array that consists of queried namespaces.
        self.namespaces_shrink = namespaces_shrink
        # Deletes the shared data group (SDG) ID of the preloaded data.
        # 
        # This parameter is required.
        self.sdgid = sdgid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_region_ids_shrink is not None:
            result['DestinationRegionIds'] = self.destination_region_ids_shrink
        if self.namespaces_shrink is not None:
            result['Namespaces'] = self.namespaces_shrink
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationRegionIds') is not None:
            self.destination_region_ids_shrink = m.get('DestinationRegionIds')
        if m.get('Namespaces') is not None:
            self.namespaces_shrink = m.get('Namespaces')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class UnloadRegionSDGResponseBodyDataResultFailedItems(TeaModel):
    def __init__(
        self,
        destination_region_id: str = None,
        error_message: str = None,
    ):
        # The ID of the destination node.
        self.destination_region_id = destination_region_id
        # The error message that is returned.
        self.error_message = error_message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_region_id is not None:
            result['DestinationRegionId'] = self.destination_region_id
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationRegionId') is not None:
            self.destination_region_id = m.get('DestinationRegionId')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        return self


class UnloadRegionSDGResponseBodyDataResult(TeaModel):
    def __init__(
        self,
        failed_count: int = None,
        failed_items: List[UnloadRegionSDGResponseBodyDataResultFailedItems] = None,
        success_count: int = None,
    ):
        # The number of failed tasks.
        self.failed_count = failed_count
        # Details about the failed tasks.
        self.failed_items = failed_items
        # The number of successful tasks.
        self.success_count = success_count

    def validate(self):
        if self.failed_items:
            for k in self.failed_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failed_count is not None:
            result['FailedCount'] = self.failed_count
        result['FailedItems'] = []
        if self.failed_items is not None:
            for k in self.failed_items:
                result['FailedItems'].append(k.to_map() if k else None)
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailedCount') is not None:
            self.failed_count = m.get('FailedCount')
        self.failed_items = []
        if m.get('FailedItems') is not None:
            for k in m.get('FailedItems'):
                temp_model = UnloadRegionSDGResponseBodyDataResultFailedItems()
                self.failed_items.append(temp_model.from_map(k))
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        return self


class UnloadRegionSDGResponseBodyData(TeaModel):
    def __init__(
        self,
        message: str = None,
        result: UnloadRegionSDGResponseBodyDataResult = None,
        success: bool = None,
    ):
        # The response message. Success is returned for a successful request.
        self.message = message
        # The execution result of the synchronization request.
        self.result = result
        # Indicates whether all tasks are successful. Valid values:
        # 
        # *   true: All tasks are successful.
        # *   false: Failed tasks exist.
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.result is not None:
            result['Result'] = self.result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Result') is not None:
            temp_model = UnloadRegionSDGResponseBodyDataResult()
            self.result = temp_model.from_map(m['Result'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UnloadRegionSDGResponseBody(TeaModel):
    def __init__(
        self,
        data: UnloadRegionSDGResponseBodyData = None,
        request_id: str = None,
    ):
        # The returned data object.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = UnloadRegionSDGResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnloadRegionSDGResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnloadRegionSDGResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnloadRegionSDGResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnmountInstanceSDGRequest(TeaModel):
    def __init__(
        self,
        instance_ids: List[str] = None,
        sdgid: str = None,
    ):
        # The IDs of the instances.
        # 
        # This parameter is required.
        self.instance_ids = instance_ids
        # The ID of the SDG.
        # 
        # This parameter is required.
        self.sdgid = sdgid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class UnmountInstanceSDGShrinkRequest(TeaModel):
    def __init__(
        self,
        instance_ids_shrink: str = None,
        sdgid: str = None,
    ):
        # The IDs of the instances.
        # 
        # This parameter is required.
        self.instance_ids_shrink = instance_ids_shrink
        # The ID of the SDG.
        # 
        # This parameter is required.
        self.sdgid = sdgid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids_shrink is not None:
            result['InstanceIds'] = self.instance_ids_shrink
        if self.sdgid is not None:
            result['SDGId'] = self.sdgid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids_shrink = m.get('InstanceIds')
        if m.get('SDGId') is not None:
            self.sdgid = m.get('SDGId')
        return self


class UnmountInstanceSDGResponseBodyDataResultFailedItems(TeaModel):
    def __init__(
        self,
        err_message: str = None,
        instance_id: str = None,
    ):
        # The error message.
        self.err_message = err_message
        # The ID of the instance.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.err_message is not None:
            result['ErrMessage'] = self.err_message
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrMessage') is not None:
            self.err_message = m.get('ErrMessage')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class UnmountInstanceSDGResponseBodyDataResult(TeaModel):
    def __init__(
        self,
        failed_count: int = None,
        failed_items: List[UnmountInstanceSDGResponseBodyDataResultFailedItems] = None,
        success_count: int = None,
    ):
        # The number of failed tasks.
        self.failed_count = failed_count
        # Details about failed tasks.
        self.failed_items = failed_items
        # The number of successful tasks.
        self.success_count = success_count

    def validate(self):
        if self.failed_items:
            for k in self.failed_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failed_count is not None:
            result['FailedCount'] = self.failed_count
        result['FailedItems'] = []
        if self.failed_items is not None:
            for k in self.failed_items:
                result['FailedItems'].append(k.to_map() if k else None)
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailedCount') is not None:
            self.failed_count = m.get('FailedCount')
        self.failed_items = []
        if m.get('FailedItems') is not None:
            for k in m.get('FailedItems'):
                temp_model = UnmountInstanceSDGResponseBodyDataResultFailedItems()
                self.failed_items.append(temp_model.from_map(k))
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        return self


class UnmountInstanceSDGResponseBodyData(TeaModel):
    def __init__(
        self,
        message: str = None,
        result: UnmountInstanceSDGResponseBodyDataResult = None,
        success: bool = None,
    ):
        # The response message. Success is returned for a successful request.
        self.message = message
        # The execution result of the synchronization request.
        self.result = result
        # Indicates whether all tasks are successful. Valid values:
        # 
        # *   true: All tasks are successful.
        # *   false: Failed tasks exist.
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.result is not None:
            result['Result'] = self.result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Result') is not None:
            temp_model = UnmountInstanceSDGResponseBodyDataResult()
            self.result = temp_model.from_map(m['Result'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UnmountInstanceSDGResponseBody(TeaModel):
    def __init__(
        self,
        data: UnmountInstanceSDGResponseBodyData = None,
        request_id: str = None,
    ):
        # The returned data object.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = UnmountInstanceSDGResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnmountInstanceSDGResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnmountInstanceSDGResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnmountInstanceSDGResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UntagResourcesRequest(TeaModel):
    def __init__(
        self,
        all: bool = None,
        resource_id: List[str] = None,
        resource_type: str = None,
        tag_key: List[str] = None,
    ):
        # Specifies whether to remove all tags from the resource. This parameter takes effect only if you do not specify TagKey.N. Valid values:
        # 
        # *   **true**\
        # *   **false** (default)
        self.all = all
        # The resource IDs. You can specify up to 50 resource IDs.
        # 
        # This parameter is required.
        self.resource_id = resource_id
        # The type of the resource.
        # 
        # This parameter is required.
        self.resource_type = resource_type
        # The keys of the tags. Valid values of N: 1 to 20.
        self.tag_key = tag_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.all is not None:
            result['All'] = self.all
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('All') is not None:
            self.all = m.get('All')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        return self


class UntagResourcesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UntagResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UntagResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UntagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateEnsSaleControlRequestSaleControlsConditionControls(TeaModel):
    def __init__(
        self,
        condition_control_module_code: str = None,
        condition_control_module_value: str = None,
    ):
        self.condition_control_module_code = condition_control_module_code
        self.condition_control_module_value = condition_control_module_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition_control_module_code is not None:
            result['ConditionControlModuleCode'] = self.condition_control_module_code
        if self.condition_control_module_value is not None:
            result['ConditionControlModuleValue'] = self.condition_control_module_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConditionControlModuleCode') is not None:
            self.condition_control_module_code = m.get('ConditionControlModuleCode')
        if m.get('ConditionControlModuleValue') is not None:
            self.condition_control_module_value = m.get('ConditionControlModuleValue')
        return self


class UpdateEnsSaleControlRequestSaleControlsModuleValue(TeaModel):
    def __init__(
        self,
        module_max_value: str = None,
        module_min_value: str = None,
        module_value: List[str] = None,
    ):
        self.module_max_value = module_max_value
        self.module_min_value = module_min_value
        self.module_value = module_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.module_max_value is not None:
            result['ModuleMaxValue'] = self.module_max_value
        if self.module_min_value is not None:
            result['ModuleMinValue'] = self.module_min_value
        if self.module_value is not None:
            result['ModuleValue'] = self.module_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ModuleMaxValue') is not None:
            self.module_max_value = m.get('ModuleMaxValue')
        if m.get('ModuleMinValue') is not None:
            self.module_min_value = m.get('ModuleMinValue')
        if m.get('ModuleValue') is not None:
            self.module_value = m.get('ModuleValue')
        return self


class UpdateEnsSaleControlRequestSaleControls(TeaModel):
    def __init__(
        self,
        condition_controls: List[UpdateEnsSaleControlRequestSaleControlsConditionControls] = None,
        description: str = None,
        module_code: str = None,
        module_value: UpdateEnsSaleControlRequestSaleControlsModuleValue = None,
        operator: str = None,
        order_type: str = None,
    ):
        self.condition_controls = condition_controls
        self.description = description
        # This parameter is required.
        self.module_code = module_code
        # This parameter is required.
        self.module_value = module_value
        # This parameter is required.
        self.operator = operator
        # This parameter is required.
        self.order_type = order_type

    def validate(self):
        if self.condition_controls:
            for k in self.condition_controls:
                if k:
                    k.validate()
        if self.module_value:
            self.module_value.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConditionControls'] = []
        if self.condition_controls is not None:
            for k in self.condition_controls:
                result['ConditionControls'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.module_code is not None:
            result['ModuleCode'] = self.module_code
        if self.module_value is not None:
            result['ModuleValue'] = self.module_value.to_map()
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.condition_controls = []
        if m.get('ConditionControls') is not None:
            for k in m.get('ConditionControls'):
                temp_model = UpdateEnsSaleControlRequestSaleControlsConditionControls()
                self.condition_controls.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ModuleCode') is not None:
            self.module_code = m.get('ModuleCode')
        if m.get('ModuleValue') is not None:
            temp_model = UpdateEnsSaleControlRequestSaleControlsModuleValue()
            self.module_value = temp_model.from_map(m['ModuleValue'])
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        return self


class UpdateEnsSaleControlRequest(TeaModel):
    def __init__(
        self,
        ali_uid_account: str = None,
        commodity_code: str = None,
        custom_account: str = None,
        sale_controls: List[UpdateEnsSaleControlRequestSaleControls] = None,
    ):
        self.ali_uid_account = ali_uid_account
        # This parameter is required.
        self.commodity_code = commodity_code
        self.custom_account = custom_account
        # This parameter is required.
        self.sale_controls = sale_controls

    def validate(self):
        if self.sale_controls:
            for k in self.sale_controls:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uid_account is not None:
            result['AliUidAccount'] = self.ali_uid_account
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.custom_account is not None:
            result['CustomAccount'] = self.custom_account
        result['SaleControls'] = []
        if self.sale_controls is not None:
            for k in self.sale_controls:
                result['SaleControls'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliUidAccount') is not None:
            self.ali_uid_account = m.get('AliUidAccount')
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('CustomAccount') is not None:
            self.custom_account = m.get('CustomAccount')
        self.sale_controls = []
        if m.get('SaleControls') is not None:
            for k in m.get('SaleControls'):
                temp_model = UpdateEnsSaleControlRequestSaleControls()
                self.sale_controls.append(temp_model.from_map(k))
        return self


class UpdateEnsSaleControlShrinkRequest(TeaModel):
    def __init__(
        self,
        ali_uid_account: str = None,
        commodity_code: str = None,
        custom_account: str = None,
        sale_controls_shrink: str = None,
    ):
        self.ali_uid_account = ali_uid_account
        # This parameter is required.
        self.commodity_code = commodity_code
        self.custom_account = custom_account
        # This parameter is required.
        self.sale_controls_shrink = sale_controls_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uid_account is not None:
            result['AliUidAccount'] = self.ali_uid_account
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.custom_account is not None:
            result['CustomAccount'] = self.custom_account
        if self.sale_controls_shrink is not None:
            result['SaleControls'] = self.sale_controls_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliUidAccount') is not None:
            self.ali_uid_account = m.get('AliUidAccount')
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('CustomAccount') is not None:
            self.custom_account = m.get('CustomAccount')
        if m.get('SaleControls') is not None:
            self.sale_controls_shrink = m.get('SaleControls')
        return self


class UpdateEnsSaleControlResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateEnsSaleControlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateEnsSaleControlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateEnsSaleControlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpgradeAICInstanceImageRequest(TeaModel):
    def __init__(
        self,
        image_id: str = None,
        server_ids: List[str] = None,
        timeout: int = None,
    ):
        # The ID of the AIC image.
        # 
        # This parameter is required.
        self.image_id = image_id
        # The IDs of the servers.
        # 
        # This parameter is required.
        self.server_ids = server_ids
        # The timeout period of the update. Unit: seconds.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.server_ids is not None:
            result['ServerIds'] = self.server_ids
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ServerIds') is not None:
            self.server_ids = m.get('ServerIds')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class UpgradeAICInstanceImageShrinkRequest(TeaModel):
    def __init__(
        self,
        image_id: str = None,
        server_ids_shrink: str = None,
        timeout: int = None,
    ):
        # The ID of the AIC image.
        # 
        # This parameter is required.
        self.image_id = image_id
        # The IDs of the servers.
        # 
        # This parameter is required.
        self.server_ids_shrink = server_ids_shrink
        # The timeout period of the update. Unit: seconds.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.server_ids_shrink is not None:
            result['ServerIds'] = self.server_ids_shrink
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ServerIds') is not None:
            self.server_ids_shrink = m.get('ServerIds')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class UpgradeAICInstanceImageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpgradeAICInstanceImageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpgradeAICInstanceImageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpgradeAICInstanceImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpgradeApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        template: str = None,
        timeout: int = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The information template for phased update. The value must be a JSON string and contain the following information:
        # 
        # *   Version range that you want to update
        # *   Configuration information of the target version
        # *   Canary release policy for resources
        # *   Intelligent upgrade policy that contains information such as the time window and resource usage limit
        # 
        # This parameter is required.
        self.template = template
        # The timeout period for asynchronous upgrade. Unit: seconds. Default value: 300.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.template is not None:
            result['Template'] = self.template
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Template') is not None:
            self.template = m.get('Template')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class UpgradeApplicationResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The task ID. You can use the task ID to query the upgrade progress or status.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class UpgradeApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpgradeApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpgradeApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


