# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import Dict, List, Any


class AbortAndRollbackChangeOrderRequest(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # ba386059-69b1-4e65-b1e5-0682d9fa\*\*\*\*\
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class AbortAndRollbackChangeOrderResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class AbortAndRollbackChangeOrderResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: AbortAndRollbackChangeOrderResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The details of the change order.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the change order was terminated or the application was rolled back. Valid values:
        # 
        # *   **true**: The change order was terminated or the application was rolled back.
        # *   **false**: The change order could not be terminated or the application could not be rolled back.
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = AbortAndRollbackChangeOrderResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class AbortAndRollbackChangeOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AbortAndRollbackChangeOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AbortAndRollbackChangeOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AbortChangeOrderRequest(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # be2e1c76-682b-4897-98d3-1d8d6478\*\*\*\*\
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class AbortChangeOrderResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class AbortChangeOrderResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: AbortChangeOrderResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the change order was terminated. Valid values:
        # 
        # *   **true**: The change order was terminated.
        # *   **false**: The change order could not be terminated.
        self.success = success
        # The ID of the trace.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = AbortChangeOrderResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class AbortChangeOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AbortChangeOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AbortChangeOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchStartApplicationsRequest(TeaModel):
    def __init__(
        self,
        app_ids: str = None,
        namespace_id: str = None,
    ):
        # ebf491f0-c1a5-45e2-b2c4-710dbe2a\*\*\*\*\
        self.app_ids = app_ids
        # cn-shanghai
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_ids is not None:
            result['AppIds'] = self.app_ids
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppIds') is not None:
            self.app_ids = m.get('AppIds')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class BatchStartApplicationsResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class BatchStartApplicationsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BatchStartApplicationsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   If the request is successful, this parameter is not returned.****\
        # *   This parameter is returned only if the request failed.**** For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the specified applications are successfully started. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BatchStartApplicationsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class BatchStartApplicationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchStartApplicationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchStartApplicationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchStopApplicationsRequest(TeaModel):
    def __init__(
        self,
        app_ids: str = None,
        namespace_id: str = None,
    ):
        # ebf491f0-c1a5-45e2-b2c4-710dbe2a\*\*\*\*,ebf491f0-c1a5-45e2-b2c4-71025e2a\*\*\*\*\
        self.app_ids = app_ids
        # cn-shanghai
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_ids is not None:
            result['AppIds'] = self.app_ids
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppIds') is not None:
            self.app_ids = m.get('AppIds')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class BatchStopApplicationsResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class BatchStopApplicationsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BatchStopApplicationsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   If the request is successful, this parameter is not returned.****\
        # *   This parameter is returned only if the request failed.**** For more information, see the "**Error codes**" section in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the specified applications are stopped. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BatchStopApplicationsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class BatchStopApplicationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchStopApplicationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchStopApplicationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindSlbRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        internet: str = None,
        internet_slb_id: str = None,
        intranet: str = None,
        intranet_slb_id: str = None,
    ):
        # 0099b7be-5f5b-4512-a7fc-56049ef1\*\*\*\*\
        self.app_id = app_id
        # \[{"port":80,"targetPort":8080,"protocol":"TCP"}]
        self.internet = internet
        # lb-bp1tg0k6d9nqaw7l1\*\*\*\*\
        self.internet_slb_id = internet_slb_id
        # \[{"port":80,"targetPort":8080,"protocol":"TCP"}]
        self.intranet = intranet
        # lb-bp1tg0k6d9nqaw7l1\*\*\*\*\
        self.intranet_slb_id = intranet_slb_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.internet is not None:
            result['Internet'] = self.internet
        if self.internet_slb_id is not None:
            result['InternetSlbId'] = self.internet_slb_id
        if self.intranet is not None:
            result['Intranet'] = self.intranet
        if self.intranet_slb_id is not None:
            result['IntranetSlbId'] = self.intranet_slb_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Internet') is not None:
            self.internet = m.get('Internet')
        if m.get('InternetSlbId') is not None:
            self.internet_slb_id = m.get('InternetSlbId')
        if m.get('Intranet') is not None:
            self.intranet = m.get('Intranet')
        if m.get('IntranetSlbId') is not None:
            self.intranet_slb_id = m.get('IntranetSlbId')
        return self


class BindSlbResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order. It can be used to query the task status.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class BindSlbResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BindSlbResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the SLB instance was successfully associated with the application. Valid values:
        # 
        # *   **true**: The SLB instance was successfully associated with the application.
        # *   **false**: The SLB instance could not be associated with the application.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BindSlbResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class BindSlbResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindSlbResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindSlbResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ConfirmPipelineBatchRequest(TeaModel):
    def __init__(
        self,
        confirm: bool = None,
        pipeline_id: str = None,
    ):
        # true
        self.confirm = confirm
        # e2e-vds-feh-\*\*\*\
        self.pipeline_id = pipeline_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.confirm is not None:
            result['Confirm'] = self.confirm
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Confirm') is not None:
            self.confirm = m.get('Confirm')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        return self


class ConfirmPipelineBatchResponseBodyData(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
    ):
        # The ID of the batch.
        self.pipeline_id = pipeline_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        return self


class ConfirmPipelineBatchResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ConfirmPipelineBatchResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The batch information.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the processing of the next batch started as required. Valid values:
        # 
        # *   **true**: The processing started.
        # *   **false**: The processing could not start.
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ConfirmPipelineBatchResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ConfirmPipelineBatchResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ConfirmPipelineBatchResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ConfirmPipelineBatchResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateApplicationRequest(TeaModel):
    def __init__(
        self,
        acr_assume_role_arn: str = None,
        acr_instance_id: str = None,
        app_description: str = None,
        app_name: str = None,
        associate_eip: bool = None,
        auto_config: bool = None,
        command: str = None,
        command_args: str = None,
        config_map_mount_desc: str = None,
        cpu: int = None,
        custom_host_alias: str = None,
        deploy: bool = None,
        edas_container_version: str = None,
        envs: str = None,
        image_pull_secrets: str = None,
        image_url: str = None,
        jar_start_args: str = None,
        jar_start_options: str = None,
        jdk: str = None,
        kafka_configs: str = None,
        liveness: str = None,
        memory: int = None,
        micro_registration: str = None,
        mount_desc: str = None,
        mount_host: str = None,
        namespace_id: str = None,
        nas_configs: str = None,
        nas_id: str = None,
        oss_ak_id: str = None,
        oss_ak_secret: str = None,
        oss_mount_descs: str = None,
        package_type: str = None,
        package_url: str = None,
        package_version: str = None,
        php_arms_config_location: str = None,
        php_config: str = None,
        php_config_location: str = None,
        post_start: str = None,
        pre_stop: str = None,
        programming_language: str = None,
        pvtz_discovery_svc: str = None,
        python: str = None,
        python_modules: str = None,
        readiness: str = None,
        replicas: int = None,
        security_group_id: str = None,
        sls_configs: str = None,
        termination_grace_period_seconds: int = None,
        timezone: str = None,
        tomcat_config: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
        war_start_options: str = None,
        web_container: str = None,
    ):
        # acs:ram::123456789012\*\*\*\*:role/adminrole
        self.acr_assume_role_arn = acr_assume_role_arn
        # cri-xxxxxx
        self.acr_instance_id = acr_instance_id
        # This is a test description.
        self.app_description = app_description
        # test
        self.app_name = app_name
        # true
        self.associate_eip = associate_eip
        # true
        self.auto_config = auto_config
        # sleep
        self.command = command
        # 1d
        self.command_args = command_args
        # \[{"configMapId":16,"key":"test","mountPath":"/tmp"}]
        self.config_map_mount_desc = config_map_mount_desc
        # 1000
        self.cpu = cpu
        # \[{"hostName":"samplehost","ip":"127.0.0.1"}]
        self.custom_host_alias = custom_host_alias
        # true
        self.deploy = deploy
        # 3.5.3
        self.edas_container_version = edas_container_version
        # \[{"name":"envtmp","value":"0"}]
        self.envs = envs
        self.image_pull_secrets = image_pull_secrets
        # registry.cn-hangzhou.aliyuncs.com/sae_test/ali_sae_test:0.0.1
        self.image_url = image_url
        # custom-args
        self.jar_start_args = jar_start_args
        # \-Xms4G -Xmx4G
        self.jar_start_options = jar_start_options
        # Open JDK 8
        self.jdk = jdk
        self.kafka_configs = kafka_configs
        # {"exec":{"command":\["sh","-c","cat /home/admin/start.sh"]},"initialDelaySeconds":30,"periodSeconds":30,"timeoutSeconds":2}
        self.liveness = liveness
        # 1024
        self.memory = memory
        self.micro_registration = micro_registration
        # \[{mountPath: "/tmp", nasPath: "/"}]
        self.mount_desc = mount_desc
        # example.com
        self.mount_host = mount_host
        # cn-beijing:test
        self.namespace_id = namespace_id
        self.nas_configs = nas_configs
        # KSAK\*\*\*\*\
        self.nas_id = nas_id
        # xxxxxx
        self.oss_ak_id = oss_ak_id
        # xxxxxx
        self.oss_ak_secret = oss_ak_secret
        # \[{"bucketName": "oss-bucket", "bucketPath": "data/user.data", "mountPath": "/usr/data/user.data", "readOnly": true}]
        self.oss_mount_descs = oss_mount_descs
        # FatJar
        self.package_type = package_type
        # http://myoss.oss-cn-\*\*\*\*.aliyuncs.com/my-buc/2019-06-30/\*\*\*\*.jar
        self.package_url = package_url
        # 1.0.0
        self.package_version = package_version
        # /usr/local/etc/php/conf.d/arms.ini
        self.php_arms_config_location = php_arms_config_location
        # k1=v1
        self.php_config = php_config
        # /usr/local/etc/php/php.ini
        self.php_config_location = php_config_location
        # {"exec":{"command":\["cat","/etc/group"]}}
        self.post_start = post_start
        # {"exec":{"command":\["cat","/etc/group"]}}
        self.pre_stop = pre_stop
        self.programming_language = programming_language
        self.pvtz_discovery_svc = pvtz_discovery_svc
        self.python = python
        self.python_modules = python_modules
        # {"exec":{"command":\["sh","-c","cat /home/admin/start.sh"]},"initialDelaySeconds":30,"periodSeconds":30,"timeoutSeconds":2}
        self.readiness = readiness
        # 1
        self.replicas = replicas
        # sg-wz969ngg2e49q5i4\*\*\*\*\
        self.security_group_id = security_group_id
        # \[{"logDir":"","logType":"stdout"},{"logDir":"/tmp/a.log"}]
        self.sls_configs = sls_configs
        # 30
        self.termination_grace_period_seconds = termination_grace_period_seconds
        # Asia/Shanghai
        self.timezone = timezone
        # {"port":8080,"contextPath":"/","maxThreads":400,"uriEncoding":"ISO-8859-1","useBodyEncodingForUri":true}
        self.tomcat_config = tomcat_config
        # vsw-bp12mw1f8k3jgygk9\*\*\*\*\
        self.v_switch_id = v_switch_id
        # vpc-bp1aevy8sofi8mh1q\*\*\*\*\
        self.vpc_id = vpc_id
        # CATALINA_OPTS=\\"$CATALINA_OPTS $Options\\" catalina.sh run
        self.war_start_options = war_start_options
        # apache-tomcat-7.0.91
        self.web_container = web_container

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acr_assume_role_arn is not None:
            result['AcrAssumeRoleArn'] = self.acr_assume_role_arn
        if self.acr_instance_id is not None:
            result['AcrInstanceId'] = self.acr_instance_id
        if self.app_description is not None:
            result['AppDescription'] = self.app_description
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.associate_eip is not None:
            result['AssociateEip'] = self.associate_eip
        if self.auto_config is not None:
            result['AutoConfig'] = self.auto_config
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        if self.config_map_mount_desc is not None:
            result['ConfigMapMountDesc'] = self.config_map_mount_desc
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.custom_host_alias is not None:
            result['CustomHostAlias'] = self.custom_host_alias
        if self.deploy is not None:
            result['Deploy'] = self.deploy
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.image_pull_secrets is not None:
            result['ImagePullSecrets'] = self.image_pull_secrets
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.jar_start_args is not None:
            result['JarStartArgs'] = self.jar_start_args
        if self.jar_start_options is not None:
            result['JarStartOptions'] = self.jar_start_options
        if self.jdk is not None:
            result['Jdk'] = self.jdk
        if self.kafka_configs is not None:
            result['KafkaConfigs'] = self.kafka_configs
        if self.liveness is not None:
            result['Liveness'] = self.liveness
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.micro_registration is not None:
            result['MicroRegistration'] = self.micro_registration
        if self.mount_desc is not None:
            result['MountDesc'] = self.mount_desc
        if self.mount_host is not None:
            result['MountHost'] = self.mount_host
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.nas_configs is not None:
            result['NasConfigs'] = self.nas_configs
        if self.nas_id is not None:
            result['NasId'] = self.nas_id
        if self.oss_ak_id is not None:
            result['OssAkId'] = self.oss_ak_id
        if self.oss_ak_secret is not None:
            result['OssAkSecret'] = self.oss_ak_secret
        if self.oss_mount_descs is not None:
            result['OssMountDescs'] = self.oss_mount_descs
        if self.package_type is not None:
            result['PackageType'] = self.package_type
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.php_arms_config_location is not None:
            result['PhpArmsConfigLocation'] = self.php_arms_config_location
        if self.php_config is not None:
            result['PhpConfig'] = self.php_config
        if self.php_config_location is not None:
            result['PhpConfigLocation'] = self.php_config_location
        if self.post_start is not None:
            result['PostStart'] = self.post_start
        if self.pre_stop is not None:
            result['PreStop'] = self.pre_stop
        if self.programming_language is not None:
            result['ProgrammingLanguage'] = self.programming_language
        if self.pvtz_discovery_svc is not None:
            result['PvtzDiscoverySvc'] = self.pvtz_discovery_svc
        if self.python is not None:
            result['Python'] = self.python
        if self.python_modules is not None:
            result['PythonModules'] = self.python_modules
        if self.readiness is not None:
            result['Readiness'] = self.readiness
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.sls_configs is not None:
            result['SlsConfigs'] = self.sls_configs
        if self.termination_grace_period_seconds is not None:
            result['TerminationGracePeriodSeconds'] = self.termination_grace_period_seconds
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.tomcat_config is not None:
            result['TomcatConfig'] = self.tomcat_config
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.war_start_options is not None:
            result['WarStartOptions'] = self.war_start_options
        if self.web_container is not None:
            result['WebContainer'] = self.web_container
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcrAssumeRoleArn') is not None:
            self.acr_assume_role_arn = m.get('AcrAssumeRoleArn')
        if m.get('AcrInstanceId') is not None:
            self.acr_instance_id = m.get('AcrInstanceId')
        if m.get('AppDescription') is not None:
            self.app_description = m.get('AppDescription')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AssociateEip') is not None:
            self.associate_eip = m.get('AssociateEip')
        if m.get('AutoConfig') is not None:
            self.auto_config = m.get('AutoConfig')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        if m.get('ConfigMapMountDesc') is not None:
            self.config_map_mount_desc = m.get('ConfigMapMountDesc')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CustomHostAlias') is not None:
            self.custom_host_alias = m.get('CustomHostAlias')
        if m.get('Deploy') is not None:
            self.deploy = m.get('Deploy')
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('ImagePullSecrets') is not None:
            self.image_pull_secrets = m.get('ImagePullSecrets')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('JarStartArgs') is not None:
            self.jar_start_args = m.get('JarStartArgs')
        if m.get('JarStartOptions') is not None:
            self.jar_start_options = m.get('JarStartOptions')
        if m.get('Jdk') is not None:
            self.jdk = m.get('Jdk')
        if m.get('KafkaConfigs') is not None:
            self.kafka_configs = m.get('KafkaConfigs')
        if m.get('Liveness') is not None:
            self.liveness = m.get('Liveness')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('MicroRegistration') is not None:
            self.micro_registration = m.get('MicroRegistration')
        if m.get('MountDesc') is not None:
            self.mount_desc = m.get('MountDesc')
        if m.get('MountHost') is not None:
            self.mount_host = m.get('MountHost')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NasConfigs') is not None:
            self.nas_configs = m.get('NasConfigs')
        if m.get('NasId') is not None:
            self.nas_id = m.get('NasId')
        if m.get('OssAkId') is not None:
            self.oss_ak_id = m.get('OssAkId')
        if m.get('OssAkSecret') is not None:
            self.oss_ak_secret = m.get('OssAkSecret')
        if m.get('OssMountDescs') is not None:
            self.oss_mount_descs = m.get('OssMountDescs')
        if m.get('PackageType') is not None:
            self.package_type = m.get('PackageType')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('PhpArmsConfigLocation') is not None:
            self.php_arms_config_location = m.get('PhpArmsConfigLocation')
        if m.get('PhpConfig') is not None:
            self.php_config = m.get('PhpConfig')
        if m.get('PhpConfigLocation') is not None:
            self.php_config_location = m.get('PhpConfigLocation')
        if m.get('PostStart') is not None:
            self.post_start = m.get('PostStart')
        if m.get('PreStop') is not None:
            self.pre_stop = m.get('PreStop')
        if m.get('ProgrammingLanguage') is not None:
            self.programming_language = m.get('ProgrammingLanguage')
        if m.get('PvtzDiscoverySvc') is not None:
            self.pvtz_discovery_svc = m.get('PvtzDiscoverySvc')
        if m.get('Python') is not None:
            self.python = m.get('Python')
        if m.get('PythonModules') is not None:
            self.python_modules = m.get('PythonModules')
        if m.get('Readiness') is not None:
            self.readiness = m.get('Readiness')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SlsConfigs') is not None:
            self.sls_configs = m.get('SlsConfigs')
        if m.get('TerminationGracePeriodSeconds') is not None:
            self.termination_grace_period_seconds = m.get('TerminationGracePeriodSeconds')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('TomcatConfig') is not None:
            self.tomcat_config = m.get('TomcatConfig')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('WarStartOptions') is not None:
            self.war_start_options = m.get('WarStartOptions')
        if m.get('WebContainer') is not None:
            self.web_container = m.get('WebContainer')
        return self


class CreateApplicationResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        change_order_id: str = None,
    ):
        # The ID of the application that is created.
        self.app_id = app_id
        # The ID of the change order. It can be used to query the task status.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class CreateApplicationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateApplicationResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code. Valid values:
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the application is created. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateApplicationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class CreateApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateApplicationScalingRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        min_ready_instance_ratio: int = None,
        min_ready_instances: int = None,
        scaling_rule_enable: bool = None,
        scaling_rule_metric: str = None,
        scaling_rule_name: str = None,
        scaling_rule_timer: str = None,
        scaling_rule_type: str = None,
    ):
        # 7171a6ca-d1cd-4928-8642-7d5cfe69\*\*\*\*\
        self.app_id = app_id
        # \-1
        self.min_ready_instance_ratio = min_ready_instance_ratio
        # 3
        self.min_ready_instances = min_ready_instances
        # true
        self.scaling_rule_enable = scaling_rule_enable
        # {"maxReplicas":3,"minReplicas":1,"metrics":\[{"metricType":"CPU","metricTargetAverageUtilization":20},{"metricType":"MEMORY","metricTargetAverageUtilization":30},{"metricType":"tcpActiveConn","metricTargetAverageUtilization":20},{"metricType":"SLB_QPS","MetricTargetAverageUtilization":25,"SlbProject":"aliyun-fc-cn-hangzhou-d95881d9-5d3c-5f26-a6b8-\*\*\*\*\*\*\*\*\*\*\*\*","SlbLogstore":"function-log","Vport":"80"},{"metricType":"SLB_RT","MetricTargetAverageUtilization":35,"SlbProject":"aliyun-fc-cn-hangzhou-d95881d9-5d3c-5f26-a6b8-\*\*\*\*\*\*\*\*\*\*\*\*","SlbLogstore":"function-log","Vport":"80"}],"scaleUpRules":{"step":"100","disabled":false,"stabilizationWindowSeconds":0},"scaleDownRules":{"step":"100","disabled":false,"stabilizationWindowSeconds":300}}
        self.scaling_rule_metric = scaling_rule_metric
        # timer-0800-2100
        self.scaling_rule_name = scaling_rule_name
        # {"beginDate":null,"endDate":null,"period":"\* \* \*","schedules":\[{"atTime":"08:00","targetReplicas":10},{"atTime":"20:00","targetReplicas":3}]}
        self.scaling_rule_timer = scaling_rule_timer
        # timing
        self.scaling_rule_type = scaling_rule_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.min_ready_instance_ratio is not None:
            result['MinReadyInstanceRatio'] = self.min_ready_instance_ratio
        if self.min_ready_instances is not None:
            result['MinReadyInstances'] = self.min_ready_instances
        if self.scaling_rule_enable is not None:
            result['ScalingRuleEnable'] = self.scaling_rule_enable
        if self.scaling_rule_metric is not None:
            result['ScalingRuleMetric'] = self.scaling_rule_metric
        if self.scaling_rule_name is not None:
            result['ScalingRuleName'] = self.scaling_rule_name
        if self.scaling_rule_timer is not None:
            result['ScalingRuleTimer'] = self.scaling_rule_timer
        if self.scaling_rule_type is not None:
            result['ScalingRuleType'] = self.scaling_rule_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('MinReadyInstanceRatio') is not None:
            self.min_ready_instance_ratio = m.get('MinReadyInstanceRatio')
        if m.get('MinReadyInstances') is not None:
            self.min_ready_instances = m.get('MinReadyInstances')
        if m.get('ScalingRuleEnable') is not None:
            self.scaling_rule_enable = m.get('ScalingRuleEnable')
        if m.get('ScalingRuleMetric') is not None:
            self.scaling_rule_metric = m.get('ScalingRuleMetric')
        if m.get('ScalingRuleName') is not None:
            self.scaling_rule_name = m.get('ScalingRuleName')
        if m.get('ScalingRuleTimer') is not None:
            self.scaling_rule_timer = m.get('ScalingRuleTimer')
        if m.get('ScalingRuleType') is not None:
            self.scaling_rule_type = m.get('ScalingRuleType')
        return self


class CreateApplicationScalingRuleResponseBodyDataMetricMetrics(TeaModel):
    def __init__(
        self,
        metric_target_average_utilization: int = None,
        metric_type: str = None,
    ):
        # The limit on the metric.
        # 
        # *   The limit on the CPU utilization. Unit: percentage.
        # *   The limit on the memory usage. Unit: percentage.
        # *   The limit on the average number of active TCP connections per second.
        # *   The limit on the QPS of the Internet-facing SLB instance.
        # *   The limit on the response time of the Internet-facing SLB instance. Unit: milliseconds.
        self.metric_target_average_utilization = metric_target_average_utilization
        # The metric that is used to trigger the auto scaling policy. Valid values:
        # 
        # *   **CPU**: the CPU utilization.
        # *   **MEMORY**: the memory usage.
        # *   **tcpActiveConn**: the average number of active TCP connections for an instance in 30 seconds.
        # *   **SLB_QPS**: the average QPS of the Internet-facing SLB instance associated with an application instance in 15 seconds.
        # *   **SLB_RT**: the average response time of the Internet-facing SLB instance in 15 seconds.
        self.metric_type = metric_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_target_average_utilization is not None:
            result['MetricTargetAverageUtilization'] = self.metric_target_average_utilization
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetricTargetAverageUtilization') is not None:
            self.metric_target_average_utilization = m.get('MetricTargetAverageUtilization')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        return self


class CreateApplicationScalingRuleResponseBodyDataMetric(TeaModel):
    def __init__(
        self,
        max_replicas: int = None,
        metrics: List[CreateApplicationScalingRuleResponseBodyDataMetricMetrics] = None,
        min_replicas: int = None,
    ):
        # The maximum number of instances.
        self.max_replicas = max_replicas
        # The list of metrics that are used to trigger the auto scaling policy.
        self.metrics = metrics
        # The minimum number of instances.
        self.min_replicas = min_replicas

    def validate(self):
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        result['Metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['Metrics'].append(k.to_map() if k else None)
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        self.metrics = []
        if m.get('Metrics') is not None:
            for k in m.get('Metrics'):
                temp_model = CreateApplicationScalingRuleResponseBodyDataMetricMetrics()
                self.metrics.append(temp_model.from_map(k))
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        return self


class CreateApplicationScalingRuleResponseBodyDataTimerSchedules(TeaModel):
    def __init__(
        self,
        at_time: str = None,
        target_replicas: int = None,
    ):
        # The point in time. Format: **Hour:Minute**.
        self.at_time = at_time
        # The expected number of instances.
        self.target_replicas = target_replicas

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.at_time is not None:
            result['AtTime'] = self.at_time
        if self.target_replicas is not None:
            result['TargetReplicas'] = self.target_replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AtTime') is not None:
            self.at_time = m.get('AtTime')
        if m.get('TargetReplicas') is not None:
            self.target_replicas = m.get('TargetReplicas')
        return self


class CreateApplicationScalingRuleResponseBodyDataTimer(TeaModel):
    def __init__(
        self,
        begin_date: str = None,
        end_date: str = None,
        period: str = None,
        schedules: List[CreateApplicationScalingRuleResponseBodyDataTimerSchedules] = None,
    ):
        # The start date of the validity period of the scheduled auto scaling policy.
        # 
        # *   If both the **BeginDate** and **EndDate** parameters are set to **null**, the auto scaling policy can always be triggered. The default value for these parameters is null.
        # *   If the two parameters are set to specific dates, the scheduled auto scaling policy can be triggered during the period between the two dates. For example, if **BeginDate** is 2021-03-25 and **EndDate** is 2021-04-25, the auto scaling policy is valid for one month.
        self.begin_date = begin_date
        # The end date of the validity period of the scheduled auto scaling policy.
        # 
        # *   If both the **BeginDate** and **EndDate** parameters are set to **null**, the auto scaling policy can always be triggered. The default value for these parameters is null.
        # *   If the two parameters are set to specific dates, the scheduled auto scaling policy can be triggered during the period between the two dates. For example, if **BeginDate** is 2021-03-25 and **EndDate** is 2021-04-25, the auto scaling policy is valid for one month.
        self.end_date = end_date
        # The days on which the scheduled auto scaling policy takes effect. Valid values:
        # 
        # *   **\* \* \***: The scheduled auto scaling policy takes effect at a specified time every day.
        # 
        # *   **\* \* Fri,Mon**: The scheduled auto scaling policy takes effect at a specified time on one or multiple days of a week. The specified time is in the GMT+8 time zone. Valid values:
        # 
        #     *   **Sun**: Sunday
        #     *   **Mon**: Monday
        #     *   **Tue**: Tuesday
        #     *   **Wed**: Wednesday
        #     *   **Thu**: Thursday
        #     *   **Fri**: Friday
        #     *   **Sat**: Saturday
        # 
        # *   **1,2,3,28,31 \* \***: The scheduled auto scaling policy takes effect at a specified time on one or multiple days of a month. Valid values: 1 to 31. If the month does not have a 31st day, the auto scaling policy takes effect on the specified days other than the 31st day.
        self.period = period
        # The points in time when the auto scaling policy is triggered within one day.
        self.schedules = schedules

    def validate(self):
        if self.schedules:
            for k in self.schedules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_date is not None:
            result['BeginDate'] = self.begin_date
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.period is not None:
            result['Period'] = self.period
        result['Schedules'] = []
        if self.schedules is not None:
            for k in self.schedules:
                result['Schedules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BeginDate') is not None:
            self.begin_date = m.get('BeginDate')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        self.schedules = []
        if m.get('Schedules') is not None:
            for k in m.get('Schedules'):
                temp_model = CreateApplicationScalingRuleResponseBodyDataTimerSchedules()
                self.schedules.append(temp_model.from_map(k))
        return self


class CreateApplicationScalingRuleResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        create_time: int = None,
        last_disable_time: int = None,
        metric: CreateApplicationScalingRuleResponseBodyDataMetric = None,
        scale_rule_enabled: bool = None,
        scale_rule_name: str = None,
        scale_rule_type: str = None,
        timer: CreateApplicationScalingRuleResponseBodyDataTimer = None,
        update_time: int = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The time when the auto scaling policy was created. Unit: milliseconds.
        self.create_time = create_time
        # The time when the auto scaling policy was last disabled.
        self.last_disable_time = last_disable_time
        # The details of the metric-based auto scaling policy.
        self.metric = metric
        # Indicates whether the auto scaling policy is enabled. Valid values:
        # 
        # *   **true**: enabled
        # *   **false**: disabled
        self.scale_rule_enabled = scale_rule_enabled
        # The name of the auto scaling policy.
        self.scale_rule_name = scale_rule_name
        # The type of the auto scaling policy. Valid values:
        # 
        # *   **timing**: the scheduled auto scaling policy.
        # *   **metric**: the metric-based auto scaling policy.
        # *   **mix**: the hybrid auto scaling policy.
        self.scale_rule_type = scale_rule_type
        # The details of the scheduled auto scaling policy.
        self.timer = timer
        # The time when the auto scaling policy was updated. Unit: milliseconds.
        self.update_time = update_time

    def validate(self):
        if self.metric:
            self.metric.validate()
        if self.timer:
            self.timer.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_disable_time is not None:
            result['LastDisableTime'] = self.last_disable_time
        if self.metric is not None:
            result['Metric'] = self.metric.to_map()
        if self.scale_rule_enabled is not None:
            result['ScaleRuleEnabled'] = self.scale_rule_enabled
        if self.scale_rule_name is not None:
            result['ScaleRuleName'] = self.scale_rule_name
        if self.scale_rule_type is not None:
            result['ScaleRuleType'] = self.scale_rule_type
        if self.timer is not None:
            result['Timer'] = self.timer.to_map()
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastDisableTime') is not None:
            self.last_disable_time = m.get('LastDisableTime')
        if m.get('Metric') is not None:
            temp_model = CreateApplicationScalingRuleResponseBodyDataMetric()
            self.metric = temp_model.from_map(m['Metric'])
        if m.get('ScaleRuleEnabled') is not None:
            self.scale_rule_enabled = m.get('ScaleRuleEnabled')
        if m.get('ScaleRuleName') is not None:
            self.scale_rule_name = m.get('ScaleRuleName')
        if m.get('ScaleRuleType') is not None:
            self.scale_rule_type = m.get('ScaleRuleType')
        if m.get('Timer') is not None:
            temp_model = CreateApplicationScalingRuleResponseBodyDataTimer()
            self.timer = temp_model.from_map(m['Timer'])
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class CreateApplicationScalingRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateApplicationScalingRuleResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        # The returned data.
        self.data = data
        self.error_code = error_code
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateApplicationScalingRuleResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class CreateApplicationScalingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateApplicationScalingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateApplicationScalingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateConfigMapRequest(TeaModel):
    def __init__(
        self,
        data: str = None,
        description: str = None,
        name: str = None,
        namespace_id: str = None,
    ):
        self.data = data
        self.description = description
        # name
        self.name = name
        # cn-hangzhou
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class CreateConfigMapResponseBodyData(TeaModel):
    def __init__(
        self,
        config_map_id: int = None,
    ):
        # The ID of the ConfigMap instance that was created.
        self.config_map_id = config_map_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        return self


class CreateConfigMapResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateConfigMapResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the call was successful.
        # *   **3xx**: indicates that the call was redirected.
        # *   **4xx**: indicates that the call failed.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned result.
        self.data = data
        # The returned error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned information.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the ConfigMap instance was created. Valid values:
        # 
        # *   **true**: The instance was created.
        # *   **false**: The call failed to be created.
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateConfigMapResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class CreateConfigMapResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateConfigMapResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateConfigMapResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateGreyTagRouteRequest(TeaModel):
    def __init__(
        self,
        alb_rules: str = None,
        app_id: str = None,
        description: str = None,
        dubbo_rules: str = None,
        name: str = None,
        sc_rules: str = None,
    ):
        self.alb_rules = alb_rules
        # 7802c49a-67bc-4167-8369-9a9c003c\*\*\*\*\
        self.app_id = app_id
        # Canary Release - Regions
        self.description = description
        # \[{"condition":"OR","group":"DUBBO","items":\[{"cond":"==","expr":".key1","index":0,"operator":"rawvalue","value":"value1"},{"cond":"==","expr":".key2","index":0,"operator":"rawvalue","value":"value2"}],"methodName":"echo","serviceName":"com.alibaba.edas.boot.EchoService","version":"1.0.0"}]
        self.dubbo_rules = dubbo_rules
        # dubbo-echo
        self.name = name
        # \[{"condition":"OR","items":\[{"cond":"==","name":"grey","operator":"rawvalue","type":"param","value":"true"},{"cond":"==","name":"grey","operator":"rawvalue","type":"cookie","value":"true"},{"cond":"==","name":"grey","operator":"rawvalue","type":"header","value":"true"}],"path":"/post-echo/hi"}]
        self.sc_rules = sc_rules

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alb_rules is not None:
            result['AlbRules'] = self.alb_rules
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.description is not None:
            result['Description'] = self.description
        if self.dubbo_rules is not None:
            result['DubboRules'] = self.dubbo_rules
        if self.name is not None:
            result['Name'] = self.name
        if self.sc_rules is not None:
            result['ScRules'] = self.sc_rules
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlbRules') is not None:
            self.alb_rules = m.get('AlbRules')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DubboRules') is not None:
            self.dubbo_rules = m.get('DubboRules')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ScRules') is not None:
            self.sc_rules = m.get('ScRules')
        return self


class CreateGreyTagRouteResponseBodyData(TeaModel):
    def __init__(
        self,
        grey_tag_route_id: int = None,
    ):
        # The ID of the canary release rule. The ID is globally unique.
        self.grey_tag_route_id = grey_tag_route_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grey_tag_route_id is not None:
            result['GreyTagRouteId'] = self.grey_tag_route_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GreyTagRouteId') is not None:
            self.grey_tag_route_id = m.get('GreyTagRouteId')
        return self


class CreateGreyTagRouteResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateGreyTagRouteResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The information about the canary release rule.
        self.data = data
        # The returned error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned information.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the information of the change order was queried. Valid values:
        # 
        # *   **true**: The information was queried.
        # *   **false**: The information failed to be queried.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateGreyTagRouteResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class CreateGreyTagRouteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateGreyTagRouteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateGreyTagRouteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateIngressRequest(TeaModel):
    def __init__(
        self,
        cert_id: str = None,
        cert_ids: str = None,
        default_rule: str = None,
        description: str = None,
        listener_port: int = None,
        listener_protocol: str = None,
        load_balance_type: str = None,
        namespace_id: str = None,
        rules: str = None,
        slb_id: str = None,
    ):
        # 188077086902\*\*\*\*\_176993d\*\*\*\*\_181437\*\*\*\*\_108724\*\*\*\*\
        self.cert_id = cert_id
        self.cert_ids = cert_ids
        # {"appId":"395b60e4-0550-458d-9c54-a265d036\*\*\*\*","containerPort":8080}
        self.default_rule = default_rule
        # ingress-for-sae-test
        self.description = description
        # 80
        self.listener_port = listener_port
        # HTTP
        self.listener_protocol = listener_protocol
        # clb
        self.load_balance_type = load_balance_type
        # cn-beijing:sae-test
        self.namespace_id = namespace_id
        # \[{"appId":"395b60e4-0550-458d-9c54-a265d036\*\*\*\*","containerPort":8080,"domain":"www.sae.site","path":"/path1"},{"appId":"666403ce-d25b-47cf-87fe-497565d2\*\*\*\*","containerPort":8080,"domain":"sae.site","path":"/path2"}]
        self.rules = rules
        # lb-uf6hucc7inlqrtcq5\*\*\*\*\
        self.slb_id = slb_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_id is not None:
            result['CertId'] = self.cert_id
        if self.cert_ids is not None:
            result['CertIds'] = self.cert_ids
        if self.default_rule is not None:
            result['DefaultRule'] = self.default_rule
        if self.description is not None:
            result['Description'] = self.description
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.listener_protocol is not None:
            result['ListenerProtocol'] = self.listener_protocol
        if self.load_balance_type is not None:
            result['LoadBalanceType'] = self.load_balance_type
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.rules is not None:
            result['Rules'] = self.rules
        if self.slb_id is not None:
            result['SlbId'] = self.slb_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertId') is not None:
            self.cert_id = m.get('CertId')
        if m.get('CertIds') is not None:
            self.cert_ids = m.get('CertIds')
        if m.get('DefaultRule') is not None:
            self.default_rule = m.get('DefaultRule')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('ListenerProtocol') is not None:
            self.listener_protocol = m.get('ListenerProtocol')
        if m.get('LoadBalanceType') is not None:
            self.load_balance_type = m.get('LoadBalanceType')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('Rules') is not None:
            self.rules = m.get('Rules')
        if m.get('SlbId') is not None:
            self.slb_id = m.get('SlbId')
        return self


class CreateIngressResponseBodyData(TeaModel):
    def __init__(
        self,
        ingress_id: int = None,
    ):
        # The ID of the routing rule.
        self.ingress_id = ingress_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ingress_id is not None:
            result['IngressId'] = self.ingress_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IngressId') is not None:
            self.ingress_id = m.get('IngressId')
        return self


class CreateIngressResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateIngressResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request failed.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the routing rule was created. Valid values:
        # 
        # *   **true**: indicates that the rule was created.
        # *   **false**: indicates that the rule could not be created.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateIngressResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class CreateIngressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateIngressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateIngressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateJobRequest(TeaModel):
    def __init__(
        self,
        acr_assume_role_arn: str = None,
        acr_instance_id: str = None,
        app_description: str = None,
        app_name: str = None,
        auto_config: bool = None,
        backoff_limit: int = None,
        command: str = None,
        command_args: str = None,
        concurrency_policy: str = None,
        config_map_mount_desc: str = None,
        cpu: int = None,
        custom_host_alias: str = None,
        edas_container_version: str = None,
        enable_image_accl: bool = None,
        envs: str = None,
        image_pull_secrets: str = None,
        image_url: str = None,
        jar_start_args: str = None,
        jar_start_options: str = None,
        jdk: str = None,
        memory: int = None,
        mount_desc: str = None,
        mount_host: str = None,
        namespace_id: str = None,
        nas_id: str = None,
        oss_ak_id: str = None,
        oss_ak_secret: str = None,
        oss_mount_descs: str = None,
        package_type: str = None,
        package_url: str = None,
        package_version: str = None,
        php_config: str = None,
        php_config_location: str = None,
        post_start: str = None,
        pre_stop: str = None,
        programming_language: str = None,
        python: str = None,
        python_modules: str = None,
        ref_app_id: str = None,
        replicas: int = None,
        security_group_id: str = None,
        slice: bool = None,
        slice_envs: str = None,
        sls_configs: str = None,
        termination_grace_period_seconds: int = None,
        timeout: int = None,
        timezone: str = None,
        tomcat_config: str = None,
        trigger_config: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
        war_start_options: str = None,
        web_container: str = None,
        workload: str = None,
    ):
        self.acr_assume_role_arn = acr_assume_role_arn
        self.acr_instance_id = acr_instance_id
        self.app_description = app_description
        self.app_name = app_name
        self.auto_config = auto_config
        self.backoff_limit = backoff_limit
        self.command = command
        self.command_args = command_args
        self.concurrency_policy = concurrency_policy
        self.config_map_mount_desc = config_map_mount_desc
        self.cpu = cpu
        self.custom_host_alias = custom_host_alias
        self.edas_container_version = edas_container_version
        self.enable_image_accl = enable_image_accl
        self.envs = envs
        self.image_pull_secrets = image_pull_secrets
        self.image_url = image_url
        self.jar_start_args = jar_start_args
        self.jar_start_options = jar_start_options
        self.jdk = jdk
        self.memory = memory
        self.mount_desc = mount_desc
        self.mount_host = mount_host
        self.namespace_id = namespace_id
        self.nas_id = nas_id
        self.oss_ak_id = oss_ak_id
        self.oss_ak_secret = oss_ak_secret
        self.oss_mount_descs = oss_mount_descs
        self.package_type = package_type
        self.package_url = package_url
        self.package_version = package_version
        self.php_config = php_config
        self.php_config_location = php_config_location
        self.post_start = post_start
        self.pre_stop = pre_stop
        self.programming_language = programming_language
        self.python = python
        self.python_modules = python_modules
        self.ref_app_id = ref_app_id
        self.replicas = replicas
        self.security_group_id = security_group_id
        self.slice = slice
        self.slice_envs = slice_envs
        self.sls_configs = sls_configs
        self.termination_grace_period_seconds = termination_grace_period_seconds
        self.timeout = timeout
        self.timezone = timezone
        self.tomcat_config = tomcat_config
        self.trigger_config = trigger_config
        self.v_switch_id = v_switch_id
        self.vpc_id = vpc_id
        self.war_start_options = war_start_options
        self.web_container = web_container
        self.workload = workload

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acr_assume_role_arn is not None:
            result['AcrAssumeRoleArn'] = self.acr_assume_role_arn
        if self.acr_instance_id is not None:
            result['AcrInstanceId'] = self.acr_instance_id
        if self.app_description is not None:
            result['AppDescription'] = self.app_description
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.auto_config is not None:
            result['AutoConfig'] = self.auto_config
        if self.backoff_limit is not None:
            result['BackoffLimit'] = self.backoff_limit
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        if self.concurrency_policy is not None:
            result['ConcurrencyPolicy'] = self.concurrency_policy
        if self.config_map_mount_desc is not None:
            result['ConfigMapMountDesc'] = self.config_map_mount_desc
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.custom_host_alias is not None:
            result['CustomHostAlias'] = self.custom_host_alias
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        if self.enable_image_accl is not None:
            result['EnableImageAccl'] = self.enable_image_accl
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.image_pull_secrets is not None:
            result['ImagePullSecrets'] = self.image_pull_secrets
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.jar_start_args is not None:
            result['JarStartArgs'] = self.jar_start_args
        if self.jar_start_options is not None:
            result['JarStartOptions'] = self.jar_start_options
        if self.jdk is not None:
            result['Jdk'] = self.jdk
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.mount_desc is not None:
            result['MountDesc'] = self.mount_desc
        if self.mount_host is not None:
            result['MountHost'] = self.mount_host
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.nas_id is not None:
            result['NasId'] = self.nas_id
        if self.oss_ak_id is not None:
            result['OssAkId'] = self.oss_ak_id
        if self.oss_ak_secret is not None:
            result['OssAkSecret'] = self.oss_ak_secret
        if self.oss_mount_descs is not None:
            result['OssMountDescs'] = self.oss_mount_descs
        if self.package_type is not None:
            result['PackageType'] = self.package_type
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.php_config is not None:
            result['PhpConfig'] = self.php_config
        if self.php_config_location is not None:
            result['PhpConfigLocation'] = self.php_config_location
        if self.post_start is not None:
            result['PostStart'] = self.post_start
        if self.pre_stop is not None:
            result['PreStop'] = self.pre_stop
        if self.programming_language is not None:
            result['ProgrammingLanguage'] = self.programming_language
        if self.python is not None:
            result['Python'] = self.python
        if self.python_modules is not None:
            result['PythonModules'] = self.python_modules
        if self.ref_app_id is not None:
            result['RefAppId'] = self.ref_app_id
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.slice is not None:
            result['Slice'] = self.slice
        if self.slice_envs is not None:
            result['SliceEnvs'] = self.slice_envs
        if self.sls_configs is not None:
            result['SlsConfigs'] = self.sls_configs
        if self.termination_grace_period_seconds is not None:
            result['TerminationGracePeriodSeconds'] = self.termination_grace_period_seconds
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.tomcat_config is not None:
            result['TomcatConfig'] = self.tomcat_config
        if self.trigger_config is not None:
            result['TriggerConfig'] = self.trigger_config
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.war_start_options is not None:
            result['WarStartOptions'] = self.war_start_options
        if self.web_container is not None:
            result['WebContainer'] = self.web_container
        if self.workload is not None:
            result['Workload'] = self.workload
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcrAssumeRoleArn') is not None:
            self.acr_assume_role_arn = m.get('AcrAssumeRoleArn')
        if m.get('AcrInstanceId') is not None:
            self.acr_instance_id = m.get('AcrInstanceId')
        if m.get('AppDescription') is not None:
            self.app_description = m.get('AppDescription')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AutoConfig') is not None:
            self.auto_config = m.get('AutoConfig')
        if m.get('BackoffLimit') is not None:
            self.backoff_limit = m.get('BackoffLimit')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        if m.get('ConcurrencyPolicy') is not None:
            self.concurrency_policy = m.get('ConcurrencyPolicy')
        if m.get('ConfigMapMountDesc') is not None:
            self.config_map_mount_desc = m.get('ConfigMapMountDesc')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CustomHostAlias') is not None:
            self.custom_host_alias = m.get('CustomHostAlias')
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        if m.get('EnableImageAccl') is not None:
            self.enable_image_accl = m.get('EnableImageAccl')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('ImagePullSecrets') is not None:
            self.image_pull_secrets = m.get('ImagePullSecrets')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('JarStartArgs') is not None:
            self.jar_start_args = m.get('JarStartArgs')
        if m.get('JarStartOptions') is not None:
            self.jar_start_options = m.get('JarStartOptions')
        if m.get('Jdk') is not None:
            self.jdk = m.get('Jdk')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('MountDesc') is not None:
            self.mount_desc = m.get('MountDesc')
        if m.get('MountHost') is not None:
            self.mount_host = m.get('MountHost')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NasId') is not None:
            self.nas_id = m.get('NasId')
        if m.get('OssAkId') is not None:
            self.oss_ak_id = m.get('OssAkId')
        if m.get('OssAkSecret') is not None:
            self.oss_ak_secret = m.get('OssAkSecret')
        if m.get('OssMountDescs') is not None:
            self.oss_mount_descs = m.get('OssMountDescs')
        if m.get('PackageType') is not None:
            self.package_type = m.get('PackageType')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('PhpConfig') is not None:
            self.php_config = m.get('PhpConfig')
        if m.get('PhpConfigLocation') is not None:
            self.php_config_location = m.get('PhpConfigLocation')
        if m.get('PostStart') is not None:
            self.post_start = m.get('PostStart')
        if m.get('PreStop') is not None:
            self.pre_stop = m.get('PreStop')
        if m.get('ProgrammingLanguage') is not None:
            self.programming_language = m.get('ProgrammingLanguage')
        if m.get('Python') is not None:
            self.python = m.get('Python')
        if m.get('PythonModules') is not None:
            self.python_modules = m.get('PythonModules')
        if m.get('RefAppId') is not None:
            self.ref_app_id = m.get('RefAppId')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('Slice') is not None:
            self.slice = m.get('Slice')
        if m.get('SliceEnvs') is not None:
            self.slice_envs = m.get('SliceEnvs')
        if m.get('SlsConfigs') is not None:
            self.sls_configs = m.get('SlsConfigs')
        if m.get('TerminationGracePeriodSeconds') is not None:
            self.termination_grace_period_seconds = m.get('TerminationGracePeriodSeconds')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('TomcatConfig') is not None:
            self.tomcat_config = m.get('TomcatConfig')
        if m.get('TriggerConfig') is not None:
            self.trigger_config = m.get('TriggerConfig')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('WarStartOptions') is not None:
            self.war_start_options = m.get('WarStartOptions')
        if m.get('WebContainer') is not None:
            self.web_container = m.get('WebContainer')
        if m.get('Workload') is not None:
            self.workload = m.get('Workload')
        return self


class CreateJobResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        change_order_id: str = None,
    ):
        self.app_id = app_id
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class CreateJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateJobResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class CreateJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateNamespaceRequest(TeaModel):
    def __init__(
        self,
        enable_micro_registration: bool = None,
        name_space_short_id: str = None,
        namespace_description: str = None,
        namespace_id: str = None,
        namespace_name: str = None,
    ):
        self.enable_micro_registration = enable_micro_registration
        self.name_space_short_id = name_space_short_id
        # desc
        self.namespace_description = namespace_description
        # cn-beijing:test
        self.namespace_id = namespace_id
        # name
        self.namespace_name = namespace_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_micro_registration is not None:
            result['EnableMicroRegistration'] = self.enable_micro_registration
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_description is not None:
            result['NamespaceDescription'] = self.namespace_description
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.namespace_name is not None:
            result['NamespaceName'] = self.namespace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableMicroRegistration') is not None:
            self.enable_micro_registration = m.get('EnableMicroRegistration')
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceDescription') is not None:
            self.namespace_description = m.get('NamespaceDescription')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NamespaceName') is not None:
            self.namespace_name = m.get('NamespaceName')
        return self


class CreateNamespaceResponseBodyData(TeaModel):
    def __init__(
        self,
        enable_micro_registration: bool = None,
        name_space_short_id: str = None,
        namespace_description: str = None,
        namespace_id: str = None,
        namespace_name: str = None,
        region_id: str = None,
    ):
        self.enable_micro_registration = enable_micro_registration
        self.name_space_short_id = name_space_short_id
        # The description of the namespace.
        self.namespace_description = namespace_description
        # The ID of the namespace.
        self.namespace_id = namespace_id
        # The name of the namespace.
        self.namespace_name = namespace_name
        # The region where the namespace resides.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_micro_registration is not None:
            result['EnableMicroRegistration'] = self.enable_micro_registration
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_description is not None:
            result['NamespaceDescription'] = self.namespace_description
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.namespace_name is not None:
            result['NamespaceName'] = self.namespace_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableMicroRegistration') is not None:
            self.enable_micro_registration = m.get('EnableMicroRegistration')
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceDescription') is not None:
            self.namespace_description = m.get('NamespaceDescription')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NamespaceName') is not None:
            self.namespace_name = m.get('NamespaceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateNamespaceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateNamespaceResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The information of the namespace.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the namespace was created. Valid values:
        # 
        # *   **true**: indicates that the namespace was created.
        # *   **false**: indicates that the namespace could not be created.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateNamespaceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class CreateNamespaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateNamespaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateNamespaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSecretRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
        secret_data: str = None,
        secret_name: str = None,
        secret_type: str = None,
    ):
        self.namespace_id = namespace_id
        self.secret_data = secret_data
        self.secret_name = secret_name
        self.secret_type = secret_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.secret_data is not None:
            result['SecretData'] = self.secret_data
        if self.secret_name is not None:
            result['SecretName'] = self.secret_name
        if self.secret_type is not None:
            result['SecretType'] = self.secret_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('SecretData') is not None:
            self.secret_data = m.get('SecretData')
        if m.get('SecretName') is not None:
            self.secret_name = m.get('SecretName')
        if m.get('SecretType') is not None:
            self.secret_type = m.get('SecretType')
        return self


class CreateSecretResponseBodyData(TeaModel):
    def __init__(
        self,
        secret_id: int = None,
    ):
        self.secret_id = secret_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.secret_id is not None:
            result['SecretId'] = self.secret_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SecretId') is not None:
            self.secret_id = m.get('SecretId')
        return self


class CreateSecretResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateSecretResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateSecretResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class CreateSecretResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSecretResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSecretResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # 017f39b8-dfa4-4e16-a84b-1dcee4b1\*\*\*\*\
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DeleteApplicationResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order that is used to query the task execution status.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class DeleteApplicationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DeleteApplicationResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The request is successful.
        # *   **3xx**: A redirection message is returned.
        # *   **4xx**: The request is invalid.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The returned results.
        self.data = data
        # The error code that is returned if the request fails.
        # 
        # *   If the request is successful, this parameter is not returned.****\
        # *   This parameter is returned only if the request failed.**** For more information about the values of this parameter, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   If the request is successful, **success** is returned.
        # *   If an error occurred, the error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the application is deleted. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The trace ID that is used to query details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DeleteApplicationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteApplicationScalingRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        scaling_rule_name: str = None,
    ):
        # 7171a6ca-d1cd-4928-8642-7d5cfe69\*\*\*\*\
        self.app_id = app_id
        # timer-0800-2100
        self.scaling_rule_name = scaling_rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.scaling_rule_name is not None:
            result['ScalingRuleName'] = self.scaling_rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ScalingRuleName') is not None:
            self.scaling_rule_name = m.get('ScalingRuleName')
        return self


class DeleteApplicationScalingRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.error_code = error_code
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteApplicationScalingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteApplicationScalingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteApplicationScalingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteConfigMapRequest(TeaModel):
    def __init__(
        self,
        config_map_id: int = None,
    ):
        # 1
        self.config_map_id = config_map_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        return self


class DeleteConfigMapResponseBodyData(TeaModel):
    def __init__(
        self,
        config_map_id: int = None,
    ):
        # The ID of the deleted ConfigMap instance.
        self.config_map_id = config_map_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        return self


class DeleteConfigMapResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DeleteConfigMapResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the call was successful.
        # *   **3xx**: indicates that the call was redirected.
        # *   **4xx**: indicates that the call failed.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned result.
        self.data = data
        # The returned error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned information. Valid values:
        # 
        # *   If the call is successful, **success** is returned.
        # *   If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the ConfigMap instance was deleted. Valid values:
        # 
        # *   **true**: The instance was deleted.
        # *   **false**: The instance failed to be deleted.
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DeleteConfigMapResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteConfigMapResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteConfigMapResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteConfigMapResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteGreyTagRouteRequest(TeaModel):
    def __init__(
        self,
        grey_tag_route_id: int = None,
    ):
        # 1
        self.grey_tag_route_id = grey_tag_route_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grey_tag_route_id is not None:
            result['GreyTagRouteId'] = self.grey_tag_route_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GreyTagRouteId') is not None:
            self.grey_tag_route_id = m.get('GreyTagRouteId')
        return self


class DeleteGreyTagRouteResponseBodyData(TeaModel):
    def __init__(
        self,
        grey_tag_route_id: int = None,
    ):
        # The ID of the canary release rule. The ID is globally unique.
        self.grey_tag_route_id = grey_tag_route_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grey_tag_route_id is not None:
            result['GreyTagRouteId'] = self.grey_tag_route_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GreyTagRouteId') is not None:
            self.grey_tag_route_id = m.get('GreyTagRouteId')
        return self


class DeleteGreyTagRouteResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DeleteGreyTagRouteResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The information about the canary release rule.
        self.data = data
        # The returned error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned information. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the information of the change order was queried. Valid values:
        # 
        # *   **true**: The information was queried.
        # *   **false**: The information failed to be queried.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DeleteGreyTagRouteResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteGreyTagRouteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteGreyTagRouteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteGreyTagRouteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteHistoryJobRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        job_id: str = None,
    ):
        self.app_id = app_id
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class DeleteHistoryJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteHistoryJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteHistoryJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteHistoryJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteIngressRequest(TeaModel):
    def __init__(
        self,
        ingress_id: int = None,
    ):
        # 87
        self.ingress_id = ingress_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ingress_id is not None:
            result['IngressId'] = self.ingress_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IngressId') is not None:
            self.ingress_id = m.get('IngressId')
        return self


class DeleteIngressResponseBodyData(TeaModel):
    def __init__(
        self,
        ingress_id: int = None,
    ):
        # The ID of the routing rule that you want to delete.
        self.ingress_id = ingress_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ingress_id is not None:
            result['IngressId'] = self.ingress_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IngressId') is not None:
            self.ingress_id = m.get('IngressId')
        return self


class DeleteIngressResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DeleteIngressResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request failed.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the routing rule was deleted. Valid values:
        # 
        # *   **true**: indicates that the routing rule was deleted.
        # *   **false**: indicates that the routing rule could not be deleted.
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DeleteIngressResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteIngressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteIngressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteIngressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteJobRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DeleteJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteNamespaceRequest(TeaModel):
    def __init__(
        self,
        name_space_short_id: str = None,
        namespace_id: str = None,
    ):
        self.name_space_short_id = name_space_short_id
        # cn-beijing:test
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class DeleteNamespaceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the namespace was deleted. Valid values:
        # 
        # *   **true**: indicates that the namespace was deleted.
        # *   **false**: indicates that the namespace could not be deleted.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteNamespaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteNamespaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteNamespaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSecretRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
        secret_id: int = None,
    ):
        self.namespace_id = namespace_id
        self.secret_id = secret_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.secret_id is not None:
            result['SecretId'] = self.secret_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('SecretId') is not None:
            self.secret_id = m.get('SecretId')
        return self


class DeleteSecretResponseBodyData(TeaModel):
    def __init__(
        self,
        secret_id: int = None,
    ):
        self.secret_id = secret_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.secret_id is not None:
            result['SecretId'] = self.secret_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SecretId') is not None:
            self.secret_id = m.get('SecretId')
        return self


class DeleteSecretResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DeleteSecretResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DeleteSecretResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteSecretResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSecretResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSecretResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeployApplicationRequest(TeaModel):
    def __init__(
        self,
        acr_assume_role_arn: str = None,
        acr_instance_id: str = None,
        app_id: str = None,
        associate_eip: bool = None,
        auto_enable_application_scaling_rule: bool = None,
        batch_wait_time: int = None,
        change_order_desc: str = None,
        command: str = None,
        command_args: str = None,
        config_map_mount_desc: str = None,
        custom_host_alias: str = None,
        deploy: str = None,
        edas_container_version: str = None,
        enable_ahas: str = None,
        enable_grey_tag_route: bool = None,
        envs: str = None,
        image_pull_secrets: str = None,
        image_url: str = None,
        jar_start_args: str = None,
        jar_start_options: str = None,
        jdk: str = None,
        kafka_configs: str = None,
        liveness: str = None,
        micro_registration: str = None,
        min_ready_instance_ratio: int = None,
        min_ready_instances: int = None,
        mount_desc: str = None,
        mount_host: str = None,
        nas_configs: str = None,
        nas_id: str = None,
        oss_ak_id: str = None,
        oss_ak_secret: str = None,
        oss_mount_descs: str = None,
        package_type: str = None,
        package_url: str = None,
        package_version: str = None,
        php_arms_config_location: str = None,
        php_config: str = None,
        php_config_location: str = None,
        post_start: str = None,
        pre_stop: str = None,
        pvtz_discovery_svc: str = None,
        python: str = None,
        python_modules: str = None,
        readiness: str = None,
        sls_configs: str = None,
        termination_grace_period_seconds: int = None,
        timezone: str = None,
        tomcat_config: str = None,
        update_strategy: str = None,
        war_start_options: str = None,
        web_container: str = None,
    ):
        # acs:ram::123456789012\*\*\*\*:role/adminrole
        self.acr_assume_role_arn = acr_assume_role_arn
        # cri-xxxxxx
        self.acr_instance_id = acr_instance_id
        # 7171a6ca-d1cd-4928-8642-7d5cfe69\*\*\*\*\
        self.app_id = app_id
        # true
        self.associate_eip = associate_eip
        # true
        self.auto_enable_application_scaling_rule = auto_enable_application_scaling_rule
        # 10
        self.batch_wait_time = batch_wait_time
        # Start Applications
        self.change_order_desc = change_order_desc
        # sleep
        self.command = command
        # 1d
        self.command_args = command_args
        # \[{"configMapId":16,"key":"test","mountPath":"/tmp"}]
        self.config_map_mount_desc = config_map_mount_desc
        # \[{"hostName":"samplehost","ip":"127.0.0.1"}]
        self.custom_host_alias = custom_host_alias
        self.deploy = deploy
        # 3.5.3
        self.edas_container_version = edas_container_version
        # false
        self.enable_ahas = enable_ahas
        # false
        self.enable_grey_tag_route = enable_grey_tag_route
        # \[{"name":"envtmp","value":"0"}]
        self.envs = envs
        self.image_pull_secrets = image_pull_secrets
        # registry.cn-hangzhou.aliyuncs.com/sae_test/ali_sae_test:0.0.1
        self.image_url = image_url
        # \-Xms4G -Xmx4G
        self.jar_start_args = jar_start_args
        # custom-option
        self.jar_start_options = jar_start_options
        # Open JDK 8
        self.jdk = jdk
        self.kafka_configs = kafka_configs
        # {"exec":{"command":\["sleep","5s"]},"initialDelaySeconds":10,"timeoutSeconds":11}
        self.liveness = liveness
        self.micro_registration = micro_registration
        # \-1
        self.min_ready_instance_ratio = min_ready_instance_ratio
        # 1
        self.min_ready_instances = min_ready_instances
        # \[{mountPath: "/tmp", nasPath: "/"}]
        self.mount_desc = mount_desc
        # 10d3b4bc9\*\*\*\*.com
        self.mount_host = mount_host
        self.nas_configs = nas_configs
        # 10d3b4\*\*\*\*\
        self.nas_id = nas_id
        # xxxxxx
        self.oss_ak_id = oss_ak_id
        # xxxxxx
        self.oss_ak_secret = oss_ak_secret
        # \[{"bucketName": "oss-bucket", "bucketPath": "data/user.data", "mountPath": "/usr/data/user.data", "readOnly": true}]
        self.oss_mount_descs = oss_mount_descs
        self.package_type = package_type
        # http://myoss.oss-cn-hangzhou.aliyuncs.com/my-buc/2019-06-30/\*\*\*\*.jar
        self.package_url = package_url
        # 1.0.1
        self.package_version = package_version
        # /usr/local/etc/php/conf.d/arms.ini
        self.php_arms_config_location = php_arms_config_location
        # k1=v1
        self.php_config = php_config
        # /usr/local/etc/php/php.ini
        self.php_config_location = php_config_location
        # {"exec":{"command":\["sh","-c","echo hello"]}}
        self.post_start = post_start
        # {"exec":{"command":\["sh","-c","echo hello"]}}
        self.pre_stop = pre_stop
        self.pvtz_discovery_svc = pvtz_discovery_svc
        self.python = python
        self.python_modules = python_modules
        # {"exec":{"command":\["sleep","6s"]},"initialDelaySeconds":15,"timeoutSeconds":12}
        self.readiness = readiness
        # \[{"logDir":"","logType":"stdout"},{"logDir":"/tmp/a.log"}]
        self.sls_configs = sls_configs
        # 10
        self.termination_grace_period_seconds = termination_grace_period_seconds
        # Asia/Shanghai
        self.timezone = timezone
        # {"port":8080,"contextPath":"/","maxThreads":400,"uriEncoding":"ISO-8859-1","useBodyEncodingForUri":true}
        self.tomcat_config = tomcat_config
        # {"type":"GrayBatchUpdate","batchUpdate":{"batch":2,"releaseType":"auto","batchWaitTime":1},"grayUpdate":{"gray":1}}
        self.update_strategy = update_strategy
        # CATALINA_OPTS=\\"$CATALINA_OPTS $Options\\" catalina.sh run
        self.war_start_options = war_start_options
        # apache-tomcat-7.0.91
        self.web_container = web_container

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acr_assume_role_arn is not None:
            result['AcrAssumeRoleArn'] = self.acr_assume_role_arn
        if self.acr_instance_id is not None:
            result['AcrInstanceId'] = self.acr_instance_id
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.associate_eip is not None:
            result['AssociateEip'] = self.associate_eip
        if self.auto_enable_application_scaling_rule is not None:
            result['AutoEnableApplicationScalingRule'] = self.auto_enable_application_scaling_rule
        if self.batch_wait_time is not None:
            result['BatchWaitTime'] = self.batch_wait_time
        if self.change_order_desc is not None:
            result['ChangeOrderDesc'] = self.change_order_desc
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        if self.config_map_mount_desc is not None:
            result['ConfigMapMountDesc'] = self.config_map_mount_desc
        if self.custom_host_alias is not None:
            result['CustomHostAlias'] = self.custom_host_alias
        if self.deploy is not None:
            result['Deploy'] = self.deploy
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        if self.enable_ahas is not None:
            result['EnableAhas'] = self.enable_ahas
        if self.enable_grey_tag_route is not None:
            result['EnableGreyTagRoute'] = self.enable_grey_tag_route
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.image_pull_secrets is not None:
            result['ImagePullSecrets'] = self.image_pull_secrets
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.jar_start_args is not None:
            result['JarStartArgs'] = self.jar_start_args
        if self.jar_start_options is not None:
            result['JarStartOptions'] = self.jar_start_options
        if self.jdk is not None:
            result['Jdk'] = self.jdk
        if self.kafka_configs is not None:
            result['KafkaConfigs'] = self.kafka_configs
        if self.liveness is not None:
            result['Liveness'] = self.liveness
        if self.micro_registration is not None:
            result['MicroRegistration'] = self.micro_registration
        if self.min_ready_instance_ratio is not None:
            result['MinReadyInstanceRatio'] = self.min_ready_instance_ratio
        if self.min_ready_instances is not None:
            result['MinReadyInstances'] = self.min_ready_instances
        if self.mount_desc is not None:
            result['MountDesc'] = self.mount_desc
        if self.mount_host is not None:
            result['MountHost'] = self.mount_host
        if self.nas_configs is not None:
            result['NasConfigs'] = self.nas_configs
        if self.nas_id is not None:
            result['NasId'] = self.nas_id
        if self.oss_ak_id is not None:
            result['OssAkId'] = self.oss_ak_id
        if self.oss_ak_secret is not None:
            result['OssAkSecret'] = self.oss_ak_secret
        if self.oss_mount_descs is not None:
            result['OssMountDescs'] = self.oss_mount_descs
        if self.package_type is not None:
            result['PackageType'] = self.package_type
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.php_arms_config_location is not None:
            result['PhpArmsConfigLocation'] = self.php_arms_config_location
        if self.php_config is not None:
            result['PhpConfig'] = self.php_config
        if self.php_config_location is not None:
            result['PhpConfigLocation'] = self.php_config_location
        if self.post_start is not None:
            result['PostStart'] = self.post_start
        if self.pre_stop is not None:
            result['PreStop'] = self.pre_stop
        if self.pvtz_discovery_svc is not None:
            result['PvtzDiscoverySvc'] = self.pvtz_discovery_svc
        if self.python is not None:
            result['Python'] = self.python
        if self.python_modules is not None:
            result['PythonModules'] = self.python_modules
        if self.readiness is not None:
            result['Readiness'] = self.readiness
        if self.sls_configs is not None:
            result['SlsConfigs'] = self.sls_configs
        if self.termination_grace_period_seconds is not None:
            result['TerminationGracePeriodSeconds'] = self.termination_grace_period_seconds
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.tomcat_config is not None:
            result['TomcatConfig'] = self.tomcat_config
        if self.update_strategy is not None:
            result['UpdateStrategy'] = self.update_strategy
        if self.war_start_options is not None:
            result['WarStartOptions'] = self.war_start_options
        if self.web_container is not None:
            result['WebContainer'] = self.web_container
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcrAssumeRoleArn') is not None:
            self.acr_assume_role_arn = m.get('AcrAssumeRoleArn')
        if m.get('AcrInstanceId') is not None:
            self.acr_instance_id = m.get('AcrInstanceId')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AssociateEip') is not None:
            self.associate_eip = m.get('AssociateEip')
        if m.get('AutoEnableApplicationScalingRule') is not None:
            self.auto_enable_application_scaling_rule = m.get('AutoEnableApplicationScalingRule')
        if m.get('BatchWaitTime') is not None:
            self.batch_wait_time = m.get('BatchWaitTime')
        if m.get('ChangeOrderDesc') is not None:
            self.change_order_desc = m.get('ChangeOrderDesc')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        if m.get('ConfigMapMountDesc') is not None:
            self.config_map_mount_desc = m.get('ConfigMapMountDesc')
        if m.get('CustomHostAlias') is not None:
            self.custom_host_alias = m.get('CustomHostAlias')
        if m.get('Deploy') is not None:
            self.deploy = m.get('Deploy')
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        if m.get('EnableAhas') is not None:
            self.enable_ahas = m.get('EnableAhas')
        if m.get('EnableGreyTagRoute') is not None:
            self.enable_grey_tag_route = m.get('EnableGreyTagRoute')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('ImagePullSecrets') is not None:
            self.image_pull_secrets = m.get('ImagePullSecrets')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('JarStartArgs') is not None:
            self.jar_start_args = m.get('JarStartArgs')
        if m.get('JarStartOptions') is not None:
            self.jar_start_options = m.get('JarStartOptions')
        if m.get('Jdk') is not None:
            self.jdk = m.get('Jdk')
        if m.get('KafkaConfigs') is not None:
            self.kafka_configs = m.get('KafkaConfigs')
        if m.get('Liveness') is not None:
            self.liveness = m.get('Liveness')
        if m.get('MicroRegistration') is not None:
            self.micro_registration = m.get('MicroRegistration')
        if m.get('MinReadyInstanceRatio') is not None:
            self.min_ready_instance_ratio = m.get('MinReadyInstanceRatio')
        if m.get('MinReadyInstances') is not None:
            self.min_ready_instances = m.get('MinReadyInstances')
        if m.get('MountDesc') is not None:
            self.mount_desc = m.get('MountDesc')
        if m.get('MountHost') is not None:
            self.mount_host = m.get('MountHost')
        if m.get('NasConfigs') is not None:
            self.nas_configs = m.get('NasConfigs')
        if m.get('NasId') is not None:
            self.nas_id = m.get('NasId')
        if m.get('OssAkId') is not None:
            self.oss_ak_id = m.get('OssAkId')
        if m.get('OssAkSecret') is not None:
            self.oss_ak_secret = m.get('OssAkSecret')
        if m.get('OssMountDescs') is not None:
            self.oss_mount_descs = m.get('OssMountDescs')
        if m.get('PackageType') is not None:
            self.package_type = m.get('PackageType')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('PhpArmsConfigLocation') is not None:
            self.php_arms_config_location = m.get('PhpArmsConfigLocation')
        if m.get('PhpConfig') is not None:
            self.php_config = m.get('PhpConfig')
        if m.get('PhpConfigLocation') is not None:
            self.php_config_location = m.get('PhpConfigLocation')
        if m.get('PostStart') is not None:
            self.post_start = m.get('PostStart')
        if m.get('PreStop') is not None:
            self.pre_stop = m.get('PreStop')
        if m.get('PvtzDiscoverySvc') is not None:
            self.pvtz_discovery_svc = m.get('PvtzDiscoverySvc')
        if m.get('Python') is not None:
            self.python = m.get('Python')
        if m.get('PythonModules') is not None:
            self.python_modules = m.get('PythonModules')
        if m.get('Readiness') is not None:
            self.readiness = m.get('Readiness')
        if m.get('SlsConfigs') is not None:
            self.sls_configs = m.get('SlsConfigs')
        if m.get('TerminationGracePeriodSeconds') is not None:
            self.termination_grace_period_seconds = m.get('TerminationGracePeriodSeconds')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('TomcatConfig') is not None:
            self.tomcat_config = m.get('TomcatConfig')
        if m.get('UpdateStrategy') is not None:
            self.update_strategy = m.get('UpdateStrategy')
        if m.get('WarStartOptions') is not None:
            self.war_start_options = m.get('WarStartOptions')
        if m.get('WebContainer') is not None:
            self.web_container = m.get('WebContainer')
        return self


class DeployApplicationResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        change_order_id: str = None,
        is_need_approval: bool = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The ID of the change order. It can be used to query the task status.
        self.change_order_id = change_order_id
        # Specifies whether approval is required when a RAM user performs release. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.is_need_approval = is_need_approval

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.is_need_approval is not None:
            result['IsNeedApproval'] = self.is_need_approval
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('IsNeedApproval') is not None:
            self.is_need_approval = m.get('IsNeedApproval')
        return self


class DeployApplicationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DeployApplicationResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code returned when the method fails to be called.
        # 
        # *   If the request is successful, this parameter is not returned.****\
        # *   This parameter is returned only if the request failed.**** For more information, see the "**Error codes**" section in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the application deployment is successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DeployApplicationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeployApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeployApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeployApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAppServiceDetailRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        service_group: str = None,
        service_name: str = None,
        service_type: str = None,
        service_version: str = None,
    ):
        # 6dcc8c9e-d3da-478a-a066-86dcf820\*\*\*\*\
        self.app_id = app_id
        # springCloud
        self.service_group = service_group
        # edas.service.provider
        self.service_name = service_name
        # springCloud
        self.service_type = service_type
        # 1.0.0
        self.service_version = service_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.service_group is not None:
            result['ServiceGroup'] = self.service_group
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        if self.service_type is not None:
            result['ServiceType'] = self.service_type
        if self.service_version is not None:
            result['ServiceVersion'] = self.service_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ServiceGroup') is not None:
            self.service_group = m.get('ServiceGroup')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        if m.get('ServiceType') is not None:
            self.service_type = m.get('ServiceType')
        if m.get('ServiceVersion') is not None:
            self.service_version = m.get('ServiceVersion')
        return self


class DescribeAppServiceDetailResponseBodyDataMethodsParameterDefinitions(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        type: str = None,
    ):
        # The description of the parameter.
        self.description = description
        # The name of the parameter.
        self.name = name
        # The type of the parameter.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeAppServiceDetailResponseBodyDataMethods(TeaModel):
    def __init__(
        self,
        method_controller: str = None,
        name: str = None,
        name_detail: str = None,
        parameter_definitions: List[DescribeAppServiceDetailResponseBodyDataMethodsParameterDefinitions] = None,
        parameter_details: List[str] = None,
        parameter_types: List[str] = None,
        paths: List[str] = None,
        request_methods: List[str] = None,
        return_details: str = None,
        return_type: str = None,
    ):
        # The class to which the method belongs.
        self.method_controller = method_controller
        # The name of the method.
        self.name = name
        # The details of the method.
        self.name_detail = name_detail
        # The definition of the parameter.
        self.parameter_definitions = parameter_definitions
        # The details of the parameters.
        self.parameter_details = parameter_details
        # The types of the parameters.
        self.parameter_types = parameter_types
        # The request paths. Format:
        # 
        # `/path`
        self.paths = paths
        # The request methods. Valid values:
        # 
        # *   **GET**\
        # *   **ALL**\
        self.request_methods = request_methods
        # The details of the response.
        self.return_details = return_details
        # The data format of the response.
        self.return_type = return_type

    def validate(self):
        if self.parameter_definitions:
            for k in self.parameter_definitions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.method_controller is not None:
            result['MethodController'] = self.method_controller
        if self.name is not None:
            result['Name'] = self.name
        if self.name_detail is not None:
            result['NameDetail'] = self.name_detail
        result['ParameterDefinitions'] = []
        if self.parameter_definitions is not None:
            for k in self.parameter_definitions:
                result['ParameterDefinitions'].append(k.to_map() if k else None)
        if self.parameter_details is not None:
            result['ParameterDetails'] = self.parameter_details
        if self.parameter_types is not None:
            result['ParameterTypes'] = self.parameter_types
        if self.paths is not None:
            result['Paths'] = self.paths
        if self.request_methods is not None:
            result['RequestMethods'] = self.request_methods
        if self.return_details is not None:
            result['ReturnDetails'] = self.return_details
        if self.return_type is not None:
            result['ReturnType'] = self.return_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MethodController') is not None:
            self.method_controller = m.get('MethodController')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NameDetail') is not None:
            self.name_detail = m.get('NameDetail')
        self.parameter_definitions = []
        if m.get('ParameterDefinitions') is not None:
            for k in m.get('ParameterDefinitions'):
                temp_model = DescribeAppServiceDetailResponseBodyDataMethodsParameterDefinitions()
                self.parameter_definitions.append(temp_model.from_map(k))
        if m.get('ParameterDetails') is not None:
            self.parameter_details = m.get('ParameterDetails')
        if m.get('ParameterTypes') is not None:
            self.parameter_types = m.get('ParameterTypes')
        if m.get('Paths') is not None:
            self.paths = m.get('Paths')
        if m.get('RequestMethods') is not None:
            self.request_methods = m.get('RequestMethods')
        if m.get('ReturnDetails') is not None:
            self.return_details = m.get('ReturnDetails')
        if m.get('ReturnType') is not None:
            self.return_type = m.get('ReturnType')
        return self


class DescribeAppServiceDetailResponseBodyData(TeaModel):
    def __init__(
        self,
        dubbo_application_name: str = None,
        edas_app_name: str = None,
        group: str = None,
        metadata: Dict[str, Any] = None,
        methods: List[DescribeAppServiceDetailResponseBodyDataMethods] = None,
        service_name: str = None,
        service_type: str = None,
        spring_application_name: str = None,
        version: str = None,
    ):
        # The name of the Dubbo application.
        self.dubbo_application_name = dubbo_application_name
        # The name of the application.
        self.edas_app_name = edas_app_name
        # The group to which the service belongs. You can create a custom group.
        self.group = group
        # The metadata. Example: `{side: "provider", port: "18081", preserved: {register: {source: "SPRING_CLOUD"}},}`.
        self.metadata = metadata
        # The methods.
        self.methods = methods
        # The name of the service.
        self.service_name = service_name
        # The type of the service. Valid values:
        # 
        # *   **dubbo**\
        # *   **springCloud**\
        self.service_type = service_type
        # The name of the Spring Cloud application.
        self.spring_application_name = spring_application_name
        # The version of the service. You can create a custom version.
        self.version = version

    def validate(self):
        if self.methods:
            for k in self.methods:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dubbo_application_name is not None:
            result['DubboApplicationName'] = self.dubbo_application_name
        if self.edas_app_name is not None:
            result['EdasAppName'] = self.edas_app_name
        if self.group is not None:
            result['Group'] = self.group
        if self.metadata is not None:
            result['Metadata'] = self.metadata
        result['Methods'] = []
        if self.methods is not None:
            for k in self.methods:
                result['Methods'].append(k.to_map() if k else None)
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        if self.service_type is not None:
            result['ServiceType'] = self.service_type
        if self.spring_application_name is not None:
            result['SpringApplicationName'] = self.spring_application_name
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DubboApplicationName') is not None:
            self.dubbo_application_name = m.get('DubboApplicationName')
        if m.get('EdasAppName') is not None:
            self.edas_app_name = m.get('EdasAppName')
        if m.get('Group') is not None:
            self.group = m.get('Group')
        if m.get('Metadata') is not None:
            self.metadata = m.get('Metadata')
        self.methods = []
        if m.get('Methods') is not None:
            for k in m.get('Methods'):
                temp_model = DescribeAppServiceDetailResponseBodyDataMethods()
                self.methods.append(temp_model.from_map(k))
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        if m.get('ServiceType') is not None:
            self.service_type = m.get('ServiceType')
        if m.get('SpringApplicationName') is not None:
            self.spring_application_name = m.get('SpringApplicationName')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DescribeAppServiceDetailResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeAppServiceDetailResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # - **2xx**: indicates that the call was successful.
        # - **3xx**: indicates that the call was redirected.
        # - **4xx**: indicates that the call failed.
        # - **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The returned error code. Valid values:
        # 
        # - If the call is successful, the **ErrorCode** parameter is not returned.
        # - If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned information.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the meta data was obtained. Valid values:
        # 
        # *   **true**: The metadata was obtained.
        # *   **false**: The metadata failed to be obtained.
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeAppServiceDetailResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeAppServiceDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAppServiceDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAppServiceDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApplicationConfigRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        version_id: str = None,
    ):
        # 7171a6ca-d1cd-4928-8642-7d5cfe69\*\*\*\*\
        self.app_id = app_id
        # 0026ff7f-2b57-4127-bdd0-9bf202bb\*\*\*\*\
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class DescribeApplicationConfigResponseBodyDataConfigMapMountDesc(TeaModel):
    def __init__(
        self,
        config_map_id: int = None,
        config_map_name: str = None,
        key: str = None,
        mount_path: str = None,
    ):
        # The ID of the ConfigMap.
        self.config_map_id = config_map_id
        # The name of the ConfigMap.
        self.config_map_name = config_map_name
        # The key-value pair that is stored in the ConfigMap.
        self.key = key
        # The path on which the ConfigMap is mounted.
        self.mount_path = mount_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        if self.config_map_name is not None:
            result['ConfigMapName'] = self.config_map_name
        if self.key is not None:
            result['Key'] = self.key
        if self.mount_path is not None:
            result['MountPath'] = self.mount_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        if m.get('ConfigMapName') is not None:
            self.config_map_name = m.get('ConfigMapName')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('MountPath') is not None:
            self.mount_path = m.get('MountPath')
        return self


class DescribeApplicationConfigResponseBodyDataMountDesc(TeaModel):
    def __init__(
        self,
        mount_path: str = None,
        nas_path: str = None,
    ):
        # The path on which the NAS file system is mounted.
        self.mount_path = mount_path
        # The directory in the NAS file system.
        self.nas_path = nas_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mount_path is not None:
            result['MountPath'] = self.mount_path
        if self.nas_path is not None:
            result['NasPath'] = self.nas_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MountPath') is not None:
            self.mount_path = m.get('MountPath')
        if m.get('NasPath') is not None:
            self.nas_path = m.get('NasPath')
        return self


class DescribeApplicationConfigResponseBodyDataOssMountDescs(TeaModel):
    def __init__(
        self,
        bucket_name: str = None,
        bucket_path: str = None,
        mount_path: str = None,
        read_only: bool = None,
    ):
        # The name of the bucket.
        self.bucket_name = bucket_name
        # The directory or object that you created in the OSS bucket. If the specified object or directory is invalid, an exception occurs.
        self.bucket_path = bucket_path
        # The directory of your container in SAE. The parameter value that you specified overwrites the original value. If the specified directory does not exist, SAE automatically creates the directory.
        self.mount_path = mount_path
        # Indicates whether the application can use the container directory to read data from or write data to resources in the directory of the OSS bucket. Valid values:
        # 
        # *   **true**: The application has read-only permissions.
        # *   **false**: The application has read and write permissions.
        self.read_only = read_only

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['bucketName'] = self.bucket_name
        if self.bucket_path is not None:
            result['bucketPath'] = self.bucket_path
        if self.mount_path is not None:
            result['mountPath'] = self.mount_path
        if self.read_only is not None:
            result['readOnly'] = self.read_only
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bucketName') is not None:
            self.bucket_name = m.get('bucketName')
        if m.get('bucketPath') is not None:
            self.bucket_path = m.get('bucketPath')
        if m.get('mountPath') is not None:
            self.mount_path = m.get('mountPath')
        if m.get('readOnly') is not None:
            self.read_only = m.get('readOnly')
        return self


class DescribeApplicationConfigResponseBodyDataTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeApplicationConfigResponseBodyData(TeaModel):
    def __init__(
        self,
        acr_assume_role_arn: str = None,
        acr_instance_id: str = None,
        app_description: str = None,
        app_id: str = None,
        app_name: str = None,
        associate_eip: bool = None,
        batch_wait_time: int = None,
        command: str = None,
        command_args: str = None,
        config_map_mount_desc: List[DescribeApplicationConfigResponseBodyDataConfigMapMountDesc] = None,
        cpu: int = None,
        custom_host_alias: str = None,
        edas_container_version: str = None,
        enable_ahas: str = None,
        enable_grey_tag_route: bool = None,
        envs: str = None,
        image_pull_secrets: str = None,
        image_url: str = None,
        jar_start_args: str = None,
        jar_start_options: str = None,
        jdk: str = None,
        kafka_configs: str = None,
        liveness: str = None,
        memory: int = None,
        micro_registration: str = None,
        min_ready_instance_ratio: int = None,
        min_ready_instances: int = None,
        mount_desc: List[DescribeApplicationConfigResponseBodyDataMountDesc] = None,
        mount_host: str = None,
        mse_application_id: str = None,
        namespace_id: str = None,
        nas_configs: str = None,
        nas_id: str = None,
        oss_ak_id: str = None,
        oss_ak_secret: str = None,
        oss_mount_descs: List[DescribeApplicationConfigResponseBodyDataOssMountDescs] = None,
        package_type: str = None,
        package_url: str = None,
        package_version: str = None,
        php_arms_config_location: str = None,
        php_config: str = None,
        php_config_location: str = None,
        post_start: str = None,
        pre_stop: str = None,
        programming_language: str = None,
        pvtz_discovery: str = None,
        python: str = None,
        python_modules: str = None,
        readiness: str = None,
        region_id: str = None,
        replicas: int = None,
        security_group_id: str = None,
        sls_configs: str = None,
        tags: List[DescribeApplicationConfigResponseBodyDataTags] = None,
        termination_grace_period_seconds: int = None,
        timezone: str = None,
        tomcat_config: str = None,
        update_strategy: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
        war_start_options: str = None,
        web_container: str = None,
    ):
        # The Alibaba Cloud Resource Name (ARN) of the RAM role that is used to pull images across accounts. For more information, see [Pull images across Alibaba Cloud accounts](~~190675~~) and [Grant permissions across Alibaba Cloud accounts by using a RAM role](~~223585~~).
        self.acr_assume_role_arn = acr_assume_role_arn
        # The ID of the Container Registry Enterprise Edition instance.
        self.acr_instance_id = acr_instance_id
        # The description of the application.
        self.app_description = app_description
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name
        # Indicates whether an elastic IP address (EIP) is associated with the application instance. Valid values:
        # 
        # *   **true**: The EIP is associated with the application instance.
        # *   **false**: The EIP is not associated with the application instance.
        self.associate_eip = associate_eip
        # The interval between batches in a phased release. Unit: seconds.
        self.batch_wait_time = batch_wait_time
        # The command that is used to start the image. The command must be an existing executable object in the container. Example:
        # 
        # ```
        # 
        # command:
        #       - echo
        #       - abc
        #       - >
        #       - file0
        # ```
        # 
        # In this example, the Command parameter is set to `Command="echo", CommandArgs=["abc", ">", "file0"]`.
        self.command = command
        # The parameters of the image startup command. The CommandArgs parameter contains the parameters that are required for the **Command** parameter. Format:
        # 
        # `["a","b"]`
        # 
        # In the preceding **Command** example, the CommandArgs parameter is set to `CommandArgs=["abc", ">", "file0"]`. The data type of `["abc", ">", "file0"]` must be an array of strings in the JSON format. You do not need to configure this parameter if it does not exist in the Command parameter.
        self.command_args = command_args
        # The details of the ConfigMap.
        self.config_map_mount_desc = config_map_mount_desc
        # The CPU specifications that are required for each instance. Unit: millicores. You cannot set this parameter to 0. Valid values:
        # 
        # *   **500**\
        # *   **1000**\
        # *   **2000**\
        # *   **4000**\
        # *   **8000**\
        # *   **16000**\
        # *   **32000**\
        self.cpu = cpu
        # The custom mappings between hostnames and IP addresses in the container. Valid values:
        # 
        # *   **hostName**: the domain name or hostname.
        # *   **ip**: the IP address.
        self.custom_host_alias = custom_host_alias
        # The version of the container, such as Ali-Tomcat, in which an application developed based on High-speed Service Framework (HSF) is deployed.
        self.edas_container_version = edas_container_version
        # Indicates whether access to Application High Availability Service (AHAS) is enabled. Valid values:
        # 
        # *   **true**: Access to AHAS is enabled.
        # *   **false**: Access to AHAS is disabled.
        self.enable_ahas = enable_ahas
        # Indicates whether canary release rules are enabled. Canary release rules apply only to applications in Spring Cloud and Dubbo frameworks. Valid values:
        # 
        # *   **true**: The canary release rules are enabled.
        # *   **false**: The canary release rules are disabled.
        self.enable_grey_tag_route = enable_grey_tag_route
        # The environment variables. Variable description:
        # 
        # *   **name**: the name of the environment variable.
        # *   **value**: the value or reference of the environment variable.
        self.envs = envs
        self.image_pull_secrets = image_pull_secrets
        # The URL of the image. This parameter is returned only if the **PackageType** parameter is set to **Image**.
        self.image_url = image_url
        # The arguments in the JAR package. The arguments are used to start the application container. The default startup command is `$JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs`.
        self.jar_start_args = jar_start_args
        # The option settings in the JAR package. The settings are used to start the application container. The default startup command is `$JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs`.
        self.jar_start_options = jar_start_options
        # The version of the Java development kit (JDK) on which the deployment package of the application depends. The following versions are supported:
        # 
        # *   **Open JDK 8**\
        # *   **Open JDK 7**\
        # *   **Dragonwell 11**\
        # *   **Dragonwell 8**\
        # *   **openjdk-8u191-jdk-alpine3.9**\
        # *   **openjdk-7u201-jdk-alpine3.9**\
        # 
        # This parameter is not returned if the **PackageType** parameter is set to **Image**.
        self.jdk = jdk
        # The logging configurations of Message Queue for Apache Kafka. The following parameters are involved:
        # 
        # *   **KafkaConfigs**: the configurations of Message Queue for Apache Kafka.
        # 
        # *   **createTime**: the time when the Message Queue for Apache Kafka instance was created.
        # 
        # *   **kafkaTopic**: the message topic that is used to classify messages.
        # 
        # *   **logDir**: the path in which logs are stored.
        # 
        # *   **logType**: the type of collected logs. Valid values:
        # 
        #     *   **file_log**: the file log that is stored in the container. The path of the file logs in the container is returned.
        #     *   **stdout**: the standard output log of the container. You can specify only one stdout value.
        # 
        # *   **kafkaEndpoint**: the endpoint of the Message Queue for Apache Kafka service.
        # 
        # *   **kafkaInstanceId**: the ID of the Message Queue for Apache Kafka instance.
        # 
        # *   **region**: the region where the Message Queue for Apache Kafka instance resides.
        self.kafka_configs = kafka_configs
        # The details of the availability check that was performed on the container. If the container fails this health check multiple times, the system disables and restarts the container. You can use one of the following methods to perform the health check:
        # 
        # *   Sample code of the **exec** method: `{"exec":{"command":["sh","-c","cat/home/admin/start.sh"]},"initialDelaySeconds":30,"periodSeconds":30,"timeoutSeconds":2}`
        # *   Sample code of the **httpGet** method: `{"httpGet":{"path":"/","port":18091,"scheme":"HTTP","isContainKeyWord":true,"keyWord":"SAE"},"initialDelaySeconds":11,"periodSeconds":10,"timeoutSeconds":1}`
        # *   Sample code of the **tcpSocket** method: `{"tcpSocket":{"port":18091},"initialDelaySeconds":11,"periodSeconds":10,"timeoutSeconds":1}`
        # 
        # >  You can use only one method to perform the health check.
        # 
        # The following parameters are involved:
        # 
        # *   **exec.command**: the health check command.
        # *   **httpGet.path**: the request path.
        # *   **httpGet.scheme**: the protocol that is used to perform the health check. Valid values: **HTTP** and **HTTPS**.
        # *   **httpGet.isContainKeyWord**: indicates whether the response contains keywords. Valid values: **true** and **false**. If this field is not returned, the advanced settings are not used.
        # *   **httpGet.keyWord**: the custom keyword. This parameter is available only if the **isContainKeyWord** field is returned.
        # *   **tcpSocket.port**: the port that is used to check the status of TCP connections.
        # *   **initialDelaySeconds**: the delay of the health check. Default value: 10. Unit: seconds.
        # *   **periodSeconds**: the interval at which health checks are performed. Default value: 30. Unit: seconds.
        # *   **timeoutSeconds**: the timeout period of the health check. Default value: 1. Unit: seconds. If you set this parameter to 0 or leave this parameter empty, the timeout period is automatically set to 1 second.
        self.liveness = liveness
        # The size of memory required by each instance. Unit: MB. You cannot set this parameter to 0. The values of this parameter correspond to the values of the Cpu parameter:
        # 
        # *   This parameter is set to **1024** if the Cpu parameter is set to 500 or 1000.
        # *   This parameter is set to **2048** if the Cpu parameter is set to 500, 1000, or 1000.
        # *   This parameter is set to **4096** if the Cpu parameter is set to 1000, 2000, or 4000.
        # *   This parameter is set to **8192** if the Cpu parameter is set to 2000, 4000, or 8000.
        # *   This parameter is set to **12288** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **16384** if the Cpu parameter is set to 4000, 8000, or 16000.
        # *   This parameter is set to **24567** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **32768** if the Cpu parameter is set to 16000.
        # *   This parameter is set to **65536** if the Cpu parameter is set to 8000, 16000, or 32000.
        # *   This parameter is set to **131072** if the Cpu parameter is set to 32000.
        self.memory = memory
        self.micro_registration = micro_registration
        # The percentage of the minimum number of available instances. Valid values:
        # 
        # *   **-1**: the default value. This value indicates that the minimum number of available instances is not measured by percentage. If you do not configure this parameter, the default value **-1** is used.
        # *   **0 to 100**: indicates that the minimum number of available instances is calculated by using the following formula: Current number of instances  (Value of MinReadyInstanceRatio  100%). If the calculated result is not an integer, the result is rounded up to the nearest integer. For example, if the percentage is set to **50**% and five instances are available, the minimum number of available instances is 3.
        # 
        # >  If the **MinReadyInstance** and **MinReadyInstanceRatio** parameters are returned and the value of the **MinReadyInstanceRatio** parameter is not **-1**, the value of the **MinReadyInstanceRatio** parameter takes effect. If the **MinReadyInstances** parameter is set to **5** and the **MinReadyInstanceRatio** parameter is set to **50**, the value of the **MinReadyInstanceRatio** parameter determines the minimum number of available instances.
        self.min_ready_instance_ratio = min_ready_instance_ratio
        # The minimum number of available instances. Valid values:
        # 
        # *   If you set the value to **0**, business interruptions occur when the application is updated.
        # *   If you set the value to **-1**, the minimum number of available instances is automatically set to a system-recommended value. The value is the nearest integer to which the calculated result of the following formula is rounded up: Current number of instances  25%. For example, if five instances are available, the minimum number of available instances is calculated by using the following formula: 5  25% = 1.25. In this case, the minimum number of available instances is 2.
        # 
        # >  Make sure that at least one instance is available during application deployment and rollback to prevent business interruptions.
        self.min_ready_instances = min_ready_instances
        # The details of the mounted NAS file system.
        self.mount_desc = mount_desc
        # The mount target of the NAS file system in the VPC where the application is deployed. If you do not need to modify this configuration during the deployment, configure the **MountHost** parameter only in the first request. You do not need to include this parameter in subsequent requests. If you need to remove this configuration, leave the **MountHost** parameter empty in the request.
        self.mount_host = mount_host
        # The ID of the microservice application.
        self.mse_application_id = mse_application_id
        # The ID of the namespace.
        self.namespace_id = namespace_id
        self.nas_configs = nas_configs
        # The ID of the NAS file system.
        self.nas_id = nas_id
        # The AccessKey ID that is used to read data from and write data to Object Storage Service (OSS) buckets.
        self.oss_ak_id = oss_ak_id
        # The AccessKey secret that is used to read data from and write data to OSS buckets.
        self.oss_ak_secret = oss_ak_secret
        # The description of the mounted OSS bucket.
        self.oss_mount_descs = oss_mount_descs
        # The type of the deployment package. Valid values:
        # 
        # *   If you deploy the application by using a Java Archive (JAR) package, you can set this parameter to **FatJar**, **War**, or **Image**.
        # 
        # *   If you deploy the application by using a PHP package, you can set this parameter to one of the following values:
        # 
        #     *   **PhpZip**\
        #     *   **IMAGE_PHP\_5\_4**\
        #     *   **IMAGE_PHP\_5\_4\_ALPINE**\
        #     *   **IMAGE_PHP\_5\_5**\
        #     *   **IMAGE_PHP\_5\_5\_ALPINE**\
        #     *   **IMAGE_PHP\_5\_6**\
        #     *   **IMAGE_PHP\_5\_6\_ALPINE**\
        #     *   **IMAGE_PHP\_7\_0**\
        #     *   **IMAGE_PHP\_7\_0\_ALPINE**\
        #     *   **IMAGE_PHP\_7\_1**\
        #     *   **IMAGE_PHP\_7\_1\_ALPINE**\
        #     *   **IMAGE_PHP\_7\_2**\
        #     *   **IMAGE_PHP\_7\_2\_ALPINE**\
        #     *   **IMAGE_PHP\_7\_3**\
        #     *   **IMAGE_PHP\_7\_3\_ALPINE**\
        self.package_type = package_type
        # The URL of the deployment package. This parameter is returned only if the **PackageType** parameter is set to **FatJar** or **War**.
        self.package_url = package_url
        # The version of the deployment package. This parameter is returned only if the **PackageType** parameter is set to **FatJar** or **War**.
        self.package_version = package_version
        # The path on which the PHP configuration file for application monitoring is mounted. Make sure that the PHP server loads the configuration file.
        # 
        # SAE automatically generates the corresponding configuration file. No manual operations are required.
        self.php_arms_config_location = php_arms_config_location
        # The details of the PHP configuration file.
        self.php_config = php_config
        # The path on which the PHP configuration file for application startup is mounted. Make sure that the PHP server uses this configuration file during the startup.
        self.php_config_location = php_config_location
        # The script that is run immediately after the container is started. Example: `{"exec":{"command":["cat","/etc/group"]}}`
        self.post_start = post_start
        # The script that is run before the container is stopped. Example: `{"exec":{"command":["cat","/etc/group"]}}`
        self.pre_stop = pre_stop
        # The programming language that is used to create the application. Valid values:
        # 
        # *   **java**: Java
        # *   **php**: PHP
        # *   **other**: Other programming languages, such as Python, C++, Go, .NET, and Node.js.
        self.programming_language = programming_language
        self.pvtz_discovery = pvtz_discovery
        self.python = python
        self.python_modules = python_modules
        # The details of the health check that was performed on the container. If the container fails this health check multiple times, the system disables and restarts the container. Containers that fail health checks cannot receive traffic from Server Load Balancer (SLB) instances. You can use the **exec**, **httpGet**, or **tcpSocket** method to perform health checks. For more information, see the description of the **Liveness** parameter.
        # 
        # >  You can use only one method to perform the health check.
        self.readiness = readiness
        # The ID of the region.
        self.region_id = region_id
        # The number of application instances.
        self.replicas = replicas
        # The ID of the security group.
        self.security_group_id = security_group_id
        # The logging configurations of Log Service.
        # 
        # *   To use Log Service resources that are automatically created by SAE, set this parameter to `[{"logDir":"","logType":"stdout"},{"logDir":"/tmp/a.log"}]`.
        # *   To use custom Log Service resources, set this parameter to `[{"projectName":"test-sls","logType":"stdout","logDir":"","logstoreName":"sae","logtailName":""},{"projectName":"test","logDir":"/tmp/a.log","logstoreName":"sae","logtailName":""}]`.
        # 
        # The following parameters are involved:
        # 
        # *   **projectName**: the name of the Log Service project.
        # *   **logDir**: the path in which logs are stored.
        # *   **logType**: the log type. **stdout**: the standard output log of the container. You can specify only one stdout value for this parameter. If you leave this parameter empty, file logs are collected.
        # *   **logstoreName**: the name of the Logstore in Log Service.
        # *   **logtailName**: the name of the Logtail configuration in Log Service. If you do not configure this parameter, a new Logtail configuration is created.
        # 
        # If you do not need to modify the logging configurations when you deploy the application, configure the **SlsConfigs** parameter only in the first request. You do not need to include this parameter in subsequent requests. If you no longer need to use Log Service, leave the **SlsConfigs** parameter empty in the request.
        self.sls_configs = sls_configs
        # The details of the tags.
        self.tags = tags
        # The timeout period for a graceful shutdown. Default value: 30. Unit: seconds. Valid values: 1 to 300.
        self.termination_grace_period_seconds = termination_grace_period_seconds
        # The time zone. Default value: **Asia/Shanghai**.
        self.timezone = timezone
        # The Tomcat configuration. If you want to delete the configuration, set this parameter to {} or leave this parameter empty. The following parameters are involved:
        # 
        # *   **port**: the port number. Valid values: 1024 to 65535. The root permissions are required to perform operations on ports whose number is smaller than 1024. Enter a value that ranges from 1025 to 65535 because the container has only the admin permissions. If you do not configure this parameter, the default port number 8080 is used.
        # *   **contextPath**: the path. Default value: /. This value indicates the root directory.
        # *   **maxThreads**: the maximum number of connections in the connection pool. Default value: 400.
        # *   **uriEncoding**: the URI encoding scheme in the Tomcat container. Valid values: **UTF-8**, **ISO-8859-1**, **GBK**, and **GB2312**. If you do not configure this parameter, the default value **ISO-8859-1** is used.
        # *   **useBodyEncoding**: indicates whether to use the encoding scheme that is specified by **BodyEncoding for URL**. Default value: **true**.
        self.tomcat_config = tomcat_config
        # The deployment policy. If the minimum number of available instances is 1, the value of the **UpdateStrategy** parameter is an empty string (""). If the minimum number of available instances is greater than 1, the following strategies can be configured:
        # 
        # *   The application is deployed on an instance. The remaining instances are automatically classified into two release batches whose interval is set to 1. In this case, the parameter is set to `{"type":"GrayBatchUpdate","batchUpdate":{"batch":2,"releaseType":"auto","batchWaitTime":1},"grayUpdate":{"gray":1}}`.
        # *   The application is deployed on an instance. The remaining instances are manually classified into two release batches. In this case, the parameter is set to `{"type":"GrayBatchUpdate","batchUpdate":{"batch":2,"releaseType":"manual"},"grayUpdate":{"gray":1}}`.
        # *   All instances are automatically classified into two release batches. The application is deployed on the instances of the two batches in parallel. In this case, the parameter is set to `{"type":"BatchUpdate","batchUpdate":{"batch":2,"releaseType":"auto","batchWaitTime":0}}`
        # 
        # The following parameters are involved:
        # 
        # *   **type**: the type of the release policy. Valid values: **GrayBatchUpdate** and **BatchUpdate**.
        # 
        # *   **batchUpdate**: the phased release policy.
        # 
        #     *   **batch**: the number of release batches.
        #     *   **releaseType**: the processing method for the batches. Valid values: **auto** and **manual**.
        #     *   **batchWaitTime**: the interval between release batches. Unit: seconds.
        # 
        # *   **grayUpdate**: the number of release batches in the phased release after a canary release. This parameter is returned only if the **type** parameter is set to **GrayBatchUpdate**.
        self.update_strategy = update_strategy
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id
        # The option settings in the WAR package. The settings are used to start the application container. The default startup command is `java $JAVA_OPTS $CATALINA_OPTS -Options org.apache.catalina.startup.Bootstrap "$@" start`.
        self.war_start_options = war_start_options
        # The version of the Tomcat container on which the deployment package depends. Valid values:
        # 
        # *   **apache-tomcat-7.0.91**\
        # *   **apache-tomcat-8.5.42**\
        # 
        # This parameter is not returned if the **PackageType** parameter is set to **Image**.
        self.web_container = web_container

    def validate(self):
        if self.config_map_mount_desc:
            for k in self.config_map_mount_desc:
                if k:
                    k.validate()
        if self.mount_desc:
            for k in self.mount_desc:
                if k:
                    k.validate()
        if self.oss_mount_descs:
            for k in self.oss_mount_descs:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acr_assume_role_arn is not None:
            result['AcrAssumeRoleArn'] = self.acr_assume_role_arn
        if self.acr_instance_id is not None:
            result['AcrInstanceId'] = self.acr_instance_id
        if self.app_description is not None:
            result['AppDescription'] = self.app_description
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.associate_eip is not None:
            result['AssociateEip'] = self.associate_eip
        if self.batch_wait_time is not None:
            result['BatchWaitTime'] = self.batch_wait_time
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        result['ConfigMapMountDesc'] = []
        if self.config_map_mount_desc is not None:
            for k in self.config_map_mount_desc:
                result['ConfigMapMountDesc'].append(k.to_map() if k else None)
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.custom_host_alias is not None:
            result['CustomHostAlias'] = self.custom_host_alias
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        if self.enable_ahas is not None:
            result['EnableAhas'] = self.enable_ahas
        if self.enable_grey_tag_route is not None:
            result['EnableGreyTagRoute'] = self.enable_grey_tag_route
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.image_pull_secrets is not None:
            result['ImagePullSecrets'] = self.image_pull_secrets
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.jar_start_args is not None:
            result['JarStartArgs'] = self.jar_start_args
        if self.jar_start_options is not None:
            result['JarStartOptions'] = self.jar_start_options
        if self.jdk is not None:
            result['Jdk'] = self.jdk
        if self.kafka_configs is not None:
            result['KafkaConfigs'] = self.kafka_configs
        if self.liveness is not None:
            result['Liveness'] = self.liveness
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.micro_registration is not None:
            result['MicroRegistration'] = self.micro_registration
        if self.min_ready_instance_ratio is not None:
            result['MinReadyInstanceRatio'] = self.min_ready_instance_ratio
        if self.min_ready_instances is not None:
            result['MinReadyInstances'] = self.min_ready_instances
        result['MountDesc'] = []
        if self.mount_desc is not None:
            for k in self.mount_desc:
                result['MountDesc'].append(k.to_map() if k else None)
        if self.mount_host is not None:
            result['MountHost'] = self.mount_host
        if self.mse_application_id is not None:
            result['MseApplicationId'] = self.mse_application_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.nas_configs is not None:
            result['NasConfigs'] = self.nas_configs
        if self.nas_id is not None:
            result['NasId'] = self.nas_id
        if self.oss_ak_id is not None:
            result['OssAkId'] = self.oss_ak_id
        if self.oss_ak_secret is not None:
            result['OssAkSecret'] = self.oss_ak_secret
        result['OssMountDescs'] = []
        if self.oss_mount_descs is not None:
            for k in self.oss_mount_descs:
                result['OssMountDescs'].append(k.to_map() if k else None)
        if self.package_type is not None:
            result['PackageType'] = self.package_type
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.php_arms_config_location is not None:
            result['PhpArmsConfigLocation'] = self.php_arms_config_location
        if self.php_config is not None:
            result['PhpConfig'] = self.php_config
        if self.php_config_location is not None:
            result['PhpConfigLocation'] = self.php_config_location
        if self.post_start is not None:
            result['PostStart'] = self.post_start
        if self.pre_stop is not None:
            result['PreStop'] = self.pre_stop
        if self.programming_language is not None:
            result['ProgrammingLanguage'] = self.programming_language
        if self.pvtz_discovery is not None:
            result['PvtzDiscovery'] = self.pvtz_discovery
        if self.python is not None:
            result['Python'] = self.python
        if self.python_modules is not None:
            result['PythonModules'] = self.python_modules
        if self.readiness is not None:
            result['Readiness'] = self.readiness
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.sls_configs is not None:
            result['SlsConfigs'] = self.sls_configs
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.termination_grace_period_seconds is not None:
            result['TerminationGracePeriodSeconds'] = self.termination_grace_period_seconds
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.tomcat_config is not None:
            result['TomcatConfig'] = self.tomcat_config
        if self.update_strategy is not None:
            result['UpdateStrategy'] = self.update_strategy
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.war_start_options is not None:
            result['WarStartOptions'] = self.war_start_options
        if self.web_container is not None:
            result['WebContainer'] = self.web_container
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcrAssumeRoleArn') is not None:
            self.acr_assume_role_arn = m.get('AcrAssumeRoleArn')
        if m.get('AcrInstanceId') is not None:
            self.acr_instance_id = m.get('AcrInstanceId')
        if m.get('AppDescription') is not None:
            self.app_description = m.get('AppDescription')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AssociateEip') is not None:
            self.associate_eip = m.get('AssociateEip')
        if m.get('BatchWaitTime') is not None:
            self.batch_wait_time = m.get('BatchWaitTime')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        self.config_map_mount_desc = []
        if m.get('ConfigMapMountDesc') is not None:
            for k in m.get('ConfigMapMountDesc'):
                temp_model = DescribeApplicationConfigResponseBodyDataConfigMapMountDesc()
                self.config_map_mount_desc.append(temp_model.from_map(k))
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CustomHostAlias') is not None:
            self.custom_host_alias = m.get('CustomHostAlias')
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        if m.get('EnableAhas') is not None:
            self.enable_ahas = m.get('EnableAhas')
        if m.get('EnableGreyTagRoute') is not None:
            self.enable_grey_tag_route = m.get('EnableGreyTagRoute')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('ImagePullSecrets') is not None:
            self.image_pull_secrets = m.get('ImagePullSecrets')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('JarStartArgs') is not None:
            self.jar_start_args = m.get('JarStartArgs')
        if m.get('JarStartOptions') is not None:
            self.jar_start_options = m.get('JarStartOptions')
        if m.get('Jdk') is not None:
            self.jdk = m.get('Jdk')
        if m.get('KafkaConfigs') is not None:
            self.kafka_configs = m.get('KafkaConfigs')
        if m.get('Liveness') is not None:
            self.liveness = m.get('Liveness')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('MicroRegistration') is not None:
            self.micro_registration = m.get('MicroRegistration')
        if m.get('MinReadyInstanceRatio') is not None:
            self.min_ready_instance_ratio = m.get('MinReadyInstanceRatio')
        if m.get('MinReadyInstances') is not None:
            self.min_ready_instances = m.get('MinReadyInstances')
        self.mount_desc = []
        if m.get('MountDesc') is not None:
            for k in m.get('MountDesc'):
                temp_model = DescribeApplicationConfigResponseBodyDataMountDesc()
                self.mount_desc.append(temp_model.from_map(k))
        if m.get('MountHost') is not None:
            self.mount_host = m.get('MountHost')
        if m.get('MseApplicationId') is not None:
            self.mse_application_id = m.get('MseApplicationId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NasConfigs') is not None:
            self.nas_configs = m.get('NasConfigs')
        if m.get('NasId') is not None:
            self.nas_id = m.get('NasId')
        if m.get('OssAkId') is not None:
            self.oss_ak_id = m.get('OssAkId')
        if m.get('OssAkSecret') is not None:
            self.oss_ak_secret = m.get('OssAkSecret')
        self.oss_mount_descs = []
        if m.get('OssMountDescs') is not None:
            for k in m.get('OssMountDescs'):
                temp_model = DescribeApplicationConfigResponseBodyDataOssMountDescs()
                self.oss_mount_descs.append(temp_model.from_map(k))
        if m.get('PackageType') is not None:
            self.package_type = m.get('PackageType')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('PhpArmsConfigLocation') is not None:
            self.php_arms_config_location = m.get('PhpArmsConfigLocation')
        if m.get('PhpConfig') is not None:
            self.php_config = m.get('PhpConfig')
        if m.get('PhpConfigLocation') is not None:
            self.php_config_location = m.get('PhpConfigLocation')
        if m.get('PostStart') is not None:
            self.post_start = m.get('PostStart')
        if m.get('PreStop') is not None:
            self.pre_stop = m.get('PreStop')
        if m.get('ProgrammingLanguage') is not None:
            self.programming_language = m.get('ProgrammingLanguage')
        if m.get('PvtzDiscovery') is not None:
            self.pvtz_discovery = m.get('PvtzDiscovery')
        if m.get('Python') is not None:
            self.python = m.get('Python')
        if m.get('PythonModules') is not None:
            self.python_modules = m.get('PythonModules')
        if m.get('Readiness') is not None:
            self.readiness = m.get('Readiness')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SlsConfigs') is not None:
            self.sls_configs = m.get('SlsConfigs')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = DescribeApplicationConfigResponseBodyDataTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TerminationGracePeriodSeconds') is not None:
            self.termination_grace_period_seconds = m.get('TerminationGracePeriodSeconds')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('TomcatConfig') is not None:
            self.tomcat_config = m.get('TomcatConfig')
        if m.get('UpdateStrategy') is not None:
            self.update_strategy = m.get('UpdateStrategy')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('WarStartOptions') is not None:
            self.war_start_options = m.get('WarStartOptions')
        if m.get('WebContainer') is not None:
            self.web_container = m.get('WebContainer')
        return self


class DescribeApplicationConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeApplicationConfigResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The details of the application.
        self.data = data
        # The returned error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned information.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the configurations of an application were obtained. Valid values:
        # 
        # *   **true**: The configurations were obtained.
        # *   **false**: The configurations failed to be obtained.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeApplicationConfigResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeApplicationConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApplicationConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApplicationConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApplicationGroupsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        current_page: int = None,
        page_size: int = None,
    ):
        # d700e680-aa4d-4ec1-afc2-6566b5ff\*\*\*\*\
        self.app_id = app_id
        # 1
        self.current_page = current_page
        # 10
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeApplicationGroupsResponseBodyData(TeaModel):
    def __init__(
        self,
        edas_container_version: str = None,
        group_id: str = None,
        group_name: str = None,
        group_type: int = None,
        image_url: str = None,
        jdk: str = None,
        package_type: str = None,
        package_url: str = None,
        package_version: str = None,
        replicas: int = None,
        running_instances: int = None,
        web_container: str = None,
    ):
        # The version of the container, such as Ali-Tomcat, in which a High-speed Service Framework (HSF) application runs.
        self.edas_container_version = edas_container_version
        # The ID of the group.
        self.group_id = group_id
        # The name of the group.
        self.group_name = group_name
        # The type of the group.
        self.group_type = group_type
        # The address of the image. This parameter is required when the **PackageType** parameter is set to **Image**.
        self.image_url = image_url
        # The version of the Java development kit (JDK) on which the deployment package of the application depends. This parameter is invalid when the **PackageType** parameter is set to **Image**.
        self.jdk = jdk
        # The type of the application deployment package. Valid values:
        # 
        # *   When you use a Java package, set this value to **FatJar**, **War**, or **Image**.
        # 
        # *   When you use a PHP package, the following values are valid:
        # 
        #     *   **PhpZip**\
        #     *   **IMAGE_PHP\_5\_4**\
        #     *   **IMAGE_PHP\_5\_4\_ALPINE**\
        #     *   **IMAGE_PHP\_5\_5**\
        #     *   **IMAGE_PHP\_5\_5\_ALPINE**\
        #     *   **IMAGE_PHP\_5\_6**\
        #     *   **IMAGE_PHP\_5\_6\_ALPINE**\
        #     *   **IMAGE_PHP\_7\_0**\
        #     *   **IMAGE_PHP\_7\_0\_ALPINE**\
        #     *   **IMAGE_PHP\_7\_1**\
        #     *   **IMAGE_PHP\_7\_1\_ALPINE**\
        #     *   **IMAGE_PHP\_7\_2**\
        #     *   **IMAGE_PHP\_7\_2\_ALPINE**\
        #     *   **IMAGE_PHP\_7\_3**\
        #     *   **IMAGE_PHP\_7\_3\_ALPINE**\
        self.package_type = package_type
        # The address of the deployment package. This parameter is required when the **PackageType** parameter is set to **FatJar**, **War**, or **PhpZip**.
        self.package_url = package_url
        # The version of the deployment package. This parameter is required when the **PackageType** parameter is set to **FatJar**, **War**, or **PhpZip**. The parameter value will be automatically generated when you use an image to deploy the application and specify the **ImageUrl** parameter.
        self.package_version = package_version
        # The total number of instances.
        self.replicas = replicas
        # The number of running instances.
        self.running_instances = running_instances
        # The version of the Apache Tomcat container on which the deployment package of the application depends. This parameter is invalid when the **PackageType** parameter is set to **Image**.
        self.web_container = web_container

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.jdk is not None:
            result['Jdk'] = self.jdk
        if self.package_type is not None:
            result['PackageType'] = self.package_type
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.running_instances is not None:
            result['RunningInstances'] = self.running_instances
        if self.web_container is not None:
            result['WebContainer'] = self.web_container
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('Jdk') is not None:
            self.jdk = m.get('Jdk')
        if m.get('PackageType') is not None:
            self.package_type = m.get('PackageType')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('RunningInstances') is not None:
            self.running_instances = m.get('RunningInstances')
        if m.get('WebContainer') is not None:
            self.web_container = m.get('WebContainer')
        return self


class DescribeApplicationGroupsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[DescribeApplicationGroupsResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The information about the instance groups of the application.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the information about instance groups of an application was obtained. Valid values:
        # 
        # *   **true**: indicates that the information was obtained.
        # *   **false**: indicates that the information could not be obtained.
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeApplicationGroupsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeApplicationGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApplicationGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApplicationGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApplicationImageRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        image_url: str = None,
    ):
        # d700e680-aa4d-4ec1-afc2-6566b5ff\*\*\*\*\
        self.app_id = app_id
        # registry-vpc.cn-hangzhou.aliyuncs.com/demo/demo:latest
        self.image_url = image_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        return self


class DescribeApplicationImageResponseBodyData(TeaModel):
    def __init__(
        self,
        cr_url: str = None,
        logo: str = None,
        region_id: str = None,
        repo_name: str = None,
        repo_namespace: str = None,
        repo_origin_type: str = None,
        repo_tag: str = None,
        repo_type: str = None,
    ):
        # This parameter is reserved.
        self.cr_url = cr_url
        # This parameter is reserved.
        self.logo = logo
        # The ID of the region.
        self.region_id = region_id
        # The name of the repository.
        self.repo_name = repo_name
        # The name of the namespace to which the repository belongs.
        self.repo_namespace = repo_namespace
        # The type of the repository. Only Container Registry is supported.
        self.repo_origin_type = repo_origin_type
        # The tag of the image.
        self.repo_tag = repo_tag
        # This parameter is reserved.
        self.repo_type = repo_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cr_url is not None:
            result['CrUrl'] = self.cr_url
        if self.logo is not None:
            result['Logo'] = self.logo
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.repo_origin_type is not None:
            result['RepoOriginType'] = self.repo_origin_type
        if self.repo_tag is not None:
            result['RepoTag'] = self.repo_tag
        if self.repo_type is not None:
            result['RepoType'] = self.repo_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CrUrl') is not None:
            self.cr_url = m.get('CrUrl')
        if m.get('Logo') is not None:
            self.logo = m.get('Logo')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RepoOriginType') is not None:
            self.repo_origin_type = m.get('RepoOriginType')
        if m.get('RepoTag') is not None:
            self.repo_tag = m.get('RepoTag')
        if m.get('RepoType') is not None:
            self.repo_type = m.get('RepoType')
        return self


class DescribeApplicationImageResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeApplicationImageResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The information about the image of an application.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the image information was obtained. Valid values:
        # 
        # *   **true**: indicates that the information was obtained.
        # *   **false**: indicates that the information could not be obtained.
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeApplicationImageResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeApplicationImageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApplicationImageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApplicationImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApplicationInstancesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        current_page: int = None,
        group_id: str = None,
        page_size: int = None,
        reverse: bool = None,
    ):
        # d700e680-aa4d-4ec1-afc2-6566b5ff\*\*\*\*\
        self.app_id = app_id
        # 1
        self.current_page = current_page
        # b2a8a925-477a-4ed7-b825-d5e22500\*\*\*\*\
        self.group_id = group_id
        # 10
        self.page_size = page_size
        # true
        self.reverse = reverse

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.reverse is not None:
            result['Reverse'] = self.reverse
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Reverse') is not None:
            self.reverse = m.get('Reverse')
        return self


class DescribeApplicationInstancesResponseBodyDataInstances(TeaModel):
    def __init__(
        self,
        create_time_stamp: int = None,
        debug_status: bool = None,
        eip: str = None,
        finish_time_stamp: int = None,
        group_id: str = None,
        image_url: str = None,
        instance_container_ip: str = None,
        instance_container_restarts: int = None,
        instance_container_status: str = None,
        instance_health_status: str = None,
        instance_id: str = None,
        package_version: str = None,
        v_switch_id: str = None,
    ):
        # The start time of the instance creation process. Unit: milliseconds.
        self.create_time_stamp = create_time_stamp
        self.debug_status = debug_status
        # The elastic IP address (EIP).
        self.eip = eip
        # The end time of the instance creation process. Unit: milliseconds.
        self.finish_time_stamp = finish_time_stamp
        # The ID of the group to which the instance belongs.
        self.group_id = group_id
        # The address of the repository.
        # 
        # >  If you deploy the application by using a JAR or WAR package, the image generated by SAE is not available for download.
        self.image_url = image_url
        # The internal IP address of the instance.
        self.instance_container_ip = instance_container_ip
        # The number of times that the instance restarted.
        self.instance_container_restarts = instance_container_restarts
        # The state of the instance. Valid values:
        # 
        # *   **Error**: An error occurred during the instance startup.
        # *   **CrashLoopBackOff**: The container failed to start. An error occurred during the startup process and persisted after the restart.
        # *   **ErrImagePull**: An error occurred while the container image was being pulled from the instance.
        # *   **ImagePullBackOff**: The container image could not be obtained.
        # *   **Pending**: The instance is waiting to be scheduled.
        # *   **Unknown**: An unknown exception occurred.
        # *   **Terminating**: The instance creation process is being terminated.
        # *   **NotFound**: The instance cannot be found.
        # *   **PodInitializing**: The instance is being initialized.
        # *   **Init:0/1**: The instance is initialized.
        # *   **Running**: The instance is running.
        self.instance_container_status = instance_container_status
        # The configurations of health checks. Valid values:
        # 
        # *   **WithoutHealthCheckConfig**: Liveness and readiness checks are not configured.
        # *   **WithoutLivenessConfig**: The liveness check is not configured.
        # *   **WithoutReadinessConfig**: The readiness check is not configured.
        # *   **NotCheckedYet**: The health checks are not performed or are in progress.
        # *   **LivenessUnhealthy**: The instance failed the liveness check.
        # *   **ReadinessUnhealthy**: The instance failed the readiness check.
        # *   **Unhealthy**: The instance failed both liveness and readiness checks.
        # *   **Healthy**: The instance passed both liveness and readiness checks.
        self.instance_health_status = instance_health_status
        # The ID of the instance.
        self.instance_id = instance_id
        # The version of the package.
        self.package_version = package_version
        # The ID of the zone where the instance is deployed.
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time_stamp is not None:
            result['CreateTimeStamp'] = self.create_time_stamp
        if self.debug_status is not None:
            result['DebugStatus'] = self.debug_status
        if self.eip is not None:
            result['Eip'] = self.eip
        if self.finish_time_stamp is not None:
            result['FinishTimeStamp'] = self.finish_time_stamp
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.instance_container_ip is not None:
            result['InstanceContainerIp'] = self.instance_container_ip
        if self.instance_container_restarts is not None:
            result['InstanceContainerRestarts'] = self.instance_container_restarts
        if self.instance_container_status is not None:
            result['InstanceContainerStatus'] = self.instance_container_status
        if self.instance_health_status is not None:
            result['InstanceHealthStatus'] = self.instance_health_status
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTimeStamp') is not None:
            self.create_time_stamp = m.get('CreateTimeStamp')
        if m.get('DebugStatus') is not None:
            self.debug_status = m.get('DebugStatus')
        if m.get('Eip') is not None:
            self.eip = m.get('Eip')
        if m.get('FinishTimeStamp') is not None:
            self.finish_time_stamp = m.get('FinishTimeStamp')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('InstanceContainerIp') is not None:
            self.instance_container_ip = m.get('InstanceContainerIp')
        if m.get('InstanceContainerRestarts') is not None:
            self.instance_container_restarts = m.get('InstanceContainerRestarts')
        if m.get('InstanceContainerStatus') is not None:
            self.instance_container_status = m.get('InstanceContainerStatus')
        if m.get('InstanceHealthStatus') is not None:
            self.instance_health_status = m.get('InstanceHealthStatus')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeApplicationInstancesResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        instances: List[DescribeApplicationInstancesResponseBodyDataInstances] = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # The number of the returned page.
        self.current_page = current_page
        # The list of application instances.
        self.instances = instances
        # The number of entries returned on each page.
        self.page_size = page_size
        # The total number of returned instances.
        self.total_size = total_size

    def validate(self):
        if self.instances:
            for k in self.instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['Instances'] = []
        if self.instances is not None:
            for k in self.instances:
                result['Instances'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.instances = []
        if m.get('Instances') is not None:
            for k in m.get('Instances'):
                temp_model = DescribeApplicationInstancesResponseBodyDataInstances()
                self.instances.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class DescribeApplicationInstancesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeApplicationInstancesResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The details of the application instances.
        self.data = data
        # The error code. 
        # 
        # - The **ErrorCode** parameter is not returned when the request succeeds.
        # - The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the list of application instances was obtained. Valid values:
        # 
        # *   **true**: indicates that the list was obtained.
        # *   **false**: indicates that the list could not be obtained.
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeApplicationInstancesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeApplicationInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApplicationInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApplicationInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApplicationScalingRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        scaling_rule_name: str = None,
    ):
        # a0d2e04c-159d-40a8-b240-d2f2c263\*\*\*\*\
        self.app_id = app_id
        # test
        self.scaling_rule_name = scaling_rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.scaling_rule_name is not None:
            result['ScalingRuleName'] = self.scaling_rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ScalingRuleName') is not None:
            self.scaling_rule_name = m.get('ScalingRuleName')
        return self


class DescribeApplicationScalingRuleResponseBodyDataMetricMetrics(TeaModel):
    def __init__(
        self,
        metric_target_average_utilization: int = None,
        metric_type: str = None,
    ):
        # The limit on the metric.
        # 
        # *   The limit on the CPU utilization. Unit: percentage.
        # *   The limit on the memory usage. Unit: percentage.
        # *   The limit on the average number of active TCP connections per second.
        # *   The limit on the QPS of the Internet-facing SLB instance.
        # *   The limit on the response time of the Internet-facing SLB instance. Unit: milliseconds.
        self.metric_target_average_utilization = metric_target_average_utilization
        # The metric that is used to trigger the auto scaling policy. Valid values:
        # 
        # *   **CPU**: the CPU utilization.
        # *   **MEMORY**: the memory usage.
        # *   **tcpActiveConn**: the average number of active TCP connections for an instance in 30 seconds.
        # *   **SLB_QPS**: the average QPS of the Internet-facing SLB instance associated with an application instance in 15 seconds.
        # *   **SLB_RT**: the average response time of the Internet-facing SLB instance in 15 seconds.
        self.metric_type = metric_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_target_average_utilization is not None:
            result['MetricTargetAverageUtilization'] = self.metric_target_average_utilization
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetricTargetAverageUtilization') is not None:
            self.metric_target_average_utilization = m.get('MetricTargetAverageUtilization')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        return self


class DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusCurrentMetrics(TeaModel):
    def __init__(
        self,
        current_value: int = None,
        name: str = None,
        type: str = None,
    ):
        # The current value of the metric.
        self.current_value = current_value
        # The name of the metric.
        # 
        # *   **cpu**: the CPU utilization.
        # *   **memory**: the memory usage.
        # *   **tcpActiveConn**: the number of active TCP connections.
        # *   **slb_incall_qps**: the QPS of the Internet-facing SLB instance.
        # *   **slb_incall_rt**: the response time of the Internet-facing SLB instance.
        self.name = name
        # The type of the data. This parameter corresponds to the metric.
        # 
        # *   **Resource**: used when the metric is the **CPU utilization** or **memory usage**.
        # *   **Pods**: used when the metric is the **number of active TCP connections**.
        # *   **External**: used when the metric is about the **SLB** instance or from **Application Real-Time Monitoring Service (ARMS)**.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_value is not None:
            result['CurrentValue'] = self.current_value
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentValue') is not None:
            self.current_value = m.get('CurrentValue')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusNextScaleMetrics(TeaModel):
    def __init__(
        self,
        name: str = None,
        next_scale_in_average_utilization: int = None,
        next_scale_out_average_utilization: int = None,
    ):
        # The name of the metric.
        # 
        # *   **cpu**: the CPU utilization.
        # *   **memory**: the memory usage.
        # *   **tcpActiveConn**: the number of active TCP connections.
        # *   **slb_incall_qps**: the QPS of the Internet-facing SLB instance.
        # *   **slb_incall_rt**: the response time of the Internet-facing SLB instance.
        self.name = name
        # The metric value as a percentage that triggers the application scale-in next time.
        self.next_scale_in_average_utilization = next_scale_in_average_utilization
        # The metric value as a percentage that triggers the application scale-out next time.
        self.next_scale_out_average_utilization = next_scale_out_average_utilization

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.next_scale_in_average_utilization is not None:
            result['NextScaleInAverageUtilization'] = self.next_scale_in_average_utilization
        if self.next_scale_out_average_utilization is not None:
            result['NextScaleOutAverageUtilization'] = self.next_scale_out_average_utilization
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NextScaleInAverageUtilization') is not None:
            self.next_scale_in_average_utilization = m.get('NextScaleInAverageUtilization')
        if m.get('NextScaleOutAverageUtilization') is not None:
            self.next_scale_out_average_utilization = m.get('NextScaleOutAverageUtilization')
        return self


class DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatus(TeaModel):
    def __init__(
        self,
        current_metrics: List[DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusCurrentMetrics] = None,
        current_replicas: int = None,
        desired_replicas: int = None,
        last_scale_time: str = None,
        next_scale_metrics: List[DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusNextScaleMetrics] = None,
        next_scale_time_period: int = None,
    ):
        # The metrics that is used to trigger the current auto scaling policy.
        self.current_metrics = current_metrics
        # The current number of instances.
        self.current_replicas = current_replicas
        # The expected number of instances.
        self.desired_replicas = desired_replicas
        # The time when the auto scaling policy was last triggered.
        self.last_scale_time = last_scale_time
        # The metrics that are used to trigger the auto scaling policy next time.
        self.next_scale_metrics = next_scale_metrics
        # The duration for which the metric-based auto scaling policy takes effect next time.
        self.next_scale_time_period = next_scale_time_period

    def validate(self):
        if self.current_metrics:
            for k in self.current_metrics:
                if k:
                    k.validate()
        if self.next_scale_metrics:
            for k in self.next_scale_metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CurrentMetrics'] = []
        if self.current_metrics is not None:
            for k in self.current_metrics:
                result['CurrentMetrics'].append(k.to_map() if k else None)
        if self.current_replicas is not None:
            result['CurrentReplicas'] = self.current_replicas
        if self.desired_replicas is not None:
            result['DesiredReplicas'] = self.desired_replicas
        if self.last_scale_time is not None:
            result['LastScaleTime'] = self.last_scale_time
        result['NextScaleMetrics'] = []
        if self.next_scale_metrics is not None:
            for k in self.next_scale_metrics:
                result['NextScaleMetrics'].append(k.to_map() if k else None)
        if self.next_scale_time_period is not None:
            result['NextScaleTimePeriod'] = self.next_scale_time_period
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.current_metrics = []
        if m.get('CurrentMetrics') is not None:
            for k in m.get('CurrentMetrics'):
                temp_model = DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusCurrentMetrics()
                self.current_metrics.append(temp_model.from_map(k))
        if m.get('CurrentReplicas') is not None:
            self.current_replicas = m.get('CurrentReplicas')
        if m.get('DesiredReplicas') is not None:
            self.desired_replicas = m.get('DesiredReplicas')
        if m.get('LastScaleTime') is not None:
            self.last_scale_time = m.get('LastScaleTime')
        self.next_scale_metrics = []
        if m.get('NextScaleMetrics') is not None:
            for k in m.get('NextScaleMetrics'):
                temp_model = DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusNextScaleMetrics()
                self.next_scale_metrics.append(temp_model.from_map(k))
        if m.get('NextScaleTimePeriod') is not None:
            self.next_scale_time_period = m.get('NextScaleTimePeriod')
        return self


class DescribeApplicationScalingRuleResponseBodyDataMetricScaleDownRules(TeaModel):
    def __init__(
        self,
        disabled: bool = None,
        stabilization_window_seconds: int = None,
        step: int = None,
    ):
        # Indicates whether the application scale-in is disabled. Valid values:
        # 
        # *   **true**: disabled.
        # *   **false**: enabled.
        # 
        # >  When this parameter is set to true, the application instances are never reduced. This prevents risks to your business in peak hours. By default, this parameter is set to false.
        self.disabled = disabled
        # The cooldown time of the scale-in. Valid values: 0 to 3600. Unit: seconds. Default value: 0.
        self.stabilization_window_seconds = stabilization_window_seconds
        # The step size for the scale-in. The maximum number of instances that can be reduced within a specific period of time.
        self.step = step

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.stabilization_window_seconds is not None:
            result['StabilizationWindowSeconds'] = self.stabilization_window_seconds
        if self.step is not None:
            result['Step'] = self.step
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('StabilizationWindowSeconds') is not None:
            self.stabilization_window_seconds = m.get('StabilizationWindowSeconds')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        return self


class DescribeApplicationScalingRuleResponseBodyDataMetricScaleUpRules(TeaModel):
    def __init__(
        self,
        disabled: bool = None,
        stabilization_window_seconds: int = None,
        step: int = None,
    ):
        # Indicates whether the application scale-in is disabled. Valid values:
        # 
        # *   **true**: The application scale-in is disabled.
        # *   **false**: The application scale-in is enabled.
        # 
        # >  When this parameter is set to true, the application instances are never reduced. This prevents risks to your business in peak hours. By default, this parameter is set to false.
        self.disabled = disabled
        # The cooldown time of the scale-out. Valid values: 0 to 3600. Unit: seconds. Default value: 0.
        self.stabilization_window_seconds = stabilization_window_seconds
        # The step size for the scale-out. The maximum number of instances that can be added within a specific period of time.
        self.step = step

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.stabilization_window_seconds is not None:
            result['StabilizationWindowSeconds'] = self.stabilization_window_seconds
        if self.step is not None:
            result['Step'] = self.step
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('StabilizationWindowSeconds') is not None:
            self.stabilization_window_seconds = m.get('StabilizationWindowSeconds')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        return self


class DescribeApplicationScalingRuleResponseBodyDataMetric(TeaModel):
    def __init__(
        self,
        max_replicas: int = None,
        metrics: List[DescribeApplicationScalingRuleResponseBodyDataMetricMetrics] = None,
        metrics_status: DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatus = None,
        min_replicas: int = None,
        scale_down_rules: DescribeApplicationScalingRuleResponseBodyDataMetricScaleDownRules = None,
        scale_up_rules: DescribeApplicationScalingRuleResponseBodyDataMetricScaleUpRules = None,
    ):
        # The maximum number of instances.
        self.max_replicas = max_replicas
        # The list of metrics that are used to trigger the auto scaling policy.
        self.metrics = metrics
        # The execution status of the metric-based auto scaling policy.
        self.metrics_status = metrics_status
        # The minimum number of instances.
        self.min_replicas = min_replicas
        # Rules that determine the application scale-in.
        self.scale_down_rules = scale_down_rules
        # Rules that determine the application scale-out.
        self.scale_up_rules = scale_up_rules

    def validate(self):
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()
        if self.metrics_status:
            self.metrics_status.validate()
        if self.scale_down_rules:
            self.scale_down_rules.validate()
        if self.scale_up_rules:
            self.scale_up_rules.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        result['Metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['Metrics'].append(k.to_map() if k else None)
        if self.metrics_status is not None:
            result['MetricsStatus'] = self.metrics_status.to_map()
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        if self.scale_down_rules is not None:
            result['ScaleDownRules'] = self.scale_down_rules.to_map()
        if self.scale_up_rules is not None:
            result['ScaleUpRules'] = self.scale_up_rules.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        self.metrics = []
        if m.get('Metrics') is not None:
            for k in m.get('Metrics'):
                temp_model = DescribeApplicationScalingRuleResponseBodyDataMetricMetrics()
                self.metrics.append(temp_model.from_map(k))
        if m.get('MetricsStatus') is not None:
            temp_model = DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatus()
            self.metrics_status = temp_model.from_map(m['MetricsStatus'])
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        if m.get('ScaleDownRules') is not None:
            temp_model = DescribeApplicationScalingRuleResponseBodyDataMetricScaleDownRules()
            self.scale_down_rules = temp_model.from_map(m['ScaleDownRules'])
        if m.get('ScaleUpRules') is not None:
            temp_model = DescribeApplicationScalingRuleResponseBodyDataMetricScaleUpRules()
            self.scale_up_rules = temp_model.from_map(m['ScaleUpRules'])
        return self


class DescribeApplicationScalingRuleResponseBodyDataTimerSchedules(TeaModel):
    def __init__(
        self,
        at_time: str = None,
        target_replicas: int = None,
    ):
        # The point in time. Format: **Hour:Minute**.
        self.at_time = at_time
        # The expected number of instances.
        self.target_replicas = target_replicas

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.at_time is not None:
            result['AtTime'] = self.at_time
        if self.target_replicas is not None:
            result['TargetReplicas'] = self.target_replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AtTime') is not None:
            self.at_time = m.get('AtTime')
        if m.get('TargetReplicas') is not None:
            self.target_replicas = m.get('TargetReplicas')
        return self


class DescribeApplicationScalingRuleResponseBodyDataTimer(TeaModel):
    def __init__(
        self,
        begin_date: str = None,
        end_date: str = None,
        period: str = None,
        schedules: List[DescribeApplicationScalingRuleResponseBodyDataTimerSchedules] = None,
    ):
        # The start date of the validity period of the scheduled auto scaling policy. Valid values:
        # 
        # *   If both the **BeginDate** and **EndDate** parameters are set to **null**, the auto scaling policy can always be triggered. The default value for these parameters is null.
        # *   If the two parameters are set to specific dates, the scheduled auto scaling policy can be triggered during the period between the two dates. For example, if **BeginDate** is **2021-03-25** and **EndDate** is **2021-04-25**, the auto scaling policy is valid for one month.
        self.begin_date = begin_date
        # The end date of the validity period of the scheduled auto scaling policy. Valid values:
        # 
        # *   If both the **BeginDate** and **EndDate** parameters are set to **null**, the auto scaling policy can always be triggered. The default value for these parameters is null.
        # *   If the two parameters are set to specific dates, the scheduled auto scaling policy can be triggered during the period between the two dates. For example, if **BeginDate** is **2021-03-25** and **EndDate** is **2021-04-25**, the auto scaling policy is valid for one month.
        self.end_date = end_date
        # The days on which the scheduled auto scaling policy takes effect. Valid values:
        # 
        # *   **\* \* \***: The scheduled auto scaling policy takes effect at a specified time every day.
        # 
        # *   **\* \* Fri,Mon**: The scheduled auto scaling policy takes effect at a specified time on one or multiple days of a week. The specified time is in the GMT+8 time zone. Valid values:
        # 
        #     *   **Sun**: Sunday
        #     *   **Mon**: Monday
        #     *   **Tue**: Tuesday
        #     *   **Wed**: Wednesday
        #     *   **Thu**: Thursday
        #     *   **Fri**: Friday
        #     *   **Sat**: Saturday
        # 
        # *   **1,2,3,28,31 \* \***: The scheduled auto scaling policy takes effect at a specified time on one or multiple days of a month. Valid values: 1 to 31. If the month does not have a 31st day, the auto scaling policy takes effect on the specified days other than the 31st day.
        self.period = period
        # The points in time when the auto scaling policy is triggered within one day.
        self.schedules = schedules

    def validate(self):
        if self.schedules:
            for k in self.schedules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_date is not None:
            result['BeginDate'] = self.begin_date
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.period is not None:
            result['Period'] = self.period
        result['Schedules'] = []
        if self.schedules is not None:
            for k in self.schedules:
                result['Schedules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BeginDate') is not None:
            self.begin_date = m.get('BeginDate')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        self.schedules = []
        if m.get('Schedules') is not None:
            for k in m.get('Schedules'):
                temp_model = DescribeApplicationScalingRuleResponseBodyDataTimerSchedules()
                self.schedules.append(temp_model.from_map(k))
        return self


class DescribeApplicationScalingRuleResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        create_time: int = None,
        last_disable_time: int = None,
        metric: DescribeApplicationScalingRuleResponseBodyDataMetric = None,
        scale_rule_enabled: bool = None,
        scale_rule_name: str = None,
        scale_rule_type: str = None,
        timer: DescribeApplicationScalingRuleResponseBodyDataTimer = None,
        update_time: int = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The time when the auto scaling policy was created. Unit: milliseconds.
        self.create_time = create_time
        # The time when the auto scaling policy was last disabled.
        self.last_disable_time = last_disable_time
        # The details of the metric-based auto scaling policy.
        self.metric = metric
        # Indicates whether the auto scaling policy is enabled. Valid values:
        # 
        # *   **true**: enabled
        # *   **false**: disabled
        self.scale_rule_enabled = scale_rule_enabled
        # The name of the auto scaling policy.
        self.scale_rule_name = scale_rule_name
        # The type of the auto scaling policy. Valid values:
        # 
        # *   **timing**: the scheduled auto scaling policy.
        # *   **metric**: the metric-based auto scaling policy.
        # *   **mix**: the hybrid auto scaling policy.
        self.scale_rule_type = scale_rule_type
        # The details of the scheduled auto scaling policy.
        self.timer = timer
        # The time when the auto scaling policy was updated. Unit: milliseconds.
        self.update_time = update_time

    def validate(self):
        if self.metric:
            self.metric.validate()
        if self.timer:
            self.timer.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_disable_time is not None:
            result['LastDisableTime'] = self.last_disable_time
        if self.metric is not None:
            result['Metric'] = self.metric.to_map()
        if self.scale_rule_enabled is not None:
            result['ScaleRuleEnabled'] = self.scale_rule_enabled
        if self.scale_rule_name is not None:
            result['ScaleRuleName'] = self.scale_rule_name
        if self.scale_rule_type is not None:
            result['ScaleRuleType'] = self.scale_rule_type
        if self.timer is not None:
            result['Timer'] = self.timer.to_map()
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastDisableTime') is not None:
            self.last_disable_time = m.get('LastDisableTime')
        if m.get('Metric') is not None:
            temp_model = DescribeApplicationScalingRuleResponseBodyDataMetric()
            self.metric = temp_model.from_map(m['Metric'])
        if m.get('ScaleRuleEnabled') is not None:
            self.scale_rule_enabled = m.get('ScaleRuleEnabled')
        if m.get('ScaleRuleName') is not None:
            self.scale_rule_name = m.get('ScaleRuleName')
        if m.get('ScaleRuleType') is not None:
            self.scale_rule_type = m.get('ScaleRuleType')
        if m.get('Timer') is not None:
            temp_model = DescribeApplicationScalingRuleResponseBodyDataTimer()
            self.timer = temp_model.from_map(m['Timer'])
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeApplicationScalingRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeApplicationScalingRuleResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        # The returned data.
        self.data = data
        self.error_code = error_code
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeApplicationScalingRuleResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeApplicationScalingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApplicationScalingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApplicationScalingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApplicationScalingRulesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # 7171a6ca-d1cd-4928-8642-7d5cfe69\*\*\*\*\
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetrics(TeaModel):
    def __init__(
        self,
        metric_target_average_utilization: int = None,
        metric_type: str = None,
    ):
        # The limit on the metric.
        # 
        # *   The limit on the CPU utilization. Unit: percentage.
        # *   The limit on the memory usage. Unit: percentage.
        # *   The limit on the average number of active TCP connections per second.
        # *   The limit on the queries per second (QPS) of the Internet-facing Server Load Balancer (SLB) instance.
        # *   The limit on the response time of the Internet-facing SLB instance. Unit: milliseconds.
        self.metric_target_average_utilization = metric_target_average_utilization
        # The metric that is used to trigger the auto scaling policy. Valid values:
        # 
        # *   **CPU**: the CPU utilization.
        # *   **MEMORY**: the memory usage.
        # *   **tcpActiveConn**: the average number of active TCP connections per second of an application instance in 30 seconds.
        # *   **SLB_QPS**: the average QPS of the Internet-facing SLB instance associated with an application instance in 15 seconds.
        # *   **SLB_RT**: the average response time of the Internet-facing SLB instance in 15 seconds.
        self.metric_type = metric_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_target_average_utilization is not None:
            result['MetricTargetAverageUtilization'] = self.metric_target_average_utilization
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetricTargetAverageUtilization') is not None:
            self.metric_target_average_utilization = m.get('MetricTargetAverageUtilization')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusCurrentMetrics(TeaModel):
    def __init__(
        self,
        current_value: int = None,
        name: str = None,
        type: str = None,
    ):
        # The current value of the metric.
        self.current_value = current_value
        # The name of the metric.
        # 
        # *   **cpu**: the CPU utilization.
        # *   **memory**: the memory usage.
        # *   **tcpActiveConn**: the number of active TCP connections.
        # *   **slb_incall_qps**: the QPS of the Internet-facing SLB instance.
        # *   **slb_incall_rt**: the response time of the Internet-facing SLB instance.
        self.name = name
        # The type of the data. This parameter corresponds to the metric.
        # 
        # *   **Resource**: used when the metric is the **CPU utilization** or **memory usage**.
        # *   **Pods**: used when the metric is the **number of active TCP connections**.
        # *   **External**: used when the metric is about the **SLB** instance or from **Application Real-Time Monitoring Service (ARMS)**.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_value is not None:
            result['CurrentValue'] = self.current_value
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentValue') is not None:
            self.current_value = m.get('CurrentValue')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusNextScaleMetrics(TeaModel):
    def __init__(
        self,
        name: str = None,
        next_scale_in_average_utilization: int = None,
        next_scale_out_average_utilization: int = None,
    ):
        # The name of the metric.
        # 
        # *   **cpu**: the CPU utilization.
        # *   **memory**: the memory usage.
        # *   **tcpActiveConn**: the number of active TCP connections.
        # *   **slb_incall_qps**: the QPS of the Internet-facing SLB instance.
        # *   **slb_incall_rt**: the response time of the Internet-facing SLB instance.
        self.name = name
        # The metric value as a percentage that triggers the application scale-in next time.
        self.next_scale_in_average_utilization = next_scale_in_average_utilization
        # The metric value as a percentage that triggers the application scale-out next time.
        self.next_scale_out_average_utilization = next_scale_out_average_utilization

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.next_scale_in_average_utilization is not None:
            result['NextScaleInAverageUtilization'] = self.next_scale_in_average_utilization
        if self.next_scale_out_average_utilization is not None:
            result['NextScaleOutAverageUtilization'] = self.next_scale_out_average_utilization
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NextScaleInAverageUtilization') is not None:
            self.next_scale_in_average_utilization = m.get('NextScaleInAverageUtilization')
        if m.get('NextScaleOutAverageUtilization') is not None:
            self.next_scale_out_average_utilization = m.get('NextScaleOutAverageUtilization')
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatus(TeaModel):
    def __init__(
        self,
        current_metrics: List[DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusCurrentMetrics] = None,
        current_replicas: int = None,
        desired_replicas: int = None,
        last_scale_time: str = None,
        max_replicas: int = None,
        min_replicas: int = None,
        next_scale_metrics: List[DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusNextScaleMetrics] = None,
        next_scale_time_period: int = None,
    ):
        # The metrics that are used to trigger the auto scaling policy this time.
        self.current_metrics = current_metrics
        # The current number of instances.
        self.current_replicas = current_replicas
        # The expected number of instances.
        self.desired_replicas = desired_replicas
        # The time when the auto scaling policy was last triggered.
        self.last_scale_time = last_scale_time
        # The maximum number of instances.
        self.max_replicas = max_replicas
        # The minimum number of instances.
        self.min_replicas = min_replicas
        # The metrics that are used to trigger the auto scaling policy next time.
        self.next_scale_metrics = next_scale_metrics
        # The duration for which the metric-based auto scaling policy takes effect next time.
        self.next_scale_time_period = next_scale_time_period

    def validate(self):
        if self.current_metrics:
            for k in self.current_metrics:
                if k:
                    k.validate()
        if self.next_scale_metrics:
            for k in self.next_scale_metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CurrentMetrics'] = []
        if self.current_metrics is not None:
            for k in self.current_metrics:
                result['CurrentMetrics'].append(k.to_map() if k else None)
        if self.current_replicas is not None:
            result['CurrentReplicas'] = self.current_replicas
        if self.desired_replicas is not None:
            result['DesiredReplicas'] = self.desired_replicas
        if self.last_scale_time is not None:
            result['LastScaleTime'] = self.last_scale_time
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        result['NextScaleMetrics'] = []
        if self.next_scale_metrics is not None:
            for k in self.next_scale_metrics:
                result['NextScaleMetrics'].append(k.to_map() if k else None)
        if self.next_scale_time_period is not None:
            result['NextScaleTimePeriod'] = self.next_scale_time_period
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.current_metrics = []
        if m.get('CurrentMetrics') is not None:
            for k in m.get('CurrentMetrics'):
                temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusCurrentMetrics()
                self.current_metrics.append(temp_model.from_map(k))
        if m.get('CurrentReplicas') is not None:
            self.current_replicas = m.get('CurrentReplicas')
        if m.get('DesiredReplicas') is not None:
            self.desired_replicas = m.get('DesiredReplicas')
        if m.get('LastScaleTime') is not None:
            self.last_scale_time = m.get('LastScaleTime')
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        self.next_scale_metrics = []
        if m.get('NextScaleMetrics') is not None:
            for k in m.get('NextScaleMetrics'):
                temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusNextScaleMetrics()
                self.next_scale_metrics.append(temp_model.from_map(k))
        if m.get('NextScaleTimePeriod') is not None:
            self.next_scale_time_period = m.get('NextScaleTimePeriod')
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleDownRules(TeaModel):
    def __init__(
        self,
        disabled: bool = None,
        stabilization_window_seconds: int = None,
        step: int = None,
    ):
        # Indicates whether the application scale-in was disabled. Valid values:
        # 
        # *   **true**: The application scale-in was disabled.
        # *   **false**: The application scale-in was enabled.
        # 
        # >  When this parameter is set to true, the application instances will never be reduced. This prevents risks to your business in peak hours. By default, this parameter is set to false.
        self.disabled = disabled
        # The cooldown time of the scale-in. Valid values: 0 to 3600. Unit: seconds. The default value is 0.
        self.stabilization_window_seconds = stabilization_window_seconds
        # The step size for the scale-in. The maximum number of instances that can be reduced in a unit of time.
        self.step = step

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.stabilization_window_seconds is not None:
            result['StabilizationWindowSeconds'] = self.stabilization_window_seconds
        if self.step is not None:
            result['Step'] = self.step
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('StabilizationWindowSeconds') is not None:
            self.stabilization_window_seconds = m.get('StabilizationWindowSeconds')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleUpRules(TeaModel):
    def __init__(
        self,
        disabled: bool = None,
        stabilization_window_seconds: int = None,
        step: int = None,
    ):
        # Indicates whether the application scale-in was disabled. Valid values:
        # 
        # *   **true**: The application scale-in was disabled.
        # *   **false**: The application scale-in was enabled.
        # 
        # >  When this parameter is set to true, the application instances will never be reduced. This prevents risks to your business in peak hours. By default, this parameter is set to false.
        self.disabled = disabled
        # The cooldown time of the scale-out. Valid values: 0 to 3600. Unit: seconds. The default value is 0.
        self.stabilization_window_seconds = stabilization_window_seconds
        # The step size for the scale-out. The maximum number of instances that can be added in a unit of time.
        self.step = step

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.stabilization_window_seconds is not None:
            result['StabilizationWindowSeconds'] = self.stabilization_window_seconds
        if self.step is not None:
            result['Step'] = self.step
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('StabilizationWindowSeconds') is not None:
            self.stabilization_window_seconds = m.get('StabilizationWindowSeconds')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetric(TeaModel):
    def __init__(
        self,
        max_replicas: int = None,
        metrics: List[DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetrics] = None,
        metrics_status: DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatus = None,
        min_replicas: int = None,
        scale_down_rules: DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleDownRules = None,
        scale_up_rules: DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleUpRules = None,
    ):
        # The maximum number of instances.
        self.max_replicas = max_replicas
        # The list of metrics that are used to trigger the auto scaling policy.
        self.metrics = metrics
        # The execution status of the metric-based auto scaling policy.
        self.metrics_status = metrics_status
        # The minimum number of instances.
        self.min_replicas = min_replicas
        # Rules that determine the application scale-in.
        self.scale_down_rules = scale_down_rules
        # Rules that determine the application scale-out.
        self.scale_up_rules = scale_up_rules

    def validate(self):
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()
        if self.metrics_status:
            self.metrics_status.validate()
        if self.scale_down_rules:
            self.scale_down_rules.validate()
        if self.scale_up_rules:
            self.scale_up_rules.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        result['Metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['Metrics'].append(k.to_map() if k else None)
        if self.metrics_status is not None:
            result['MetricsStatus'] = self.metrics_status.to_map()
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        if self.scale_down_rules is not None:
            result['ScaleDownRules'] = self.scale_down_rules.to_map()
        if self.scale_up_rules is not None:
            result['ScaleUpRules'] = self.scale_up_rules.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        self.metrics = []
        if m.get('Metrics') is not None:
            for k in m.get('Metrics'):
                temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetrics()
                self.metrics.append(temp_model.from_map(k))
        if m.get('MetricsStatus') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatus()
            self.metrics_status = temp_model.from_map(m['MetricsStatus'])
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        if m.get('ScaleDownRules') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleDownRules()
            self.scale_down_rules = temp_model.from_map(m['ScaleDownRules'])
        if m.get('ScaleUpRules') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleUpRules()
            self.scale_up_rules = temp_model.from_map(m['ScaleUpRules'])
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimerSchedules(TeaModel):
    def __init__(
        self,
        at_time: str = None,
        max_replicas: int = None,
        min_replicas: int = None,
        target_replicas: int = None,
    ):
        # The point in time. Format: **Hour:Minute**.
        self.at_time = at_time
        # The maximum number of instances.
        self.max_replicas = max_replicas
        # The minimum number of instances.
        self.min_replicas = min_replicas
        # The expected number of instances.
        self.target_replicas = target_replicas

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.at_time is not None:
            result['AtTime'] = self.at_time
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        if self.target_replicas is not None:
            result['TargetReplicas'] = self.target_replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AtTime') is not None:
            self.at_time = m.get('AtTime')
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        if m.get('TargetReplicas') is not None:
            self.target_replicas = m.get('TargetReplicas')
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimer(TeaModel):
    def __init__(
        self,
        begin_date: str = None,
        end_date: str = None,
        period: str = None,
        schedules: List[DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimerSchedules] = None,
    ):
        # The start date of the validity period of the scheduled auto scaling policy. Valid values:
        # 
        # *   If both the **BeginDate** and **EndDate** parameters are set to **null**, the auto scaling policy can always be triggered. The default value for these parameters is null.
        # *   If the two parameters are set to specific dates, the scheduled auto scaling policy can be triggered during the period between the two dates. For example, if **BeginDate** is 2021-03-25 and **EndDate** is 2021-04-25, the auto scaling policy is valid for one month.
        self.begin_date = begin_date
        # The end date of the validity period of the scheduled auto scaling policy. Valid values:
        # 
        # *   If both the **BeginDate** and **EndDate** parameters are set to **null**, the auto scaling policy can always be triggered. The default value for these parameters is null.
        # *   If the two parameters are set to specific dates, the scheduled auto scaling policy can be triggered during the period between the two dates. For example, if **BeginDate** is 2021-03-25 and **EndDate** is 2021-04-25, the auto scaling policy is valid for one month.
        self.end_date = end_date
        # The days on which the scheduled auto scaling policy takes effect. Valid values:
        # 
        # *   **\* \* \***: The scheduled auto scaling policy takes effect at a specified time every day.
        # 
        # *   **\* \* Fri,Mon**: The scheduled auto scaling policy takes effect at a specified time on one or multiple days of a week. The specified time is in the GMT+8 time zone. Valid values:
        # 
        #     *   **Sun**: Sunday
        #     *   **Mon**: Monday
        #     *   **Tue**: Tuesday
        #     *   **Wed**: Wednesday
        #     *   **Thu**: Thursday
        #     *   **Fri**: Friday
        #     *   **Sat**: Saturday
        # 
        # *   **1,2,3,28,31 \* \***: The scheduled auto scaling policy takes effect at a specified time on one or multiple days of a month. Valid values: 1 to 31. If the month does not have a 31st day, the auto scaling policy takes effect on the specified days other than the 31st day.
        self.period = period
        # The points in time when the auto scaling policy is triggered within one day.
        self.schedules = schedules

    def validate(self):
        if self.schedules:
            for k in self.schedules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_date is not None:
            result['BeginDate'] = self.begin_date
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.period is not None:
            result['Period'] = self.period
        result['Schedules'] = []
        if self.schedules is not None:
            for k in self.schedules:
                result['Schedules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BeginDate') is not None:
            self.begin_date = m.get('BeginDate')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        self.schedules = []
        if m.get('Schedules') is not None:
            for k in m.get('Schedules'):
                temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimerSchedules()
                self.schedules.append(temp_model.from_map(k))
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRules(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        create_time: int = None,
        last_disable_time: int = None,
        metric: DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetric = None,
        scale_rule_enabled: bool = None,
        scale_rule_name: str = None,
        scale_rule_type: str = None,
        timer: DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimer = None,
        update_time: int = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The time when the auto scaling policy was created. Unit: milliseconds.
        self.create_time = create_time
        # The time when the auto scaling policy was last disabled.
        self.last_disable_time = last_disable_time
        # The details of the metric-based auto scaling policy.
        self.metric = metric
        # Indicates whether the auto scaling policy is enabled. Valid values:
        # 
        # *   **true**: enabled
        # *   **false**: disabled
        self.scale_rule_enabled = scale_rule_enabled
        # The name of the auto scaling policy.
        self.scale_rule_name = scale_rule_name
        # The type of the auto scaling policy. Valid values:
        # 
        # *   **timing**: the scheduled auto scaling policy.
        # *   **metric**: the metric-based auto scaling policy.
        # *   **mix**: the hybrid auto scaling policy.
        self.scale_rule_type = scale_rule_type
        # The details of the scheduled auto scaling policy.
        self.timer = timer
        # The time when the auto scaling policy was updated. Unit: milliseconds.
        self.update_time = update_time

    def validate(self):
        if self.metric:
            self.metric.validate()
        if self.timer:
            self.timer.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_disable_time is not None:
            result['LastDisableTime'] = self.last_disable_time
        if self.metric is not None:
            result['Metric'] = self.metric.to_map()
        if self.scale_rule_enabled is not None:
            result['ScaleRuleEnabled'] = self.scale_rule_enabled
        if self.scale_rule_name is not None:
            result['ScaleRuleName'] = self.scale_rule_name
        if self.scale_rule_type is not None:
            result['ScaleRuleType'] = self.scale_rule_type
        if self.timer is not None:
            result['Timer'] = self.timer.to_map()
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastDisableTime') is not None:
            self.last_disable_time = m.get('LastDisableTime')
        if m.get('Metric') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetric()
            self.metric = temp_model.from_map(m['Metric'])
        if m.get('ScaleRuleEnabled') is not None:
            self.scale_rule_enabled = m.get('ScaleRuleEnabled')
        if m.get('ScaleRuleName') is not None:
            self.scale_rule_name = m.get('ScaleRuleName')
        if m.get('ScaleRuleType') is not None:
            self.scale_rule_type = m.get('ScaleRuleType')
        if m.get('Timer') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimer()
            self.timer = temp_model.from_map(m['Timer'])
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeApplicationScalingRulesResponseBodyData(TeaModel):
    def __init__(
        self,
        application_scaling_rules: List[DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRules] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # The auto scaling policies of the application.
        self.application_scaling_rules = application_scaling_rules
        # The number of the returned page.
        self.current_page = current_page
        # The number of entries returned on each page.
        self.page_size = page_size
        # The total number of auto scaling policies.
        self.total_size = total_size

    def validate(self):
        if self.application_scaling_rules:
            for k in self.application_scaling_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ApplicationScalingRules'] = []
        if self.application_scaling_rules is not None:
            for k in self.application_scaling_rules:
                result['ApplicationScalingRules'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.application_scaling_rules = []
        if m.get('ApplicationScalingRules') is not None:
            for k in m.get('ApplicationScalingRules'):
                temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRules()
                self.application_scaling_rules.append(temp_model.from_map(k))
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class DescribeApplicationScalingRulesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeApplicationScalingRulesResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        # The returned data.
        self.data = data
        self.error_code = error_code
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeApplicationScalingRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApplicationScalingRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApplicationSlbsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # 017f39b8-dfa4-4e16-a84b-1dcee4b1\*\*\*\*\
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DescribeApplicationSlbsResponseBodyDataInternet(TeaModel):
    def __init__(
        self,
        https_cert_id: str = None,
        port: int = None,
        protocol: str = None,
        target_port: int = None,
    ):
        # The ID of the SSL certificate issued by Alibaba Cloud.
        self.https_cert_id = https_cert_id
        # The port specified for the SLB listener.
        self.port = port
        # The supported protocol.
        self.protocol = protocol
        # The container port.
        self.target_port = target_port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.https_cert_id is not None:
            result['HttpsCertId'] = self.https_cert_id
        if self.port is not None:
            result['Port'] = self.port
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.target_port is not None:
            result['TargetPort'] = self.target_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HttpsCertId') is not None:
            self.https_cert_id = m.get('HttpsCertId')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('TargetPort') is not None:
            self.target_port = m.get('TargetPort')
        return self


class DescribeApplicationSlbsResponseBodyDataIntranet(TeaModel):
    def __init__(
        self,
        https_cert_id: str = None,
        port: int = None,
        protocol: str = None,
        target_port: int = None,
    ):
        # The ID of the SSL certificate issued by Alibaba Cloud.
        self.https_cert_id = https_cert_id
        # The port specified for the SLB listener.
        self.port = port
        # The supported protocol.
        self.protocol = protocol
        # The container port.
        self.target_port = target_port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.https_cert_id is not None:
            result['HttpsCertId'] = self.https_cert_id
        if self.port is not None:
            result['Port'] = self.port
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.target_port is not None:
            result['TargetPort'] = self.target_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HttpsCertId') is not None:
            self.https_cert_id = m.get('HttpsCertId')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('TargetPort') is not None:
            self.target_port = m.get('TargetPort')
        return self


class DescribeApplicationSlbsResponseBodyData(TeaModel):
    def __init__(
        self,
        internet: List[DescribeApplicationSlbsResponseBodyDataInternet] = None,
        internet_ip: str = None,
        internet_slb_expired: bool = None,
        internet_slb_id: str = None,
        intranet: List[DescribeApplicationSlbsResponseBodyDataIntranet] = None,
        intranet_ip: str = None,
        intranet_slb_expired: bool = None,
        intranet_slb_id: str = None,
    ):
        # Configurations of Internet-facing SLB instances.
        self.internet = internet
        # The IP address of the Internet-facing SLB instance.
        self.internet_ip = internet_ip
        self.internet_slb_expired = internet_slb_expired
        # The ID of the Internet-facing SLB instance.
        self.internet_slb_id = internet_slb_id
        # Configurations of internal-facing SLB instances.
        self.intranet = intranet
        # The IP address of the internal-facing SLB instance.
        self.intranet_ip = intranet_ip
        self.intranet_slb_expired = intranet_slb_expired
        # The ID of the internal-facing SLB instance.
        self.intranet_slb_id = intranet_slb_id

    def validate(self):
        if self.internet:
            for k in self.internet:
                if k:
                    k.validate()
        if self.intranet:
            for k in self.intranet:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Internet'] = []
        if self.internet is not None:
            for k in self.internet:
                result['Internet'].append(k.to_map() if k else None)
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.internet_slb_expired is not None:
            result['InternetSlbExpired'] = self.internet_slb_expired
        if self.internet_slb_id is not None:
            result['InternetSlbId'] = self.internet_slb_id
        result['Intranet'] = []
        if self.intranet is not None:
            for k in self.intranet:
                result['Intranet'].append(k.to_map() if k else None)
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.intranet_slb_expired is not None:
            result['IntranetSlbExpired'] = self.intranet_slb_expired
        if self.intranet_slb_id is not None:
            result['IntranetSlbId'] = self.intranet_slb_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.internet = []
        if m.get('Internet') is not None:
            for k in m.get('Internet'):
                temp_model = DescribeApplicationSlbsResponseBodyDataInternet()
                self.internet.append(temp_model.from_map(k))
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('InternetSlbExpired') is not None:
            self.internet_slb_expired = m.get('InternetSlbExpired')
        if m.get('InternetSlbId') is not None:
            self.internet_slb_id = m.get('InternetSlbId')
        self.intranet = []
        if m.get('Intranet') is not None:
            for k in m.get('Intranet'):
                temp_model = DescribeApplicationSlbsResponseBodyDataIntranet()
                self.intranet.append(temp_model.from_map(k))
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('IntranetSlbExpired') is not None:
            self.intranet_slb_expired = m.get('IntranetSlbExpired')
        if m.get('IntranetSlbId') is not None:
            self.intranet_slb_id = m.get('IntranetSlbId')
        return self


class DescribeApplicationSlbsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeApplicationSlbsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the information about the SLB instances that are associated with an application was obtained successfully. Valid values:
        # 
        # *   **true**: indicates that the information was obtained successfully.
        # *   **false**: indicates that the information failed to be obtained.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeApplicationSlbsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeApplicationSlbsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApplicationSlbsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApplicationSlbsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApplicationStatusRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # 0099b7be-5f5b-4512-a7fc-56049ef1\*\*\*\*\
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DescribeApplicationStatusResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        arms_advanced_enabled: str = None,
        arms_apm_info: str = None,
        create_time: str = None,
        current_status: str = None,
        enable_agent: bool = None,
        file_size_limit: int = None,
        last_change_order_id: str = None,
        last_change_order_running: bool = None,
        last_change_order_status: str = None,
        running_instances: int = None,
        sub_status: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # Indicates whether Application Real-Time Monitoring Service (ARMS) advanced monitoring is enabled. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.arms_advanced_enabled = arms_advanced_enabled
        # The metadata of the application in ARMS.
        self.arms_apm_info = arms_apm_info
        # The time when the application was created.
        self.create_time = create_time
        # The current state of the application. Valid values:
        # 
        # *   **RUNNING**\
        # *   **STOPPED**\
        # *   **UNKNOWN**\
        self.current_status = current_status
        # Indicates whether SAE agent is enabled.
        # 
        # *   **true**\
        # *   **false**\
        self.enable_agent = enable_agent
        # The file size limit. Unit: KB. Valid values: 0 to 10240.
        self.file_size_limit = file_size_limit
        # The ID of the latest change order that is executed. If no change orders have been executed or if change orders have expired, an empty parameter is returned.
        self.last_change_order_id = last_change_order_id
        # Indicates whether the latest change order is being executed. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.last_change_order_running = last_change_order_running
        # The state of the latest change order. Valid values:
        # 
        # *   **READY**: The change order is ready.
        # *   **RUNNING**: The change order is being executed.
        # *   **SUCCESS**: The change order was executed successfully.
        # *   **FAIL**: The change order failed to be executed.
        # *   **ABORT**: The change order is stopped.
        # *   **WAIT_BATCH_CONFIRM**: The change order is pending execution. You must manually confirm the release batch.
        # *   **AUTO_BATCH_WAIT**: The change order is pending execution. SAE will automatically confirm the release batch.
        # *   **SYSTEM_FAIL**: A system exception occurred.
        # *   **WAIT_APPROVAL**: The change order is pending approval.
        # *   **APPROVED**: The change order is approved and is pending execution.
        self.last_change_order_status = last_change_order_status
        # The number of running instances of the application.
        self.running_instances = running_instances
        # Indicates whether an error occurred while the change order was being executed. Valid values:
        # 
        # *   **NORMAL**\
        # *   **RUNNING_BUT_HAS_ERROR** If an error occurs during a batch release, you must manually perform a rollback. In this case, the change order is still running because the task is not completed, but the state of the change order is RUNNING_BUT_HAS_ERROR.
        self.sub_status = sub_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.arms_advanced_enabled is not None:
            result['ArmsAdvancedEnabled'] = self.arms_advanced_enabled
        if self.arms_apm_info is not None:
            result['ArmsApmInfo'] = self.arms_apm_info
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.current_status is not None:
            result['CurrentStatus'] = self.current_status
        if self.enable_agent is not None:
            result['EnableAgent'] = self.enable_agent
        if self.file_size_limit is not None:
            result['FileSizeLimit'] = self.file_size_limit
        if self.last_change_order_id is not None:
            result['LastChangeOrderId'] = self.last_change_order_id
        if self.last_change_order_running is not None:
            result['LastChangeOrderRunning'] = self.last_change_order_running
        if self.last_change_order_status is not None:
            result['LastChangeOrderStatus'] = self.last_change_order_status
        if self.running_instances is not None:
            result['RunningInstances'] = self.running_instances
        if self.sub_status is not None:
            result['SubStatus'] = self.sub_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ArmsAdvancedEnabled') is not None:
            self.arms_advanced_enabled = m.get('ArmsAdvancedEnabled')
        if m.get('ArmsApmInfo') is not None:
            self.arms_apm_info = m.get('ArmsApmInfo')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CurrentStatus') is not None:
            self.current_status = m.get('CurrentStatus')
        if m.get('EnableAgent') is not None:
            self.enable_agent = m.get('EnableAgent')
        if m.get('FileSizeLimit') is not None:
            self.file_size_limit = m.get('FileSizeLimit')
        if m.get('LastChangeOrderId') is not None:
            self.last_change_order_id = m.get('LastChangeOrderId')
        if m.get('LastChangeOrderRunning') is not None:
            self.last_change_order_running = m.get('LastChangeOrderRunning')
        if m.get('LastChangeOrderStatus') is not None:
            self.last_change_order_status = m.get('LastChangeOrderStatus')
        if m.get('RunningInstances') is not None:
            self.running_instances = m.get('RunningInstances')
        if m.get('SubStatus') is not None:
            self.sub_status = m.get('SubStatus')
        return self


class DescribeApplicationStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeApplicationStatusResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   If the request is successful, this parameter is not returned.****\
        # *   This parameter is returned only if the request failed.**** For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message. Valid values:
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether information of the application is successfully obtained. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeApplicationStatusResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeApplicationStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApplicationStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApplicationStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeChangeOrderRequest(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # 76fa5c0-9ebb-4bb4-b383-1f885447\*\*\*\*\
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class DescribeChangeOrderResponseBodyDataPipelines(TeaModel):
    def __init__(
        self,
        batch_type: int = None,
        parallel_count: int = None,
        pipeline_id: str = None,
        pipeline_name: str = None,
        start_time: int = None,
        status: int = None,
        update_time: int = None,
    ):
        # The batch type.
        self.batch_type = batch_type
        # The number of parallel tasks in a batch.
        self.parallel_count = parallel_count
        # The ID of the batch.
        self.pipeline_id = pipeline_id
        # The name of the batch.
        self.pipeline_name = pipeline_name
        # The time when the batch processing starts.
        self.start_time = start_time
        # The status of the batch. Valid values:
        # 
        # *   **0**: The batch is being prepared.
        # *   **1**: The batch is being processed.
        # *   **2**: The batch was processed.
        # *   **3**: The batch could not be processed.
        # *   **6**: The batch processing was terminated.
        # *   **8**: The execution process is pending. You must manually determine the release batch.
        # *   **9**: The execution process is pending. SAE will automatically determine the release batch.
        # *   **10**: The batch could not be processed due to a system exception.
        # *   **11**: The change order is pending approval.
        # *   **12**: The change order is approved and is pending execution.
        self.status = status
        # The time when the batch information is last modified.
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_type is not None:
            result['BatchType'] = self.batch_type
        if self.parallel_count is not None:
            result['ParallelCount'] = self.parallel_count
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.pipeline_name is not None:
            result['PipelineName'] = self.pipeline_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BatchType') is not None:
            self.batch_type = m.get('BatchType')
        if m.get('ParallelCount') is not None:
            self.parallel_count = m.get('ParallelCount')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('PipelineName') is not None:
            self.pipeline_name = m.get('PipelineName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeChangeOrderResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        approval_id: str = None,
        auto: bool = None,
        batch_count: int = None,
        batch_type: str = None,
        batch_wait_time: int = None,
        change_order_id: str = None,
        co_type: str = None,
        co_type_code: str = None,
        create_time: str = None,
        current_pipeline_id: str = None,
        description: str = None,
        error_message: str = None,
        pipelines: List[DescribeChangeOrderResponseBodyDataPipelines] = None,
        status: int = None,
        sub_status: int = None,
        support_rollback: bool = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name
        # The approval ID of the change order.
        self.approval_id = approval_id
        # Indicates whether SAE automatically determines the release batches. Valid values:
        # 
        # *   **true**: SAE automatically determines the release batches.
        # *   **false**: SAE does not automatically determine the release batches.
        self.auto = auto
        # The number of release batches.
        self.batch_count = batch_count
        # The mode in which the release batches are determined. Valid values:
        # 
        # *   **auto**: SAE automatically determines the release batches.
        # *   **Manual**: You must manually determine the release batches.
        self.batch_type = batch_type
        # The interval between batches when SAE automatically determines the release batches in a phased release. Unit: minutes.
        self.batch_wait_time = batch_wait_time
        # The ID of the change order.
        self.change_order_id = change_order_id
        # The description about the change type, which corresponds to the **CoTypeCode** parameter.
        self.co_type = co_type
        # The code of the change type. Valid values:
        # 
        # *   **CoBindSlb**: associates the Server Load Balancer (SLB) instance with the application.
        # *   **CoUnbindSlb**: disassociates the SLB instance from the application.
        # *   **CoCreateApp**: creates the application.
        # *   **CoDeleteApp**: deletes the application.
        # *   **CoDeploy**: deploys the application.
        # *   **CoRestartApplication**: restarts the application.
        # *   **CoRollback**: rolls back the application.
        # *   **CoScaleIn**: scales in the application.
        # *   **CoScaleOut**: scales out the application.
        # *   **CoStart**: starts the application.
        # *   **CoStop**: stops the application.
        # *   **CoRescaleApplicationVertically**: modifies the instance specifications.
        # *   **CoDeployHistroy**: rolls back the application to a historical version.
        # *   **CoBindNas**: associates a network-attached storage (NAS) file system with the application.
        # *   **CoUnbindNas**: disassociates the NAS file system from the application.
        # *   **CoBatchStartApplication**: starts multiple applications concurrently.
        # *   **CoBatchStopApplication**: stops multiple applications concurrently.
        # *   **CoRestartInstances**: restarts the instances.
        # *   **CoDeleteInstances**: deletes the instances.
        # *   **CoScaleInAppWithInstances**: reduces the number of specified application instances.
        self.co_type_code = co_type_code
        # The time when the change order was created.
        self.create_time = create_time
        # The ID of the current batch.
        self.current_pipeline_id = current_pipeline_id
        # The description of the change order.
        self.description = description
        # The error message.
        self.error_message = error_message
        # The batch information.
        self.pipelines = pipelines
        # The status of the change order. Valid values:
        # 
        # *   **0**: The change order is being prepared.
        # *   **1**: The change order is being executed.
        # *   **2**: The change order was executed.
        # *   **3**: The change order could not be executed.
        # *   **6**: The change order was terminated.
        # *   **8**: The execution process is pending. You must manually determine the release batch.
        # *   **9**: The execution process is pending. SAE will automatically determine the release batches.
        # *   **10**: The execution failed due to a system exception.
        # *   **11**: The change order is pending approval.
        # *   **12**: The change order is approved and is pending execution.
        self.status = status
        # The substatus of the change order. This parameter indicates whether an exception occurred while the change order was being executed. Valid values:
        # 
        # *   **0**: No exception occurred.
        # *   **1**: An exception occurred. For example, when an error occurred during a phased release, you must manually roll back the application. In this case, the change order cannot be completed, so the Status parameter is still displayed as "1", which indicates that the change order is being executed. You can check the value of this parameter to determine whether an exception occurs.
        self.sub_status = sub_status
        # Indicates whether the application can be rolled back. Valid values:
        # 
        # *   **true**: The application can be rolled back.
        # *   **false**: The application cannot be rolled back.
        self.support_rollback = support_rollback

    def validate(self):
        if self.pipelines:
            for k in self.pipelines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.approval_id is not None:
            result['ApprovalId'] = self.approval_id
        if self.auto is not None:
            result['Auto'] = self.auto
        if self.batch_count is not None:
            result['BatchCount'] = self.batch_count
        if self.batch_type is not None:
            result['BatchType'] = self.batch_type
        if self.batch_wait_time is not None:
            result['BatchWaitTime'] = self.batch_wait_time
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.co_type is not None:
            result['CoType'] = self.co_type
        if self.co_type_code is not None:
            result['CoTypeCode'] = self.co_type_code
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.current_pipeline_id is not None:
            result['CurrentPipelineId'] = self.current_pipeline_id
        if self.description is not None:
            result['Description'] = self.description
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['Pipelines'] = []
        if self.pipelines is not None:
            for k in self.pipelines:
                result['Pipelines'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        if self.sub_status is not None:
            result['SubStatus'] = self.sub_status
        if self.support_rollback is not None:
            result['SupportRollback'] = self.support_rollback
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ApprovalId') is not None:
            self.approval_id = m.get('ApprovalId')
        if m.get('Auto') is not None:
            self.auto = m.get('Auto')
        if m.get('BatchCount') is not None:
            self.batch_count = m.get('BatchCount')
        if m.get('BatchType') is not None:
            self.batch_type = m.get('BatchType')
        if m.get('BatchWaitTime') is not None:
            self.batch_wait_time = m.get('BatchWaitTime')
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('CoType') is not None:
            self.co_type = m.get('CoType')
        if m.get('CoTypeCode') is not None:
            self.co_type_code = m.get('CoTypeCode')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CurrentPipelineId') is not None:
            self.current_pipeline_id = m.get('CurrentPipelineId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.pipelines = []
        if m.get('Pipelines') is not None:
            for k in m.get('Pipelines'):
                temp_model = DescribeChangeOrderResponseBodyDataPipelines()
                self.pipelines.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubStatus') is not None:
            self.sub_status = m.get('SubStatus')
        if m.get('SupportRollback') is not None:
            self.support_rollback = m.get('SupportRollback')
        return self


class DescribeChangeOrderResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeChangeOrderResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The details of the change order.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the information of a change order was obtained. Valid values:
        # 
        # *   **true**: The information was obtained.
        # *   **false**: The information could not be obtained.
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeChangeOrderResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeChangeOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeChangeOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeChangeOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeComponentsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        type: str = None,
    ):
        # d700e680-aa4d-4ec1-afc2-6566b5ff\*\*\*\*\
        self.app_id = app_id
        # TOMCAT
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeComponentsResponseBodyData(TeaModel):
    def __init__(
        self,
        component_description: str = None,
        component_key: str = None,
        expired: bool = None,
        type: str = None,
    ):
        # The description of the component.
        self.component_description = component_description
        # The ID of the component.
        self.component_key = component_key
        # Indicates whether the component is expired. Valid values:
        # 
        # *   **true**: The component is expired.
        # *   **false**: The component is not expired.
        self.expired = expired
        # The component type.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.component_description is not None:
            result['ComponentDescription'] = self.component_description
        if self.component_key is not None:
            result['ComponentKey'] = self.component_key
        if self.expired is not None:
            result['Expired'] = self.expired
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComponentDescription') is not None:
            self.component_description = m.get('ComponentDescription')
        if m.get('ComponentKey') is not None:
            self.component_key = m.get('ComponentKey')
        if m.get('Expired') is not None:
            self.expired = m.get('Expired')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeComponentsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[DescribeComponentsResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The details of the component.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the component version was obtained. Valid values:
        # 
        # *   **true**: indicates that the component version was obtained.
        # *   **false**: indicates that the component version could not be obtained.
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeComponentsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeComponentsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeComponentsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeComponentsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeConfigMapRequest(TeaModel):
    def __init__(
        self,
        config_map_id: int = None,
    ):
        # 1
        self.config_map_id = config_map_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        return self


class DescribeConfigMapResponseBodyDataRelateApps(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        return self


class DescribeConfigMapResponseBodyData(TeaModel):
    def __init__(
        self,
        config_map_id: int = None,
        create_time: int = None,
        data: Dict[str, Any] = None,
        description: str = None,
        name: str = None,
        namespace_id: str = None,
        relate_apps: List[DescribeConfigMapResponseBodyDataRelateApps] = None,
        update_time: int = None,
    ):
        # The ID of the ConfigMap instance.
        self.config_map_id = config_map_id
        # The time when the instance was created.
        self.create_time = create_time
        # The data of ConfigMap key-value pairs. Format:
        # 
        # {"k1":"v1", "k2":"v2"}
        # 
        # k specifies a key and v specifies a value. For more information, see [Manage and use configurations](~~171326~~).
        self.data = data
        # The description of the instance.
        self.description = description
        # The name of the ConfigMap instance.
        self.name = name
        # The ID of the namespace to which the instance belongs.
        self.namespace_id = namespace_id
        # The application that is associated with the instance.
        self.relate_apps = relate_apps
        # The time when the instance was last modified.
        self.update_time = update_time

    def validate(self):
        if self.relate_apps:
            for k in self.relate_apps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.data is not None:
            result['Data'] = self.data
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        result['RelateApps'] = []
        if self.relate_apps is not None:
            for k in self.relate_apps:
                result['RelateApps'].append(k.to_map() if k else None)
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        self.relate_apps = []
        if m.get('RelateApps') is not None:
            for k in m.get('RelateApps'):
                temp_model = DescribeConfigMapResponseBodyDataRelateApps()
                self.relate_apps.append(temp_model.from_map(k))
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeConfigMapResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeConfigMapResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the call was successful.
        # *   **3xx**: indicates that the call was redirected.
        # *   **4xx**: indicates that the call failed.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned result.
        self.data = data
        # The returned error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned information. Valid values:
        # 
        # *   If the call is successful, **success** is returned.
        # *   If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the details of the ConfigMap instance were obtained. Valid values:
        # 
        # *   **true**: The details were obtained.
        # *   **false**: The details failed to be obtained.
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeConfigMapResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeConfigMapResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeConfigMapResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeConfigMapResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeConfigurationPriceRequest(TeaModel):
    def __init__(
        self,
        cpu: int = None,
        memory: int = None,
        workload: str = None,
    ):
        self.cpu = cpu
        self.memory = memory
        self.workload = workload

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.workload is not None:
            result['Workload'] = self.workload
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('Workload') is not None:
            self.workload = m.get('Workload')
        return self


class DescribeConfigurationPriceResponseBodyDataBagUsage(TeaModel):
    def __init__(
        self,
        cpu: float = None,
        mem: float = None,
    ):
        self.cpu = cpu
        self.mem = mem

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.mem is not None:
            result['Mem'] = self.mem
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        return self


class DescribeConfigurationPriceResponseBodyDataOrder(TeaModel):
    def __init__(
        self,
        discount_amount: float = None,
        original_amount: float = None,
        rule_ids: List[str] = None,
        trade_amount: float = None,
    ):
        self.discount_amount = discount_amount
        self.original_amount = original_amount
        self.rule_ids = rule_ids
        self.trade_amount = trade_amount

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.discount_amount is not None:
            result['DiscountAmount'] = self.discount_amount
        if self.original_amount is not None:
            result['OriginalAmount'] = self.original_amount
        if self.rule_ids is not None:
            result['RuleIds'] = self.rule_ids
        if self.trade_amount is not None:
            result['TradeAmount'] = self.trade_amount
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DiscountAmount') is not None:
            self.discount_amount = m.get('DiscountAmount')
        if m.get('OriginalAmount') is not None:
            self.original_amount = m.get('OriginalAmount')
        if m.get('RuleIds') is not None:
            self.rule_ids = m.get('RuleIds')
        if m.get('TradeAmount') is not None:
            self.trade_amount = m.get('TradeAmount')
        return self


class DescribeConfigurationPriceResponseBodyDataRules(TeaModel):
    def __init__(
        self,
        name: str = None,
        rule_desc_id: int = None,
    ):
        self.name = name
        self.rule_desc_id = rule_desc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.rule_desc_id is not None:
            result['RuleDescId'] = self.rule_desc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RuleDescId') is not None:
            self.rule_desc_id = m.get('RuleDescId')
        return self


class DescribeConfigurationPriceResponseBodyData(TeaModel):
    def __init__(
        self,
        bag_usage: DescribeConfigurationPriceResponseBodyDataBagUsage = None,
        order: DescribeConfigurationPriceResponseBodyDataOrder = None,
        rules: List[DescribeConfigurationPriceResponseBodyDataRules] = None,
    ):
        self.bag_usage = bag_usage
        self.order = order
        self.rules = rules

    def validate(self):
        if self.bag_usage:
            self.bag_usage.validate()
        if self.order:
            self.order.validate()
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bag_usage is not None:
            result['BagUsage'] = self.bag_usage.to_map()
        if self.order is not None:
            result['Order'] = self.order.to_map()
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BagUsage') is not None:
            temp_model = DescribeConfigurationPriceResponseBodyDataBagUsage()
            self.bag_usage = temp_model.from_map(m['BagUsage'])
        if m.get('Order') is not None:
            temp_model = DescribeConfigurationPriceResponseBodyDataOrder()
            self.order = temp_model.from_map(m['Order'])
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = DescribeConfigurationPriceResponseBodyDataRules()
                self.rules.append(temp_model.from_map(k))
        return self


class DescribeConfigurationPriceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeConfigurationPriceResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeConfigurationPriceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeConfigurationPriceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeConfigurationPriceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeConfigurationPriceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEdasContainersResponseBodyData(TeaModel):
    def __init__(
        self,
        disabled: bool = None,
        edas_container_version: str = None,
    ):
        # Indicates whether the component is disabled. Valid values:
        # 
        # *   **true**: indicates that the component is disabled.
        # *   **false**: indicates that the component is not disabled.
        self.disabled = disabled
        # The version of the container, such as Ali-Tomcat, in which a High-speed Service Framework (HSF) application runs.
        self.edas_container_version = edas_container_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        return self


class DescribeEdasContainersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[DescribeEdasContainersResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The list of components.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the list of container components of a microservice application was obtained. Valid values:
        # 
        # *   **true**: indicates that the list was obtained.
        # *   **false**: indicates that the list could not be obtained.
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeEdasContainersResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeEdasContainersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEdasContainersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEdasContainersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGreyTagRouteRequest(TeaModel):
    def __init__(
        self,
        grey_tag_route_id: int = None,
    ):
        # 1
        self.grey_tag_route_id = grey_tag_route_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grey_tag_route_id is not None:
            result['GreyTagRouteId'] = self.grey_tag_route_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GreyTagRouteId') is not None:
            self.grey_tag_route_id = m.get('GreyTagRouteId')
        return self


class DescribeGreyTagRouteResponseBodyDataAlbRulesItems(TeaModel):
    def __init__(
        self,
        cond: str = None,
        expr: str = None,
        index: int = None,
        name: str = None,
        operator: str = None,
        type: str = None,
        value: str = None,
    ):
        self.cond = cond
        self.expr = expr
        self.index = index
        self.name = name
        self.operator = operator
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cond is not None:
            result['cond'] = self.cond
        if self.expr is not None:
            result['expr'] = self.expr
        if self.index is not None:
            result['index'] = self.index
        if self.name is not None:
            result['name'] = self.name
        if self.operator is not None:
            result['operator'] = self.operator
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cond') is not None:
            self.cond = m.get('cond')
        if m.get('expr') is not None:
            self.expr = m.get('expr')
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeGreyTagRouteResponseBodyDataAlbRules(TeaModel):
    def __init__(
        self,
        condition: str = None,
        ingress_id: str = None,
        items: List[DescribeGreyTagRouteResponseBodyDataAlbRulesItems] = None,
        service_id: str = None,
    ):
        self.condition = condition
        self.ingress_id = ingress_id
        self.items = items
        self.service_id = service_id

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['condition'] = self.condition
        if self.ingress_id is not None:
            result['ingressId'] = self.ingress_id
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.service_id is not None:
            result['serviceId'] = self.service_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        if m.get('ingressId') is not None:
            self.ingress_id = m.get('ingressId')
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = DescribeGreyTagRouteResponseBodyDataAlbRulesItems()
                self.items.append(temp_model.from_map(k))
        if m.get('serviceId') is not None:
            self.service_id = m.get('serviceId')
        return self


class DescribeGreyTagRouteResponseBodyDataDubboRulesItems(TeaModel):
    def __init__(
        self,
        cond: str = None,
        expr: str = None,
        index: int = None,
        name: str = None,
        operator: str = None,
        type: str = None,
        value: str = None,
    ):
        # The comparison operator. Valid values: **>**, **<**, **>=**, **<=**, **==**, and **! =**.
        self.cond = cond
        # The expression that is used to obtain the value of the parameter. Valid values:
        # 
        # - **Empty**: obtains the value of the parameter.
        # - **.name**: obtains the name property of the parameter. This expression works the same way as args0.getName().
        # - **.isEnabled()**: obtains the enabled property of the parameter. This expression works the same way as args0.isEnabled().
        # - **[0]**: indicates that the value of the parameter is an array and obtains the first value of the array. This expression works the same way as args0[0]. This expression does not start with a period (.).
        # - **.get(0)**: indicates that the value of the parameter is a list and obtains the first value of the list. This expression works the same way as args0.get(0).
        # - **.get("key")**: indicates that the value of the parameter is a map and obtains the value of the key in the map. This expression works the same way as args0.get("key").
        self.expr = expr
        # The index of the parameter. The value 0 indicates the first parameter.
        self.index = index
        # This parameter is not returned for Dubbo services.
        self.name = name
        # The operator. Valid values:
        # 
        # - **rawvalue**: direct comparison.
        # - **list**: whitelist.
        # - **mod**: mods 100.
        # - **deterministic_proportional_steaming_division**: percentage.
        self.operator = operator
        # This parameter is not returned for Dubbo services.
        self.type = type
        # The value of the parameter. This value is compared with the value that is obtained based on the **expr** and **index** parameters.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cond is not None:
            result['cond'] = self.cond
        if self.expr is not None:
            result['expr'] = self.expr
        if self.index is not None:
            result['index'] = self.index
        if self.name is not None:
            result['name'] = self.name
        if self.operator is not None:
            result['operator'] = self.operator
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cond') is not None:
            self.cond = m.get('cond')
        if m.get('expr') is not None:
            self.expr = m.get('expr')
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeGreyTagRouteResponseBodyDataDubboRules(TeaModel):
    def __init__(
        self,
        condition: str = None,
        group: str = None,
        items: List[DescribeGreyTagRouteResponseBodyDataDubboRulesItems] = None,
        method_name: str = None,
        service_name: str = None,
        version: str = None,
    ):
        # The relationship between the conditions in the canary release rule. Valid values:
        # 
        # - **AND**: The conditions are in the logical AND relation. All conditions must be met at the same time.
        # - **OR**: The conditions are in the logical OR relation. At least one of the conditions must be met.
        self.condition = condition
        # The group of the Dubbo service that corresponds to the canary release rule.
        self.group = group
        # The conditions.
        self.items = items
        # The method name of the Dubbo service.
        self.method_name = method_name
        # The name of the Dubbo service.
        self.service_name = service_name
        # The version of the Dubbo service.
        self.version = version

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['condition'] = self.condition
        if self.group is not None:
            result['group'] = self.group
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.method_name is not None:
            result['methodName'] = self.method_name
        if self.service_name is not None:
            result['serviceName'] = self.service_name
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        if m.get('group') is not None:
            self.group = m.get('group')
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = DescribeGreyTagRouteResponseBodyDataDubboRulesItems()
                self.items.append(temp_model.from_map(k))
        if m.get('methodName') is not None:
            self.method_name = m.get('methodName')
        if m.get('serviceName') is not None:
            self.service_name = m.get('serviceName')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class DescribeGreyTagRouteResponseBodyDataScRulesItems(TeaModel):
    def __init__(
        self,
        cond: str = None,
        expr: str = None,
        index: int = None,
        name: str = None,
        operator: str = None,
        type: str = None,
        value: str = None,
    ):
        # The comparison operator. Valid values: **>**, **<**, **>=**, **<=**, **==**, and **! =**.
        self.cond = cond
        # This parameter is not returned for Spring Cloud applications.
        self.expr = expr
        # This parameter is not returned for Spring Cloud applications.
        self.index = index
        # The name of the parameter.
        self.name = name
        # The operator. Valid values:
        # 
        # *   **rawvalue**: direct comparison.
        # *   **list**: whitelist.
        # *   **mod**: mods 100.
        # *   **deterministic_proportional_steaming_division**: percentage.
        self.operator = operator
        # The type of the comparison. Valid values:
        # 
        # *   **param**: parameter
        # *   **cookie**: cookie
        # *   **header**: header
        self.type = type
        # The value of the parameter. This value is compared with the value that is obtained based on the **type** and **name** parameters.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cond is not None:
            result['cond'] = self.cond
        if self.expr is not None:
            result['expr'] = self.expr
        if self.index is not None:
            result['index'] = self.index
        if self.name is not None:
            result['name'] = self.name
        if self.operator is not None:
            result['operator'] = self.operator
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cond') is not None:
            self.cond = m.get('cond')
        if m.get('expr') is not None:
            self.expr = m.get('expr')
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeGreyTagRouteResponseBodyDataScRules(TeaModel):
    def __init__(
        self,
        condition: str = None,
        items: List[DescribeGreyTagRouteResponseBodyDataScRulesItems] = None,
        path: str = None,
    ):
        # The relationship between the conditions in the canary release rule. Valid values:
        # 
        # *   **AND**: The conditions are in the logical AND relation. All conditions must be met at the same time.
        # *   **OR**: The conditions are in the logical OR relation. At least one of the conditions must be met.
        self.condition = condition
        # The conditions.
        self.items = items
        # The path of the canary release rule of the Spring Cloud application.
        self.path = path

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['condition'] = self.condition
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.path is not None:
            result['path'] = self.path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = DescribeGreyTagRouteResponseBodyDataScRulesItems()
                self.items.append(temp_model.from_map(k))
        if m.get('path') is not None:
            self.path = m.get('path')
        return self


class DescribeGreyTagRouteResponseBodyData(TeaModel):
    def __init__(
        self,
        alb_rules: List[DescribeGreyTagRouteResponseBodyDataAlbRules] = None,
        app_id: str = None,
        create_time: int = None,
        description: str = None,
        dubbo_rules: List[DescribeGreyTagRouteResponseBodyDataDubboRules] = None,
        grey_tag_route_id: int = None,
        name: str = None,
        sc_rules: List[DescribeGreyTagRouteResponseBodyDataScRules] = None,
        update_time: int = None,
    ):
        self.alb_rules = alb_rules
        # The ID of the application.
        self.app_id = app_id
        # The timestamp when the canary release rule was created. Unit: milliseconds.
        self.create_time = create_time
        # The description of the canary release rule.
        self.description = description
        # The canary release rule of the Dubbo service.
        self.dubbo_rules = dubbo_rules
        # The ID of the canary release rule. The ID is globally unique.
        self.grey_tag_route_id = grey_tag_route_id
        # The name of the canary release rule.
        self.name = name
        # The canary release rule of the Spring Cloud application.
        self.sc_rules = sc_rules
        # The timestamp when the canary release rule was updated. Unit: milliseconds.
        self.update_time = update_time

    def validate(self):
        if self.alb_rules:
            for k in self.alb_rules:
                if k:
                    k.validate()
        if self.dubbo_rules:
            for k in self.dubbo_rules:
                if k:
                    k.validate()
        if self.sc_rules:
            for k in self.sc_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlbRules'] = []
        if self.alb_rules is not None:
            for k in self.alb_rules:
                result['AlbRules'].append(k.to_map() if k else None)
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        result['DubboRules'] = []
        if self.dubbo_rules is not None:
            for k in self.dubbo_rules:
                result['DubboRules'].append(k.to_map() if k else None)
        if self.grey_tag_route_id is not None:
            result['GreyTagRouteId'] = self.grey_tag_route_id
        if self.name is not None:
            result['Name'] = self.name
        result['ScRules'] = []
        if self.sc_rules is not None:
            for k in self.sc_rules:
                result['ScRules'].append(k.to_map() if k else None)
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alb_rules = []
        if m.get('AlbRules') is not None:
            for k in m.get('AlbRules'):
                temp_model = DescribeGreyTagRouteResponseBodyDataAlbRules()
                self.alb_rules.append(temp_model.from_map(k))
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.dubbo_rules = []
        if m.get('DubboRules') is not None:
            for k in m.get('DubboRules'):
                temp_model = DescribeGreyTagRouteResponseBodyDataDubboRules()
                self.dubbo_rules.append(temp_model.from_map(k))
        if m.get('GreyTagRouteId') is not None:
            self.grey_tag_route_id = m.get('GreyTagRouteId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.sc_rules = []
        if m.get('ScRules') is not None:
            for k in m.get('ScRules'):
                temp_model = DescribeGreyTagRouteResponseBodyDataScRules()
                self.sc_rules.append(temp_model.from_map(k))
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeGreyTagRouteResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeGreyTagRouteResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # - **2xx**: The call was successful.
        # - **3xx**: The call was redirected.
        # - **4xx**: The call failed.
        # - **5xx**: A server error occurred.
        self.code = code
        # The information about the canary release rule.
        self.data = data
        # The returned error code. Valid values:
        # 
        # - If the call is successful, the **ErrorCode** parameter is not returned.
        # - If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned information.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the information of the change order was queried. Valid values:
        # 
        # - **true**: The information was queried.
        # - **false**: The information failed to be queried.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeGreyTagRouteResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeGreyTagRouteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGreyTagRouteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGreyTagRouteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeIngressRequest(TeaModel):
    def __init__(
        self,
        ingress_id: int = None,
    ):
        # 87
        self.ingress_id = ingress_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ingress_id is not None:
            result['IngressId'] = self.ingress_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IngressId') is not None:
            self.ingress_id = m.get('IngressId')
        return self


class DescribeIngressResponseBodyDataDefaultRule(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        backend_protocol: str = None,
        container_port: int = None,
    ):
        # The ID of the application specified in the default rule.
        self.app_id = app_id
        # The name of the application specified in the default rule.
        self.app_name = app_name
        self.backend_protocol = backend_protocol
        # The container port of the application specified in the default rule.
        self.container_port = container_port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.backend_protocol is not None:
            result['BackendProtocol'] = self.backend_protocol
        if self.container_port is not None:
            result['ContainerPort'] = self.container_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BackendProtocol') is not None:
            self.backend_protocol = m.get('BackendProtocol')
        if m.get('ContainerPort') is not None:
            self.container_port = m.get('ContainerPort')
        return self


class DescribeIngressResponseBodyDataRules(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        backend_protocol: str = None,
        container_port: int = None,
        domain: str = None,
        path: str = None,
    ):
        # The ID of the application specified in the forwarding rule.
        self.app_id = app_id
        # The name of the application specified in the forwarding rule.
        self.app_name = app_name
        self.backend_protocol = backend_protocol
        # The container port of the application specified in the forwarding rule.
        self.container_port = container_port
        # The domain name of the application.
        self.domain = domain
        # The path of the URL.
        self.path = path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.backend_protocol is not None:
            result['BackendProtocol'] = self.backend_protocol
        if self.container_port is not None:
            result['ContainerPort'] = self.container_port
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.path is not None:
            result['Path'] = self.path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BackendProtocol') is not None:
            self.backend_protocol = m.get('BackendProtocol')
        if m.get('ContainerPort') is not None:
            self.container_port = m.get('ContainerPort')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        return self


class DescribeIngressResponseBodyData(TeaModel):
    def __init__(
        self,
        cert_id: str = None,
        cert_ids: str = None,
        default_rule: DescribeIngressResponseBodyDataDefaultRule = None,
        description: str = None,
        id: int = None,
        listener_port: int = None,
        listener_protocol: str = None,
        load_balance_type: str = None,
        name: str = None,
        namespace_id: str = None,
        rules: List[DescribeIngressResponseBodyDataRules] = None,
        slb_id: str = None,
        slb_type: str = None,
    ):
        # The ID of the certificate.
        self.cert_id = cert_id
        self.cert_ids = cert_ids
        # The default rule.
        self.default_rule = default_rule
        # The name of the routing rule.
        self.description = description
        # The ID of the routing rule.
        self.id = id
        # The port specified for the SLB listener.
        self.listener_port = listener_port
        # The protocol used to forward requests. Valid values:
        # 
        # *   **HTTP**: used when the application needs to identify the transmitted data.
        # *   **HTTPS**: used when the application requires encrypted data transmission.
        self.listener_protocol = listener_protocol
        # The type of the SLB instance based on the processing capabilities. Valid values:
        # 
        # *   **clb**: the Classic Load Balancer (CLB) instance.
        # *   **alb**: the Application Load Balancer (ALB) instance.
        self.load_balance_type = load_balance_type
        # The name of the routing rule.
        self.name = name
        # The ID of the namespace.
        self.namespace_id = namespace_id
        # The forwarding rules.
        self.rules = rules
        # The ID of the SLB instance.
        self.slb_id = slb_id
        # The type of the SLB instance based on the IP address. Valid values:
        # 
        # *   **internet**: the Internet-facing SLB instance.
        # *   **intranet**: the internal-facing SLB instance.
        self.slb_type = slb_type

    def validate(self):
        if self.default_rule:
            self.default_rule.validate()
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_id is not None:
            result['CertId'] = self.cert_id
        if self.cert_ids is not None:
            result['CertIds'] = self.cert_ids
        if self.default_rule is not None:
            result['DefaultRule'] = self.default_rule.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.listener_protocol is not None:
            result['ListenerProtocol'] = self.listener_protocol
        if self.load_balance_type is not None:
            result['LoadBalanceType'] = self.load_balance_type
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        if self.slb_id is not None:
            result['SlbId'] = self.slb_id
        if self.slb_type is not None:
            result['SlbType'] = self.slb_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertId') is not None:
            self.cert_id = m.get('CertId')
        if m.get('CertIds') is not None:
            self.cert_ids = m.get('CertIds')
        if m.get('DefaultRule') is not None:
            temp_model = DescribeIngressResponseBodyDataDefaultRule()
            self.default_rule = temp_model.from_map(m['DefaultRule'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('ListenerProtocol') is not None:
            self.listener_protocol = m.get('ListenerProtocol')
        if m.get('LoadBalanceType') is not None:
            self.load_balance_type = m.get('LoadBalanceType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = DescribeIngressResponseBodyDataRules()
                self.rules.append(temp_model.from_map(k))
        if m.get('SlbId') is not None:
            self.slb_id = m.get('SlbId')
        if m.get('SlbType') is not None:
            self.slb_type = m.get('SlbType')
        return self


class DescribeIngressResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeIngressResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the configurations of the routing rule were queried successfully. Valid values:
        # 
        # *   **true**: indicates that the query was successful.
        # *   **false**: indicates that the query failed.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeIngressResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeIngressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeIngressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeIngressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceLogRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
    ):
        # \*\*\*\*\*\*-d700e680-aa4d-4ec1-afc2-6566b5ff4d7a-85d44d4bfc-\*\*\*\*\*\
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeInstanceLogResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The log of the instance.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the log of the instance was obtained. Valid values:
        # 
        # *   **true**: indicates that the log was obtained.
        # *   **false**: indicates that the log could not be obtained.
        self.success = success
        # The ID of the trace.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeInstanceLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInstanceLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceSpecificationsResponseBodyData(TeaModel):
    def __init__(
        self,
        cpu: int = None,
        enable: bool = None,
        id: int = None,
        memory: int = None,
        spec_info: str = None,
        version: int = None,
    ):
        # The CPU specification of the instance type. Unit: millicore.
        self.cpu = cpu
        # Indicates whether the instance type is available. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.enable = enable
        # The ID of the instance type.
        self.id = id
        # The memory size of the instance type. Unit: MB.
        self.memory = memory
        # The name of the instance type.
        self.spec_info = spec_info
        # The version number of the instance type.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.id is not None:
            result['Id'] = self.id
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.spec_info is not None:
            result['SpecInfo'] = self.spec_info
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('SpecInfo') is not None:
            self.spec_info = m.get('SpecInfo')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DescribeInstanceSpecificationsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[DescribeInstanceSpecificationsResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # Information of instance types.
        self.data = data
        # The error code.
        # 
        # *   If the request is successful, this parameter is not returned.****\
        # *   This parameter is returned only if the request failed.**** For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message. Valid values:
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether information of the instance types is successfully obtained. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeInstanceSpecificationsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeInstanceSpecificationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInstanceSpecificationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceSpecificationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeJobRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        job_id: str = None,
    ):
        self.app_id = app_id
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class DescribeJobResponseBodyDataConfigMapMountDesc(TeaModel):
    def __init__(
        self,
        config_map_id: int = None,
        config_map_name: str = None,
        key: str = None,
        mount_path: str = None,
    ):
        # ConfigMap ID
        self.config_map_id = config_map_id
        self.config_map_name = config_map_name
        self.key = key
        self.mount_path = mount_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        if self.config_map_name is not None:
            result['ConfigMapName'] = self.config_map_name
        if self.key is not None:
            result['Key'] = self.key
        if self.mount_path is not None:
            result['MountPath'] = self.mount_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        if m.get('ConfigMapName') is not None:
            self.config_map_name = m.get('ConfigMapName')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('MountPath') is not None:
            self.mount_path = m.get('MountPath')
        return self


class DescribeJobResponseBodyDataMountDesc(TeaModel):
    def __init__(
        self,
        mount_path: str = None,
        nas_path: str = None,
    ):
        self.mount_path = mount_path
        self.nas_path = nas_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mount_path is not None:
            result['MountPath'] = self.mount_path
        if self.nas_path is not None:
            result['NasPath'] = self.nas_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MountPath') is not None:
            self.mount_path = m.get('MountPath')
        if m.get('NasPath') is not None:
            self.nas_path = m.get('NasPath')
        return self


class DescribeJobResponseBodyDataOssMountDescs(TeaModel):
    def __init__(
        self,
        bucket_name: str = None,
        bucket_path: str = None,
        mount_path: str = None,
        read_only: bool = None,
    ):
        self.bucket_name = bucket_name
        self.bucket_path = bucket_path
        self.mount_path = mount_path
        self.read_only = read_only

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['bucketName'] = self.bucket_name
        if self.bucket_path is not None:
            result['bucketPath'] = self.bucket_path
        if self.mount_path is not None:
            result['mountPath'] = self.mount_path
        if self.read_only is not None:
            result['readOnly'] = self.read_only
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bucketName') is not None:
            self.bucket_name = m.get('bucketName')
        if m.get('bucketPath') is not None:
            self.bucket_path = m.get('bucketPath')
        if m.get('mountPath') is not None:
            self.mount_path = m.get('mountPath')
        if m.get('readOnly') is not None:
            self.read_only = m.get('readOnly')
        return self


class DescribeJobResponseBodyDataTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeJobResponseBodyData(TeaModel):
    def __init__(
        self,
        acr_assume_role_arn: str = None,
        acr_instance_id: str = None,
        app_description: str = None,
        app_id: str = None,
        app_name: str = None,
        backoff_limit: int = None,
        command: str = None,
        command_args: str = None,
        concurrency_policy: str = None,
        config_map_mount_desc: List[DescribeJobResponseBodyDataConfigMapMountDesc] = None,
        cpu: int = None,
        custom_host_alias: str = None,
        edas_container_version: str = None,
        envs: str = None,
        image_pull_secrets: str = None,
        image_url: str = None,
        jar_start_args: str = None,
        jar_start_options: str = None,
        jdk: str = None,
        memory: int = None,
        mount_desc: List[DescribeJobResponseBodyDataMountDesc] = None,
        mount_host: str = None,
        namespace_id: str = None,
        nas_configs: str = None,
        nas_id: str = None,
        oss_ak_id: str = None,
        oss_ak_secret: str = None,
        oss_mount_descs: List[DescribeJobResponseBodyDataOssMountDescs] = None,
        package_type: str = None,
        package_url: str = None,
        package_version: str = None,
        php_config: str = None,
        php_config_location: str = None,
        post_start: str = None,
        pre_stop: str = None,
        programming_language: str = None,
        public_web_hook_urls: List[str] = None,
        python: str = None,
        python_modules: str = None,
        ref_app_id: str = None,
        refed_app_ids: List[str] = None,
        region_id: str = None,
        replicas: int = None,
        security_group_id: str = None,
        slice: bool = None,
        slice_envs: str = None,
        sls_configs: str = None,
        suspend: bool = None,
        tags: List[DescribeJobResponseBodyDataTags] = None,
        termination_grace_period_seconds: int = None,
        timeout: int = None,
        timezone: str = None,
        tomcat_config: str = None,
        trigger_config: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
        vpc_web_hook_urls: List[str] = None,
        war_start_options: str = None,
        web_container: str = None,
    ):
        self.acr_assume_role_arn = acr_assume_role_arn
        self.acr_instance_id = acr_instance_id
        self.app_description = app_description
        self.app_id = app_id
        self.app_name = app_name
        self.backoff_limit = backoff_limit
        self.command = command
        self.command_args = command_args
        self.concurrency_policy = concurrency_policy
        self.config_map_mount_desc = config_map_mount_desc
        self.cpu = cpu
        self.custom_host_alias = custom_host_alias
        self.edas_container_version = edas_container_version
        self.envs = envs
        self.image_pull_secrets = image_pull_secrets
        self.image_url = image_url
        self.jar_start_args = jar_start_args
        self.jar_start_options = jar_start_options
        self.jdk = jdk
        self.memory = memory
        self.mount_desc = mount_desc
        self.mount_host = mount_host
        self.namespace_id = namespace_id
        self.nas_configs = nas_configs
        # NAS ID
        self.nas_id = nas_id
        self.oss_ak_id = oss_ak_id
        self.oss_ak_secret = oss_ak_secret
        self.oss_mount_descs = oss_mount_descs
        self.package_type = package_type
        self.package_url = package_url
        self.package_version = package_version
        self.php_config = php_config
        self.php_config_location = php_config_location
        self.post_start = post_start
        self.pre_stop = pre_stop
        self.programming_language = programming_language
        self.public_web_hook_urls = public_web_hook_urls
        self.python = python
        self.python_modules = python_modules
        self.ref_app_id = ref_app_id
        self.refed_app_ids = refed_app_ids
        self.region_id = region_id
        self.replicas = replicas
        self.security_group_id = security_group_id
        self.slice = slice
        self.slice_envs = slice_envs
        self.sls_configs = sls_configs
        self.suspend = suspend
        self.tags = tags
        self.termination_grace_period_seconds = termination_grace_period_seconds
        self.timeout = timeout
        self.timezone = timezone
        self.tomcat_config = tomcat_config
        self.trigger_config = trigger_config
        # vSwitch ID
        self.v_switch_id = v_switch_id
        # VPC ID
        self.vpc_id = vpc_id
        self.vpc_web_hook_urls = vpc_web_hook_urls
        self.war_start_options = war_start_options
        self.web_container = web_container

    def validate(self):
        if self.config_map_mount_desc:
            for k in self.config_map_mount_desc:
                if k:
                    k.validate()
        if self.mount_desc:
            for k in self.mount_desc:
                if k:
                    k.validate()
        if self.oss_mount_descs:
            for k in self.oss_mount_descs:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acr_assume_role_arn is not None:
            result['AcrAssumeRoleArn'] = self.acr_assume_role_arn
        if self.acr_instance_id is not None:
            result['AcrInstanceId'] = self.acr_instance_id
        if self.app_description is not None:
            result['AppDescription'] = self.app_description
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.backoff_limit is not None:
            result['BackoffLimit'] = self.backoff_limit
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        if self.concurrency_policy is not None:
            result['ConcurrencyPolicy'] = self.concurrency_policy
        result['ConfigMapMountDesc'] = []
        if self.config_map_mount_desc is not None:
            for k in self.config_map_mount_desc:
                result['ConfigMapMountDesc'].append(k.to_map() if k else None)
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.custom_host_alias is not None:
            result['CustomHostAlias'] = self.custom_host_alias
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.image_pull_secrets is not None:
            result['ImagePullSecrets'] = self.image_pull_secrets
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.jar_start_args is not None:
            result['JarStartArgs'] = self.jar_start_args
        if self.jar_start_options is not None:
            result['JarStartOptions'] = self.jar_start_options
        if self.jdk is not None:
            result['Jdk'] = self.jdk
        if self.memory is not None:
            result['Memory'] = self.memory
        result['MountDesc'] = []
        if self.mount_desc is not None:
            for k in self.mount_desc:
                result['MountDesc'].append(k.to_map() if k else None)
        if self.mount_host is not None:
            result['MountHost'] = self.mount_host
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.nas_configs is not None:
            result['NasConfigs'] = self.nas_configs
        if self.nas_id is not None:
            result['NasId'] = self.nas_id
        if self.oss_ak_id is not None:
            result['OssAkId'] = self.oss_ak_id
        if self.oss_ak_secret is not None:
            result['OssAkSecret'] = self.oss_ak_secret
        result['OssMountDescs'] = []
        if self.oss_mount_descs is not None:
            for k in self.oss_mount_descs:
                result['OssMountDescs'].append(k.to_map() if k else None)
        if self.package_type is not None:
            result['PackageType'] = self.package_type
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.php_config is not None:
            result['PhpConfig'] = self.php_config
        if self.php_config_location is not None:
            result['PhpConfigLocation'] = self.php_config_location
        if self.post_start is not None:
            result['PostStart'] = self.post_start
        if self.pre_stop is not None:
            result['PreStop'] = self.pre_stop
        if self.programming_language is not None:
            result['ProgrammingLanguage'] = self.programming_language
        if self.public_web_hook_urls is not None:
            result['PublicWebHookUrls'] = self.public_web_hook_urls
        if self.python is not None:
            result['Python'] = self.python
        if self.python_modules is not None:
            result['PythonModules'] = self.python_modules
        if self.ref_app_id is not None:
            result['RefAppId'] = self.ref_app_id
        if self.refed_app_ids is not None:
            result['RefedAppIds'] = self.refed_app_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.slice is not None:
            result['Slice'] = self.slice
        if self.slice_envs is not None:
            result['SliceEnvs'] = self.slice_envs
        if self.sls_configs is not None:
            result['SlsConfigs'] = self.sls_configs
        if self.suspend is not None:
            result['Suspend'] = self.suspend
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.termination_grace_period_seconds is not None:
            result['TerminationGracePeriodSeconds'] = self.termination_grace_period_seconds
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.tomcat_config is not None:
            result['TomcatConfig'] = self.tomcat_config
        if self.trigger_config is not None:
            result['TriggerConfig'] = self.trigger_config
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vpc_web_hook_urls is not None:
            result['VpcWebHookUrls'] = self.vpc_web_hook_urls
        if self.war_start_options is not None:
            result['WarStartOptions'] = self.war_start_options
        if self.web_container is not None:
            result['WebContainer'] = self.web_container
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcrAssumeRoleArn') is not None:
            self.acr_assume_role_arn = m.get('AcrAssumeRoleArn')
        if m.get('AcrInstanceId') is not None:
            self.acr_instance_id = m.get('AcrInstanceId')
        if m.get('AppDescription') is not None:
            self.app_description = m.get('AppDescription')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BackoffLimit') is not None:
            self.backoff_limit = m.get('BackoffLimit')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        if m.get('ConcurrencyPolicy') is not None:
            self.concurrency_policy = m.get('ConcurrencyPolicy')
        self.config_map_mount_desc = []
        if m.get('ConfigMapMountDesc') is not None:
            for k in m.get('ConfigMapMountDesc'):
                temp_model = DescribeJobResponseBodyDataConfigMapMountDesc()
                self.config_map_mount_desc.append(temp_model.from_map(k))
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CustomHostAlias') is not None:
            self.custom_host_alias = m.get('CustomHostAlias')
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('ImagePullSecrets') is not None:
            self.image_pull_secrets = m.get('ImagePullSecrets')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('JarStartArgs') is not None:
            self.jar_start_args = m.get('JarStartArgs')
        if m.get('JarStartOptions') is not None:
            self.jar_start_options = m.get('JarStartOptions')
        if m.get('Jdk') is not None:
            self.jdk = m.get('Jdk')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        self.mount_desc = []
        if m.get('MountDesc') is not None:
            for k in m.get('MountDesc'):
                temp_model = DescribeJobResponseBodyDataMountDesc()
                self.mount_desc.append(temp_model.from_map(k))
        if m.get('MountHost') is not None:
            self.mount_host = m.get('MountHost')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NasConfigs') is not None:
            self.nas_configs = m.get('NasConfigs')
        if m.get('NasId') is not None:
            self.nas_id = m.get('NasId')
        if m.get('OssAkId') is not None:
            self.oss_ak_id = m.get('OssAkId')
        if m.get('OssAkSecret') is not None:
            self.oss_ak_secret = m.get('OssAkSecret')
        self.oss_mount_descs = []
        if m.get('OssMountDescs') is not None:
            for k in m.get('OssMountDescs'):
                temp_model = DescribeJobResponseBodyDataOssMountDescs()
                self.oss_mount_descs.append(temp_model.from_map(k))
        if m.get('PackageType') is not None:
            self.package_type = m.get('PackageType')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('PhpConfig') is not None:
            self.php_config = m.get('PhpConfig')
        if m.get('PhpConfigLocation') is not None:
            self.php_config_location = m.get('PhpConfigLocation')
        if m.get('PostStart') is not None:
            self.post_start = m.get('PostStart')
        if m.get('PreStop') is not None:
            self.pre_stop = m.get('PreStop')
        if m.get('ProgrammingLanguage') is not None:
            self.programming_language = m.get('ProgrammingLanguage')
        if m.get('PublicWebHookUrls') is not None:
            self.public_web_hook_urls = m.get('PublicWebHookUrls')
        if m.get('Python') is not None:
            self.python = m.get('Python')
        if m.get('PythonModules') is not None:
            self.python_modules = m.get('PythonModules')
        if m.get('RefAppId') is not None:
            self.ref_app_id = m.get('RefAppId')
        if m.get('RefedAppIds') is not None:
            self.refed_app_ids = m.get('RefedAppIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('Slice') is not None:
            self.slice = m.get('Slice')
        if m.get('SliceEnvs') is not None:
            self.slice_envs = m.get('SliceEnvs')
        if m.get('SlsConfigs') is not None:
            self.sls_configs = m.get('SlsConfigs')
        if m.get('Suspend') is not None:
            self.suspend = m.get('Suspend')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = DescribeJobResponseBodyDataTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TerminationGracePeriodSeconds') is not None:
            self.termination_grace_period_seconds = m.get('TerminationGracePeriodSeconds')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('TomcatConfig') is not None:
            self.tomcat_config = m.get('TomcatConfig')
        if m.get('TriggerConfig') is not None:
            self.trigger_config = m.get('TriggerConfig')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VpcWebHookUrls') is not None:
            self.vpc_web_hook_urls = m.get('VpcWebHookUrls')
        if m.get('WarStartOptions') is not None:
            self.war_start_options = m.get('WarStartOptions')
        if m.get('WebContainer') is not None:
            self.web_container = m.get('WebContainer')
        return self


class DescribeJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeJobResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeJobHistoryRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        current_page: int = None,
        page_size: int = None,
        state: str = None,
    ):
        self.app_id = app_id
        self.current_page = current_page
        self.page_size = page_size
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class DescribeJobHistoryResponseBodyDataJobs(TeaModel):
    def __init__(
        self,
        active: int = None,
        completion_time: int = None,
        failed: int = None,
        job_id: str = None,
        message: str = None,
        start_time: int = None,
        state: str = None,
        succeeded: int = None,
    ):
        self.active = active
        self.completion_time = completion_time
        self.failed = failed
        self.job_id = job_id
        self.message = message
        self.start_time = start_time
        self.state = state
        self.succeeded = succeeded

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active is not None:
            result['Active'] = self.active
        if self.completion_time is not None:
            result['CompletionTime'] = self.completion_time
        if self.failed is not None:
            result['Failed'] = self.failed
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.state is not None:
            result['State'] = self.state
        if self.succeeded is not None:
            result['Succeeded'] = self.succeeded
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Active') is not None:
            self.active = m.get('Active')
        if m.get('CompletionTime') is not None:
            self.completion_time = m.get('CompletionTime')
        if m.get('Failed') is not None:
            self.failed = m.get('Failed')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Succeeded') is not None:
            self.succeeded = m.get('Succeeded')
        return self


class DescribeJobHistoryResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        jobs: List[DescribeJobHistoryResponseBodyDataJobs] = None,
        page_size: int = None,
        total_size: int = None,
    ):
        self.current_page = current_page
        self.jobs = jobs
        self.page_size = page_size
        self.total_size = total_size

    def validate(self):
        if self.jobs:
            for k in self.jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['Jobs'] = []
        if self.jobs is not None:
            for k in self.jobs:
                result['Jobs'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.jobs = []
        if m.get('Jobs') is not None:
            for k in m.get('Jobs'):
                temp_model = DescribeJobHistoryResponseBodyDataJobs()
                self.jobs.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class DescribeJobHistoryResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeJobHistoryResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeJobHistoryResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeJobHistoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeJobHistoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeJobHistoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeJobStatusRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        job_id: str = None,
    ):
        self.app_id = app_id
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class DescribeJobStatusResponseBodyData(TeaModel):
    def __init__(
        self,
        active: int = None,
        completion_time: int = None,
        failed: int = None,
        job_id: str = None,
        message: str = None,
        start_time: int = None,
        state: str = None,
        succeeded: int = None,
    ):
        self.active = active
        self.completion_time = completion_time
        self.failed = failed
        self.job_id = job_id
        self.message = message
        self.start_time = start_time
        self.state = state
        self.succeeded = succeeded

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active is not None:
            result['Active'] = self.active
        if self.completion_time is not None:
            result['CompletionTime'] = self.completion_time
        if self.failed is not None:
            result['Failed'] = self.failed
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.state is not None:
            result['State'] = self.state
        if self.succeeded is not None:
            result['Succeeded'] = self.succeeded
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Active') is not None:
            self.active = m.get('Active')
        if m.get('CompletionTime') is not None:
            self.completion_time = m.get('CompletionTime')
        if m.get('Failed') is not None:
            self.failed = m.get('Failed')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Succeeded') is not None:
            self.succeeded = m.get('Succeeded')
        return self


class DescribeJobStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeJobStatusResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeJobStatusResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeJobStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeJobStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeJobStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNamespaceRequest(TeaModel):
    def __init__(
        self,
        name_space_short_id: str = None,
        namespace_id: str = None,
    ):
        self.name_space_short_id = name_space_short_id
        # cn-beijing:test
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class DescribeNamespaceResponseBodyData(TeaModel):
    def __init__(
        self,
        enable_micro_registration: bool = None,
        name_space_short_id: str = None,
        namespace_description: str = None,
        namespace_id: str = None,
        namespace_name: str = None,
        region_id: str = None,
    ):
        self.enable_micro_registration = enable_micro_registration
        self.name_space_short_id = name_space_short_id
        # The description of the namespace.
        self.namespace_description = namespace_description
        # The ID of the namespace. The information of the default namespace cannot be queried or modified. The default namespace cannot be deleted.
        self.namespace_id = namespace_id
        # The name of the namespace.
        self.namespace_name = namespace_name
        # The ID of the region.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_micro_registration is not None:
            result['EnableMicroRegistration'] = self.enable_micro_registration
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_description is not None:
            result['NamespaceDescription'] = self.namespace_description
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.namespace_name is not None:
            result['NamespaceName'] = self.namespace_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableMicroRegistration') is not None:
            self.enable_micro_registration = m.get('EnableMicroRegistration')
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceDescription') is not None:
            self.namespace_description = m.get('NamespaceDescription')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NamespaceName') is not None:
            self.namespace_name = m.get('NamespaceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeNamespaceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeNamespaceResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The information of the namespace.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the information of the namespace was queried successfully. Valid values:
        # 
        # *   **true**: indicates that the query was successful.
        # *   **false**: indicates that the query failed.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeNamespaceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeNamespaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNamespaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNamespaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNamespaceListRequest(TeaModel):
    def __init__(
        self,
        contain_custom: bool = None,
        hybrid_cloud_exclude: bool = None,
    ):
        # true
        self.contain_custom = contain_custom
        # true
        self.hybrid_cloud_exclude = hybrid_cloud_exclude

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contain_custom is not None:
            result['ContainCustom'] = self.contain_custom
        if self.hybrid_cloud_exclude is not None:
            result['HybridCloudExclude'] = self.hybrid_cloud_exclude
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContainCustom') is not None:
            self.contain_custom = m.get('ContainCustom')
        if m.get('HybridCloudExclude') is not None:
            self.hybrid_cloud_exclude = m.get('HybridCloudExclude')
        return self


class DescribeNamespaceListResponseBodyData(TeaModel):
    def __init__(
        self,
        agent_install: str = None,
        current: bool = None,
        custom: bool = None,
        hybrid_cloud_enable: bool = None,
        name_space_short_id: str = None,
        namespace_id: str = None,
        namespace_name: str = None,
        region_id: str = None,
        security_group_id: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
    ):
        # The command that was run to install the agent.
        self.agent_install = agent_install
        # This parameter is no longer valid.
        self.current = current
        # Indicates whether custom namespaces are returned. Valid values:
        # 
        # *   **true**: Custom namespaces are returned.
        # *   **false**: Custom namespaces are not returned.
        self.custom = custom
        # Specifies whether hybrid cloud namespaces are excluded. Valid values:
        # 
        # *   **true**: Hybrid cloud namespaces are excluded.
        # *   **false**: Hybrid cloud namespaces are included.
        self.hybrid_cloud_enable = hybrid_cloud_enable
        self.name_space_short_id = name_space_short_id
        # The ID of the namespace.
        self.namespace_id = namespace_id
        # The name of the namespace.
        self.namespace_name = namespace_name
        # The region to which the namespace belongs.
        self.region_id = region_id
        # The ID of the security group.
        self.security_group_id = security_group_id
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_install is not None:
            result['AgentInstall'] = self.agent_install
        if self.current is not None:
            result['Current'] = self.current
        if self.custom is not None:
            result['Custom'] = self.custom
        if self.hybrid_cloud_enable is not None:
            result['HybridCloudEnable'] = self.hybrid_cloud_enable
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.namespace_name is not None:
            result['NamespaceName'] = self.namespace_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentInstall') is not None:
            self.agent_install = m.get('AgentInstall')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        if m.get('Custom') is not None:
            self.custom = m.get('Custom')
        if m.get('HybridCloudEnable') is not None:
            self.hybrid_cloud_enable = m.get('HybridCloudEnable')
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NamespaceName') is not None:
            self.namespace_name = m.get('NamespaceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeNamespaceListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[DescribeNamespaceListResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The list of namespaces.
        self.data = data
        # The returned error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned information. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the namespaces were obtained. Valid values:
        # 
        # *   **true**: The namespaces were obtained.
        # *   **false**: The namespaces failed to be obtained.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeNamespaceListResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeNamespaceListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNamespaceListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNamespaceListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNamespaceResourcesRequest(TeaModel):
    def __init__(
        self,
        name_space_short_id: str = None,
        namespace_id: str = None,
    ):
        self.name_space_short_id = name_space_short_id
        # cn-shanghai:test
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class DescribeNamespaceResourcesResponseBodyData(TeaModel):
    def __init__(
        self,
        app_count: int = None,
        belong_region: str = None,
        description: str = None,
        jump_server_app_id: str = None,
        jump_server_ip: str = None,
        last_change_order_id: str = None,
        last_change_order_running: bool = None,
        last_change_order_status: str = None,
        name_space_short_id: str = None,
        namespace_id: str = None,
        namespace_name: str = None,
        notification_expired: bool = None,
        security_group_id: str = None,
        tenant_id: str = None,
        user_id: str = None,
        v_switch_id: str = None,
        v_switch_name: str = None,
        vpc_id: str = None,
        vpc_name: str = None,
    ):
        # The number of applications.
        self.app_count = app_count
        # The region to which the namespace belongs.
        self.belong_region = belong_region
        # The description of the namespace.
        self.description = description
        # The ID of the jump server application.
        self.jump_server_app_id = jump_server_app_id
        # The IP address of the jump server.
        self.jump_server_ip = jump_server_ip
        # The ID of the change order.
        self.last_change_order_id = last_change_order_id
        # Indicates whether a change order is being executed in the namespace. Valid values:
        # 
        # *   **true**: indicates that a change order is being executed in the namespace.
        # *   **false**: indicates that no change orders are being executed in the namespace.
        self.last_change_order_running = last_change_order_running
        # The status of the latest change order. Valid values:
        # 
        # *   **READY**: The change order is ready.
        # *   **RUNNING**: The change order is being executed.
        # *   **SUCCESS**: The change order was executed.
        # *   **FAIL**: The change order could not be executed.
        # *   **ABORT**: The change order was terminated.
        # *   **WAIT_BATCH_CONFIRM**: The change order is pending execution. You must manually confirm the release batch.
        # *   **AUTO_BATCH_WAIT**: The change order is pending execution. SAE will automatically confirm the release batch.
        # *   **SYSTEM_FAIL**: A system exception occurred.
        # *   **WAIT_APPROVAL**: The change order is pending approval.
        # *   **APPROVED**: The change order is approved and is pending execution.
        self.last_change_order_status = last_change_order_status
        self.name_space_short_id = name_space_short_id
        # The ID of the namespace.
        self.namespace_id = namespace_id
        # The name of the namespace.
        self.namespace_name = namespace_name
        # Indicates whether the notification of a change order is expired. Valid values:
        # 
        # *   **true**: indicates that the notification is expired.
        # *   **false**: indicates that the notification is not expired.
        self.notification_expired = notification_expired
        # The ID of the security group.
        self.security_group_id = security_group_id
        # The ID of the tenant in the SAE namespace.
        self.tenant_id = tenant_id
        # The ID of the user.
        self.user_id = user_id
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id
        # The name of the vSwitch.
        self.v_switch_name = v_switch_name
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id
        # The name of the VPC.
        self.vpc_name = vpc_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_count is not None:
            result['AppCount'] = self.app_count
        if self.belong_region is not None:
            result['BelongRegion'] = self.belong_region
        if self.description is not None:
            result['Description'] = self.description
        if self.jump_server_app_id is not None:
            result['JumpServerAppId'] = self.jump_server_app_id
        if self.jump_server_ip is not None:
            result['JumpServerIp'] = self.jump_server_ip
        if self.last_change_order_id is not None:
            result['LastChangeOrderId'] = self.last_change_order_id
        if self.last_change_order_running is not None:
            result['LastChangeOrderRunning'] = self.last_change_order_running
        if self.last_change_order_status is not None:
            result['LastChangeOrderStatus'] = self.last_change_order_status
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.namespace_name is not None:
            result['NamespaceName'] = self.namespace_name
        if self.notification_expired is not None:
            result['NotificationExpired'] = self.notification_expired
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.v_switch_name is not None:
            result['VSwitchName'] = self.v_switch_name
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vpc_name is not None:
            result['VpcName'] = self.vpc_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppCount') is not None:
            self.app_count = m.get('AppCount')
        if m.get('BelongRegion') is not None:
            self.belong_region = m.get('BelongRegion')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('JumpServerAppId') is not None:
            self.jump_server_app_id = m.get('JumpServerAppId')
        if m.get('JumpServerIp') is not None:
            self.jump_server_ip = m.get('JumpServerIp')
        if m.get('LastChangeOrderId') is not None:
            self.last_change_order_id = m.get('LastChangeOrderId')
        if m.get('LastChangeOrderRunning') is not None:
            self.last_change_order_running = m.get('LastChangeOrderRunning')
        if m.get('LastChangeOrderStatus') is not None:
            self.last_change_order_status = m.get('LastChangeOrderStatus')
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NamespaceName') is not None:
            self.namespace_name = m.get('NamespaceName')
        if m.get('NotificationExpired') is not None:
            self.notification_expired = m.get('NotificationExpired')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VSwitchName') is not None:
            self.v_switch_name = m.get('VSwitchName')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VpcName') is not None:
            self.vpc_name = m.get('VpcName')
        return self


class DescribeNamespaceResourcesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeNamespaceResourcesResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request failed.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the information about resources in the namespace was queried successfully. Valid values:
        # 
        # *   **true**: indicates that the query was successful.
        # *   **false**: indicates that the query failed.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeNamespaceResourcesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeNamespaceResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNamespaceResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNamespaceResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNamespacesRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
    ):
        # 1
        self.current_page = current_page
        # 10
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeNamespacesResponseBodyDataNamespaces(TeaModel):
    def __init__(
        self,
        access_key: str = None,
        address_server_host: str = None,
        name_space_short_id: str = None,
        namespace_description: str = None,
        namespace_id: str = None,
        namespace_name: str = None,
        region_id: str = None,
        secret_key: str = None,
        tenant_id: str = None,
    ):
        # The ACM-specific AccessKey ID. It can be used to manage data in an Application Configuration Management (ACM) namespace. For more information, see [Differences between Alibaba Cloud AccessKey and ACM-specific AccessKey](~~~~).
        self.access_key = access_key
        self.address_server_host = address_server_host
        self.name_space_short_id = name_space_short_id
        # The description of the namespace.
        self.namespace_description = namespace_description
        # The ID of the namespace. The information of the default namespace cannot be queried or modified. The default namespace cannot be deleted.
        self.namespace_id = namespace_id
        # The name of the namespace.
        self.namespace_name = namespace_name
        # The ID of the region.
        self.region_id = region_id
        # The ACM-specific AccessKey secret. It can be used to manage data in an ACM namespace. For more information, see [Differences between Alibaba Cloud AccessKey and ACM-specific AccessKey](~~~~).
        self.secret_key = secret_key
        # The ID of the tenant.
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_key is not None:
            result['AccessKey'] = self.access_key
        if self.address_server_host is not None:
            result['AddressServerHost'] = self.address_server_host
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_description is not None:
            result['NamespaceDescription'] = self.namespace_description
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.namespace_name is not None:
            result['NamespaceName'] = self.namespace_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.secret_key is not None:
            result['SecretKey'] = self.secret_key
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessKey') is not None:
            self.access_key = m.get('AccessKey')
        if m.get('AddressServerHost') is not None:
            self.address_server_host = m.get('AddressServerHost')
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceDescription') is not None:
            self.namespace_description = m.get('NamespaceDescription')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NamespaceName') is not None:
            self.namespace_name = m.get('NamespaceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SecretKey') is not None:
            self.secret_key = m.get('SecretKey')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeNamespacesResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        namespaces: List[DescribeNamespacesResponseBodyDataNamespaces] = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # The list of namespaces.
        self.namespaces = namespaces
        # The number of entries returned on each page.
        self.page_size = page_size
        # The total number of namespaces.
        self.total_size = total_size

    def validate(self):
        if self.namespaces:
            for k in self.namespaces:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['Namespaces'] = []
        if self.namespaces is not None:
            for k in self.namespaces:
                result['Namespaces'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.namespaces = []
        if m.get('Namespaces') is not None:
            for k in m.get('Namespaces'):
                temp_model = DescribeNamespacesResponseBodyDataNamespaces()
                self.namespaces.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class DescribeNamespacesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeNamespacesResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request failed.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The information of namespaces.
        self.data = data
        # The error code. 
        # 
        # - The **ErrorCode** parameter is not returned when the request succeeds.
        # - The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error message is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the details of namespaces were queried successfully. Valid values:
        # 
        # *   **true**: indicates that the query was successful.
        # *   **false**: indicates that the query failed.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeNamespacesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeNamespacesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNamespacesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNamespacesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePipelineRequest(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
    ):
        # 917660ba-5092-44ca-b8e0-80012c96\*\*\*\*\
        self.pipeline_id = pipeline_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        return self


class DescribePipelineResponseBodyDataStageListTaskList(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_ignore: int = None,
        error_message: str = None,
        message: str = None,
        show_manual_ignore: bool = None,
        stage_id: str = None,
        status: int = None,
        task_id: str = None,
        task_name: str = None,
    ):
        # The error code returned when the task could not be executed. If the task is successfully executed, this parameter is not returned.
        self.error_code = error_code
        # Indicates whether to execute the subsequent tasks when the task failed. Valid values:
        # 
        # *   **0**: The subsequent tasks cannot be executed.
        # *   **1**: The subsequent tasks can be executed.
        self.error_ignore = error_ignore
        # The error message returned when the task could not be executed. If the task is successfully executed, this parameter is not returned.
        self.error_message = error_message
        # The returned message indicating the task execution result.
        self.message = message
        # Indicates whether a running task can be manually skipped. Valid values:
        # 
        # *   **true**: The running task can be skipped.
        # *   **false**: The running task cannot be skipped.
        self.show_manual_ignore = show_manual_ignore
        # The ID of the stage.
        self.stage_id = stage_id
        # The task status. Valid values:
        # 
        # *   **0**: The task is prepared for execution.
        # *   **1**: The task is being executed.
        # *   **2**: The task was executed.
        # *   **3**: The task could not be executed.
        # *   **5**: The task is pending retry.
        # *   **6**: The task was terminated.
        self.status = status
        # The ID of the task.
        self.task_id = task_id
        # The name of the task.
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_ignore is not None:
            result['ErrorIgnore'] = self.error_ignore
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message is not None:
            result['Message'] = self.message
        if self.show_manual_ignore is not None:
            result['ShowManualIgnore'] = self.show_manual_ignore
        if self.stage_id is not None:
            result['StageId'] = self.stage_id
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorIgnore') is not None:
            self.error_ignore = m.get('ErrorIgnore')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ShowManualIgnore') is not None:
            self.show_manual_ignore = m.get('ShowManualIgnore')
        if m.get('StageId') is not None:
            self.stage_id = m.get('StageId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        return self


class DescribePipelineResponseBodyDataStageList(TeaModel):
    def __init__(
        self,
        executor_type: int = None,
        stage_id: str = None,
        stage_name: str = None,
        status: int = None,
        task_list: List[DescribePipelineResponseBodyDataStageListTaskList] = None,
    ):
        # The execution type of the stage. Valid values:
        # 
        # *   **0**: in sequence.
        # *   **1**: in parallel.
        self.executor_type = executor_type
        # The ID of the stage.
        self.stage_id = stage_id
        # The name of the stage.
        self.stage_name = stage_name
        # The status of the batch processing stage. Valid values:
        # 
        # *   **0**: The batch is prepared for this processing stage.
        # *   **1**: The processing stage is in progress.
        # *   **2**: The processing stage was complete.
        # *   **3**: The processing failed in this stage.
        # *   **6**: The processing stage was terminated.
        self.status = status
        # The list of task statuses.
        self.task_list = task_list

    def validate(self):
        if self.task_list:
            for k in self.task_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.executor_type is not None:
            result['ExecutorType'] = self.executor_type
        if self.stage_id is not None:
            result['StageId'] = self.stage_id
        if self.stage_name is not None:
            result['StageName'] = self.stage_name
        if self.status is not None:
            result['Status'] = self.status
        result['TaskList'] = []
        if self.task_list is not None:
            for k in self.task_list:
                result['TaskList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExecutorType') is not None:
            self.executor_type = m.get('ExecutorType')
        if m.get('StageId') is not None:
            self.stage_id = m.get('StageId')
        if m.get('StageName') is not None:
            self.stage_name = m.get('StageName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.task_list = []
        if m.get('TaskList') is not None:
            for k in m.get('TaskList'):
                temp_model = DescribePipelineResponseBodyDataStageListTaskList()
                self.task_list.append(temp_model.from_map(k))
        return self


class DescribePipelineResponseBodyData(TeaModel):
    def __init__(
        self,
        co_status: str = None,
        current_stage_id: str = None,
        next_pipeline_id: str = None,
        pipeline_id: str = None,
        pipeline_name: str = None,
        pipeline_status: int = None,
        show_batch: bool = None,
        stage_list: List[DescribePipelineResponseBodyDataStageList] = None,
    ):
        # The status of the change order for the batch.
        self.co_status = co_status
        # The ID of the batch processing stage.
        self.current_stage_id = current_stage_id
        # The ID of the next batch.
        self.next_pipeline_id = next_pipeline_id
        # The ID of the batch.
        self.pipeline_id = pipeline_id
        # The name of the batch.
        self.pipeline_name = pipeline_name
        # The batch status. Valid values:
        # 
        # *   **0**: The batch is prepared for processing.
        # *   **1**: The batch is being processed.
        # *   **2**: The batch was processed.
        # *   **3**: The batch could not be processed.
        # *   **6**: The batch processing was terminated.
        # *   **10**: The batch could not be processed due to a system exception.
        self.pipeline_status = pipeline_status
        # Indicates whether to start processing the next batch. Valid values:
        # 
        # *   **false**: indicates that the next batch cannot be processed yet.
        # *   **true**: indicates that the next batch can be processed now.
        self.show_batch = show_batch
        # The list of batch processing stages.
        self.stage_list = stage_list

    def validate(self):
        if self.stage_list:
            for k in self.stage_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.co_status is not None:
            result['CoStatus'] = self.co_status
        if self.current_stage_id is not None:
            result['CurrentStageId'] = self.current_stage_id
        if self.next_pipeline_id is not None:
            result['NextPipelineId'] = self.next_pipeline_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.pipeline_name is not None:
            result['PipelineName'] = self.pipeline_name
        if self.pipeline_status is not None:
            result['PipelineStatus'] = self.pipeline_status
        if self.show_batch is not None:
            result['ShowBatch'] = self.show_batch
        result['StageList'] = []
        if self.stage_list is not None:
            for k in self.stage_list:
                result['StageList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CoStatus') is not None:
            self.co_status = m.get('CoStatus')
        if m.get('CurrentStageId') is not None:
            self.current_stage_id = m.get('CurrentStageId')
        if m.get('NextPipelineId') is not None:
            self.next_pipeline_id = m.get('NextPipelineId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('PipelineName') is not None:
            self.pipeline_name = m.get('PipelineName')
        if m.get('PipelineStatus') is not None:
            self.pipeline_status = m.get('PipelineStatus')
        if m.get('ShowBatch') is not None:
            self.show_batch = m.get('ShowBatch')
        self.stage_list = []
        if m.get('StageList') is not None:
            for k in m.get('StageList'):
                temp_model = DescribePipelineResponseBodyDataStageList()
                self.stage_list.append(temp_model.from_map(k))
        return self


class DescribePipelineResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribePipelineResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The batch information.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the batch information was obtained. Valid values:
        # 
        # *   **true**: indicates that the information was obtained.
        # *   **false**: indicates that the information could not be obtained.
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribePipelineResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribePipelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePipelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRegionsResponseBodyRegionsRegionRecommendZones(TeaModel):
    def __init__(
        self,
        recommend_zone: List[str] = None,
    ):
        self.recommend_zone = recommend_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.recommend_zone is not None:
            result['RecommendZone'] = self.recommend_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RecommendZone') is not None:
            self.recommend_zone = m.get('RecommendZone')
        return self


class DescribeRegionsResponseBodyRegionsRegion(TeaModel):
    def __init__(
        self,
        local_name: str = None,
        recommend_zones: DescribeRegionsResponseBodyRegionsRegionRecommendZones = None,
        region_endpoint: str = None,
        region_id: str = None,
    ):
        # The list of regions.
        self.local_name = local_name
        # The ID of the region. Valid values:
        # 
        # *   **cn-hangzhou**: the ID of the China (Hangzhou) region
        # *   **cn-shanghai**: the ID of the China (Shanghai) region
        # *   **cn-beijing**: the ID of the China (Beijing) region
        # *   **cn-zhangjiakou**: the ID of the China (Zhangjiakou) region
        # *   **cn-shenzhen**: the ID of the China (Shenzhen) region
        # *   **cn-guangzhou**: the ID of the China (Guangzhou) region
        # *   **cn-hongkong**: the ID of the China (Hong Kong) region
        # *   **ap-southeast-1**: the ID of the Singapore region
        # *   **us-west-1**: the ID of the US (Silicon Valley) region
        self.recommend_zones = recommend_zones
        # The name of the region. Valid values:
        # 
        # *   **China (Hangzhou)**\
        # *   **China (Shanghai)**\
        # *   **China (Beijing)**\
        # *   **China (Zhangjiakou)**\
        # *   **China (Shenzhen)**\
        # *   **China (Guangzhou)**\
        # *   **China (Hong Kong)**\
        # *   **Singapore (Singapore)**\
        # *   **US (Silicon Valley)**\
        self.region_endpoint = region_endpoint
        # The endpoint of the region. Valid values:
        # 
        # *   **sae.cn-hangzhou.aliyuncs.com**\
        # *   **sae.cn-shanghai.aliyuncs.com**\
        # *   **sae.cn-beijing.aliyuncs.com**\
        # *   **sae.cn-zhangjiakou.aliyuncs.com**\
        # *   **sae.cn-shenzhen.aliyuncs.com**\
        # *   **sae.cn-guangzhou.aliyuncs.com**\
        # *   **sae.cn-hongkong.aliyuncs.com**\
        # *   **sae.ap-southeast-1.aliyuncs.com**\
        # *   **sae.us-west-1.aliyuncs.com**\
        self.region_id = region_id

    def validate(self):
        if self.recommend_zones:
            self.recommend_zones.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.local_name is not None:
            result['LocalName'] = self.local_name
        if self.recommend_zones is not None:
            result['RecommendZones'] = self.recommend_zones.to_map()
        if self.region_endpoint is not None:
            result['RegionEndpoint'] = self.region_endpoint
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LocalName') is not None:
            self.local_name = m.get('LocalName')
        if m.get('RecommendZones') is not None:
            temp_model = DescribeRegionsResponseBodyRegionsRegionRecommendZones()
            self.recommend_zones = temp_model.from_map(m['RecommendZones'])
        if m.get('RegionEndpoint') is not None:
            self.region_endpoint = m.get('RegionEndpoint')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeRegionsResponseBodyRegions(TeaModel):
    def __init__(
        self,
        region: List[DescribeRegionsResponseBodyRegionsRegion] = None,
    ):
        self.region = region

    def validate(self):
        if self.region:
            for k in self.region:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Region'] = []
        if self.region is not None:
            for k in self.region:
                result['Region'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.region = []
        if m.get('Region') is not None:
            for k in m.get('Region'):
                temp_model = DescribeRegionsResponseBodyRegionsRegion()
                self.region.append(temp_model.from_map(k))
        return self


class DescribeRegionsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        regions: DescribeRegionsResponseBodyRegions = None,
        request_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # - **2xx**: The call was successful.
        # - **3xx**: The call was redirected.
        # - **4xx**: The call failed.
        # - **5xx**: A server error occurred.
        self.code = code
        # No request parameters are required.
        self.message = message
        # The ID of the request.
        self.regions = regions
        # The returned information.
        self.request_id = request_id

    def validate(self):
        if self.regions:
            self.regions.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.regions is not None:
            result['Regions'] = self.regions.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Regions') is not None:
            temp_model = DescribeRegionsResponseBodyRegions()
            self.regions = temp_model.from_map(m['Regions'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeRegionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRegionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRegionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecretRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
        secret_id: int = None,
    ):
        self.namespace_id = namespace_id
        self.secret_id = secret_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.secret_id is not None:
            result['SecretId'] = self.secret_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('SecretId') is not None:
            self.secret_id = m.get('SecretId')
        return self


class DescribeSecretResponseBodyDataRelateApps(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
    ):
        self.app_id = app_id
        self.app_name = app_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        return self


class DescribeSecretResponseBodyData(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        namespace_id: str = None,
        relate_apps: List[DescribeSecretResponseBodyDataRelateApps] = None,
        secret_data: Dict[str, str] = None,
        secret_id: int = None,
        secret_name: str = None,
        secret_type: str = None,
        update_time: int = None,
    ):
        self.create_time = create_time
        self.namespace_id = namespace_id
        self.relate_apps = relate_apps
        self.secret_data = secret_data
        self.secret_id = secret_id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.update_time = update_time

    def validate(self):
        if self.relate_apps:
            for k in self.relate_apps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        result['RelateApps'] = []
        if self.relate_apps is not None:
            for k in self.relate_apps:
                result['RelateApps'].append(k.to_map() if k else None)
        if self.secret_data is not None:
            result['SecretData'] = self.secret_data
        if self.secret_id is not None:
            result['SecretId'] = self.secret_id
        if self.secret_name is not None:
            result['SecretName'] = self.secret_name
        if self.secret_type is not None:
            result['SecretType'] = self.secret_type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        self.relate_apps = []
        if m.get('RelateApps') is not None:
            for k in m.get('RelateApps'):
                temp_model = DescribeSecretResponseBodyDataRelateApps()
                self.relate_apps.append(temp_model.from_map(k))
        if m.get('SecretData') is not None:
            self.secret_data = m.get('SecretData')
        if m.get('SecretId') is not None:
            self.secret_id = m.get('SecretId')
        if m.get('SecretName') is not None:
            self.secret_name = m.get('SecretName')
        if m.get('SecretType') is not None:
            self.secret_type = m.get('SecretType')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeSecretResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeSecretResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeSecretResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeSecretResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSecretResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecretResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableApplicationScalingRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        scaling_rule_name: str = None,
    ):
        # 7171a6ca-d1cd-4928-8642-7d5cfe69\*\*\*\*\
        self.app_id = app_id
        # timer-0800-2100
        self.scaling_rule_name = scaling_rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.scaling_rule_name is not None:
            result['ScalingRuleName'] = self.scaling_rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ScalingRuleName') is not None:
            self.scaling_rule_name = m.get('ScalingRuleName')
        return self


class DisableApplicationScalingRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.error_code = error_code
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DisableApplicationScalingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableApplicationScalingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableApplicationScalingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableApplicationScalingRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        scaling_rule_name: str = None,
    ):
        # 7171a6ca-d1cd-4928-8642-7d5cfe69\*\*\*\*\
        self.app_id = app_id
        # timer-0800-2100
        self.scaling_rule_name = scaling_rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.scaling_rule_name is not None:
            result['ScalingRuleName'] = self.scaling_rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ScalingRuleName') is not None:
            self.scaling_rule_name = m.get('ScalingRuleName')
        return self


class EnableApplicationScalingRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.error_code = error_code
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class EnableApplicationScalingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableApplicationScalingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableApplicationScalingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecJobRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        command: str = None,
        command_args: str = None,
        envs: str = None,
        event_id: str = None,
        jar_start_args: str = None,
        jar_start_options: str = None,
        replicas: str = None,
        time: str = None,
        war_start_options: str = None,
    ):
        self.app_id = app_id
        self.command = command
        self.command_args = command_args
        self.envs = envs
        self.event_id = event_id
        self.jar_start_args = jar_start_args
        self.jar_start_options = jar_start_options
        self.replicas = replicas
        self.time = time
        self.war_start_options = war_start_options

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.jar_start_args is not None:
            result['JarStartArgs'] = self.jar_start_args
        if self.jar_start_options is not None:
            result['JarStartOptions'] = self.jar_start_options
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.time is not None:
            result['Time'] = self.time
        if self.war_start_options is not None:
            result['WarStartOptions'] = self.war_start_options
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('JarStartArgs') is not None:
            self.jar_start_args = m.get('JarStartArgs')
        if m.get('JarStartOptions') is not None:
            self.jar_start_options = m.get('JarStartOptions')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('WarStartOptions') is not None:
            self.war_start_options = m.get('WarStartOptions')
        return self


class ExecJobResponseBodyData(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        msg: str = None,
        success: str = None,
    ):
        self.code = code
        self.data = data
        self.msg = msg
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExecJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ExecJobResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ExecJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ExecJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExecJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetArmsTopNMetricRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        limit: int = None,
        order_by: str = None,
        region_id: str = None,
        start_time: int = None,
    ):
        self.end_time = end_time
        self.limit = limit
        self.order_by = order_by
        self.region_id = region_id
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetArmsTopNMetricResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        count: int = None,
        error: int = None,
        name: str = None,
        region_id: str = None,
        rt: int = None,
    ):
        self.app_id = app_id
        self.count = count
        self.error = error
        self.name = name
        self.region_id = region_id
        self.rt = rt

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.count is not None:
            result['Count'] = self.count
        if self.error is not None:
            result['Error'] = self.error
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rt is not None:
            result['Rt'] = self.rt
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Error') is not None:
            self.error = m.get('Error')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Rt') is not None:
            self.rt = m.get('Rt')
        return self


class GetArmsTopNMetricResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[GetArmsTopNMetricResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GetArmsTopNMetricResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetArmsTopNMetricResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetArmsTopNMetricResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetArmsTopNMetricResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAvailabilityMetricRequest(TeaModel):
    def __init__(
        self,
        limit: int = None,
        region_id: str = None,
    ):
        self.limit = limit
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetAvailabilityMetricResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        enable_autoscale: int = None,
        error_instances: int = None,
        instances: int = None,
        name: str = None,
        region_id: str = None,
        runnings: int = None,
    ):
        self.app_id = app_id
        self.enable_autoscale = enable_autoscale
        self.error_instances = error_instances
        self.instances = instances
        self.name = name
        self.region_id = region_id
        self.runnings = runnings

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.enable_autoscale is not None:
            result['EnableAutoscale'] = self.enable_autoscale
        if self.error_instances is not None:
            result['ErrorInstances'] = self.error_instances
        if self.instances is not None:
            result['Instances'] = self.instances
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.runnings is not None:
            result['Runnings'] = self.runnings
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EnableAutoscale') is not None:
            self.enable_autoscale = m.get('EnableAutoscale')
        if m.get('ErrorInstances') is not None:
            self.error_instances = m.get('ErrorInstances')
        if m.get('Instances') is not None:
            self.instances = m.get('Instances')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Runnings') is not None:
            self.runnings = m.get('Runnings')
        return self


class GetAvailabilityMetricResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[GetAvailabilityMetricResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GetAvailabilityMetricResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetAvailabilityMetricResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAvailabilityMetricResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAvailabilityMetricResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetChangeOrderMetricRequest(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        limit: int = None,
        order_by: str = None,
        region_id: str = None,
    ):
        self.create_time = create_time
        self.limit = limit
        self.order_by = order_by
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetChangeOrderMetricResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        error: int = None,
        error_percent: float = None,
        name: str = None,
        region_id: str = None,
        total: int = None,
    ):
        self.app_id = app_id
        self.error = error
        self.error_percent = error_percent
        self.name = name
        self.region_id = region_id
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.error is not None:
            result['Error'] = self.error
        if self.error_percent is not None:
            result['ErrorPercent'] = self.error_percent
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Error') is not None:
            self.error = m.get('Error')
        if m.get('ErrorPercent') is not None:
            self.error_percent = m.get('ErrorPercent')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class GetChangeOrderMetricResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[GetChangeOrderMetricResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GetChangeOrderMetricResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetChangeOrderMetricResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetChangeOrderMetricResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetChangeOrderMetricResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetScaleAppMetricRequest(TeaModel):
    def __init__(
        self,
        limit: int = None,
        region_id: str = None,
    ):
        self.limit = limit
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetScaleAppMetricResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        max_replicas: int = None,
        name: str = None,
        region_id: str = None,
        runnings: int = None,
    ):
        self.app_id = app_id
        self.max_replicas = max_replicas
        self.name = name
        self.region_id = region_id
        self.runnings = runnings

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.runnings is not None:
            result['Runnings'] = self.runnings
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Runnings') is not None:
            self.runnings = m.get('Runnings')
        return self


class GetScaleAppMetricResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[GetScaleAppMetricResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GetScaleAppMetricResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetScaleAppMetricResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetScaleAppMetricResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetScaleAppMetricResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetWarningEventMetricRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        limit: int = None,
        region_id: str = None,
        start_time: int = None,
    ):
        self.end_time = end_time
        self.limit = limit
        self.region_id = region_id
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetWarningEventMetricResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        name: str = None,
        region_id: str = None,
        warning_count: int = None,
    ):
        self.app_id = app_id
        self.name = name
        self.region_id = region_id
        self.warning_count = warning_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.warning_count is not None:
            result['WarningCount'] = self.warning_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('WarningCount') is not None:
            self.warning_count = m.get('WarningCount')
        return self


class GetWarningEventMetricResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[GetWarningEventMetricResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GetWarningEventMetricResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetWarningEventMetricResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetWarningEventMetricResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetWarningEventMetricResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAppEventsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        current_page: int = None,
        event_type: str = None,
        namespace: str = None,
        object_kind: str = None,
        object_name: str = None,
        page_size: int = None,
        reason: str = None,
    ):
        # f7730764-d88f-4b9a-8d8e-cd8efbfe\*\*\*\*\
        self.app_id = app_id
        # 1
        self.current_page = current_page
        # Warning
        self.event_type = event_type
        # cn-beijing
        self.namespace = namespace
        # Pod
        self.object_kind = object_kind
        # errew-b86bf540-b4dc-47d8-a42f-b4997c14bd8f-5595cbddd6-x\*\*\*\*\
        self.object_name = object_name
        # 10
        self.page_size = page_size
        # Started
        self.reason = reason

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.object_kind is not None:
            result['ObjectKind'] = self.object_kind
        if self.object_name is not None:
            result['ObjectName'] = self.object_name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.reason is not None:
            result['Reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('ObjectKind') is not None:
            self.object_kind = m.get('ObjectKind')
        if m.get('ObjectName') is not None:
            self.object_name = m.get('ObjectName')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        return self


class ListAppEventsResponseBodyDataAppEventEntity(TeaModel):
    def __init__(
        self,
        event_type: str = None,
        first_timestamp: str = None,
        last_timestamp: str = None,
        message: str = None,
        object_kind: str = None,
        object_name: str = None,
        reason: str = None,
    ):
        # The type of the event.
        self.event_type = event_type
        # The timestamp of the first occurrence of an event.
        self.first_timestamp = first_timestamp
        # The timestamp of the last occurrence of an event.
        self.last_timestamp = last_timestamp
        # The description of the event.
        self.message = message
        # The type of the object.
        self.object_kind = object_kind
        # The name of the object.
        self.object_name = object_name
        # The reason why the event occurred.
        self.reason = reason

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.first_timestamp is not None:
            result['FirstTimestamp'] = self.first_timestamp
        if self.last_timestamp is not None:
            result['LastTimestamp'] = self.last_timestamp
        if self.message is not None:
            result['Message'] = self.message
        if self.object_kind is not None:
            result['ObjectKind'] = self.object_kind
        if self.object_name is not None:
            result['ObjectName'] = self.object_name
        if self.reason is not None:
            result['Reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('FirstTimestamp') is not None:
            self.first_timestamp = m.get('FirstTimestamp')
        if m.get('LastTimestamp') is not None:
            self.last_timestamp = m.get('LastTimestamp')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ObjectKind') is not None:
            self.object_kind = m.get('ObjectKind')
        if m.get('ObjectName') is not None:
            self.object_name = m.get('ObjectName')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        return self


class ListAppEventsResponseBodyData(TeaModel):
    def __init__(
        self,
        app_event_entity: List[ListAppEventsResponseBodyDataAppEventEntity] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # The list of events.
        self.app_event_entity = app_event_entity
        # The number of the returned page.
        self.current_page = current_page
        # The number of entries returned on each page.
        self.page_size = page_size
        # The total number of events that occurred in the application.
        self.total_size = total_size

    def validate(self):
        if self.app_event_entity:
            for k in self.app_event_entity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AppEventEntity'] = []
        if self.app_event_entity is not None:
            for k in self.app_event_entity:
                result['AppEventEntity'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.app_event_entity = []
        if m.get('AppEventEntity') is not None:
            for k in m.get('AppEventEntity'):
                temp_model = ListAppEventsResponseBodyDataAppEventEntity()
                self.app_event_entity.append(temp_model.from_map(k))
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListAppEventsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListAppEventsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The details of events.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the events that occurred in an application were obtained. Valid values:
        # 
        # *   **true**: indicates that the events were obtained.
        # *   **false**: indicates that the events could not be obtained.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListAppEventsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListAppEventsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAppEventsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAppEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAppServicesPageRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        page_number: int = None,
        page_size: int = None,
        service_type: str = None,
    ):
        # 6dcc8c9e-d3da-478a-a066-86dcf820\*\*\*\*\
        self.app_id = app_id
        # 1
        self.page_number = page_number
        # 9999
        self.page_size = page_size
        # springCloud
        self.service_type = service_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.service_type is not None:
            result['ServiceType'] = self.service_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ServiceType') is not None:
            self.service_type = m.get('ServiceType')
        return self


class ListAppServicesPageResponseBodyDataResult(TeaModel):
    def __init__(
        self,
        edas_app_id: str = None,
        edas_app_name: str = None,
        group: str = None,
        instance_num: int = None,
        service_name: str = None,
        version: str = None,
    ):
        # The ID of the application.
        self.edas_app_id = edas_app_id
        # The name of the application.
        self.edas_app_name = edas_app_name
        # The group to which the service belongs. You can create a custom group.
        self.group = group
        # The total number of instances.
        self.instance_num = instance_num
        # The name of the service.
        self.service_name = service_name
        # The version of the service. You can create a custom version.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.edas_app_id is not None:
            result['EdasAppId'] = self.edas_app_id
        if self.edas_app_name is not None:
            result['EdasAppName'] = self.edas_app_name
        if self.group is not None:
            result['Group'] = self.group
        if self.instance_num is not None:
            result['InstanceNum'] = self.instance_num
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EdasAppId') is not None:
            self.edas_app_id = m.get('EdasAppId')
        if m.get('EdasAppName') is not None:
            self.edas_app_name = m.get('EdasAppName')
        if m.get('Group') is not None:
            self.group = m.get('Group')
        if m.get('InstanceNum') is not None:
            self.instance_num = m.get('InstanceNum')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListAppServicesPageResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: str = None,
        page_number: str = None,
        page_size: str = None,
        result: List[ListAppServicesPageResponseBodyDataResult] = None,
        total_size: str = None,
    ):
        # The page number of the current page.
        self.current_page = current_page
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page. Valid values: 0 to 9999.
        self.page_size = page_size
        # The returned result.
        self.result = result
        # The total number of pages returned.
        self.total_size = total_size

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Result'] = []
        if self.result is not None:
            for k in self.result:
                result['Result'].append(k.to_map() if k else None)
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.result = []
        if m.get('Result') is not None:
            for k in m.get('Result'):
                temp_model = ListAppServicesPageResponseBodyDataResult()
                self.result.append(temp_model.from_map(k))
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListAppServicesPageResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListAppServicesPageResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the call was successful.
        # *   **3xx**: indicates that the call was redirected.
        # *   **4xx**: indicates that the call failed.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The details of microservices.
        self.data = data
        # The returned error code. Valid values:
        # 
        # - If the call is successful, the **ErrorCode** parameter is not returned.
        # - If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned information.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the microservice list was obtained. Valid values:
        # 
        # *   **true**: The list was obtained.
        # *   **false**: The list failed to be obtained.
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListAppServicesPageResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListAppServicesPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAppServicesPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAppServicesPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAppVersionsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # 7171a6ca-d1cd-4928-8642-7d5cfe69\*\*\*\*\
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class ListAppVersionsResponseBodyData(TeaModel):
    def __init__(
        self,
        build_package_url: str = None,
        create_time: str = None,
        id: str = None,
        type: str = None,
        war_url: str = None,
    ):
        # The download link of the WAR or JAR package. This parameter is returned when the **Type** parameter is set to **url**.
        self.build_package_url = build_package_url
        # The time when the application was created.
        self.create_time = create_time
        # The ID of the version.
        self.id = id
        # The deployment method of the application. Valid values:
        # 
        # *   **image**: indicates that the application was deployed by using an image.
        # *   **upload**: indicates that the application was deployed by uploading a WAR or JAR package.
        # *   **url**: indicates that the application was deployed by specifying the URL of a WAR or JAR package.
        self.type = type
        # *   The address of the image. This parameter is returned when the **Type** parameter is set to **image**.
        # *   The download link of the WAR or JAR package. This parameter is returned when the **Type** parameter is set to **upload**.
        self.war_url = war_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.build_package_url is not None:
            result['BuildPackageUrl'] = self.build_package_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.id is not None:
            result['Id'] = self.id
        if self.type is not None:
            result['Type'] = self.type
        if self.war_url is not None:
            result['WarUrl'] = self.war_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BuildPackageUrl') is not None:
            self.build_package_url = m.get('BuildPackageUrl')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WarUrl') is not None:
            self.war_url = m.get('WarUrl')
        return self


class ListAppVersionsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListAppVersionsResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The information about the versions.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the historical versions of the application were obtained. Valid values:
        # 
        # *   **true**: indicates that the historical versions of the application were obtained.
        # *   **false**: indicates that the historical versions of the application could not be obtained.
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListAppVersionsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListAppVersionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAppVersionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAppVersionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListApplicationsRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        current_page: int = None,
        field_type: str = None,
        field_value: str = None,
        namespace_id: str = None,
        order_by: str = None,
        page_size: int = None,
        reverse: bool = None,
        tags: str = None,
    ):
        # demo-app
        self.app_name = app_name
        # 1
        self.current_page = current_page
        # appName
        self.field_type = field_type
        # demo-app
        self.field_value = field_value
        # cn-beijing:demo
        self.namespace_id = namespace_id
        # runnings
        self.order_by = order_by
        # 20
        self.page_size = page_size
        # true
        self.reverse = reverse
        # \[{"key":"key","value":"value"}]
        self.tags = tags

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.field_type is not None:
            result['FieldType'] = self.field_type
        if self.field_value is not None:
            result['FieldValue'] = self.field_value
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.reverse is not None:
            result['Reverse'] = self.reverse
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('FieldType') is not None:
            self.field_type = m.get('FieldType')
        if m.get('FieldValue') is not None:
            self.field_value = m.get('FieldValue')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Reverse') is not None:
            self.reverse = m.get('Reverse')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class ListApplicationsResponseBodyDataApplicationsTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListApplicationsResponseBodyDataApplications(TeaModel):
    def __init__(
        self,
        app_deleting_status: bool = None,
        app_description: str = None,
        app_id: str = None,
        app_name: str = None,
        instances: int = None,
        namespace_id: str = None,
        region_id: str = None,
        running_instances: int = None,
        tags: List[ListApplicationsResponseBodyDataApplicationsTags] = None,
    ):
        # Indicates whether the application is being deleted. Valid values:
        # 
        # *   **true**: The application is being deleted.
        # *   **false**: The application is not being deleted.
        self.app_deleting_status = app_deleting_status
        # The description of the application.
        self.app_description = app_description
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name
        # The number of application instances.
        self.instances = instances
        # The ID of the namespace.
        self.namespace_id = namespace_id
        # The ID of the region.
        self.region_id = region_id
        # The number of running instances.
        self.running_instances = running_instances
        # The tags of the application.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_deleting_status is not None:
            result['AppDeletingStatus'] = self.app_deleting_status
        if self.app_description is not None:
            result['AppDescription'] = self.app_description
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.instances is not None:
            result['Instances'] = self.instances
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.running_instances is not None:
            result['RunningInstances'] = self.running_instances
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppDeletingStatus') is not None:
            self.app_deleting_status = m.get('AppDeletingStatus')
        if m.get('AppDescription') is not None:
            self.app_description = m.get('AppDescription')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Instances') is not None:
            self.instances = m.get('Instances')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RunningInstances') is not None:
            self.running_instances = m.get('RunningInstances')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListApplicationsResponseBodyDataApplicationsTags()
                self.tags.append(temp_model.from_map(k))
        return self


class ListApplicationsResponseBodyData(TeaModel):
    def __init__(
        self,
        applications: List[ListApplicationsResponseBodyDataApplications] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # The list of applications.
        self.applications = applications
        # The number of the returned page.
        self.current_page = current_page
        # The number of entries returned on each page.
        self.page_size = page_size
        # The total number of applications.
        self.total_size = total_size

    def validate(self):
        if self.applications:
            for k in self.applications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Applications'] = []
        if self.applications is not None:
            for k in self.applications:
                result['Applications'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.applications = []
        if m.get('Applications') is not None:
            for k in m.get('Applications'):
                temp_model = ListApplicationsResponseBodyDataApplications()
                self.applications.append(temp_model.from_map(k))
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListApplicationsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        current_page: int = None,
        data: ListApplicationsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total_size: int = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The number of the returned page.
        self.current_page = current_page
        # The information about applications.
        self.data = data
        # The error code. 
        # 
        # - The **ErrorCode** parameter is not returned when the request succeeds.
        # - The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The number of entries returned on each page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the list of applications was obtained. Valid values:
        # 
        # *   **true**: indicates that the list was obtained.
        # *   **false**: indicates that the list could not be obtained.
        self.success = success
        # The total number of applications.
        self.total_size = total_size

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Data') is not None:
            temp_model = ListApplicationsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListApplicationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListApplicationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListApplicationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListChangeOrdersRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        co_status: str = None,
        co_type: str = None,
        current_page: int = None,
        key: str = None,
        page_size: int = None,
    ):
        # 145341c-9708-4967-b3ec-24933767\*\*\*\*\
        self.app_id = app_id
        # 2
        self.co_status = co_status
        # CoCreateApp
        self.co_type = co_type
        # 1
        self.current_page = current_page
        # test
        self.key = key
        # 20
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.co_status is not None:
            result['CoStatus'] = self.co_status
        if self.co_type is not None:
            result['CoType'] = self.co_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.key is not None:
            result['Key'] = self.key
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CoStatus') is not None:
            self.co_status = m.get('CoStatus')
        if m.get('CoType') is not None:
            self.co_type = m.get('CoType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListChangeOrdersResponseBodyDataChangeOrderList(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        batch_count: int = None,
        batch_type: str = None,
        change_order_id: str = None,
        co_type: str = None,
        co_type_code: str = None,
        create_time: str = None,
        create_user_id: str = None,
        description: str = None,
        finish_time: str = None,
        group_id: str = None,
        source: str = None,
        status: int = None,
        user_id: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The number of release batches.
        self.batch_count = batch_count
        # The mode in which the release batches are determined. Valid values:
        # 
        # *   **auto**: SAE automatically determines the release batches.
        # *   **manual**: You must manually determine the release batches.
        self.batch_type = batch_type
        # The ID of the change order.
        self.change_order_id = change_order_id
        # The change type, which corresponds to the **CoTypeCode** parameter.
        self.co_type = co_type
        # The code of the change type. Valid values:
        # 
        # *   **CoBindSlb**: associates an SLB instance with the application.
        # *   **CoUnbindSlb**: disassociates the SLB instance from the application.
        # *   **CoCreateApp**: creates the application.
        # *   **CoDeleteApp**: deletes the application.
        # *   **CoDeploy**: deploys the application.
        # *   **CoRestartApplication**: restarts the application.
        # *   **CoRollback**: rolls back the application.
        # *   **CoScaleIn**: scales in the application.
        # *   **CoScaleOut**: scales out the application.
        # *   **CoStart**: starts the application.
        # *   **CoStop**: stops the application.
        # *   **CoRescaleApplicationVertically**: modifies the instance specifications.
        # *   **CoDeployHistroy**: rolls back the application to a historical version.
        # *   **CoBindNas**: associates a NAS file system with the application.
        # *   **CoUnbindNas**: disassociates the NAS file system from the application.
        # *   **CoBatchStartApplication**: starts multiple applications concurrently.
        # *   **CoBatchStopApplication**: stops multiple applications concurrently.
        # *   **CoRestartInstances**: restarts the instances.
        # *   **CoDeleteInstances**: deletes the instances.
        # *   **CoScaleInAppWithInstances**: reduces the number of the specified application instances.
        self.co_type_code = co_type_code
        # The time when the change order was created.
        self.create_time = create_time
        # The ID of the user who created the change order.
        self.create_user_id = create_user_id
        # The description about the application.
        self.description = description
        # The time when the change order was completed.
        self.finish_time = finish_time
        # The ID of the group.
        self.group_id = group_id
        # The source of the change order.
        self.source = source
        # The status of the change order. Valid values:
        # 
        # *   **0**: The change order is being prepared.
        # *   **1**: The change order is being executed.
        # *   **2**: The change order was executed.
        # *   **3**: The change order could not be executed.
        # *   **6**: The change order was terminated.
        # *   **8**: The execution process is pending. You must manually determine the release batch.
        # *   **9**: The execution process is pending. SAE will automatically determine the release batch.
        # *   **10**: The change order could not be executed due to a system exception.
        # *   **11**: The change order is pending approval.
        # *   **12**: The change order is approved and is pending execution.
        self.status = status
        # The ID of the user.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.batch_count is not None:
            result['BatchCount'] = self.batch_count
        if self.batch_type is not None:
            result['BatchType'] = self.batch_type
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.co_type is not None:
            result['CoType'] = self.co_type
        if self.co_type_code is not None:
            result['CoTypeCode'] = self.co_type_code
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user_id is not None:
            result['CreateUserId'] = self.create_user_id
        if self.description is not None:
            result['Description'] = self.description
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.source is not None:
            result['Source'] = self.source
        if self.status is not None:
            result['Status'] = self.status
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BatchCount') is not None:
            self.batch_count = m.get('BatchCount')
        if m.get('BatchType') is not None:
            self.batch_type = m.get('BatchType')
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('CoType') is not None:
            self.co_type = m.get('CoType')
        if m.get('CoTypeCode') is not None:
            self.co_type_code = m.get('CoTypeCode')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUserId') is not None:
            self.create_user_id = m.get('CreateUserId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListChangeOrdersResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_list: List[ListChangeOrdersResponseBodyDataChangeOrderList] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # The list of change orders.
        self.change_order_list = change_order_list
        # The number of the returned page.
        self.current_page = current_page
        # The number of entries returned on each page.
        self.page_size = page_size
        # The total number of change orders.
        self.total_size = total_size

    def validate(self):
        if self.change_order_list:
            for k in self.change_order_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ChangeOrderList'] = []
        if self.change_order_list is not None:
            for k in self.change_order_list:
                result['ChangeOrderList'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.change_order_list = []
        if m.get('ChangeOrderList') is not None:
            for k in m.get('ChangeOrderList'):
                temp_model = ListChangeOrdersResponseBodyDataChangeOrderList()
                self.change_order_list.append(temp_model.from_map(k))
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListChangeOrdersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListChangeOrdersResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The information about change orders.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the list of change orders was obtained. Valid values:
        # 
        # *   **true**: indicates that the list was obtained.
        # *   **false**: indicates that the list could not be obtained.
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListChangeOrdersResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListChangeOrdersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListChangeOrdersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListChangeOrdersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListConsumedServicesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # b2a8a925-477a-4ed7-b825-d5e22500\*\*\*\*\
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class ListConsumedServicesResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group_2ip: str = None,
        groups: List[str] = None,
        ips: List[str] = None,
        name: str = None,
        type: str = None,
        version: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # A reserved parameter.
        self.group_2ip = group_2ip
        # The service group that corresponds to the published service.
        self.groups = groups
        # The subscription address of the service.
        self.ips = ips
        # The name of the published service.
        self.name = name
        # The type of the published service.
        self.type = type
        # The version of the published service
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.group_2ip is not None:
            result['Group2Ip'] = self.group_2ip
        if self.groups is not None:
            result['Groups'] = self.groups
        if self.ips is not None:
            result['Ips'] = self.ips
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Group2Ip') is not None:
            self.group_2ip = m.get('Group2Ip')
        if m.get('Groups') is not None:
            self.groups = m.get('Groups')
        if m.get('Ips') is not None:
            self.ips = m.get('Ips')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListConsumedServicesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListConsumedServicesResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the call was successful.
        # *   **3xx**: indicates that the call was redirected.
        # *   **4xx**: indicates that the call failed.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The details of the microservices.
        self.data = data
        # The returned error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned information. Valid values:
        # 
        # *   If the call is successful, **success** is returned.
        # *   If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the microservice list was obtained. Valid values:
        # 
        # *   **true**: The list was obtained.
        # *   **false**: The list failed to be obtained.
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListConsumedServicesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListConsumedServicesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListConsumedServicesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListConsumedServicesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListGreyTagRouteRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # 7171a6ca-d1cd-4928-8642-7d5cfe69\*\*\*\*\
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class ListGreyTagRouteResponseBodyDataResultAlbRulesItems(TeaModel):
    def __init__(
        self,
        cond: str = None,
        expr: str = None,
        index: int = None,
        name: str = None,
        operator: str = None,
        type: str = None,
        value: str = None,
    ):
        self.cond = cond
        self.expr = expr
        self.index = index
        self.name = name
        self.operator = operator
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cond is not None:
            result['cond'] = self.cond
        if self.expr is not None:
            result['expr'] = self.expr
        if self.index is not None:
            result['index'] = self.index
        if self.name is not None:
            result['name'] = self.name
        if self.operator is not None:
            result['operator'] = self.operator
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cond') is not None:
            self.cond = m.get('cond')
        if m.get('expr') is not None:
            self.expr = m.get('expr')
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListGreyTagRouteResponseBodyDataResultAlbRules(TeaModel):
    def __init__(
        self,
        condition: str = None,
        ingress_id: str = None,
        items: List[ListGreyTagRouteResponseBodyDataResultAlbRulesItems] = None,
        service_name: str = None,
    ):
        self.condition = condition
        self.ingress_id = ingress_id
        self.items = items
        self.service_name = service_name

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['condition'] = self.condition
        if self.ingress_id is not None:
            result['ingressId'] = self.ingress_id
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.service_name is not None:
            result['serviceName'] = self.service_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        if m.get('ingressId') is not None:
            self.ingress_id = m.get('ingressId')
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = ListGreyTagRouteResponseBodyDataResultAlbRulesItems()
                self.items.append(temp_model.from_map(k))
        if m.get('serviceName') is not None:
            self.service_name = m.get('serviceName')
        return self


class ListGreyTagRouteResponseBodyDataResultDubboRulesItems(TeaModel):
    def __init__(
        self,
        cond: str = None,
        expr: str = None,
        index: int = None,
        name: str = None,
        operator: str = None,
        type: str = None,
        value: str = None,
    ):
        # The comparison operator. Valid values: **>**, **<**, **>=**, **<=**, **==**, and **! =**.
        self.cond = cond
        # The expression that is used to obtain the value of the parameter. The syntax of the expression must follow the standard of the SpEL. Valid values:
        # 
        # - **Empty**: obtains the value of the parameter.
        # - **.name**: obtains the name property of the parameter. This expression works the same way as args0.getName().
        # - **.isEnabled()**: obtains the enabled property of the parameter. This expression works the same way as args0.isEnabled().
        # - **[0]**: indicates that the value of the parameter is an array and obtains the first value of the array. This expression works the same way as args0[0]. This expression does not start with a period (.).
        # - **.get(0)**: indicates that the value of the parameter is a list and obtains the first value of the list. This expression works the same way as args0.get(0).
        # - **.get("key")**: indicates that the value of the parameter is a map and obtains the value of the key in the map. This expression works the same way as args0.get("key").  >  For more information about the expressions that are used to obtain parameter values, see  [Spring Expression Language (SpEL)](https://docs.spring.io/spring-integration/docs/current/reference/html/spel.html).
        self.expr = expr
        # The index of the parameter. The value 0 indicates the first parameter.
        self.index = index
        # This parameter is not returned for Dubbo services.
        self.name = name
        # The operator. Valid values:
        # 
        # - **rawvalue**: direct comparison.
        # - **list**: whitelist.
        # - **mod**: mods 100.
        # - **deterministic_proportional_steaming_division**: percentage.
        self.operator = operator
        # This parameter is not returned for Dubbo services.
        self.type = type
        # The value of the parameter. This value is compared with the value that is obtained based on the **expr** and **index** parameters.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cond is not None:
            result['cond'] = self.cond
        if self.expr is not None:
            result['expr'] = self.expr
        if self.index is not None:
            result['index'] = self.index
        if self.name is not None:
            result['name'] = self.name
        if self.operator is not None:
            result['operator'] = self.operator
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cond') is not None:
            self.cond = m.get('cond')
        if m.get('expr') is not None:
            self.expr = m.get('expr')
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListGreyTagRouteResponseBodyDataResultDubboRules(TeaModel):
    def __init__(
        self,
        condition: str = None,
        group: str = None,
        items: List[ListGreyTagRouteResponseBodyDataResultDubboRulesItems] = None,
        method_name: str = None,
        service_name: str = None,
        version: str = None,
    ):
        # The relationship between the conditions in the canary release rule. Valid values:
        # 
        # - **AND**: The conditions are in the logical AND relation. All conditions must be met at the same time.
        # - **OR**: The conditions are in the logical OR relation. At least one of the conditions must be met.
        self.condition = condition
        # The group of the Dubbo service that corresponds to the canary release rule.
        self.group = group
        # The conditions.
        self.items = items
        # The method name of the Dubbo service.
        self.method_name = method_name
        # The name of the Dubbo service.
        self.service_name = service_name
        # The version of the Dubbo service.
        self.version = version

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['condition'] = self.condition
        if self.group is not None:
            result['group'] = self.group
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.method_name is not None:
            result['methodName'] = self.method_name
        if self.service_name is not None:
            result['serviceName'] = self.service_name
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        if m.get('group') is not None:
            self.group = m.get('group')
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = ListGreyTagRouteResponseBodyDataResultDubboRulesItems()
                self.items.append(temp_model.from_map(k))
        if m.get('methodName') is not None:
            self.method_name = m.get('methodName')
        if m.get('serviceName') is not None:
            self.service_name = m.get('serviceName')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class ListGreyTagRouteResponseBodyDataResultScRulesItems(TeaModel):
    def __init__(
        self,
        cond: str = None,
        expr: str = None,
        index: int = None,
        name: str = None,
        operator: str = None,
        type: str = None,
        value: str = None,
    ):
        # The comparison operator. Valid values: **>**, **<**, **>=**, **<=**, **==**, and **! =**.
        self.cond = cond
        # This parameter is not returned for Spring Cloud applications.
        self.expr = expr
        # This parameter is not returned for Spring Cloud applications.
        self.index = index
        # The name of the parameter.
        self.name = name
        # The operator. Valid values:
        # 
        # *   **rawvalue**: direct comparison.
        # *   **list**: whitelist.
        # *   **mod**: mods 100.
        # *   **deterministic_proportional_steaming_division**: percentage.
        self.operator = operator
        # The type of the comparison. Valid values:
        # 
        # *   **param**: parameter
        # *   **cookie**: cookie
        # *   **header**: header
        self.type = type
        # The value of the parameter. This value is compared with the value that is obtained based on the **type** and **name** parameters.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cond is not None:
            result['cond'] = self.cond
        if self.expr is not None:
            result['expr'] = self.expr
        if self.index is not None:
            result['index'] = self.index
        if self.name is not None:
            result['name'] = self.name
        if self.operator is not None:
            result['operator'] = self.operator
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cond') is not None:
            self.cond = m.get('cond')
        if m.get('expr') is not None:
            self.expr = m.get('expr')
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListGreyTagRouteResponseBodyDataResultScRules(TeaModel):
    def __init__(
        self,
        condition: str = None,
        items: List[ListGreyTagRouteResponseBodyDataResultScRulesItems] = None,
        path: str = None,
    ):
        # The relationship between the conditions in the canary release rule. Valid values:
        # 
        # *   **AND**: The conditions are in the logical AND relation. All conditions must be met at the same time.
        # *   **OR**: The conditions are in the logical OR relation. At least one of the conditions must be met.
        self.condition = condition
        # The conditions.
        self.items = items
        # The path of the canary release rule of the Spring Cloud application.
        self.path = path

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['condition'] = self.condition
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.path is not None:
            result['path'] = self.path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = ListGreyTagRouteResponseBodyDataResultScRulesItems()
                self.items.append(temp_model.from_map(k))
        if m.get('path') is not None:
            self.path = m.get('path')
        return self


class ListGreyTagRouteResponseBodyDataResult(TeaModel):
    def __init__(
        self,
        alb_rules: List[ListGreyTagRouteResponseBodyDataResultAlbRules] = None,
        create_time: int = None,
        description: str = None,
        dubbo_rules: List[ListGreyTagRouteResponseBodyDataResultDubboRules] = None,
        grey_tag_route_id: int = None,
        name: str = None,
        sc_rules: List[ListGreyTagRouteResponseBodyDataResultScRules] = None,
        update_time: int = None,
    ):
        self.alb_rules = alb_rules
        # The timestamp when the canary release rule was created. Unit: milliseconds.
        self.create_time = create_time
        # The description of the canary release rule.
        self.description = description
        # The canary release rule of the Dubbo service.
        self.dubbo_rules = dubbo_rules
        # The ID of the canary release rule.
        self.grey_tag_route_id = grey_tag_route_id
        # The name of the canary release rule.
        self.name = name
        # The canary release rule of the Spring Cloud application.
        self.sc_rules = sc_rules
        # The timestamp when the canary release rule was updated. Unit: milliseconds.
        self.update_time = update_time

    def validate(self):
        if self.alb_rules:
            for k in self.alb_rules:
                if k:
                    k.validate()
        if self.dubbo_rules:
            for k in self.dubbo_rules:
                if k:
                    k.validate()
        if self.sc_rules:
            for k in self.sc_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlbRules'] = []
        if self.alb_rules is not None:
            for k in self.alb_rules:
                result['AlbRules'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        result['DubboRules'] = []
        if self.dubbo_rules is not None:
            for k in self.dubbo_rules:
                result['DubboRules'].append(k.to_map() if k else None)
        if self.grey_tag_route_id is not None:
            result['GreyTagRouteId'] = self.grey_tag_route_id
        if self.name is not None:
            result['Name'] = self.name
        result['ScRules'] = []
        if self.sc_rules is not None:
            for k in self.sc_rules:
                result['ScRules'].append(k.to_map() if k else None)
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alb_rules = []
        if m.get('AlbRules') is not None:
            for k in m.get('AlbRules'):
                temp_model = ListGreyTagRouteResponseBodyDataResultAlbRules()
                self.alb_rules.append(temp_model.from_map(k))
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.dubbo_rules = []
        if m.get('DubboRules') is not None:
            for k in m.get('DubboRules'):
                temp_model = ListGreyTagRouteResponseBodyDataResultDubboRules()
                self.dubbo_rules.append(temp_model.from_map(k))
        if m.get('GreyTagRouteId') is not None:
            self.grey_tag_route_id = m.get('GreyTagRouteId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.sc_rules = []
        if m.get('ScRules') is not None:
            for k in m.get('ScRules'):
                temp_model = ListGreyTagRouteResponseBodyDataResultScRules()
                self.sc_rules.append(temp_model.from_map(k))
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class ListGreyTagRouteResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        result: List[ListGreyTagRouteResponseBodyDataResult] = None,
        total_size: int = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned on each page. Valid value: **1**.
        self.page_size = page_size
        # The returned result.
        self.result = result
        # The total number of canary release rules. Valid value: **1**.
        self.total_size = total_size

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Result'] = []
        if self.result is not None:
            for k in self.result:
                result['Result'].append(k.to_map() if k else None)
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.result = []
        if m.get('Result') is not None:
            for k in m.get('Result'):
                temp_model = ListGreyTagRouteResponseBodyDataResult()
                self.result.append(temp_model.from_map(k))
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListGreyTagRouteResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListGreyTagRouteResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # - **2xx**: The call was successful.
        # - **3xx**: The call was redirected.
        # - **4xx**: The call failed.
        # - **5xx**: A server error occurred.
        self.code = code
        # The information about the canary release rule.
        self.data = data
        # The returned error code. Valid values:
        # 
        # - If the call is successful, the **ErrorCode** parameter is not returned.
        # - If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned information. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the information of the change order was queried. Valid values:
        # 
        # - **true**: The information was queried.
        # - **false**: The information failed to be queried.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListGreyTagRouteResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListGreyTagRouteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListGreyTagRouteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListGreyTagRouteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIngressesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        namespace_id: str = None,
    ):
        # bbf3a590-6d13-46fe-8ca9-c947a20b\*\*\*\*\
        self.app_id = app_id
        # cn-beijing
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class ListIngressesResponseBodyDataIngressList(TeaModel):
    def __init__(
        self,
        cert_id: str = None,
        cert_ids: str = None,
        description: str = None,
        id: int = None,
        listener_port: str = None,
        listener_protocol: str = None,
        load_balance_type: str = None,
        name: str = None,
        namespace_id: str = None,
        slb_id: str = None,
        slb_type: str = None,
    ):
        # The ID of the certificate.
        self.cert_id = cert_id
        self.cert_ids = cert_ids
        # The name of the routing rule.
        self.description = description
        # The ID of the routing rule.
        self.id = id
        # The port specified for the SLB listener.
        self.listener_port = listener_port
        # The protocol used to forward requests. Valid values:
        # 
        # *   **HTTP**: used when the application needs to identify the transmitted data.
        # *   **HTTPS**: used when the application requires encrypted data transmission.
        self.listener_protocol = listener_protocol
        # The type of the SLB instance based on the processing capabilities. Valid values:
        # 
        # *   **clb**: the Classic Load Balancer (CLB) instance.
        # *   **alb**: the Application Load Balancer (ALB) instance.
        self.load_balance_type = load_balance_type
        # The name of the routing rule.
        self.name = name
        # The ID of the namespace.
        self.namespace_id = namespace_id
        # The ID of the SLB instance.
        self.slb_id = slb_id
        # The type of the SLB instance based on the IP address. Valid values:
        # 
        # *   **internet**: the Internet-facing SLB instance.
        # *   **intranet**: the internal-facing SLB instance.
        self.slb_type = slb_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_id is not None:
            result['CertId'] = self.cert_id
        if self.cert_ids is not None:
            result['CertIds'] = self.cert_ids
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.listener_protocol is not None:
            result['ListenerProtocol'] = self.listener_protocol
        if self.load_balance_type is not None:
            result['LoadBalanceType'] = self.load_balance_type
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.slb_id is not None:
            result['SlbId'] = self.slb_id
        if self.slb_type is not None:
            result['SlbType'] = self.slb_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertId') is not None:
            self.cert_id = m.get('CertId')
        if m.get('CertIds') is not None:
            self.cert_ids = m.get('CertIds')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('ListenerProtocol') is not None:
            self.listener_protocol = m.get('ListenerProtocol')
        if m.get('LoadBalanceType') is not None:
            self.load_balance_type = m.get('LoadBalanceType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('SlbId') is not None:
            self.slb_id = m.get('SlbId')
        if m.get('SlbType') is not None:
            self.slb_type = m.get('SlbType')
        return self


class ListIngressesResponseBodyData(TeaModel):
    def __init__(
        self,
        ingress_list: List[ListIngressesResponseBodyDataIngressList] = None,
    ):
        # The list of routing rules.
        self.ingress_list = ingress_list

    def validate(self):
        if self.ingress_list:
            for k in self.ingress_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['IngressList'] = []
        if self.ingress_list is not None:
            for k in self.ingress_list:
                result['IngressList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ingress_list = []
        if m.get('IngressList') is not None:
            for k in m.get('IngressList'):
                temp_model = ListIngressesResponseBodyDataIngressList()
                self.ingress_list.append(temp_model.from_map(k))
        return self


class ListIngressesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListIngressesResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code. 
        # 
        # - The **ErrorCode** parameter is not returned when the request succeeds.
        # - The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the list of routing rules was obtained. Valid values:
        # 
        # *   **true**: indicates that the list was obtained.
        # *   **false**: indicates that the list could not be obtained.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListIngressesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListIngressesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIngressesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIngressesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListJobsRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        current_page: int = None,
        field_type: str = None,
        field_value: str = None,
        namespace_id: str = None,
        order_by: str = None,
        page_size: int = None,
        reverse: bool = None,
        tags: str = None,
        workload: str = None,
    ):
        self.app_name = app_name
        self.current_page = current_page
        self.field_type = field_type
        self.field_value = field_value
        self.namespace_id = namespace_id
        self.order_by = order_by
        self.page_size = page_size
        self.reverse = reverse
        self.tags = tags
        self.workload = workload

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.field_type is not None:
            result['FieldType'] = self.field_type
        if self.field_value is not None:
            result['FieldValue'] = self.field_value
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.reverse is not None:
            result['Reverse'] = self.reverse
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.workload is not None:
            result['Workload'] = self.workload
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('FieldType') is not None:
            self.field_type = m.get('FieldType')
        if m.get('FieldValue') is not None:
            self.field_value = m.get('FieldValue')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Reverse') is not None:
            self.reverse = m.get('Reverse')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Workload') is not None:
            self.workload = m.get('Workload')
        return self


class ListJobsResponseBodyDataApplicationsTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListJobsResponseBodyDataApplications(TeaModel):
    def __init__(
        self,
        active: int = None,
        app_description: str = None,
        app_id: str = None,
        app_name: str = None,
        completion_time: int = None,
        cpu: int = None,
        failed: int = None,
        last_changeorder_state: str = None,
        last_job_state: str = None,
        last_start_time: int = None,
        mem: int = None,
        namespace_id: str = None,
        region_id: str = None,
        succeeded: int = None,
        suspend: bool = None,
        tags: List[ListJobsResponseBodyDataApplicationsTags] = None,
        trigger_config: str = None,
    ):
        self.active = active
        self.app_description = app_description
        self.app_id = app_id
        self.app_name = app_name
        self.completion_time = completion_time
        self.cpu = cpu
        self.failed = failed
        self.last_changeorder_state = last_changeorder_state
        self.last_job_state = last_job_state
        self.last_start_time = last_start_time
        self.mem = mem
        self.namespace_id = namespace_id
        self.region_id = region_id
        self.succeeded = succeeded
        self.suspend = suspend
        self.tags = tags
        self.trigger_config = trigger_config

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active is not None:
            result['Active'] = self.active
        if self.app_description is not None:
            result['AppDescription'] = self.app_description
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.completion_time is not None:
            result['CompletionTime'] = self.completion_time
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.failed is not None:
            result['Failed'] = self.failed
        if self.last_changeorder_state is not None:
            result['LastChangeorderState'] = self.last_changeorder_state
        if self.last_job_state is not None:
            result['LastJobState'] = self.last_job_state
        if self.last_start_time is not None:
            result['LastStartTime'] = self.last_start_time
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.succeeded is not None:
            result['Succeeded'] = self.succeeded
        if self.suspend is not None:
            result['Suspend'] = self.suspend
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.trigger_config is not None:
            result['TriggerConfig'] = self.trigger_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Active') is not None:
            self.active = m.get('Active')
        if m.get('AppDescription') is not None:
            self.app_description = m.get('AppDescription')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('CompletionTime') is not None:
            self.completion_time = m.get('CompletionTime')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('Failed') is not None:
            self.failed = m.get('Failed')
        if m.get('LastChangeorderState') is not None:
            self.last_changeorder_state = m.get('LastChangeorderState')
        if m.get('LastJobState') is not None:
            self.last_job_state = m.get('LastJobState')
        if m.get('LastStartTime') is not None:
            self.last_start_time = m.get('LastStartTime')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Succeeded') is not None:
            self.succeeded = m.get('Succeeded')
        if m.get('Suspend') is not None:
            self.suspend = m.get('Suspend')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListJobsResponseBodyDataApplicationsTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TriggerConfig') is not None:
            self.trigger_config = m.get('TriggerConfig')
        return self


class ListJobsResponseBodyData(TeaModel):
    def __init__(
        self,
        applications: List[ListJobsResponseBodyDataApplications] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
    ):
        self.applications = applications
        self.current_page = current_page
        self.page_size = page_size
        self.total_size = total_size

    def validate(self):
        if self.applications:
            for k in self.applications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Applications'] = []
        if self.applications is not None:
            for k in self.applications:
                result['Applications'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.applications = []
        if m.get('Applications') is not None:
            for k in m.get('Applications'):
                temp_model = ListJobsResponseBodyDataApplications()
                self.applications.append(temp_model.from_map(k))
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListJobsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        current_page: int = None,
        data: ListJobsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total_size: int = None,
    ):
        self.code = code
        self.current_page = current_page
        self.data = data
        self.error_code = error_code
        self.message = message
        self.page_size = page_size
        self.request_id = request_id
        self.success = success
        self.total_size = total_size

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Data') is not None:
            temp_model = ListJobsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLogConfigsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        current_page: int = None,
        page_size: int = None,
    ):
        # 56f77b65-788d-442a-9885-7f20d91f\*\*\*\*\
        self.app_id = app_id
        # 1
        self.current_page = current_page
        # 10
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListLogConfigsResponseBodyDataLogConfigs(TeaModel):
    def __init__(
        self,
        config_name: str = None,
        create_time: str = None,
        log_dir: str = None,
        log_type: str = None,
        region_id: str = None,
        sls_log_store: str = None,
        sls_project: str = None,
        store_type: str = None,
    ):
        # The name of the Log Service configuration.
        self.config_name = config_name
        # The time when the configuration was created.
        self.create_time = create_time
        # The path of logs.
        self.log_dir = log_dir
        # The type of the log. Set this value to **file_log**.
        self.log_type = log_type
        # The ID of the region.
        self.region_id = region_id
        # The name of the Logstore in Log Service.
        self.sls_log_store = sls_log_store
        # The ID of the Log Service project.
        self.sls_project = sls_project
        # The storage type of logs.
        self.store_type = store_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_name is not None:
            result['ConfigName'] = self.config_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.log_dir is not None:
            result['LogDir'] = self.log_dir
        if self.log_type is not None:
            result['LogType'] = self.log_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.sls_log_store is not None:
            result['SlsLogStore'] = self.sls_log_store
        if self.sls_project is not None:
            result['SlsProject'] = self.sls_project
        if self.store_type is not None:
            result['StoreType'] = self.store_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigName') is not None:
            self.config_name = m.get('ConfigName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LogDir') is not None:
            self.log_dir = m.get('LogDir')
        if m.get('LogType') is not None:
            self.log_type = m.get('LogType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SlsLogStore') is not None:
            self.sls_log_store = m.get('SlsLogStore')
        if m.get('SlsProject') is not None:
            self.sls_project = m.get('SlsProject')
        if m.get('StoreType') is not None:
            self.store_type = m.get('StoreType')
        return self


class ListLogConfigsResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        log_configs: List[ListLogConfigsResponseBodyDataLogConfigs] = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # The number of the returned page.
        self.current_page = current_page
        # The details of logging configurations.
        self.log_configs = log_configs
        # The number of entries returned on each page.
        self.page_size = page_size
        # The total number of returned entries.
        self.total_size = total_size

    def validate(self):
        if self.log_configs:
            for k in self.log_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['LogConfigs'] = []
        if self.log_configs is not None:
            for k in self.log_configs:
                result['LogConfigs'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.log_configs = []
        if m.get('LogConfigs') is not None:
            for k in m.get('LogConfigs'):
                temp_model = ListLogConfigsResponseBodyDataLogConfigs()
                self.log_configs.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListLogConfigsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListLogConfigsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The logging configurations.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the logging configurations of an application were obtained. Valid values:
        # 
        # *   **true**: indicates that the configurations were obtained.
        # *   **false**: indicates that the configurations could not be obtained.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListLogConfigsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListLogConfigsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLogConfigsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLogConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListNamespaceChangeOrdersRequest(TeaModel):
    def __init__(
        self,
        co_status: str = None,
        co_type: str = None,
        current_page: int = None,
        key: str = None,
        namespace_id: str = None,
        page_size: int = None,
    ):
        # 2
        self.co_status = co_status
        # CoBatchStartApplication
        self.co_type = co_type
        # 1
        self.current_page = current_page
        # test
        self.key = key
        # cn-shanghai:test
        self.namespace_id = namespace_id
        # 20
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.co_status is not None:
            result['CoStatus'] = self.co_status
        if self.co_type is not None:
            result['CoType'] = self.co_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.key is not None:
            result['Key'] = self.key
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CoStatus') is not None:
            self.co_status = m.get('CoStatus')
        if m.get('CoType') is not None:
            self.co_type = m.get('CoType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListNamespaceChangeOrdersResponseBodyDataChangeOrderList(TeaModel):
    def __init__(
        self,
        batch_count: int = None,
        batch_type: str = None,
        change_order_id: str = None,
        co_type: str = None,
        co_type_code: str = None,
        create_time: str = None,
        create_user_id: str = None,
        description: str = None,
        finish_time: str = None,
        group_id: str = None,
        namespace_id: str = None,
        pipelines: str = None,
        source: str = None,
        status: int = None,
        user_id: str = None,
    ):
        # The number of release batches.
        self.batch_count = batch_count
        # The mode in which the release batches are determined. Valid values:
        # 
        # *   **auto**: SAE automatically determines the release batches.
        # *   **manual**: You must manually determine the release batches.
        self.batch_type = batch_type
        # The ID of the change order.
        self.change_order_id = change_order_id
        # The type of the change order, which corresponds the **CoTypeCode** parameter.
        self.co_type = co_type
        # The code of the change order type. Valid values:
        # 
        # *   **CoBatchStartApplication**: starts multiple applications concurrently.
        # *   **CoBatchStopApplication**: stops multiple applications concurrently.
        self.co_type_code = co_type_code
        # The time when the change order was created.
        self.create_time = create_time
        # The ID of the user who created the change order.
        self.create_user_id = create_user_id
        # The description of the change order.
        self.description = description
        # The time when the change order was completed.
        self.finish_time = finish_time
        # The ID of the group.
        self.group_id = group_id
        # The ID of the namespace.
        self.namespace_id = namespace_id
        # The information about release batches.
        self.pipelines = pipelines
        # The source of the change order.
        self.source = source
        # The status of the change order. Valid values:
        # 
        # *   **0**: The change order is being prepared.
        # *   **1**: The change order is being executed.
        # *   **2**: The change order was executed.
        # *   **3**: The change order could not be executed.
        # *   **6**: The change order was terminated.
        # *   **10**: The change order could not be executed due to a system exception.
        self.status = status
        # The ID of the user.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_count is not None:
            result['BatchCount'] = self.batch_count
        if self.batch_type is not None:
            result['BatchType'] = self.batch_type
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.co_type is not None:
            result['CoType'] = self.co_type
        if self.co_type_code is not None:
            result['CoTypeCode'] = self.co_type_code
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user_id is not None:
            result['CreateUserId'] = self.create_user_id
        if self.description is not None:
            result['Description'] = self.description
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.pipelines is not None:
            result['Pipelines'] = self.pipelines
        if self.source is not None:
            result['Source'] = self.source
        if self.status is not None:
            result['Status'] = self.status
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BatchCount') is not None:
            self.batch_count = m.get('BatchCount')
        if m.get('BatchType') is not None:
            self.batch_type = m.get('BatchType')
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('CoType') is not None:
            self.co_type = m.get('CoType')
        if m.get('CoTypeCode') is not None:
            self.co_type_code = m.get('CoTypeCode')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUserId') is not None:
            self.create_user_id = m.get('CreateUserId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('Pipelines') is not None:
            self.pipelines = m.get('Pipelines')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListNamespaceChangeOrdersResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_list: List[ListNamespaceChangeOrdersResponseBodyDataChangeOrderList] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # The list of change orders.
        self.change_order_list = change_order_list
        # The number of the returned page.
        self.current_page = current_page
        # The number of entries returned on each page.
        self.page_size = page_size
        # The total number of change orders.
        self.total_size = total_size

    def validate(self):
        if self.change_order_list:
            for k in self.change_order_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ChangeOrderList'] = []
        if self.change_order_list is not None:
            for k in self.change_order_list:
                result['ChangeOrderList'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.change_order_list = []
        if m.get('ChangeOrderList') is not None:
            for k in m.get('ChangeOrderList'):
                temp_model = ListNamespaceChangeOrdersResponseBodyDataChangeOrderList()
                self.change_order_list.append(temp_model.from_map(k))
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListNamespaceChangeOrdersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListNamespaceChangeOrdersResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the list of change orders was obtained. Valid values:
        # 
        # *   **true**: indicates that the list was obtained.
        # *   **false**: indicates that the list could not be obtained.
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListNamespaceChangeOrdersResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListNamespaceChangeOrdersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListNamespaceChangeOrdersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListNamespaceChangeOrdersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListNamespacedConfigMapsRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
    ):
        # cn-hangzhou
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class ListNamespacedConfigMapsResponseBodyDataConfigMapsRelateApps(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        return self


class ListNamespacedConfigMapsResponseBodyDataConfigMaps(TeaModel):
    def __init__(
        self,
        config_map_id: int = None,
        create_time: int = None,
        data: Dict[str, Any] = None,
        description: str = None,
        name: str = None,
        namespace_id: str = None,
        relate_apps: List[ListNamespacedConfigMapsResponseBodyDataConfigMapsRelateApps] = None,
        update_time: int = None,
    ):
        # The ID of the ConfigMap instance.
        self.config_map_id = config_map_id
        # The time when the instance was created.
        self.create_time = create_time
        # The data of ConfigMap key-value pairs. Format:
        # 
        # {"k1":"v1", "k2":"v2"}
        # 
        # k specifies a key and v specifies a value. For more information, see [Manage and use configurations](~~171326~~).
        self.data = data
        # The description of the instance.
        self.description = description
        # The name of the ConfigMap instance.
        self.name = name
        # The ID of the namespace.
        self.namespace_id = namespace_id
        # The application that is associated with the instance.
        self.relate_apps = relate_apps
        # The time when the instance was last modified.
        self.update_time = update_time

    def validate(self):
        if self.relate_apps:
            for k in self.relate_apps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.data is not None:
            result['Data'] = self.data
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        result['RelateApps'] = []
        if self.relate_apps is not None:
            for k in self.relate_apps:
                result['RelateApps'].append(k.to_map() if k else None)
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        self.relate_apps = []
        if m.get('RelateApps') is not None:
            for k in m.get('RelateApps'):
                temp_model = ListNamespacedConfigMapsResponseBodyDataConfigMapsRelateApps()
                self.relate_apps.append(temp_model.from_map(k))
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class ListNamespacedConfigMapsResponseBodyData(TeaModel):
    def __init__(
        self,
        config_maps: List[ListNamespacedConfigMapsResponseBodyDataConfigMaps] = None,
    ):
        # The ConfigMap instances.
        self.config_maps = config_maps

    def validate(self):
        if self.config_maps:
            for k in self.config_maps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConfigMaps'] = []
        if self.config_maps is not None:
            for k in self.config_maps:
                result['ConfigMaps'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.config_maps = []
        if m.get('ConfigMaps') is not None:
            for k in m.get('ConfigMaps'):
                temp_model = ListNamespacedConfigMapsResponseBodyDataConfigMaps()
                self.config_maps.append(temp_model.from_map(k))
        return self


class ListNamespacedConfigMapsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListNamespacedConfigMapsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the call was successful.
        # *   **3xx**: indicates that the call was redirected.
        # *   **4xx**: indicates that the call failed.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned result.
        self.data = data
        # The returned error code. Valid values:
        # 
        # - If the call is successful, the **ErrorCode** parameter is not returned.
        # - If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned information. Valid values:
        # 
        # *   If the call is successful, **success** is returned.
        # *   If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the ConfigMap instances were obtained. Valid values:
        # 
        # *   **true**: The instances were obtained.
        # *   **false**: The instances failed to be obtained.
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListNamespacedConfigMapsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListNamespacedConfigMapsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListNamespacedConfigMapsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListNamespacedConfigMapsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPublishedServicesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # b2a8a925-477a-4ed7-b825-d5e22500\*\*\*\*\
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class ListPublishedServicesResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group_2ip: str = None,
        groups: List[str] = None,
        ips: List[str] = None,
        name: str = None,
        type: str = None,
        version: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The reserved parameter. This parameter does not take effect.
        self.group_2ip = group_2ip
        # The service group that corresponds to the consumed service.
        self.groups = groups
        # The subscription address of the service.
        self.ips = ips
        # The name of the published service.
        self.name = name
        # The type of the published service.
        self.type = type
        # The version of the published services.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.group_2ip is not None:
            result['Group2Ip'] = self.group_2ip
        if self.groups is not None:
            result['Groups'] = self.groups
        if self.ips is not None:
            result['Ips'] = self.ips
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Group2Ip') is not None:
            self.group_2ip = m.get('Group2Ip')
        if m.get('Groups') is not None:
            self.groups = m.get('Groups')
        if m.get('Ips') is not None:
            self.ips = m.get('Ips')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListPublishedServicesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListPublishedServicesResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the call was successful.
        # *   **3xx**: indicates that the call was redirected.
        # *   **4xx**: indicates that the call failed.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The details of the microservices.
        self.data = data
        # The returned error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned information. Valid values:
        # 
        # *   If the call is successful, **success** is returned.
        # *   If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the microservice list was obtained. Valid values:
        # 
        # *   **true**: The list was obtained.
        # *   **false**: The list failed to be obtained.
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListPublishedServicesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListPublishedServicesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPublishedServicesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPublishedServicesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSecretsRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
    ):
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class ListSecretsResponseBodyDataSecretsRelateApps(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
    ):
        self.app_id = app_id
        self.app_name = app_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        return self


class ListSecretsResponseBodyDataSecrets(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        namespace_id: str = None,
        relate_apps: List[ListSecretsResponseBodyDataSecretsRelateApps] = None,
        secret_id: int = None,
        secret_name: str = None,
        secret_type: str = None,
        update_time: int = None,
    ):
        self.create_time = create_time
        self.namespace_id = namespace_id
        self.relate_apps = relate_apps
        self.secret_id = secret_id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.update_time = update_time

    def validate(self):
        if self.relate_apps:
            for k in self.relate_apps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        result['RelateApps'] = []
        if self.relate_apps is not None:
            for k in self.relate_apps:
                result['RelateApps'].append(k.to_map() if k else None)
        if self.secret_id is not None:
            result['SecretId'] = self.secret_id
        if self.secret_name is not None:
            result['SecretName'] = self.secret_name
        if self.secret_type is not None:
            result['SecretType'] = self.secret_type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        self.relate_apps = []
        if m.get('RelateApps') is not None:
            for k in m.get('RelateApps'):
                temp_model = ListSecretsResponseBodyDataSecretsRelateApps()
                self.relate_apps.append(temp_model.from_map(k))
        if m.get('SecretId') is not None:
            self.secret_id = m.get('SecretId')
        if m.get('SecretName') is not None:
            self.secret_name = m.get('SecretName')
        if m.get('SecretType') is not None:
            self.secret_type = m.get('SecretType')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class ListSecretsResponseBodyData(TeaModel):
    def __init__(
        self,
        secrets: List[ListSecretsResponseBodyDataSecrets] = None,
    ):
        self.secrets = secrets

    def validate(self):
        if self.secrets:
            for k in self.secrets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Secrets'] = []
        if self.secrets is not None:
            for k in self.secrets:
                result['Secrets'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.secrets = []
        if m.get('Secrets') is not None:
            for k in m.get('Secrets'):
                temp_model = ListSecretsResponseBodyDataSecrets()
                self.secrets.append(temp_model.from_map(k))
        return self


class ListSecretsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListSecretsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListSecretsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListSecretsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSecretsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSecretsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTagResourcesRequest(TeaModel):
    def __init__(
        self,
        next_token: str = None,
        region_id: str = None,
        resource_ids: str = None,
        resource_type: str = None,
        tags: str = None,
    ):
        # A2RN
        self.next_token = next_token
        # cn-beijing
        self.region_id = region_id
        # \["d42921c4-5433-4abd-8075-0e536f8b\*\*\*\*"]
        self.resource_ids = resource_ids
        # application
        self.resource_type = resource_type
        # \[{"key":"k1","value":"v1"}]
        self.tags = tags

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_ids is not None:
            result['ResourceIds'] = self.resource_ids
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceIds') is not None:
            self.resource_ids = m.get('ResourceIds')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class ListTagResourcesResponseBodyDataTagResources(TeaModel):
    def __init__(
        self,
        resource_id: str = None,
        resource_type: str = None,
        tag_key: str = None,
        tag_value: str = None,
    ):
        # The ID of the application.
        self.resource_id = resource_id
        # The type of the resource. Set the value to `application`.
        self.resource_type = resource_type
        # The tag key.
        self.tag_key = tag_key
        # The tag value.
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class ListTagResourcesResponseBodyData(TeaModel):
    def __init__(
        self,
        next_token: str = None,
        tag_resources: List[ListTagResourcesResponseBodyDataTagResources] = None,
    ):
        # A maximum of 50 entries can be returned for a query. If a query generates more than 50 entries, the NextToken parameter is returned with the first 50 entries. You can use the NextToken parameter value to retrieve the subsequent entries that are not returned in the current query result.
        self.next_token = next_token
        # The mapping relationships between applications and tags.
        self.tag_resources = tag_resources

    def validate(self):
        if self.tag_resources:
            for k in self.tag_resources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        result['TagResources'] = []
        if self.tag_resources is not None:
            for k in self.tag_resources:
                result['TagResources'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        self.tag_resources = []
        if m.get('TagResources') is not None:
            for k in m.get('TagResources'):
                temp_model = ListTagResourcesResponseBodyDataTagResources()
                self.tag_resources.append(temp_model.from_map(k))
        return self


class ListTagResourcesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListTagResourcesResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code. 
        # 
        # - The **ErrorCode** parameter is not returned when the request succeeds.
        # - The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether mapping relationships between applications and tags were queried successfully. Valid values:
        # 
        # *   **true**: The query was successful.
        # *   **false**: The query failed.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListTagResourcesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListTagResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTagResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OpenSaeServiceResponseBody(TeaModel):
    def __init__(
        self,
        order_id: str = None,
        request_id: str = None,
    ):
        # The ID of the order.
        self.order_id = order_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OpenSaeServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OpenSaeServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OpenSaeServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryResourceStaticsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # 7171a6ca-d1cd-4928-8642-7d5cfe69\*\*\*\*\
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class QueryResourceStaticsResponseBodyDataRealTimeRes(TeaModel):
    def __init__(
        self,
        cpu: float = None,
        memory: float = None,
    ):
        # The CPU usage. Unit: core per minute.
        self.cpu = cpu
        # The memory usage. Unit: GiB per minute.
        self.memory = memory

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.memory is not None:
            result['Memory'] = self.memory
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        return self


class QueryResourceStaticsResponseBodyDataSummary(TeaModel):
    def __init__(
        self,
        cpu: float = None,
        memory: float = None,
    ):
        # The CPU usage. Unit: core per minute.
        self.cpu = cpu
        # The memory usage. Unit: GiB per minute.
        self.memory = memory

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.memory is not None:
            result['Memory'] = self.memory
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        return self


class QueryResourceStaticsResponseBodyData(TeaModel):
    def __init__(
        self,
        real_time_res: QueryResourceStaticsResponseBodyDataRealTimeRes = None,
        summary: QueryResourceStaticsResponseBodyDataSummary = None,
    ):
        # The real-time resource usage.
        self.real_time_res = real_time_res
        # The resource usage of the current month.
        self.summary = summary

    def validate(self):
        if self.real_time_res:
            self.real_time_res.validate()
        if self.summary:
            self.summary.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.real_time_res is not None:
            result['RealTimeRes'] = self.real_time_res.to_map()
        if self.summary is not None:
            result['Summary'] = self.summary.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RealTimeRes') is not None:
            temp_model = QueryResourceStaticsResponseBodyDataRealTimeRes()
            self.real_time_res = temp_model.from_map(m['RealTimeRes'])
        if m.get('Summary') is not None:
            temp_model = QueryResourceStaticsResponseBodyDataSummary()
            self.summary = temp_model.from_map(m['Summary'])
        return self


class QueryResourceStaticsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryResourceStaticsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The resource usage.
        self.data = data
        # The error code. 
        # 
        # - The **ErrorCode** parameter is not returned when the request succeeds.
        # - The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the resource usage of an application was obtained. Valid values:
        # 
        # *   **true**: indicates that the resource usage was obtained.
        # *   **false**: indicates that the resource usage could not be obtained.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryResourceStaticsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class QueryResourceStaticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryResourceStaticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryResourceStaticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReduceApplicationCapacityByInstanceIdsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        instance_ids: str = None,
    ):
        # 0099b7be-5f5b-4512-a7fc-56049ef1\*\*\*\*\
        self.app_id = app_id
        # b2a8a925-477a-4ed7-b825-d5e22500\*\*\*\*\
        self.instance_ids = instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        return self


class ReduceApplicationCapacityByInstanceIdsResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class ReduceApplicationCapacityByInstanceIdsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ReduceApplicationCapacityByInstanceIdsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code.
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The information of the change order.
        self.data = data
        # The error code.
        # 
        # *   If the request is successful, this parameter is not returned.****\
        # *   This parameter is returned only if the request failed.**** For more information, see the "**Error codes**" section in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether information of the change order is successfully queried. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The ID of the trace. It can be used to query details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ReduceApplicationCapacityByInstanceIdsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ReduceApplicationCapacityByInstanceIdsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReduceApplicationCapacityByInstanceIdsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReduceApplicationCapacityByInstanceIdsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RescaleApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        auto_enable_application_scaling_rule: bool = None,
        min_ready_instance_ratio: int = None,
        min_ready_instances: int = None,
        replicas: int = None,
    ):
        # 0099b7be-5f5b-4512-a7fc-56049ef1\*\*\*\*\
        self.app_id = app_id
        # true
        self.auto_enable_application_scaling_rule = auto_enable_application_scaling_rule
        # \-1
        self.min_ready_instance_ratio = min_ready_instance_ratio
        # 1
        self.min_ready_instances = min_ready_instances
        # 5
        self.replicas = replicas

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.auto_enable_application_scaling_rule is not None:
            result['AutoEnableApplicationScalingRule'] = self.auto_enable_application_scaling_rule
        if self.min_ready_instance_ratio is not None:
            result['MinReadyInstanceRatio'] = self.min_ready_instance_ratio
        if self.min_ready_instances is not None:
            result['MinReadyInstances'] = self.min_ready_instances
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AutoEnableApplicationScalingRule') is not None:
            self.auto_enable_application_scaling_rule = m.get('AutoEnableApplicationScalingRule')
        if m.get('MinReadyInstanceRatio') is not None:
            self.min_ready_instance_ratio = m.get('MinReadyInstanceRatio')
        if m.get('MinReadyInstances') is not None:
            self.min_ready_instances = m.get('MinReadyInstances')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        return self


class RescaleApplicationResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class RescaleApplicationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: RescaleApplicationResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   If the request is successful, this parameter is not returned.****\
        # *   This parameter is returned only if the request failed.**** For more information, see the "**Error codes**" section in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the application is successfully scaled. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = RescaleApplicationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RescaleApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RescaleApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RescaleApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RescaleApplicationVerticallyRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        cpu: str = None,
        memory: str = None,
    ):
        # 0099b7be-5f5b-4512-a7fc-56049ef1\*\*\*\*\
        self.app_id = app_id
        # 1000
        self.cpu = cpu
        # 2048
        self.memory = memory

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.memory is not None:
            result['Memory'] = self.memory
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        return self


class RescaleApplicationVerticallyResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class RescaleApplicationVerticallyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: RescaleApplicationVerticallyResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   If the request is successful, this parameter is not returned.****\
        # *   This parameter is returned only if the request failed.**** For more information, see the "**Error codes**" section in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the instance specifications are changed. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The ID of the trace. It can be used to query details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = RescaleApplicationVerticallyResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RescaleApplicationVerticallyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RescaleApplicationVerticallyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RescaleApplicationVerticallyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RestartApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        min_ready_instance_ratio: int = None,
        min_ready_instances: int = None,
    ):
        # 0099b7be-5f5b-4512-a7fc-56049ef1\*\*\*\*\
        self.app_id = app_id
        # \-1
        self.min_ready_instance_ratio = min_ready_instance_ratio
        # 1
        self.min_ready_instances = min_ready_instances

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.min_ready_instance_ratio is not None:
            result['MinReadyInstanceRatio'] = self.min_ready_instance_ratio
        if self.min_ready_instances is not None:
            result['MinReadyInstances'] = self.min_ready_instances
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('MinReadyInstanceRatio') is not None:
            self.min_ready_instance_ratio = m.get('MinReadyInstanceRatio')
        if m.get('MinReadyInstances') is not None:
            self.min_ready_instances = m.get('MinReadyInstances')
        return self


class RestartApplicationResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class RestartApplicationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: RestartApplicationResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   If the request is successful, this parameter is not returned.****\
        # *   This parameter is returned only if the request failed.**** For more information, see the "**Error codes**" section in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   If the request is successful, **success** is returned.
        # *   An error message is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the instance is successfully restarted. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = RestartApplicationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RestartApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RestartApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RestartApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RestartInstancesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        instance_ids: str = None,
    ):
        # 1daa7236-3844-4f36-b39a-605b0cc0\*\*\*\*\
        self.app_id = app_id
        # mysae-1daa7236-3844-4f36-b39a-605b0cc0caa6-\*\*\*\*\*\
        self.instance_ids = instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        return self


class RestartInstancesResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class RestartInstancesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: RestartInstancesResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The details of the application.
        self.data = data
        # The error code.
        # 
        # *   If the request is successful, this parameter is not returned.****\
        # *   This parameter is returned only if the request failed.**** For more information, see the "**Error codes**" section in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   If the request is successful, **success** is returned.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Specifies whether the instances are successfully restarted. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = RestartInstancesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RestartInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RestartInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RestartInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RollbackApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        auto_enable_application_scaling_rule: str = None,
        batch_wait_time: int = None,
        min_ready_instance_ratio: int = None,
        min_ready_instances: int = None,
        update_strategy: str = None,
        version_id: str = None,
    ):
        # 017f39b8-dfa4-4e16-a84b-1dcee4b1\*\*\*\*\
        self.app_id = app_id
        # true
        self.auto_enable_application_scaling_rule = auto_enable_application_scaling_rule
        # 10
        self.batch_wait_time = batch_wait_time
        # \-1
        self.min_ready_instance_ratio = min_ready_instance_ratio
        # 1
        self.min_ready_instances = min_ready_instances
        # {"type":"GrayBatchUpdate","batchUpdate":{"batch":2,"releaseType":"auto","batchWaitTime":1},"grayUpdate":{"gray":1}}
        self.update_strategy = update_strategy
        # 0026ff7f-2b57-4127-bdd0-9bf202bb9\*\*\*\*\
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.auto_enable_application_scaling_rule is not None:
            result['AutoEnableApplicationScalingRule'] = self.auto_enable_application_scaling_rule
        if self.batch_wait_time is not None:
            result['BatchWaitTime'] = self.batch_wait_time
        if self.min_ready_instance_ratio is not None:
            result['MinReadyInstanceRatio'] = self.min_ready_instance_ratio
        if self.min_ready_instances is not None:
            result['MinReadyInstances'] = self.min_ready_instances
        if self.update_strategy is not None:
            result['UpdateStrategy'] = self.update_strategy
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AutoEnableApplicationScalingRule') is not None:
            self.auto_enable_application_scaling_rule = m.get('AutoEnableApplicationScalingRule')
        if m.get('BatchWaitTime') is not None:
            self.batch_wait_time = m.get('BatchWaitTime')
        if m.get('MinReadyInstanceRatio') is not None:
            self.min_ready_instance_ratio = m.get('MinReadyInstanceRatio')
        if m.get('MinReadyInstances') is not None:
            self.min_ready_instances = m.get('MinReadyInstances')
        if m.get('UpdateStrategy') is not None:
            self.update_strategy = m.get('UpdateStrategy')
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class RollbackApplicationResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        is_need_approval: bool = None,
    ):
        # The ID of the change order.
        self.change_order_id = change_order_id
        # Specifies whether approval is required when a RAM user performs release. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.is_need_approval = is_need_approval

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.is_need_approval is not None:
            result['IsNeedApproval'] = self.is_need_approval
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('IsNeedApproval') is not None:
            self.is_need_approval = m.get('IsNeedApproval')
        return self


class RollbackApplicationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: RollbackApplicationResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the request is successful, this parameter is not returned.****\
        # *   This parameter is returned only if the request failed.**** For more information, see the "**Error codes**" section in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the application is successfully rolled back. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = RollbackApplicationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RollbackApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RollbackApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RollbackApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # 0099b7be-5f5b-4512-a7fc-56049ef1\*\*\*\*\
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class StartApplicationResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class StartApplicationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: StartApplicationResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   If the request is successful, this parameter is not returned.****\
        # *   This parameter is returned only if the request failed.**** For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the application is started. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = StartApplicationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class StartApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # 0099b7be-5f5b-4512-a7fc-56049ef1\*\*\*\*\
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class StopApplicationResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class StopApplicationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: StopApplicationResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   If the request is successful, this parameter is not returned.****\
        # *   This parameter is returned only if the request failed.**** For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the specified application is stopped. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = StopApplicationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class StopApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SuspendJobRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        suspend: bool = None,
    ):
        self.app_id = app_id
        self.suspend = suspend

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.suspend is not None:
            result['Suspend'] = self.suspend
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Suspend') is not None:
            self.suspend = m.get('Suspend')
        return self


class SuspendJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class SuspendJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SuspendJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SuspendJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TagResourcesRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        resource_ids: str = None,
        resource_type: str = None,
        tags: str = None,
    ):
        # cn-beijing
        self.region_id = region_id
        # \["d42921c4-5433-4abd-8075-0e536f8b\*\*\*\*"]
        self.resource_ids = resource_ids
        # application
        self.resource_type = resource_type
        # \[{"key":"k1","value":"v1"}]
        self.tags = tags

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_ids is not None:
            result['ResourceIds'] = self.resource_ids
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceIds') is not None:
            self.resource_ids = m.get('ResourceIds')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class TagResourcesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # Indicates that the operation was successful.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether tags were added to the specified resources successfully. Valid values:
        # 
        # *   **true**: indicates that tags were added to the specified resources successfully.
        # *   **false**: indicates that tags could not be added to the specified resources.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class TagResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TagResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnbindSlbRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        internet: bool = None,
        intranet: bool = None,
    ):
        # 0099b7be-5f5b-4512-a7fc-56049ef1\*\*\*\*\
        self.app_id = app_id
        # true
        self.internet = internet
        # true
        self.intranet = intranet

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.internet is not None:
            result['Internet'] = self.internet
        if self.intranet is not None:
            result['Intranet'] = self.intranet
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Internet') is not None:
            self.internet = m.get('Internet')
        if m.get('Intranet') is not None:
            self.intranet = m.get('Intranet')
        return self


class UnbindSlbResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order. It can be used to query the task status.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class UnbindSlbResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UnbindSlbResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the internal-facing or Internet-facing SLB instance was disassociated successfully. Valid values:
        # 
        # *   **true**: The SLB instance was disassociated successfully.
        # *   **false**: The SLB instance could not be disassociated.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UnbindSlbResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UnbindSlbResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnbindSlbResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnbindSlbResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UntagResourcesRequest(TeaModel):
    def __init__(
        self,
        delete_all: bool = None,
        region_id: str = None,
        resource_ids: str = None,
        resource_type: str = None,
        tag_keys: str = None,
    ):
        # false
        self.delete_all = delete_all
        # cn-beijing
        self.region_id = region_id
        # \["d42921c4-5433-4abd-8075-0e536f8b\*\*\*\*"]
        self.resource_ids = resource_ids
        # application
        self.resource_type = resource_type
        # \["k1","k2"]
        self.tag_keys = tag_keys

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delete_all is not None:
            result['DeleteAll'] = self.delete_all
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_ids is not None:
            result['ResourceIds'] = self.resource_ids
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag_keys is not None:
            result['TagKeys'] = self.tag_keys
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeleteAll') is not None:
            self.delete_all = m.get('DeleteAll')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceIds') is not None:
            self.resource_ids = m.get('ResourceIds')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TagKeys') is not None:
            self.tag_keys = m.get('TagKeys')
        return self


class UntagResourcesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the tags were removed. Valid values:
        # 
        # *   **true**: The tags were removed.
        # *   **false**: The tags could not be removed.
        self.success = success
        # The ID of the trace. It can be used to query details of a request.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UntagResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UntagResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UntagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAppSecurityGroupRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        security_group_id: str = None,
    ):
        # 017f39b8-dfa4-4e16-a84b-1dcee4b1\*\*\*\*\
        self.app_id = app_id
        # sg-wz969ngg2e49q5i4\*\*\*\*\
        self.security_group_id = security_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class UpdateAppSecurityGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The error code.
        # 
        # *   If the request is successful, this parameter is not returned.****\
        # *   This parameter is returned only if the request failed.**** For more information, see the "**Error codes**" section in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   If the request is successful, **success** is returned.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the security group of the application is successfully updated. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The ID of the trace. It can be used to query details of a request.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateAppSecurityGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAppSecurityGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAppSecurityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateApplicationDescriptionRequest(TeaModel):
    def __init__(
        self,
        app_description: str = None,
        app_id: str = None,
    ):
        self.app_description = app_description
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_description is not None:
            result['AppDescription'] = self.app_description
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppDescription') is not None:
            self.app_description = m.get('AppDescription')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class UpdateApplicationDescriptionResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateApplicationDescriptionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateApplicationDescriptionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateApplicationDescriptionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateApplicationScalingRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        min_ready_instance_ratio: int = None,
        min_ready_instances: int = None,
        scaling_rule_metric: str = None,
        scaling_rule_name: str = None,
        scaling_rule_timer: str = None,
    ):
        # 7171a6ca-d1cd-4928-8642-7d5cfe69\*\*\*\*\
        self.app_id = app_id
        # \-1
        self.min_ready_instance_ratio = min_ready_instance_ratio
        # 3
        self.min_ready_instances = min_ready_instances
        # {"maxReplicas":3,"minReplicas":1,"metrics":\[{"metricType":"CPU","metricTargetAverageUtilization":20},{"metricType":"MEMORY","metricTargetAverageUtilization":30},{"metricType":"tcpActiveConn","metricTargetAverageUtilization":20},{"metricType":"SLB_QPS","MetricTargetAverageUtilization":25,"SlbProject":"aliyun-fc-cn-hangzhou-d95881d9-5d3c-5f26-a6b8-\*\*\*\*\*\*\*\*\*\*\*\*","SlbLogstore":"function-log","Vport":"80"},{"metricType":"SLB_RT","MetricTargetAverageUtilization":35,"SlbProject":"aliyun-fc-cn-hangzhou-d95881d9-5d3c-5f26-a6b8-\*\*\*\*\*\*\*\*\*\*\*\*","SlbLogstore":"function-log","Vport":"80"}],"scaleUpRules":{"step":"100","disabled":false,"stabilizationWindowSeconds":0},"scaleDownRules":{"step":"100","disabled":false,"stabilizationWindowSeconds":300}}
        self.scaling_rule_metric = scaling_rule_metric
        # timer-0800-2100
        self.scaling_rule_name = scaling_rule_name
        # {"beginDate":null,"endDate":null,"period":"\* \* \*","schedules":\[{"atTime":"08:00","targetReplicas":10},{"atTime":"20:00","targetReplicas":3}]}
        self.scaling_rule_timer = scaling_rule_timer

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.min_ready_instance_ratio is not None:
            result['MinReadyInstanceRatio'] = self.min_ready_instance_ratio
        if self.min_ready_instances is not None:
            result['MinReadyInstances'] = self.min_ready_instances
        if self.scaling_rule_metric is not None:
            result['ScalingRuleMetric'] = self.scaling_rule_metric
        if self.scaling_rule_name is not None:
            result['ScalingRuleName'] = self.scaling_rule_name
        if self.scaling_rule_timer is not None:
            result['ScalingRuleTimer'] = self.scaling_rule_timer
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('MinReadyInstanceRatio') is not None:
            self.min_ready_instance_ratio = m.get('MinReadyInstanceRatio')
        if m.get('MinReadyInstances') is not None:
            self.min_ready_instances = m.get('MinReadyInstances')
        if m.get('ScalingRuleMetric') is not None:
            self.scaling_rule_metric = m.get('ScalingRuleMetric')
        if m.get('ScalingRuleName') is not None:
            self.scaling_rule_name = m.get('ScalingRuleName')
        if m.get('ScalingRuleTimer') is not None:
            self.scaling_rule_timer = m.get('ScalingRuleTimer')
        return self


class UpdateApplicationScalingRuleResponseBodyDataMetricMetrics(TeaModel):
    def __init__(
        self,
        metric_target_average_utilization: int = None,
        metric_type: str = None,
    ):
        # The limit on the metric.
        # 
        # *   The limit on the CPU utilization. Unit: percentage.
        # *   The limit on the memory usage. Unit: percentage.
        # *   The limit on the average number of active TCP connections per second.
        # *   The limit on the QPS of the Internet-facing SLB instance.
        # *   The limit on the response time of the Internet-facing SLB instance. Unit: milliseconds.
        self.metric_target_average_utilization = metric_target_average_utilization
        # The metric that is used to trigger the auto scaling policy. Valid values:
        # 
        # *   **CPU**: the CPU utilization.
        # *   **MEMORY**: the memory usage.
        # *   **tcpActiveConn**: the average number of active TCP connections for an instance in 30 seconds.
        # *   **SLB_QPS**: the average QPS of the Internet-facing SLB instance associated with an application instance in 15 seconds.
        # *   **SLB_RT**: the average response time of the Internet-facing SLB instance in 15 seconds.
        self.metric_type = metric_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_target_average_utilization is not None:
            result['MetricTargetAverageUtilization'] = self.metric_target_average_utilization
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetricTargetAverageUtilization') is not None:
            self.metric_target_average_utilization = m.get('MetricTargetAverageUtilization')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        return self


class UpdateApplicationScalingRuleResponseBodyDataMetric(TeaModel):
    def __init__(
        self,
        max_replicas: int = None,
        metrics: List[UpdateApplicationScalingRuleResponseBodyDataMetricMetrics] = None,
        min_replicas: int = None,
    ):
        # The maximum number of instances.
        self.max_replicas = max_replicas
        # The list of metrics that are used to trigger the auto scaling policy.
        self.metrics = metrics
        # The minimum number of instances.
        self.min_replicas = min_replicas

    def validate(self):
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        result['Metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['Metrics'].append(k.to_map() if k else None)
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        self.metrics = []
        if m.get('Metrics') is not None:
            for k in m.get('Metrics'):
                temp_model = UpdateApplicationScalingRuleResponseBodyDataMetricMetrics()
                self.metrics.append(temp_model.from_map(k))
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        return self


class UpdateApplicationScalingRuleResponseBodyDataTimerSchedules(TeaModel):
    def __init__(
        self,
        at_time: str = None,
        target_replicas: int = None,
    ):
        # The point in time. Format: **Hour:Minute**.
        self.at_time = at_time
        # The expected number of instances.
        self.target_replicas = target_replicas

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.at_time is not None:
            result['AtTime'] = self.at_time
        if self.target_replicas is not None:
            result['TargetReplicas'] = self.target_replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AtTime') is not None:
            self.at_time = m.get('AtTime')
        if m.get('TargetReplicas') is not None:
            self.target_replicas = m.get('TargetReplicas')
        return self


class UpdateApplicationScalingRuleResponseBodyDataTimer(TeaModel):
    def __init__(
        self,
        begin_date: str = None,
        end_date: str = None,
        period: str = None,
        schedules: List[UpdateApplicationScalingRuleResponseBodyDataTimerSchedules] = None,
    ):
        # The start date of the validity period of the scheduled auto scaling policy. Parameter description:
        # 
        # *   If both the **BeginDate** and **EndDate** parameters are set to **null**, the auto scaling policy can always be triggered. The default value for these parameters is null.
        # *   If the two parameters are set to specific dates, the scheduled auto scaling policy can be triggered during the period between the two dates. For example, if **BeginDate** is 2021-03-25 and **EndDate** is 2021-04-25, the auto scaling policy is valid for one month.
        self.begin_date = begin_date
        # The end date of the validity period of the scheduled auto scaling policy. Parameter description:
        # 
        # *   If both the **BeginDate** and **EndDate** parameters are set to **null**, the auto scaling policy can always be triggered. The default value for these parameters is null.
        # *   If the two parameters are set to specific dates, the scheduled auto scaling policy can be triggered during the period between the two dates. For example, if **BeginDate** is 2021-03-25 and **EndDate** is 2021-04-25, the auto scaling policy is valid for one month.
        self.end_date = end_date
        # The days on which the scheduled auto scaling policy takes effect. Valid values:
        # 
        # *   **\* \* \***: The scheduled auto scaling policy takes effect at a specified time every day.
        # 
        # *   **\* \* Fri,Mon**: The scheduled auto scaling policy takes effect at a specified time on one or multiple days of a week. The specified time is in the GMT+8 time zone. Valid values:
        # 
        #     *   **Sun**: Sunday
        #     *   **Mon**: Monday
        #     *   **Tue**: Tuesday
        #     *   **Wed**: Wednesday
        #     *   **Thu**: Thursday
        #     *   **Fri**: Friday
        #     *   **Sat**: Saturday
        # 
        # *   **1,2,3,28,31 \* \***: The scheduled auto scaling policy takes effect at a specified time on one or multiple days of a month. Valid values: 1 to 31. If the month does not have a 31st day, the auto scaling policy takes effect on the specified days other than the 31st day.
        self.period = period
        # The points in time when the auto scaling policy is triggered within one day.
        self.schedules = schedules

    def validate(self):
        if self.schedules:
            for k in self.schedules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_date is not None:
            result['BeginDate'] = self.begin_date
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.period is not None:
            result['Period'] = self.period
        result['Schedules'] = []
        if self.schedules is not None:
            for k in self.schedules:
                result['Schedules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BeginDate') is not None:
            self.begin_date = m.get('BeginDate')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        self.schedules = []
        if m.get('Schedules') is not None:
            for k in m.get('Schedules'):
                temp_model = UpdateApplicationScalingRuleResponseBodyDataTimerSchedules()
                self.schedules.append(temp_model.from_map(k))
        return self


class UpdateApplicationScalingRuleResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        create_time: int = None,
        last_disable_time: int = None,
        metric: UpdateApplicationScalingRuleResponseBodyDataMetric = None,
        scale_rule_enabled: bool = None,
        scale_rule_name: str = None,
        scale_rule_type: str = None,
        timer: UpdateApplicationScalingRuleResponseBodyDataTimer = None,
        update_time: int = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The time when the auto scaling policy was created. Unit: milliseconds.
        self.create_time = create_time
        # The time when the auto scaling policy was last disabled.
        self.last_disable_time = last_disable_time
        # The details of the metric-based auto scaling policy.
        self.metric = metric
        # Indicates whether the auto scaling policy is enabled. Valid values:
        # 
        # *   **true**: enabled
        # *   **false**: disabled
        self.scale_rule_enabled = scale_rule_enabled
        # The name of the auto scaling policy.
        self.scale_rule_name = scale_rule_name
        # The type of the auto scaling policy. Valid values:
        # 
        # *   **timing**: the scheduled auto scaling policy.
        # *   **metric**: the metric-based auto scaling policy.
        # *   **mix**: the hybrid auto scaling policy.
        self.scale_rule_type = scale_rule_type
        # The details of the scheduled auto scaling policy.
        self.timer = timer
        # The time when the auto scaling policy was updated. Unit: milliseconds.
        self.update_time = update_time

    def validate(self):
        if self.metric:
            self.metric.validate()
        if self.timer:
            self.timer.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_disable_time is not None:
            result['LastDisableTime'] = self.last_disable_time
        if self.metric is not None:
            result['Metric'] = self.metric.to_map()
        if self.scale_rule_enabled is not None:
            result['ScaleRuleEnabled'] = self.scale_rule_enabled
        if self.scale_rule_name is not None:
            result['ScaleRuleName'] = self.scale_rule_name
        if self.scale_rule_type is not None:
            result['ScaleRuleType'] = self.scale_rule_type
        if self.timer is not None:
            result['Timer'] = self.timer.to_map()
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastDisableTime') is not None:
            self.last_disable_time = m.get('LastDisableTime')
        if m.get('Metric') is not None:
            temp_model = UpdateApplicationScalingRuleResponseBodyDataMetric()
            self.metric = temp_model.from_map(m['Metric'])
        if m.get('ScaleRuleEnabled') is not None:
            self.scale_rule_enabled = m.get('ScaleRuleEnabled')
        if m.get('ScaleRuleName') is not None:
            self.scale_rule_name = m.get('ScaleRuleName')
        if m.get('ScaleRuleType') is not None:
            self.scale_rule_type = m.get('ScaleRuleType')
        if m.get('Timer') is not None:
            temp_model = UpdateApplicationScalingRuleResponseBodyDataTimer()
            self.timer = temp_model.from_map(m['Timer'])
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class UpdateApplicationScalingRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UpdateApplicationScalingRuleResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        # The returned data.
        self.data = data
        self.error_code = error_code
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateApplicationScalingRuleResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateApplicationScalingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateApplicationScalingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateApplicationScalingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateApplicationVswitchesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        v_switch_id: str = None,
    ):
        self.app_id = app_id
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class UpdateApplicationVswitchesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateApplicationVswitchesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateApplicationVswitchesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateApplicationVswitchesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateConfigMapRequest(TeaModel):
    def __init__(
        self,
        config_map_id: int = None,
        data: str = None,
        description: str = None,
    ):
        # 1
        self.config_map_id = config_map_id
        self.data = data
        self.description = description

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        if self.data is not None:
            result['Data'] = self.data
        if self.description is not None:
            result['Description'] = self.description
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        return self


class UpdateConfigMapResponseBodyData(TeaModel):
    def __init__(
        self,
        config_map_id: str = None,
    ):
        # The ID of the ConfigMap instance.
        self.config_map_id = config_map_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        return self


class UpdateConfigMapResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UpdateConfigMapResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx:**: indicates that the call was successful.
        # *   **3xx**: indicates that the call was redirected.
        # *   **4xx**: indicates that the call failed.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned result.
        self.data = data
        # The returned error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned information.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the ConfigMap instance was updated. Valid values:
        # 
        # *   **true**: The instance was updated.
        # *   **false**: The instance failed to be updated.
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateConfigMapResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateConfigMapResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateConfigMapResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateConfigMapResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateGreyTagRouteRequest(TeaModel):
    def __init__(
        self,
        alb_rules: str = None,
        description: str = None,
        dubbo_rules: str = None,
        grey_tag_route_id: int = None,
        sc_rules: str = None,
    ):
        self.alb_rules = alb_rules
        # Canary Release - Regions
        self.description = description
        # \[{"condition":"OR","group":"DUBBO","items":\[{"cond":"==","expr":".key1","index":0,"operator":"rawvalue","value":"value1"},{"cond":"==","expr":".key2","index":0,"operator":"rawvalue","value":"value2"}],"methodName":"echo","serviceName":"com.alibaba.edas.boot.EchoService","version":"1.0.0"}]
        self.dubbo_rules = dubbo_rules
        # 1
        self.grey_tag_route_id = grey_tag_route_id
        # \[{"condition":"OR","items":\[{"cond":"==","name":"grey","operator":"rawvalue","type":"param","value":"true"},{"cond":"==","name":"grey","operator":"rawvalue","type":"cookie","value":"true"},{"cond":"==","name":"grey","operator":"rawvalue","type":"header","value":"true"}],"path":"/post-echo/hi"}]
        self.sc_rules = sc_rules

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alb_rules is not None:
            result['AlbRules'] = self.alb_rules
        if self.description is not None:
            result['Description'] = self.description
        if self.dubbo_rules is not None:
            result['DubboRules'] = self.dubbo_rules
        if self.grey_tag_route_id is not None:
            result['GreyTagRouteId'] = self.grey_tag_route_id
        if self.sc_rules is not None:
            result['ScRules'] = self.sc_rules
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlbRules') is not None:
            self.alb_rules = m.get('AlbRules')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DubboRules') is not None:
            self.dubbo_rules = m.get('DubboRules')
        if m.get('GreyTagRouteId') is not None:
            self.grey_tag_route_id = m.get('GreyTagRouteId')
        if m.get('ScRules') is not None:
            self.sc_rules = m.get('ScRules')
        return self


class UpdateGreyTagRouteResponseBodyData(TeaModel):
    def __init__(
        self,
        grey_tag_route_id: int = None,
    ):
        # The ID of the canary release rule. The ID is globally unique.
        self.grey_tag_route_id = grey_tag_route_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grey_tag_route_id is not None:
            result['GreyTagRouteId'] = self.grey_tag_route_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GreyTagRouteId') is not None:
            self.grey_tag_route_id = m.get('GreyTagRouteId')
        return self


class UpdateGreyTagRouteResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UpdateGreyTagRouteResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The information about the canary release rule.
        self.data = data
        # The returned error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned information.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the information of the change order was queried. Valid values:
        # 
        # *   **true**: The information was queried.
        # *   **false**: The information failed to be queried.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateGreyTagRouteResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateGreyTagRouteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateGreyTagRouteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateGreyTagRouteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateIngressRequest(TeaModel):
    def __init__(
        self,
        cert_id: str = None,
        cert_ids: str = None,
        default_rule: str = None,
        description: str = None,
        ingress_id: int = None,
        listener_port: str = None,
        listener_protocol: str = None,
        load_balance_type: str = None,
        rules: str = None,
    ):
        # 188077086902\*\*\*\*\_176993d\*\*\*\*\_181437\*\*\*\*\_108724\*\*\*\*\
        self.cert_id = cert_id
        self.cert_ids = cert_ids
        # {"appId":"395b60e4-0550-458d-9c54-a265d036\*\*\*\*","containerPort":8080}
        self.default_rule = default_rule
        # ingress-sae-test
        self.description = description
        # 87
        self.ingress_id = ingress_id
        # 443
        self.listener_port = listener_port
        # HTTP
        self.listener_protocol = listener_protocol
        # clb
        self.load_balance_type = load_balance_type
        # \[{"appId":"395b60e4-0550-458d-9c54-a265d036\*\*\*\*","containerPort":8080,"domain":"www.sae.site","path":"/path1"},{"appId":"666403ce-d25b-47cf-87fe-497565d2\*\*\*\*","containerPort":8080,"domain":"sae.site","path":"/path2"}]
        self.rules = rules

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_id is not None:
            result['CertId'] = self.cert_id
        if self.cert_ids is not None:
            result['CertIds'] = self.cert_ids
        if self.default_rule is not None:
            result['DefaultRule'] = self.default_rule
        if self.description is not None:
            result['Description'] = self.description
        if self.ingress_id is not None:
            result['IngressId'] = self.ingress_id
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.listener_protocol is not None:
            result['ListenerProtocol'] = self.listener_protocol
        if self.load_balance_type is not None:
            result['LoadBalanceType'] = self.load_balance_type
        if self.rules is not None:
            result['Rules'] = self.rules
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertId') is not None:
            self.cert_id = m.get('CertId')
        if m.get('CertIds') is not None:
            self.cert_ids = m.get('CertIds')
        if m.get('DefaultRule') is not None:
            self.default_rule = m.get('DefaultRule')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IngressId') is not None:
            self.ingress_id = m.get('IngressId')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('ListenerProtocol') is not None:
            self.listener_protocol = m.get('ListenerProtocol')
        if m.get('LoadBalanceType') is not None:
            self.load_balance_type = m.get('LoadBalanceType')
        if m.get('Rules') is not None:
            self.rules = m.get('Rules')
        return self


class UpdateIngressResponseBodyData(TeaModel):
    def __init__(
        self,
        ingress_id: int = None,
    ):
        # The ID of the routing rule.
        self.ingress_id = ingress_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ingress_id is not None:
            result['IngressId'] = self.ingress_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IngressId') is not None:
            self.ingress_id = m.get('IngressId')
        return self


class UpdateIngressResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UpdateIngressResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the configurations of the routing rule were updated. Valid values:
        # 
        # *   **true**: The configurations were updated.
        # *   **false**: The configurations could not be updated.
        self.success = success
        # The ID of the trace.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateIngressResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateIngressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateIngressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateIngressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateJobRequest(TeaModel):
    def __init__(
        self,
        acr_assume_role_arn: str = None,
        acr_instance_id: str = None,
        app_id: str = None,
        backoff_limit: int = None,
        command: str = None,
        command_args: str = None,
        concurrency_policy: str = None,
        config_map_mount_desc: str = None,
        custom_host_alias: str = None,
        edas_container_version: str = None,
        enable_image_accl: bool = None,
        envs: str = None,
        image_pull_secrets: str = None,
        image_url: str = None,
        jar_start_args: str = None,
        jar_start_options: str = None,
        jdk: str = None,
        mount_desc: str = None,
        mount_host: str = None,
        nas_id: str = None,
        oss_ak_id: str = None,
        oss_ak_secret: str = None,
        oss_mount_descs: str = None,
        package_url: str = None,
        package_version: str = None,
        php: str = None,
        php_config: str = None,
        php_config_location: str = None,
        post_start: str = None,
        pre_stop: str = None,
        programming_language: str = None,
        python: str = None,
        python_modules: str = None,
        ref_app_id: str = None,
        replicas: str = None,
        slice: bool = None,
        slice_envs: str = None,
        sls_configs: str = None,
        termination_grace_period_seconds: int = None,
        timeout: int = None,
        timezone: str = None,
        tomcat_config: str = None,
        trigger_config: str = None,
        war_start_options: str = None,
        web_container: str = None,
    ):
        self.acr_assume_role_arn = acr_assume_role_arn
        self.acr_instance_id = acr_instance_id
        self.app_id = app_id
        self.backoff_limit = backoff_limit
        self.command = command
        self.command_args = command_args
        self.concurrency_policy = concurrency_policy
        self.config_map_mount_desc = config_map_mount_desc
        self.custom_host_alias = custom_host_alias
        self.edas_container_version = edas_container_version
        self.enable_image_accl = enable_image_accl
        self.envs = envs
        self.image_pull_secrets = image_pull_secrets
        self.image_url = image_url
        self.jar_start_args = jar_start_args
        self.jar_start_options = jar_start_options
        self.jdk = jdk
        self.mount_desc = mount_desc
        self.mount_host = mount_host
        self.nas_id = nas_id
        self.oss_ak_id = oss_ak_id
        self.oss_ak_secret = oss_ak_secret
        self.oss_mount_descs = oss_mount_descs
        self.package_url = package_url
        self.package_version = package_version
        self.php = php
        self.php_config = php_config
        self.php_config_location = php_config_location
        self.post_start = post_start
        self.pre_stop = pre_stop
        self.programming_language = programming_language
        self.python = python
        self.python_modules = python_modules
        self.ref_app_id = ref_app_id
        self.replicas = replicas
        self.slice = slice
        self.slice_envs = slice_envs
        self.sls_configs = sls_configs
        self.termination_grace_period_seconds = termination_grace_period_seconds
        self.timeout = timeout
        self.timezone = timezone
        self.tomcat_config = tomcat_config
        self.trigger_config = trigger_config
        self.war_start_options = war_start_options
        self.web_container = web_container

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acr_assume_role_arn is not None:
            result['AcrAssumeRoleArn'] = self.acr_assume_role_arn
        if self.acr_instance_id is not None:
            result['AcrInstanceId'] = self.acr_instance_id
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.backoff_limit is not None:
            result['BackoffLimit'] = self.backoff_limit
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        if self.concurrency_policy is not None:
            result['ConcurrencyPolicy'] = self.concurrency_policy
        if self.config_map_mount_desc is not None:
            result['ConfigMapMountDesc'] = self.config_map_mount_desc
        if self.custom_host_alias is not None:
            result['CustomHostAlias'] = self.custom_host_alias
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        if self.enable_image_accl is not None:
            result['EnableImageAccl'] = self.enable_image_accl
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.image_pull_secrets is not None:
            result['ImagePullSecrets'] = self.image_pull_secrets
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.jar_start_args is not None:
            result['JarStartArgs'] = self.jar_start_args
        if self.jar_start_options is not None:
            result['JarStartOptions'] = self.jar_start_options
        if self.jdk is not None:
            result['Jdk'] = self.jdk
        if self.mount_desc is not None:
            result['MountDesc'] = self.mount_desc
        if self.mount_host is not None:
            result['MountHost'] = self.mount_host
        if self.nas_id is not None:
            result['NasId'] = self.nas_id
        if self.oss_ak_id is not None:
            result['OssAkId'] = self.oss_ak_id
        if self.oss_ak_secret is not None:
            result['OssAkSecret'] = self.oss_ak_secret
        if self.oss_mount_descs is not None:
            result['OssMountDescs'] = self.oss_mount_descs
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.php is not None:
            result['Php'] = self.php
        if self.php_config is not None:
            result['PhpConfig'] = self.php_config
        if self.php_config_location is not None:
            result['PhpConfigLocation'] = self.php_config_location
        if self.post_start is not None:
            result['PostStart'] = self.post_start
        if self.pre_stop is not None:
            result['PreStop'] = self.pre_stop
        if self.programming_language is not None:
            result['ProgrammingLanguage'] = self.programming_language
        if self.python is not None:
            result['Python'] = self.python
        if self.python_modules is not None:
            result['PythonModules'] = self.python_modules
        if self.ref_app_id is not None:
            result['RefAppId'] = self.ref_app_id
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.slice is not None:
            result['Slice'] = self.slice
        if self.slice_envs is not None:
            result['SliceEnvs'] = self.slice_envs
        if self.sls_configs is not None:
            result['SlsConfigs'] = self.sls_configs
        if self.termination_grace_period_seconds is not None:
            result['TerminationGracePeriodSeconds'] = self.termination_grace_period_seconds
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.tomcat_config is not None:
            result['TomcatConfig'] = self.tomcat_config
        if self.trigger_config is not None:
            result['TriggerConfig'] = self.trigger_config
        if self.war_start_options is not None:
            result['WarStartOptions'] = self.war_start_options
        if self.web_container is not None:
            result['WebContainer'] = self.web_container
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcrAssumeRoleArn') is not None:
            self.acr_assume_role_arn = m.get('AcrAssumeRoleArn')
        if m.get('AcrInstanceId') is not None:
            self.acr_instance_id = m.get('AcrInstanceId')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BackoffLimit') is not None:
            self.backoff_limit = m.get('BackoffLimit')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        if m.get('ConcurrencyPolicy') is not None:
            self.concurrency_policy = m.get('ConcurrencyPolicy')
        if m.get('ConfigMapMountDesc') is not None:
            self.config_map_mount_desc = m.get('ConfigMapMountDesc')
        if m.get('CustomHostAlias') is not None:
            self.custom_host_alias = m.get('CustomHostAlias')
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        if m.get('EnableImageAccl') is not None:
            self.enable_image_accl = m.get('EnableImageAccl')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('ImagePullSecrets') is not None:
            self.image_pull_secrets = m.get('ImagePullSecrets')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('JarStartArgs') is not None:
            self.jar_start_args = m.get('JarStartArgs')
        if m.get('JarStartOptions') is not None:
            self.jar_start_options = m.get('JarStartOptions')
        if m.get('Jdk') is not None:
            self.jdk = m.get('Jdk')
        if m.get('MountDesc') is not None:
            self.mount_desc = m.get('MountDesc')
        if m.get('MountHost') is not None:
            self.mount_host = m.get('MountHost')
        if m.get('NasId') is not None:
            self.nas_id = m.get('NasId')
        if m.get('OssAkId') is not None:
            self.oss_ak_id = m.get('OssAkId')
        if m.get('OssAkSecret') is not None:
            self.oss_ak_secret = m.get('OssAkSecret')
        if m.get('OssMountDescs') is not None:
            self.oss_mount_descs = m.get('OssMountDescs')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('Php') is not None:
            self.php = m.get('Php')
        if m.get('PhpConfig') is not None:
            self.php_config = m.get('PhpConfig')
        if m.get('PhpConfigLocation') is not None:
            self.php_config_location = m.get('PhpConfigLocation')
        if m.get('PostStart') is not None:
            self.post_start = m.get('PostStart')
        if m.get('PreStop') is not None:
            self.pre_stop = m.get('PreStop')
        if m.get('ProgrammingLanguage') is not None:
            self.programming_language = m.get('ProgrammingLanguage')
        if m.get('Python') is not None:
            self.python = m.get('Python')
        if m.get('PythonModules') is not None:
            self.python_modules = m.get('PythonModules')
        if m.get('RefAppId') is not None:
            self.ref_app_id = m.get('RefAppId')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('Slice') is not None:
            self.slice = m.get('Slice')
        if m.get('SliceEnvs') is not None:
            self.slice_envs = m.get('SliceEnvs')
        if m.get('SlsConfigs') is not None:
            self.sls_configs = m.get('SlsConfigs')
        if m.get('TerminationGracePeriodSeconds') is not None:
            self.termination_grace_period_seconds = m.get('TerminationGracePeriodSeconds')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('TomcatConfig') is not None:
            self.tomcat_config = m.get('TomcatConfig')
        if m.get('TriggerConfig') is not None:
            self.trigger_config = m.get('TriggerConfig')
        if m.get('WarStartOptions') is not None:
            self.war_start_options = m.get('WarStartOptions')
        if m.get('WebContainer') is not None:
            self.web_container = m.get('WebContainer')
        return self


class UpdateJobResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        change_order_id: str = None,
    ):
        self.app_id = app_id
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class UpdateJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UpdateJobResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateNamespaceRequest(TeaModel):
    def __init__(
        self,
        enable_micro_registration: bool = None,
        name_space_short_id: str = None,
        namespace_description: str = None,
        namespace_id: str = None,
        namespace_name: str = None,
    ):
        self.enable_micro_registration = enable_micro_registration
        self.name_space_short_id = name_space_short_id
        # desc
        self.namespace_description = namespace_description
        # cn-beijing:test
        self.namespace_id = namespace_id
        # name
        self.namespace_name = namespace_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_micro_registration is not None:
            result['EnableMicroRegistration'] = self.enable_micro_registration
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_description is not None:
            result['NamespaceDescription'] = self.namespace_description
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.namespace_name is not None:
            result['NamespaceName'] = self.namespace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableMicroRegistration') is not None:
            self.enable_micro_registration = m.get('EnableMicroRegistration')
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceDescription') is not None:
            self.namespace_description = m.get('NamespaceDescription')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NamespaceName') is not None:
            self.namespace_name = m.get('NamespaceName')
        return self


class UpdateNamespaceResponseBodyData(TeaModel):
    def __init__(
        self,
        enable_micro_registration: bool = None,
        name_space_short_id: str = None,
        namespace_description: str = None,
        namespace_id: str = None,
        namespace_name: str = None,
        region_id: str = None,
    ):
        self.enable_micro_registration = enable_micro_registration
        self.name_space_short_id = name_space_short_id
        # The description of the namespace.
        self.namespace_description = namespace_description
        # The ID of the namespace.
        self.namespace_id = namespace_id
        # The name of the namespace.
        self.namespace_name = namespace_name
        # The region where the namespace resides.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_micro_registration is not None:
            result['EnableMicroRegistration'] = self.enable_micro_registration
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_description is not None:
            result['NamespaceDescription'] = self.namespace_description
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.namespace_name is not None:
            result['NamespaceName'] = self.namespace_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableMicroRegistration') is not None:
            self.enable_micro_registration = m.get('EnableMicroRegistration')
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceDescription') is not None:
            self.namespace_description = m.get('NamespaceDescription')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NamespaceName') is not None:
            self.namespace_name = m.get('NamespaceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class UpdateNamespaceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UpdateNamespaceResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The information of the namespace.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the information of the namespace was updated. Valid values:
        # 
        # *   **true**: indicates that the information was updated.
        # *   **false**: indicates that the information could not be updated.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateNamespaceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateNamespaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateNamespaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateNamespaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateNamespaceVpcRequest(TeaModel):
    def __init__(
        self,
        name_space_short_id: str = None,
        namespace_id: str = None,
        vpc_id: str = None,
    ):
        self.name_space_short_id = name_space_short_id
        # cn-beijing:test
        self.namespace_id = namespace_id
        # vpc-2ze0i263cnn311nvj\*\*\*\*\
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class UpdateNamespaceVpcResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the VPC information was updated. Valid values:
        # 
        # *   **true**: indicates that the information was updated.
        # *   **false**: indicates that the information could not be updated.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateNamespaceVpcResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateNamespaceVpcResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateNamespaceVpcResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSecretRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
        secret_data: str = None,
        secret_id: int = None,
    ):
        self.namespace_id = namespace_id
        self.secret_data = secret_data
        self.secret_id = secret_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.secret_data is not None:
            result['SecretData'] = self.secret_data
        if self.secret_id is not None:
            result['SecretId'] = self.secret_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('SecretData') is not None:
            self.secret_data = m.get('SecretData')
        if m.get('SecretId') is not None:
            self.secret_id = m.get('SecretId')
        return self


class UpdateSecretResponseBodyData(TeaModel):
    def __init__(
        self,
        secret_id: int = None,
    ):
        self.secret_id = secret_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.secret_id is not None:
            result['SecretId'] = self.secret_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SecretId') is not None:
            self.secret_id = m.get('SecretId')
        return self


class UpdateSecretResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UpdateSecretResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateSecretResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateSecretResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSecretResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSecretResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


