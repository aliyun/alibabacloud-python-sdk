# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import List, Any, Dict


class AclEntryConfig(TeaModel):
    def __init__(
        self,
        entry: str = None,
    ):
        # This parameter is required.
        self.entry = entry

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entry is not None:
            result['entry'] = self.entry
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('entry') is not None:
            self.entry = m.get('entry')
        return self


class AclConfig(TeaModel):
    def __init__(
        self,
        acl_entries: List[AclEntryConfig] = None,
    ):
        # This parameter is required.
        self.acl_entries = acl_entries

    def validate(self):
        if self.acl_entries:
            for k in self.acl_entries:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['aclEntries'] = []
        if self.acl_entries is not None:
            for k in self.acl_entries:
                result['aclEntries'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.acl_entries = []
        if m.get('aclEntries') is not None:
            for k in m.get('aclEntries'):
                temp_model = AclEntryConfig()
                self.acl_entries.append(temp_model.from_map(k))
        return self


class AppStackInstanceEndpoints(TeaModel):
    def __init__(
        self,
        address: str = None,
        name: str = None,
        protocol: str = None,
    ):
        self.address = address
        self.name = name
        self.protocol = protocol

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.name is not None:
            result['Name'] = self.name
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        return self


class AppStackInstanceParameters(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        self.name = name
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class AppStackInstance(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        endpoints: List[AppStackInstanceEndpoints] = None,
        instance_id: str = None,
        instance_name: str = None,
        parameters: List[AppStackInstanceParameters] = None,
        stack_id: str = None,
        status: str = None,
        update_time: int = None,
    ):
        self.create_time = create_time
        self.endpoints = endpoints
        self.instance_id = instance_id
        self.instance_name = instance_name
        self.parameters = parameters
        self.stack_id = stack_id
        self.status = status
        self.update_time = update_time

    def validate(self):
        if self.endpoints:
            for k in self.endpoints:
                if k:
                    k.validate()
        if self.parameters:
            for k in self.parameters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        result['Endpoints'] = []
        if self.endpoints is not None:
            for k in self.endpoints:
                result['Endpoints'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        result['Parameters'] = []
        if self.parameters is not None:
            for k in self.parameters:
                result['Parameters'].append(k.to_map() if k else None)
        if self.stack_id is not None:
            result['StackId'] = self.stack_id
        if self.status is not None:
            result['Status'] = self.status
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        self.endpoints = []
        if m.get('Endpoints') is not None:
            for k in m.get('Endpoints'):
                temp_model = AppStackInstanceEndpoints()
                self.endpoints.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        self.parameters = []
        if m.get('Parameters') is not None:
            for k in m.get('Parameters'):
                temp_model = AppStackInstanceParameters()
                self.parameters.append(temp_model.from_map(k))
        if m.get('StackId') is not None:
            self.stack_id = m.get('StackId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class AppStackResource(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        instance_id: str = None,
        product_code: str = None,
        resource_id: str = None,
        resource_name: str = None,
        resource_type: str = None,
        stack_id: str = None,
        status: str = None,
    ):
        self.create_time = create_time
        self.instance_id = instance_id
        self.product_code = product_code
        self.resource_id = resource_id
        self.resource_name = resource_name
        self.resource_type = resource_type
        self.stack_id = stack_id
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.product_code is not None:
            result['ProductCode'] = self.product_code
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_name is not None:
            result['ResourceName'] = self.resource_name
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.stack_id is not None:
            result['StackId'] = self.stack_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ProductCode') is not None:
            self.product_code = m.get('ProductCode')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceName') is not None:
            self.resource_name = m.get('ResourceName')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('StackId') is not None:
            self.stack_id = m.get('StackId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class AppStackTaskSteps(TeaModel):
    def __init__(
        self,
        code: str = None,
        duration: int = None,
        end_time: int = None,
        id: str = None,
        message: str = None,
        name: str = None,
        start_time: int = None,
        status: str = None,
    ):
        self.code = code
        self.duration = duration
        self.end_time = end_time
        self.id = id
        self.message = message
        self.name = name
        self.start_time = start_time
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        if self.name is not None:
            result['Name'] = self.name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class AppStackTask(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        end_time: int = None,
        instance_id: str = None,
        stack_id: str = None,
        start_time: int = None,
        status: str = None,
        steps: List[AppStackTaskSteps] = None,
        task_id: str = None,
    ):
        self.create_time = create_time
        self.end_time = end_time
        self.instance_id = instance_id
        self.stack_id = stack_id
        self.start_time = start_time
        self.status = status
        self.steps = steps
        self.task_id = task_id

    def validate(self):
        if self.steps:
            for k in self.steps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.stack_id is not None:
            result['StackId'] = self.stack_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        result['Steps'] = []
        if self.steps is not None:
            for k in self.steps:
                result['Steps'].append(k.to_map() if k else None)
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('StackId') is not None:
            self.stack_id = m.get('StackId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.steps = []
        if m.get('Steps') is not None:
            for k in m.get('Steps'):
                temp_model = AppStackTaskSteps()
                self.steps.append(temp_model.from_map(k))
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DNSOption(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        self.name = name
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class CustomDNS(TeaModel):
    def __init__(
        self,
        dns_options: List[DNSOption] = None,
        name_servers: List[str] = None,
        searches: List[str] = None,
    ):
        self.dns_options = dns_options
        self.name_servers = name_servers
        self.searches = searches

    def validate(self):
        if self.dns_options:
            for k in self.dns_options:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['dnsOptions'] = []
        if self.dns_options is not None:
            for k in self.dns_options:
                result['dnsOptions'].append(k.to_map() if k else None)
        if self.name_servers is not None:
            result['nameServers'] = self.name_servers
        if self.searches is not None:
            result['searches'] = self.searches
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dns_options = []
        if m.get('dnsOptions') is not None:
            for k in m.get('dnsOptions'):
                temp_model = DNSOption()
                self.dns_options.append(temp_model.from_map(k))
        if m.get('nameServers') is not None:
            self.name_servers = m.get('nameServers')
        if m.get('searches') is not None:
            self.searches = m.get('searches')
        return self


class CustomHealthCheckConfig(TeaModel):
    def __init__(
        self,
        failure_threshold: int = None,
        http_get_url: str = None,
        initial_delay_seconds: int = None,
        period_seconds: int = None,
        success_threshold: int = None,
        timeout_seconds: int = None,
    ):
        self.failure_threshold = failure_threshold
        self.http_get_url = http_get_url
        self.initial_delay_seconds = initial_delay_seconds
        self.period_seconds = period_seconds
        self.success_threshold = success_threshold
        self.timeout_seconds = timeout_seconds

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failure_threshold is not None:
            result['failureThreshold'] = self.failure_threshold
        if self.http_get_url is not None:
            result['httpGetUrl'] = self.http_get_url
        if self.initial_delay_seconds is not None:
            result['initialDelaySeconds'] = self.initial_delay_seconds
        if self.period_seconds is not None:
            result['periodSeconds'] = self.period_seconds
        if self.success_threshold is not None:
            result['successThreshold'] = self.success_threshold
        if self.timeout_seconds is not None:
            result['timeoutSeconds'] = self.timeout_seconds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('failureThreshold') is not None:
            self.failure_threshold = m.get('failureThreshold')
        if m.get('httpGetUrl') is not None:
            self.http_get_url = m.get('httpGetUrl')
        if m.get('initialDelaySeconds') is not None:
            self.initial_delay_seconds = m.get('initialDelaySeconds')
        if m.get('periodSeconds') is not None:
            self.period_seconds = m.get('periodSeconds')
        if m.get('successThreshold') is not None:
            self.success_threshold = m.get('successThreshold')
        if m.get('timeoutSeconds') is not None:
            self.timeout_seconds = m.get('timeoutSeconds')
        return self


class HostAlias(TeaModel):
    def __init__(
        self,
        hostnames: List[str] = None,
        ip: str = None,
    ):
        self.hostnames = hostnames
        self.ip = ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hostnames is not None:
            result['hostnames'] = self.hostnames
        if self.ip is not None:
            result['ip'] = self.ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('hostnames') is not None:
            self.hostnames = m.get('hostnames')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        return self


class CustomHostAlias(TeaModel):
    def __init__(
        self,
        host_aliases: List[HostAlias] = None,
    ):
        self.host_aliases = host_aliases

    def validate(self):
        if self.host_aliases:
            for k in self.host_aliases:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['hostAliases'] = []
        if self.host_aliases is not None:
            for k in self.host_aliases:
                result['hostAliases'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.host_aliases = []
        if m.get('hostAliases') is not None:
            for k in m.get('hostAliases'):
                temp_model = HostAlias()
                self.host_aliases.append(temp_model.from_map(k))
        return self


class CustomRuntimeConfig(TeaModel):
    def __init__(
        self,
        args: List[str] = None,
        command: List[str] = None,
    ):
        self.args = args
        self.command = command

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.args is not None:
            result['args'] = self.args
        if self.command is not None:
            result['command'] = self.command
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('args') is not None:
            self.args = m.get('args')
        if m.get('command') is not None:
            self.command = m.get('command')
        return self


class HTTPTriggerConfig(TeaModel):
    def __init__(
        self,
        acl_config: AclConfig = None,
        auth_config: Any = None,
        auth_type: str = None,
        disable_urlinternet: bool = None,
        safe_mode: bool = None,
    ):
        self.acl_config = acl_config
        self.auth_config = auth_config
        self.auth_type = auth_type
        self.disable_urlinternet = disable_urlinternet
        self.safe_mode = safe_mode

    def validate(self):
        if self.acl_config:
            self.acl_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acl_config is not None:
            result['aclConfig'] = self.acl_config.to_map()
        if self.auth_config is not None:
            result['authConfig'] = self.auth_config
        if self.auth_type is not None:
            result['authType'] = self.auth_type
        if self.disable_urlinternet is not None:
            result['disableURLInternet'] = self.disable_urlinternet
        if self.safe_mode is not None:
            result['safeMode'] = self.safe_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aclConfig') is not None:
            temp_model = AclConfig()
            self.acl_config = temp_model.from_map(m['aclConfig'])
        if m.get('authConfig') is not None:
            self.auth_config = m.get('authConfig')
        if m.get('authType') is not None:
            self.auth_type = m.get('authType')
        if m.get('disableURLInternet') is not None:
            self.disable_urlinternet = m.get('disableURLInternet')
        if m.get('safeMode') is not None:
            self.safe_mode = m.get('safeMode')
        return self


class RegistryAuthConfig(TeaModel):
    def __init__(
        self,
        password: str = None,
        role: str = None,
        user_name: str = None,
    ):
        self.password = password
        self.role = role
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.password is not None:
            result['password'] = self.password
        if self.role is not None:
            result['role'] = self.role
        if self.user_name is not None:
            result['userName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('password') is not None:
            self.password = m.get('password')
        if m.get('role') is not None:
            self.role = m.get('role')
        if m.get('userName') is not None:
            self.user_name = m.get('userName')
        return self


class RegistryCertConfig(TeaModel):
    def __init__(
        self,
        insecure: bool = None,
        root_ca_cert_base_64: str = None,
    ):
        self.insecure = insecure
        self.root_ca_cert_base_64 = root_ca_cert_base_64

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.insecure is not None:
            result['insecure'] = self.insecure
        if self.root_ca_cert_base_64 is not None:
            result['rootCaCertBase64'] = self.root_ca_cert_base_64
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('insecure') is not None:
            self.insecure = m.get('insecure')
        if m.get('rootCaCertBase64') is not None:
            self.root_ca_cert_base_64 = m.get('rootCaCertBase64')
        return self


class RegistryConfig(TeaModel):
    def __init__(
        self,
        auth_config: RegistryAuthConfig = None,
        cert_config: RegistryCertConfig = None,
    ):
        self.auth_config = auth_config
        self.cert_config = cert_config

    def validate(self):
        if self.auth_config:
            self.auth_config.validate()
        if self.cert_config:
            self.cert_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_config is not None:
            result['authConfig'] = self.auth_config.to_map()
        if self.cert_config is not None:
            result['certConfig'] = self.cert_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('authConfig') is not None:
            temp_model = RegistryAuthConfig()
            self.auth_config = temp_model.from_map(m['authConfig'])
        if m.get('certConfig') is not None:
            temp_model = RegistryCertConfig()
            self.cert_config = temp_model.from_map(m['certConfig'])
        return self


class ImageConfig(TeaModel):
    def __init__(
        self,
        acceleration_type: str = None,
        image: str = None,
        instance_id: str = None,
        registry_config: RegistryConfig = None,
    ):
        self.acceleration_type = acceleration_type
        self.image = image
        self.instance_id = instance_id
        self.registry_config = registry_config

    def validate(self):
        if self.registry_config:
            self.registry_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acceleration_type is not None:
            result['accelerationType'] = self.acceleration_type
        if self.image is not None:
            result['image'] = self.image
        if self.instance_id is not None:
            result['instanceID'] = self.instance_id
        if self.registry_config is not None:
            result['registryConfig'] = self.registry_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accelerationType') is not None:
            self.acceleration_type = m.get('accelerationType')
        if m.get('image') is not None:
            self.image = m.get('image')
        if m.get('instanceID') is not None:
            self.instance_id = m.get('instanceID')
        if m.get('registryConfig') is not None:
            temp_model = RegistryConfig()
            self.registry_config = temp_model.from_map(m['registryConfig'])
        return self


class LifecycleHook(TeaModel):
    def __init__(
        self,
        handler: str = None,
        timeout: int = None,
    ):
        self.handler = handler
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.handler is not None:
            result['handler'] = self.handler
        if self.timeout is not None:
            result['timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('handler') is not None:
            self.handler = m.get('handler')
        if m.get('timeout') is not None:
            self.timeout = m.get('timeout')
        return self


class InstanceLifecycleConfig(TeaModel):
    def __init__(
        self,
        pre_freeze: LifecycleHook = None,
        pre_stop: LifecycleHook = None,
    ):
        self.pre_freeze = pre_freeze
        self.pre_stop = pre_stop

    def validate(self):
        if self.pre_freeze:
            self.pre_freeze.validate()
        if self.pre_stop:
            self.pre_stop.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pre_freeze is not None:
            result['preFreeze'] = self.pre_freeze.to_map()
        if self.pre_stop is not None:
            result['preStop'] = self.pre_stop.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('preFreeze') is not None:
            temp_model = LifecycleHook()
            self.pre_freeze = temp_model.from_map(m['preFreeze'])
        if m.get('preStop') is not None:
            temp_model = LifecycleHook()
            self.pre_stop = temp_model.from_map(m['preStop'])
        return self


class ProbeProbeHandlerHttpGetHttpHeaders(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        self.name = name
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ProbeProbeHandlerHttpGet(TeaModel):
    def __init__(
        self,
        http_headers: List[ProbeProbeHandlerHttpGetHttpHeaders] = None,
        path: str = None,
        port: int = None,
    ):
        self.http_headers = http_headers
        self.path = path
        self.port = port

    def validate(self):
        if self.http_headers:
            for k in self.http_headers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['httpHeaders'] = []
        if self.http_headers is not None:
            for k in self.http_headers:
                result['httpHeaders'].append(k.to_map() if k else None)
        if self.path is not None:
            result['path'] = self.path
        if self.port is not None:
            result['port'] = self.port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.http_headers = []
        if m.get('httpHeaders') is not None:
            for k in m.get('httpHeaders'):
                temp_model = ProbeProbeHandlerHttpGetHttpHeaders()
                self.http_headers.append(temp_model.from_map(k))
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('port') is not None:
            self.port = m.get('port')
        return self


class ProbeProbeHandlerTcpSocket(TeaModel):
    def __init__(
        self,
        port: int = None,
    ):
        self.port = port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.port is not None:
            result['port'] = self.port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('port') is not None:
            self.port = m.get('port')
        return self


class ProbeProbeHandler(TeaModel):
    def __init__(
        self,
        http_get: ProbeProbeHandlerHttpGet = None,
        tcp_socket: ProbeProbeHandlerTcpSocket = None,
    ):
        self.http_get = http_get
        self.tcp_socket = tcp_socket

    def validate(self):
        if self.http_get:
            self.http_get.validate()
        if self.tcp_socket:
            self.tcp_socket.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.http_get is not None:
            result['httpGet'] = self.http_get.to_map()
        if self.tcp_socket is not None:
            result['tcpSocket'] = self.tcp_socket.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpGet') is not None:
            temp_model = ProbeProbeHandlerHttpGet()
            self.http_get = temp_model.from_map(m['httpGet'])
        if m.get('tcpSocket') is not None:
            temp_model = ProbeProbeHandlerTcpSocket()
            self.tcp_socket = temp_model.from_map(m['tcpSocket'])
        return self


class Probe(TeaModel):
    def __init__(
        self,
        failure_threshold: int = None,
        initial_delay_seconds: int = None,
        period_seconds: int = None,
        probe_handler: ProbeProbeHandler = None,
        timeout_seconds: int = None,
    ):
        self.failure_threshold = failure_threshold
        self.initial_delay_seconds = initial_delay_seconds
        self.period_seconds = period_seconds
        self.probe_handler = probe_handler
        self.timeout_seconds = timeout_seconds

    def validate(self):
        if self.probe_handler:
            self.probe_handler.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failure_threshold is not None:
            result['failureThreshold'] = self.failure_threshold
        if self.initial_delay_seconds is not None:
            result['initialDelaySeconds'] = self.initial_delay_seconds
        if self.period_seconds is not None:
            result['periodSeconds'] = self.period_seconds
        if self.probe_handler is not None:
            result['probeHandler'] = self.probe_handler.to_map()
        if self.timeout_seconds is not None:
            result['timeoutSeconds'] = self.timeout_seconds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('failureThreshold') is not None:
            self.failure_threshold = m.get('failureThreshold')
        if m.get('initialDelaySeconds') is not None:
            self.initial_delay_seconds = m.get('initialDelaySeconds')
        if m.get('periodSeconds') is not None:
            self.period_seconds = m.get('periodSeconds')
        if m.get('probeHandler') is not None:
            temp_model = ProbeProbeHandler()
            self.probe_handler = temp_model.from_map(m['probeHandler'])
        if m.get('timeoutSeconds') is not None:
            self.timeout_seconds = m.get('timeoutSeconds')
        return self


class LogConfig(TeaModel):
    def __init__(
        self,
        enable_instance_metrics: bool = None,
        enable_request_metrics: bool = None,
        log_begin_rule: str = None,
        logstore: str = None,
        project: str = None,
        push_to_user_sls: bool = None,
    ):
        self.enable_instance_metrics = enable_instance_metrics
        self.enable_request_metrics = enable_request_metrics
        self.log_begin_rule = log_begin_rule
        self.logstore = logstore
        self.project = project
        self.push_to_user_sls = push_to_user_sls

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_instance_metrics is not None:
            result['enableInstanceMetrics'] = self.enable_instance_metrics
        if self.enable_request_metrics is not None:
            result['enableRequestMetrics'] = self.enable_request_metrics
        if self.log_begin_rule is not None:
            result['logBeginRule'] = self.log_begin_rule
        if self.logstore is not None:
            result['logstore'] = self.logstore
        if self.project is not None:
            result['project'] = self.project
        if self.push_to_user_sls is not None:
            result['pushToUserSLS'] = self.push_to_user_sls
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enableInstanceMetrics') is not None:
            self.enable_instance_metrics = m.get('enableInstanceMetrics')
        if m.get('enableRequestMetrics') is not None:
            self.enable_request_metrics = m.get('enableRequestMetrics')
        if m.get('logBeginRule') is not None:
            self.log_begin_rule = m.get('logBeginRule')
        if m.get('logstore') is not None:
            self.logstore = m.get('logstore')
        if m.get('project') is not None:
            self.project = m.get('project')
        if m.get('pushToUserSLS') is not None:
            self.push_to_user_sls = m.get('pushToUserSLS')
        return self


class NASMountConfig(TeaModel):
    def __init__(
        self,
        enable_tls: bool = None,
        mount_dir: str = None,
        server_addr: str = None,
    ):
        self.enable_tls = enable_tls
        self.mount_dir = mount_dir
        self.server_addr = server_addr

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_tls is not None:
            result['enableTLS'] = self.enable_tls
        if self.mount_dir is not None:
            result['mountDir'] = self.mount_dir
        if self.server_addr is not None:
            result['serverAddr'] = self.server_addr
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enableTLS') is not None:
            self.enable_tls = m.get('enableTLS')
        if m.get('mountDir') is not None:
            self.mount_dir = m.get('mountDir')
        if m.get('serverAddr') is not None:
            self.server_addr = m.get('serverAddr')
        return self


class NASConfig(TeaModel):
    def __init__(
        self,
        mount_points: List[NASMountConfig] = None,
    ):
        self.mount_points = mount_points

    def validate(self):
        if self.mount_points:
            for k in self.mount_points:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['mountPoints'] = []
        if self.mount_points is not None:
            for k in self.mount_points:
                result['mountPoints'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.mount_points = []
        if m.get('mountPoints') is not None:
            for k in m.get('mountPoints'):
                temp_model = NASMountConfig()
                self.mount_points.append(temp_model.from_map(k))
        return self


class OSSMountPoint(TeaModel):
    def __init__(
        self,
        bucket_name: str = None,
        bucket_path: str = None,
        mount_dir: str = None,
        read_only: bool = None,
    ):
        self.bucket_name = bucket_name
        self.bucket_path = bucket_path
        self.mount_dir = mount_dir
        self.read_only = read_only

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['bucketName'] = self.bucket_name
        if self.bucket_path is not None:
            result['bucketPath'] = self.bucket_path
        if self.mount_dir is not None:
            result['mountDir'] = self.mount_dir
        if self.read_only is not None:
            result['readOnly'] = self.read_only
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bucketName') is not None:
            self.bucket_name = m.get('bucketName')
        if m.get('bucketPath') is not None:
            self.bucket_path = m.get('bucketPath')
        if m.get('mountDir') is not None:
            self.mount_dir = m.get('mountDir')
        if m.get('readOnly') is not None:
            self.read_only = m.get('readOnly')
        return self


class OSSMountConfig(TeaModel):
    def __init__(
        self,
        mount_points: List[OSSMountPoint] = None,
    ):
        self.mount_points = mount_points

    def validate(self):
        if self.mount_points:
            for k in self.mount_points:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['mountPoints'] = []
        if self.mount_points is not None:
            for k in self.mount_points:
                result['mountPoints'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.mount_points = []
        if m.get('mountPoints') is not None:
            for k in m.get('mountPoints'):
                temp_model = OSSMountPoint()
                self.mount_points.append(temp_model.from_map(k))
        return self


class ScaleConfig(TeaModel):
    def __init__(
        self,
        always_allocate_cpu: bool = None,
        maximum_instance_count: int = None,
        minimum_instance_count: int = None,
        request_id: str = None,
    ):
        self.always_allocate_cpu = always_allocate_cpu
        self.maximum_instance_count = maximum_instance_count
        self.minimum_instance_count = minimum_instance_count
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.always_allocate_cpu is not None:
            result['alwaysAllocateCPU'] = self.always_allocate_cpu
        if self.maximum_instance_count is not None:
            result['maximumInstanceCount'] = self.maximum_instance_count
        if self.minimum_instance_count is not None:
            result['minimumInstanceCount'] = self.minimum_instance_count
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alwaysAllocateCPU') is not None:
            self.always_allocate_cpu = m.get('alwaysAllocateCPU')
        if m.get('maximumInstanceCount') is not None:
            self.maximum_instance_count = m.get('maximumInstanceCount')
        if m.get('minimumInstanceCount') is not None:
            self.minimum_instance_count = m.get('minimumInstanceCount')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class SLSConfigCollectConfigs(TeaModel):
    def __init__(
        self,
        log_path: str = None,
        log_type: str = None,
        logstore_name: str = None,
        logtail_name: str = None,
        project_name: str = None,
    ):
        self.log_path = log_path
        self.log_type = log_type
        self.logstore_name = logstore_name
        self.logtail_name = logtail_name
        self.project_name = project_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.log_path is not None:
            result['logPath'] = self.log_path
        if self.log_type is not None:
            result['logType'] = self.log_type
        if self.logstore_name is not None:
            result['logstoreName'] = self.logstore_name
        if self.logtail_name is not None:
            result['logtailName'] = self.logtail_name
        if self.project_name is not None:
            result['projectName'] = self.project_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('logPath') is not None:
            self.log_path = m.get('logPath')
        if m.get('logType') is not None:
            self.log_type = m.get('logType')
        if m.get('logstoreName') is not None:
            self.logstore_name = m.get('logstoreName')
        if m.get('logtailName') is not None:
            self.logtail_name = m.get('logtailName')
        if m.get('projectName') is not None:
            self.project_name = m.get('projectName')
        return self


class SLSConfig(TeaModel):
    def __init__(
        self,
        collect_configs: List[SLSConfigCollectConfigs] = None,
    ):
        self.collect_configs = collect_configs

    def validate(self):
        if self.collect_configs:
            for k in self.collect_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['collectConfigs'] = []
        if self.collect_configs is not None:
            for k in self.collect_configs:
                result['collectConfigs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.collect_configs = []
        if m.get('collectConfigs') is not None:
            for k in m.get('collectConfigs'):
                temp_model = SLSConfigCollectConfigs()
                self.collect_configs.append(temp_model.from_map(k))
        return self


class JaegerConfig(TeaModel):
    def __init__(
        self,
        endpoint: str = None,
    ):
        self.endpoint = endpoint

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.endpoint is not None:
            result['endpoint'] = self.endpoint
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endpoint') is not None:
            self.endpoint = m.get('endpoint')
        return self


class TracingConfig(TeaModel):
    def __init__(
        self,
        jaeger_config: JaegerConfig = None,
        params: Any = None,
        type: str = None,
    ):
        self.jaeger_config = jaeger_config
        self.params = params
        self.type = type

    def validate(self):
        if self.jaeger_config:
            self.jaeger_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.jaeger_config is not None:
            result['jaegerConfig'] = self.jaeger_config.to_map()
        if self.params is not None:
            result['params'] = self.params
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('jaegerConfig') is not None:
            temp_model = JaegerConfig()
            self.jaeger_config = temp_model.from_map(m['jaegerConfig'])
        if m.get('params') is not None:
            self.params = m.get('params')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class Version(TeaModel):
    def __init__(
        self,
        created_time: str = None,
        description: str = None,
        image: str = None,
        last_modified_time: str = None,
        request_id: str = None,
        version_id: str = None,
        weight: float = None,
    ):
        self.created_time = created_time
        self.description = description
        self.image = image
        self.last_modified_time = last_modified_time
        self.request_id = request_id
        self.version_id = version_id
        self.weight = weight

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_time is not None:
            result['createdTime'] = self.created_time
        if self.description is not None:
            result['description'] = self.description
        if self.image is not None:
            result['image'] = self.image
        if self.last_modified_time is not None:
            result['lastModifiedTime'] = self.last_modified_time
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.version_id is not None:
            result['versionId'] = self.version_id
        if self.weight is not None:
            result['weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createdTime') is not None:
            self.created_time = m.get('createdTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('image') is not None:
            self.image = m.get('image')
        if m.get('lastModifiedTime') is not None:
            self.last_modified_time = m.get('lastModifiedTime')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('versionId') is not None:
            self.version_id = m.get('versionId')
        if m.get('weight') is not None:
            self.weight = m.get('weight')
        return self


class VPCConfig(TeaModel):
    def __init__(
        self,
        anytunnel_via_eni: bool = None,
        role: str = None,
        security_group_id: str = None,
        v_switch_ids: List[str] = None,
        vpc_id: str = None,
    ):
        self.anytunnel_via_eni = anytunnel_via_eni
        self.role = role
        self.security_group_id = security_group_id
        self.v_switch_ids = v_switch_ids
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.anytunnel_via_eni is not None:
            result['anytunnelViaENI'] = self.anytunnel_via_eni
        if self.role is not None:
            result['role'] = self.role
        if self.security_group_id is not None:
            result['securityGroupId'] = self.security_group_id
        if self.v_switch_ids is not None:
            result['vSwitchIds'] = self.v_switch_ids
        if self.vpc_id is not None:
            result['vpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('anytunnelViaENI') is not None:
            self.anytunnel_via_eni = m.get('anytunnelViaENI')
        if m.get('role') is not None:
            self.role = m.get('role')
        if m.get('securityGroupId') is not None:
            self.security_group_id = m.get('securityGroupId')
        if m.get('vSwitchIds') is not None:
            self.v_switch_ids = m.get('vSwitchIds')
        if m.get('vpcId') is not None:
            self.vpc_id = m.get('vpcId')
        return self


class Application(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        application_id: str = None,
        application_name: str = None,
        args: str = None,
        ca_port: int = None,
        code_checksum: str = None,
        code_size: int = None,
        command: str = None,
        cpu: float = None,
        created_time: str = None,
        custom_dns: CustomDNS = None,
        custom_domain_name: str = None,
        custom_health_check_config: CustomHealthCheckConfig = None,
        custom_host_alias: CustomHostAlias = None,
        custom_runtime_config: CustomRuntimeConfig = None,
        description: str = None,
        disk_size: int = None,
        enable_app_metric: bool = None,
        enable_arms_advanced: bool = None,
        environment_variables: Dict[str, str] = None,
        gpu_memory_size: int = None,
        handler: str = None,
        http_trigger_config: HTTPTriggerConfig = None,
        image_config: ImageConfig = None,
        initialization_timeout: int = None,
        initializer: str = None,
        instance_concurrency: int = None,
        instance_lifecycle_config: InstanceLifecycleConfig = None,
        instance_soft_concurrency: int = None,
        instance_type: str = None,
        internet_access: bool = None,
        last_modified_time: str = None,
        layers: List[str] = None,
        layers_arn_v2: List[str] = None,
        liveness_probe: Probe = None,
        log_config: LogConfig = None,
        memory_size: int = None,
        namespace: str = None,
        namespace_id: str = None,
        namespace_name: str = None,
        nas_config: NASConfig = None,
        oss_mount_config: OSSMountConfig = None,
        programming_language: str = None,
        runtime: str = None,
        scale_config: ScaleConfig = None,
        sls_config: SLSConfig = None,
        startup_probe: Probe = None,
        timeout: int = None,
        tracing_config: TracingConfig = None,
        url_internet: str = None,
        url_intranet: str = None,
        version: Version = None,
        vpc_config: VPCConfig = None,
    ):
        self.request_id = request_id
        self.application_id = application_id
        self.application_name = application_name
        self.args = args
        self.ca_port = ca_port
        self.code_checksum = code_checksum
        self.code_size = code_size
        self.command = command
        self.cpu = cpu
        self.created_time = created_time
        self.custom_dns = custom_dns
        self.custom_domain_name = custom_domain_name
        self.custom_health_check_config = custom_health_check_config
        self.custom_host_alias = custom_host_alias
        self.custom_runtime_config = custom_runtime_config
        self.description = description
        self.disk_size = disk_size
        self.enable_app_metric = enable_app_metric
        self.enable_arms_advanced = enable_arms_advanced
        self.environment_variables = environment_variables
        self.gpu_memory_size = gpu_memory_size
        self.handler = handler
        self.http_trigger_config = http_trigger_config
        self.image_config = image_config
        self.initialization_timeout = initialization_timeout
        self.initializer = initializer
        self.instance_concurrency = instance_concurrency
        self.instance_lifecycle_config = instance_lifecycle_config
        self.instance_soft_concurrency = instance_soft_concurrency
        self.instance_type = instance_type
        self.internet_access = internet_access
        self.last_modified_time = last_modified_time
        self.layers = layers
        self.layers_arn_v2 = layers_arn_v2
        self.liveness_probe = liveness_probe
        self.log_config = log_config
        self.memory_size = memory_size
        self.namespace = namespace
        self.namespace_id = namespace_id
        self.namespace_name = namespace_name
        self.nas_config = nas_config
        self.oss_mount_config = oss_mount_config
        self.programming_language = programming_language
        self.runtime = runtime
        self.scale_config = scale_config
        self.sls_config = sls_config
        self.startup_probe = startup_probe
        self.timeout = timeout
        self.tracing_config = tracing_config
        self.url_internet = url_internet
        self.url_intranet = url_intranet
        self.version = version
        self.vpc_config = vpc_config

    def validate(self):
        if self.custom_dns:
            self.custom_dns.validate()
        if self.custom_health_check_config:
            self.custom_health_check_config.validate()
        if self.custom_host_alias:
            self.custom_host_alias.validate()
        if self.custom_runtime_config:
            self.custom_runtime_config.validate()
        if self.http_trigger_config:
            self.http_trigger_config.validate()
        if self.image_config:
            self.image_config.validate()
        if self.instance_lifecycle_config:
            self.instance_lifecycle_config.validate()
        if self.liveness_probe:
            self.liveness_probe.validate()
        if self.log_config:
            self.log_config.validate()
        if self.nas_config:
            self.nas_config.validate()
        if self.oss_mount_config:
            self.oss_mount_config.validate()
        if self.scale_config:
            self.scale_config.validate()
        if self.sls_config:
            self.sls_config.validate()
        if self.startup_probe:
            self.startup_probe.validate()
        if self.tracing_config:
            self.tracing_config.validate()
        if self.version:
            self.version.validate()
        if self.vpc_config:
            self.vpc_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.application_id is not None:
            result['applicationId'] = self.application_id
        if self.application_name is not None:
            result['applicationName'] = self.application_name
        if self.args is not None:
            result['args'] = self.args
        if self.ca_port is not None:
            result['caPort'] = self.ca_port
        if self.code_checksum is not None:
            result['codeChecksum'] = self.code_checksum
        if self.code_size is not None:
            result['codeSize'] = self.code_size
        if self.command is not None:
            result['command'] = self.command
        if self.cpu is not None:
            result['cpu'] = self.cpu
        if self.created_time is not None:
            result['createdTime'] = self.created_time
        if self.custom_dns is not None:
            result['customDNS'] = self.custom_dns.to_map()
        if self.custom_domain_name is not None:
            result['customDomainName'] = self.custom_domain_name
        if self.custom_health_check_config is not None:
            result['customHealthCheckConfig'] = self.custom_health_check_config.to_map()
        if self.custom_host_alias is not None:
            result['customHostAlias'] = self.custom_host_alias.to_map()
        if self.custom_runtime_config is not None:
            result['customRuntimeConfig'] = self.custom_runtime_config.to_map()
        if self.description is not None:
            result['description'] = self.description
        if self.disk_size is not None:
            result['diskSize'] = self.disk_size
        if self.enable_app_metric is not None:
            result['enableAppMetric'] = self.enable_app_metric
        if self.enable_arms_advanced is not None:
            result['enableArmsAdvanced'] = self.enable_arms_advanced
        if self.environment_variables is not None:
            result['environmentVariables'] = self.environment_variables
        if self.gpu_memory_size is not None:
            result['gpuMemorySize'] = self.gpu_memory_size
        if self.handler is not None:
            result['handler'] = self.handler
        if self.http_trigger_config is not None:
            result['httpTriggerConfig'] = self.http_trigger_config.to_map()
        if self.image_config is not None:
            result['imageConfig'] = self.image_config.to_map()
        if self.initialization_timeout is not None:
            result['initializationTimeout'] = self.initialization_timeout
        if self.initializer is not None:
            result['initializer'] = self.initializer
        if self.instance_concurrency is not None:
            result['instanceConcurrency'] = self.instance_concurrency
        if self.instance_lifecycle_config is not None:
            result['instanceLifecycleConfig'] = self.instance_lifecycle_config.to_map()
        if self.instance_soft_concurrency is not None:
            result['instanceSoftConcurrency'] = self.instance_soft_concurrency
        if self.instance_type is not None:
            result['instanceType'] = self.instance_type
        if self.internet_access is not None:
            result['internetAccess'] = self.internet_access
        if self.last_modified_time is not None:
            result['lastModifiedTime'] = self.last_modified_time
        if self.layers is not None:
            result['layers'] = self.layers
        if self.layers_arn_v2 is not None:
            result['layersArnV2'] = self.layers_arn_v2
        if self.liveness_probe is not None:
            result['livenessProbe'] = self.liveness_probe.to_map()
        if self.log_config is not None:
            result['logConfig'] = self.log_config.to_map()
        if self.memory_size is not None:
            result['memorySize'] = self.memory_size
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.namespace_id is not None:
            result['namespaceID'] = self.namespace_id
        if self.namespace_name is not None:
            result['namespaceName'] = self.namespace_name
        if self.nas_config is not None:
            result['nasConfig'] = self.nas_config.to_map()
        if self.oss_mount_config is not None:
            result['ossMountConfig'] = self.oss_mount_config.to_map()
        if self.programming_language is not None:
            result['programmingLanguage'] = self.programming_language
        if self.runtime is not None:
            result['runtime'] = self.runtime
        if self.scale_config is not None:
            result['scaleConfig'] = self.scale_config.to_map()
        if self.sls_config is not None:
            result['slsConfig'] = self.sls_config.to_map()
        if self.startup_probe is not None:
            result['startupProbe'] = self.startup_probe.to_map()
        if self.timeout is not None:
            result['timeout'] = self.timeout
        if self.tracing_config is not None:
            result['tracingConfig'] = self.tracing_config.to_map()
        if self.url_internet is not None:
            result['urlInternet'] = self.url_internet
        if self.url_intranet is not None:
            result['urlIntranet'] = self.url_intranet
        if self.version is not None:
            result['version'] = self.version.to_map()
        if self.vpc_config is not None:
            result['vpcConfig'] = self.vpc_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('applicationId') is not None:
            self.application_id = m.get('applicationId')
        if m.get('applicationName') is not None:
            self.application_name = m.get('applicationName')
        if m.get('args') is not None:
            self.args = m.get('args')
        if m.get('caPort') is not None:
            self.ca_port = m.get('caPort')
        if m.get('codeChecksum') is not None:
            self.code_checksum = m.get('codeChecksum')
        if m.get('codeSize') is not None:
            self.code_size = m.get('codeSize')
        if m.get('command') is not None:
            self.command = m.get('command')
        if m.get('cpu') is not None:
            self.cpu = m.get('cpu')
        if m.get('createdTime') is not None:
            self.created_time = m.get('createdTime')
        if m.get('customDNS') is not None:
            temp_model = CustomDNS()
            self.custom_dns = temp_model.from_map(m['customDNS'])
        if m.get('customDomainName') is not None:
            self.custom_domain_name = m.get('customDomainName')
        if m.get('customHealthCheckConfig') is not None:
            temp_model = CustomHealthCheckConfig()
            self.custom_health_check_config = temp_model.from_map(m['customHealthCheckConfig'])
        if m.get('customHostAlias') is not None:
            temp_model = CustomHostAlias()
            self.custom_host_alias = temp_model.from_map(m['customHostAlias'])
        if m.get('customRuntimeConfig') is not None:
            temp_model = CustomRuntimeConfig()
            self.custom_runtime_config = temp_model.from_map(m['customRuntimeConfig'])
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('diskSize') is not None:
            self.disk_size = m.get('diskSize')
        if m.get('enableAppMetric') is not None:
            self.enable_app_metric = m.get('enableAppMetric')
        if m.get('enableArmsAdvanced') is not None:
            self.enable_arms_advanced = m.get('enableArmsAdvanced')
        if m.get('environmentVariables') is not None:
            self.environment_variables = m.get('environmentVariables')
        if m.get('gpuMemorySize') is not None:
            self.gpu_memory_size = m.get('gpuMemorySize')
        if m.get('handler') is not None:
            self.handler = m.get('handler')
        if m.get('httpTriggerConfig') is not None:
            temp_model = HTTPTriggerConfig()
            self.http_trigger_config = temp_model.from_map(m['httpTriggerConfig'])
        if m.get('imageConfig') is not None:
            temp_model = ImageConfig()
            self.image_config = temp_model.from_map(m['imageConfig'])
        if m.get('initializationTimeout') is not None:
            self.initialization_timeout = m.get('initializationTimeout')
        if m.get('initializer') is not None:
            self.initializer = m.get('initializer')
        if m.get('instanceConcurrency') is not None:
            self.instance_concurrency = m.get('instanceConcurrency')
        if m.get('instanceLifecycleConfig') is not None:
            temp_model = InstanceLifecycleConfig()
            self.instance_lifecycle_config = temp_model.from_map(m['instanceLifecycleConfig'])
        if m.get('instanceSoftConcurrency') is not None:
            self.instance_soft_concurrency = m.get('instanceSoftConcurrency')
        if m.get('instanceType') is not None:
            self.instance_type = m.get('instanceType')
        if m.get('internetAccess') is not None:
            self.internet_access = m.get('internetAccess')
        if m.get('lastModifiedTime') is not None:
            self.last_modified_time = m.get('lastModifiedTime')
        if m.get('layers') is not None:
            self.layers = m.get('layers')
        if m.get('layersArnV2') is not None:
            self.layers_arn_v2 = m.get('layersArnV2')
        if m.get('livenessProbe') is not None:
            temp_model = Probe()
            self.liveness_probe = temp_model.from_map(m['livenessProbe'])
        if m.get('logConfig') is not None:
            temp_model = LogConfig()
            self.log_config = temp_model.from_map(m['logConfig'])
        if m.get('memorySize') is not None:
            self.memory_size = m.get('memorySize')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('namespaceID') is not None:
            self.namespace_id = m.get('namespaceID')
        if m.get('namespaceName') is not None:
            self.namespace_name = m.get('namespaceName')
        if m.get('nasConfig') is not None:
            temp_model = NASConfig()
            self.nas_config = temp_model.from_map(m['nasConfig'])
        if m.get('ossMountConfig') is not None:
            temp_model = OSSMountConfig()
            self.oss_mount_config = temp_model.from_map(m['ossMountConfig'])
        if m.get('programmingLanguage') is not None:
            self.programming_language = m.get('programmingLanguage')
        if m.get('runtime') is not None:
            self.runtime = m.get('runtime')
        if m.get('scaleConfig') is not None:
            temp_model = ScaleConfig()
            self.scale_config = temp_model.from_map(m['scaleConfig'])
        if m.get('slsConfig') is not None:
            temp_model = SLSConfig()
            self.sls_config = temp_model.from_map(m['slsConfig'])
        if m.get('startupProbe') is not None:
            temp_model = Probe()
            self.startup_probe = temp_model.from_map(m['startupProbe'])
        if m.get('timeout') is not None:
            self.timeout = m.get('timeout')
        if m.get('tracingConfig') is not None:
            temp_model = TracingConfig()
            self.tracing_config = temp_model.from_map(m['tracingConfig'])
        if m.get('urlInternet') is not None:
            self.url_internet = m.get('urlInternet')
        if m.get('urlIntranet') is not None:
            self.url_intranet = m.get('urlIntranet')
        if m.get('version') is not None:
            temp_model = Version()
            self.version = temp_model.from_map(m['version'])
        if m.get('vpcConfig') is not None:
            temp_model = VPCConfig()
            self.vpc_config = temp_model.from_map(m['vpcConfig'])
        return self


class ApplicationStatus(TeaModel):
    def __init__(
        self,
        instance_count: int = None,
        scale_config: ScaleConfig = None,
    ):
        self.instance_count = instance_count
        self.scale_config = scale_config

    def validate(self):
        if self.scale_config:
            self.scale_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_count is not None:
            result['instanceCount'] = self.instance_count
        if self.scale_config is not None:
            result['scaleConfig'] = self.scale_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('instanceCount') is not None:
            self.instance_count = m.get('instanceCount')
        if m.get('scaleConfig') is not None:
            temp_model = ScaleConfig()
            self.scale_config = temp_model.from_map(m['scaleConfig'])
        return self


class ApplicationWithStatus(TeaModel):
    def __init__(
        self,
        application: Application = None,
        status: ApplicationStatus = None,
    ):
        self.application = application
        self.status = status

    def validate(self):
        if self.application:
            self.application.validate()
        if self.status:
            self.status.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application is not None:
            result['application'] = self.application.to_map()
        if self.status is not None:
            result['status'] = self.status.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('application') is not None:
            temp_model = Application()
            self.application = temp_model.from_map(m['application'])
        if m.get('status') is not None:
            temp_model = ApplicationStatus()
            self.status = temp_model.from_map(m['status'])
        return self


class ArmsConfig(TeaModel):
    def __init__(
        self,
        agent_version: str = None,
        app_id: str = None,
        license_key: str = None,
    ):
        self.agent_version = agent_version
        self.app_id = app_id
        self.license_key = license_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_version is not None:
            result['agentVersion'] = self.agent_version
        if self.app_id is not None:
            result['appId'] = self.app_id
        if self.license_key is not None:
            result['licenseKey'] = self.license_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('agentVersion') is not None:
            self.agent_version = m.get('agentVersion')
        if m.get('appId') is not None:
            self.app_id = m.get('appId')
        if m.get('licenseKey') is not None:
            self.license_key = m.get('licenseKey')
        return self


class TomcatConfig(TeaModel):
    def __init__(
        self,
        context_path: str = None,
        max_threads: int = None,
        port: int = None,
        uri_encoding: str = None,
        use_body_encoding_for_uri: bool = None,
        version: str = None,
    ):
        self.context_path = context_path
        self.max_threads = max_threads
        self.port = port
        self.uri_encoding = uri_encoding
        self.use_body_encoding_for_uri = use_body_encoding_for_uri
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.context_path is not None:
            result['ContextPath'] = self.context_path
        if self.max_threads is not None:
            result['MaxThreads'] = self.max_threads
        if self.port is not None:
            result['Port'] = self.port
        if self.uri_encoding is not None:
            result['UriEncoding'] = self.uri_encoding
        if self.use_body_encoding_for_uri is not None:
            result['UseBodyEncodingForUri'] = self.use_body_encoding_for_uri
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContextPath') is not None:
            self.context_path = m.get('ContextPath')
        if m.get('MaxThreads') is not None:
            self.max_threads = m.get('MaxThreads')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('UriEncoding') is not None:
            self.uri_encoding = m.get('UriEncoding')
        if m.get('UseBodyEncodingForUri') is not None:
            self.use_body_encoding_for_uri = m.get('UseBodyEncodingForUri')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class BuildPipelineBuildConfig(TeaModel):
    def __init__(
        self,
        before_build_command: str = None,
        build_type: str = None,
        dockerfile_path: str = None,
        run_command: str = None,
        runtime_type: str = None,
        runtime_version: str = None,
        tomcat_config: TomcatConfig = None,
        working_dir: str = None,
    ):
        self.before_build_command = before_build_command
        # This parameter is required.
        self.build_type = build_type
        self.dockerfile_path = dockerfile_path
        self.run_command = run_command
        self.runtime_type = runtime_type
        self.runtime_version = runtime_version
        self.tomcat_config = tomcat_config
        self.working_dir = working_dir

    def validate(self):
        if self.tomcat_config:
            self.tomcat_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.before_build_command is not None:
            result['BeforeBuildCommand'] = self.before_build_command
        if self.build_type is not None:
            result['BuildType'] = self.build_type
        if self.dockerfile_path is not None:
            result['DockerfilePath'] = self.dockerfile_path
        if self.run_command is not None:
            result['RunCommand'] = self.run_command
        if self.runtime_type is not None:
            result['RuntimeType'] = self.runtime_type
        if self.runtime_version is not None:
            result['RuntimeVersion'] = self.runtime_version
        if self.tomcat_config is not None:
            result['TomcatConfig'] = self.tomcat_config.to_map()
        if self.working_dir is not None:
            result['WorkingDir'] = self.working_dir
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BeforeBuildCommand') is not None:
            self.before_build_command = m.get('BeforeBuildCommand')
        if m.get('BuildType') is not None:
            self.build_type = m.get('BuildType')
        if m.get('DockerfilePath') is not None:
            self.dockerfile_path = m.get('DockerfilePath')
        if m.get('RunCommand') is not None:
            self.run_command = m.get('RunCommand')
        if m.get('RuntimeType') is not None:
            self.runtime_type = m.get('RuntimeType')
        if m.get('RuntimeVersion') is not None:
            self.runtime_version = m.get('RuntimeVersion')
        if m.get('TomcatConfig') is not None:
            temp_model = TomcatConfig()
            self.tomcat_config = temp_model.from_map(m['TomcatConfig'])
        if m.get('WorkingDir') is not None:
            self.working_dir = m.get('WorkingDir')
        return self


class BuildPipelineCodeConfig(TeaModel):
    def __init__(
        self,
        account_id: str = None,
        branch_name: str = None,
        commit_id: str = None,
        commit_url: str = None,
        organization_id: str = None,
        provider: str = None,
        repo_full_name: str = None,
        repo_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id
        # This parameter is required.
        self.branch_name = branch_name
        self.commit_id = commit_id
        self.commit_url = commit_url
        self.organization_id = organization_id
        # This parameter is required.
        self.provider = provider
        # This parameter is required.
        self.repo_full_name = repo_full_name
        # This parameter is required.
        self.repo_id = repo_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['AccountId'] = self.account_id
        if self.branch_name is not None:
            result['BranchName'] = self.branch_name
        if self.commit_id is not None:
            result['CommitId'] = self.commit_id
        if self.commit_url is not None:
            result['CommitUrl'] = self.commit_url
        if self.organization_id is not None:
            result['OrganizationId'] = self.organization_id
        if self.provider is not None:
            result['Provider'] = self.provider
        if self.repo_full_name is not None:
            result['RepoFullName'] = self.repo_full_name
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccountId') is not None:
            self.account_id = m.get('AccountId')
        if m.get('BranchName') is not None:
            self.branch_name = m.get('BranchName')
        if m.get('CommitId') is not None:
            self.commit_id = m.get('CommitId')
        if m.get('CommitUrl') is not None:
            self.commit_url = m.get('CommitUrl')
        if m.get('OrganizationId') is not None:
            self.organization_id = m.get('OrganizationId')
        if m.get('Provider') is not None:
            self.provider = m.get('Provider')
        if m.get('RepoFullName') is not None:
            self.repo_full_name = m.get('RepoFullName')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        return self


class BuildPipelineDeployConfig(TeaModel):
    def __init__(
        self,
        always_allocate_cpu: bool = None,
        maximum_instance_count: int = None,
        minimum_instance_count: int = None,
        update_application_input: str = None,
        update_traffic: bool = None,
    ):
        self.always_allocate_cpu = always_allocate_cpu
        self.maximum_instance_count = maximum_instance_count
        self.minimum_instance_count = minimum_instance_count
        self.update_application_input = update_application_input
        self.update_traffic = update_traffic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.always_allocate_cpu is not None:
            result['AlwaysAllocateCPU'] = self.always_allocate_cpu
        if self.maximum_instance_count is not None:
            result['MaximumInstanceCount'] = self.maximum_instance_count
        if self.minimum_instance_count is not None:
            result['MinimumInstanceCount'] = self.minimum_instance_count
        if self.update_application_input is not None:
            result['UpdateApplicationInput'] = self.update_application_input
        if self.update_traffic is not None:
            result['UpdateTraffic'] = self.update_traffic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlwaysAllocateCPU') is not None:
            self.always_allocate_cpu = m.get('AlwaysAllocateCPU')
        if m.get('MaximumInstanceCount') is not None:
            self.maximum_instance_count = m.get('MaximumInstanceCount')
        if m.get('MinimumInstanceCount') is not None:
            self.minimum_instance_count = m.get('MinimumInstanceCount')
        if m.get('UpdateApplicationInput') is not None:
            self.update_application_input = m.get('UpdateApplicationInput')
        if m.get('UpdateTraffic') is not None:
            self.update_traffic = m.get('UpdateTraffic')
        return self


class BuildPipelineImageConfig(TeaModel):
    def __init__(
        self,
        instance_type: str = None,
        namespace: str = None,
        repository: str = None,
    ):
        self.instance_type = instance_type
        self.namespace = namespace
        self.repository = repository

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.repository is not None:
            result['Repository'] = self.repository
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Repository') is not None:
            self.repository = m.get('Repository')
        return self


class BuildPipelinePackageConfig(TeaModel):
    def __init__(
        self,
        package_name: str = None,
        package_type: str = None,
        package_url: str = None,
        package_version: str = None,
    ):
        self.package_name = package_name
        self.package_type = package_type
        self.package_url = package_url
        self.package_version = package_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.package_name is not None:
            result['PackageName'] = self.package_name
        if self.package_type is not None:
            result['PackageType'] = self.package_type
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PackageName') is not None:
            self.package_name = m.get('PackageName')
        if m.get('PackageType') is not None:
            self.package_type = m.get('PackageType')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        return self


class BuildPipelineTriggerConfig(TeaModel):
    def __init__(
        self,
        branch_name: str = None,
        tag_name: str = None,
        type: str = None,
    ):
        self.branch_name = branch_name
        self.tag_name = tag_name
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.branch_name is not None:
            result['BranchName'] = self.branch_name
        if self.tag_name is not None:
            result['TagName'] = self.tag_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BranchName') is not None:
            self.branch_name = m.get('BranchName')
        if m.get('TagName') is not None:
            self.tag_name = m.get('TagName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class BuildPipeline(TeaModel):
    def __init__(
        self,
        application_id: str = None,
        application_name: str = None,
        build_config: BuildPipelineBuildConfig = None,
        code_config: BuildPipelineCodeConfig = None,
        deploy_config: BuildPipelineDeployConfig = None,
        enabled: bool = None,
        image_config: BuildPipelineImageConfig = None,
        package_config: BuildPipelinePackageConfig = None,
        trigger_config: BuildPipelineTriggerConfig = None,
    ):
        # This parameter is required.
        self.application_id = application_id
        # This parameter is required.
        self.application_name = application_name
        # This parameter is required.
        self.build_config = build_config
        # This parameter is required.
        self.code_config = code_config
        self.deploy_config = deploy_config
        self.enabled = enabled
        self.image_config = image_config
        self.package_config = package_config
        # This parameter is required.
        self.trigger_config = trigger_config

    def validate(self):
        if self.build_config:
            self.build_config.validate()
        if self.code_config:
            self.code_config.validate()
        if self.deploy_config:
            self.deploy_config.validate()
        if self.image_config:
            self.image_config.validate()
        if self.package_config:
            self.package_config.validate()
        if self.trigger_config:
            self.trigger_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_id is not None:
            result['ApplicationId'] = self.application_id
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        if self.build_config is not None:
            result['BuildConfig'] = self.build_config.to_map()
        if self.code_config is not None:
            result['CodeConfig'] = self.code_config.to_map()
        if self.deploy_config is not None:
            result['DeployConfig'] = self.deploy_config.to_map()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.image_config is not None:
            result['ImageConfig'] = self.image_config.to_map()
        if self.package_config is not None:
            result['PackageConfig'] = self.package_config.to_map()
        if self.trigger_config is not None:
            result['TriggerConfig'] = self.trigger_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationId') is not None:
            self.application_id = m.get('ApplicationId')
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        if m.get('BuildConfig') is not None:
            temp_model = BuildPipelineBuildConfig()
            self.build_config = temp_model.from_map(m['BuildConfig'])
        if m.get('CodeConfig') is not None:
            temp_model = BuildPipelineCodeConfig()
            self.code_config = temp_model.from_map(m['CodeConfig'])
        if m.get('DeployConfig') is not None:
            temp_model = BuildPipelineDeployConfig()
            self.deploy_config = temp_model.from_map(m['DeployConfig'])
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('ImageConfig') is not None:
            temp_model = BuildPipelineImageConfig()
            self.image_config = temp_model.from_map(m['ImageConfig'])
        if m.get('PackageConfig') is not None:
            temp_model = BuildPipelinePackageConfig()
            self.package_config = temp_model.from_map(m['PackageConfig'])
        if m.get('TriggerConfig') is not None:
            temp_model = BuildPipelineTriggerConfig()
            self.trigger_config = temp_model.from_map(m['TriggerConfig'])
        return self


class BuildPipelineRunBuildConfigTrigger(TeaModel):
    def __init__(
        self,
        branch_name: str = None,
        tag_name: str = None,
        type: str = None,
    ):
        self.branch_name = branch_name
        self.tag_name = tag_name
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.branch_name is not None:
            result['BranchName'] = self.branch_name
        if self.tag_name is not None:
            result['TagName'] = self.tag_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BranchName') is not None:
            self.branch_name = m.get('BranchName')
        if m.get('TagName') is not None:
            self.tag_name = m.get('TagName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class BuildPipelineRunBuildConfig(TeaModel):
    def __init__(
        self,
        before_build_command: str = None,
        build_type: str = None,
        dockerfile_path: str = None,
        run_command: str = None,
        runtime_type: str = None,
        runtime_version: str = None,
        tomcat_config: TomcatConfig = None,
        trigger: BuildPipelineRunBuildConfigTrigger = None,
        working_dir: str = None,
    ):
        self.before_build_command = before_build_command
        # This parameter is required.
        self.build_type = build_type
        self.dockerfile_path = dockerfile_path
        self.run_command = run_command
        self.runtime_type = runtime_type
        self.runtime_version = runtime_version
        self.tomcat_config = tomcat_config
        # This parameter is required.
        self.trigger = trigger
        self.working_dir = working_dir

    def validate(self):
        if self.tomcat_config:
            self.tomcat_config.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.before_build_command is not None:
            result['BeforeBuildCommand'] = self.before_build_command
        if self.build_type is not None:
            result['BuildType'] = self.build_type
        if self.dockerfile_path is not None:
            result['DockerfilePath'] = self.dockerfile_path
        if self.run_command is not None:
            result['RunCommand'] = self.run_command
        if self.runtime_type is not None:
            result['RuntimeType'] = self.runtime_type
        if self.runtime_version is not None:
            result['RuntimeVersion'] = self.runtime_version
        if self.tomcat_config is not None:
            result['TomcatConfig'] = self.tomcat_config.to_map()
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        if self.working_dir is not None:
            result['WorkingDir'] = self.working_dir
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BeforeBuildCommand') is not None:
            self.before_build_command = m.get('BeforeBuildCommand')
        if m.get('BuildType') is not None:
            self.build_type = m.get('BuildType')
        if m.get('DockerfilePath') is not None:
            self.dockerfile_path = m.get('DockerfilePath')
        if m.get('RunCommand') is not None:
            self.run_command = m.get('RunCommand')
        if m.get('RuntimeType') is not None:
            self.runtime_type = m.get('RuntimeType')
        if m.get('RuntimeVersion') is not None:
            self.runtime_version = m.get('RuntimeVersion')
        if m.get('TomcatConfig') is not None:
            temp_model = TomcatConfig()
            self.tomcat_config = temp_model.from_map(m['TomcatConfig'])
        if m.get('Trigger') is not None:
            temp_model = BuildPipelineRunBuildConfigTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        if m.get('WorkingDir') is not None:
            self.working_dir = m.get('WorkingDir')
        return self


class BuildPipelineRunCodeConfig(TeaModel):
    def __init__(
        self,
        account_id: str = None,
        branch_name: str = None,
        commit_id: str = None,
        commit_url: str = None,
        organization_id: str = None,
        provider: str = None,
        repo_full_name: str = None,
        repo_id: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id
        # This parameter is required.
        self.branch_name = branch_name
        self.commit_id = commit_id
        self.commit_url = commit_url
        self.organization_id = organization_id
        # This parameter is required.
        self.provider = provider
        # This parameter is required.
        self.repo_full_name = repo_full_name
        # This parameter is required.
        self.repo_id = repo_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['AccountId'] = self.account_id
        if self.branch_name is not None:
            result['BranchName'] = self.branch_name
        if self.commit_id is not None:
            result['CommitId'] = self.commit_id
        if self.commit_url is not None:
            result['CommitUrl'] = self.commit_url
        if self.organization_id is not None:
            result['OrganizationId'] = self.organization_id
        if self.provider is not None:
            result['Provider'] = self.provider
        if self.repo_full_name is not None:
            result['RepoFullName'] = self.repo_full_name
        if self.repo_id is not None:
            result['RepoId'] = self.repo_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccountId') is not None:
            self.account_id = m.get('AccountId')
        if m.get('BranchName') is not None:
            self.branch_name = m.get('BranchName')
        if m.get('CommitId') is not None:
            self.commit_id = m.get('CommitId')
        if m.get('CommitUrl') is not None:
            self.commit_url = m.get('CommitUrl')
        if m.get('OrganizationId') is not None:
            self.organization_id = m.get('OrganizationId')
        if m.get('Provider') is not None:
            self.provider = m.get('Provider')
        if m.get('RepoFullName') is not None:
            self.repo_full_name = m.get('RepoFullName')
        if m.get('RepoId') is not None:
            self.repo_id = m.get('RepoId')
        return self


class BuildPipelineRunDeployConfig(TeaModel):
    def __init__(
        self,
        always_allocate_cpu: bool = None,
        maximum_instance_count: int = None,
        minimum_instance_count: int = None,
        update_application_input: str = None,
        update_traffic: bool = None,
    ):
        self.always_allocate_cpu = always_allocate_cpu
        self.maximum_instance_count = maximum_instance_count
        self.minimum_instance_count = minimum_instance_count
        self.update_application_input = update_application_input
        self.update_traffic = update_traffic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.always_allocate_cpu is not None:
            result['AlwaysAllocateCPU'] = self.always_allocate_cpu
        if self.maximum_instance_count is not None:
            result['MaximumInstanceCount'] = self.maximum_instance_count
        if self.minimum_instance_count is not None:
            result['MinimumInstanceCount'] = self.minimum_instance_count
        if self.update_application_input is not None:
            result['UpdateApplicationInput'] = self.update_application_input
        if self.update_traffic is not None:
            result['UpdateTraffic'] = self.update_traffic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlwaysAllocateCPU') is not None:
            self.always_allocate_cpu = m.get('AlwaysAllocateCPU')
        if m.get('MaximumInstanceCount') is not None:
            self.maximum_instance_count = m.get('MaximumInstanceCount')
        if m.get('MinimumInstanceCount') is not None:
            self.minimum_instance_count = m.get('MinimumInstanceCount')
        if m.get('UpdateApplicationInput') is not None:
            self.update_application_input = m.get('UpdateApplicationInput')
        if m.get('UpdateTraffic') is not None:
            self.update_traffic = m.get('UpdateTraffic')
        return self


class BuildPipelineRunImageConfig(TeaModel):
    def __init__(
        self,
        instance_type: str = None,
        namespace: str = None,
        repository: str = None,
    ):
        self.instance_type = instance_type
        self.namespace = namespace
        self.repository = repository

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.repository is not None:
            result['Repository'] = self.repository
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Repository') is not None:
            self.repository = m.get('Repository')
        return self


class BuildPipelineRunPackageConfig(TeaModel):
    def __init__(
        self,
        package_name: str = None,
        package_type: str = None,
        package_url: str = None,
        package_version: str = None,
    ):
        self.package_name = package_name
        self.package_type = package_type
        self.package_url = package_url
        self.package_version = package_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.package_name is not None:
            result['PackageName'] = self.package_name
        if self.package_type is not None:
            result['PackageType'] = self.package_type
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PackageName') is not None:
            self.package_name = m.get('PackageName')
        if m.get('PackageType') is not None:
            self.package_type = m.get('PackageType')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        return self


class BuildPipelineRunSteps(TeaModel):
    def __init__(
        self,
        description: str = None,
        duration: int = None,
        end_time: int = None,
        id: str = None,
        name: str = None,
        result: str = None,
        start_time: int = None,
        status: str = None,
    ):
        self.description = description
        self.duration = duration
        self.end_time = end_time
        self.id = id
        self.name = name
        self.result = result
        self.start_time = start_time
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.result is not None:
            result['Result'] = self.result
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class BuildPipelineRunTriggerConfig(TeaModel):
    def __init__(
        self,
        branch_name: str = None,
        tag_name: str = None,
        type: str = None,
    ):
        self.branch_name = branch_name
        self.tag_name = tag_name
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.branch_name is not None:
            result['BranchName'] = self.branch_name
        if self.tag_name is not None:
            result['TagName'] = self.tag_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BranchName') is not None:
            self.branch_name = m.get('BranchName')
        if m.get('TagName') is not None:
            self.tag_name = m.get('TagName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class BuildPipelineRun(TeaModel):
    def __init__(
        self,
        build_config: BuildPipelineRunBuildConfig = None,
        build_duration: int = None,
        code_config: BuildPipelineRunCodeConfig = None,
        create_time: int = None,
        deploy_config: BuildPipelineRunDeployConfig = None,
        deploy_duration: int = None,
        end_time: int = None,
        image_config: BuildPipelineRunImageConfig = None,
        package_config: BuildPipelineRunPackageConfig = None,
        pipeline_id: str = None,
        pipeline_run_id: str = None,
        start_time: int = None,
        status: str = None,
        steps: List[BuildPipelineRunSteps] = None,
        trigger_config: BuildPipelineRunTriggerConfig = None,
        version_id: str = None,
        wait_duration: int = None,
    ):
        self.build_config = build_config
        self.build_duration = build_duration
        self.code_config = code_config
        self.create_time = create_time
        self.deploy_config = deploy_config
        self.deploy_duration = deploy_duration
        self.end_time = end_time
        self.image_config = image_config
        self.package_config = package_config
        self.pipeline_id = pipeline_id
        self.pipeline_run_id = pipeline_run_id
        self.start_time = start_time
        self.status = status
        self.steps = steps
        self.trigger_config = trigger_config
        self.version_id = version_id
        self.wait_duration = wait_duration

    def validate(self):
        if self.build_config:
            self.build_config.validate()
        if self.code_config:
            self.code_config.validate()
        if self.deploy_config:
            self.deploy_config.validate()
        if self.image_config:
            self.image_config.validate()
        if self.package_config:
            self.package_config.validate()
        if self.steps:
            for k in self.steps:
                if k:
                    k.validate()
        if self.trigger_config:
            self.trigger_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.build_config is not None:
            result['BuildConfig'] = self.build_config.to_map()
        if self.build_duration is not None:
            result['BuildDuration'] = self.build_duration
        if self.code_config is not None:
            result['CodeConfig'] = self.code_config.to_map()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deploy_config is not None:
            result['DeployConfig'] = self.deploy_config.to_map()
        if self.deploy_duration is not None:
            result['DeployDuration'] = self.deploy_duration
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.image_config is not None:
            result['ImageConfig'] = self.image_config.to_map()
        if self.package_config is not None:
            result['PackageConfig'] = self.package_config.to_map()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.pipeline_run_id is not None:
            result['PipelineRunId'] = self.pipeline_run_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        result['Steps'] = []
        if self.steps is not None:
            for k in self.steps:
                result['Steps'].append(k.to_map() if k else None)
        if self.trigger_config is not None:
            result['TriggerConfig'] = self.trigger_config.to_map()
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        if self.wait_duration is not None:
            result['WaitDuration'] = self.wait_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BuildConfig') is not None:
            temp_model = BuildPipelineRunBuildConfig()
            self.build_config = temp_model.from_map(m['BuildConfig'])
        if m.get('BuildDuration') is not None:
            self.build_duration = m.get('BuildDuration')
        if m.get('CodeConfig') is not None:
            temp_model = BuildPipelineRunCodeConfig()
            self.code_config = temp_model.from_map(m['CodeConfig'])
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeployConfig') is not None:
            temp_model = BuildPipelineRunDeployConfig()
            self.deploy_config = temp_model.from_map(m['DeployConfig'])
        if m.get('DeployDuration') is not None:
            self.deploy_duration = m.get('DeployDuration')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ImageConfig') is not None:
            temp_model = BuildPipelineRunImageConfig()
            self.image_config = temp_model.from_map(m['ImageConfig'])
        if m.get('PackageConfig') is not None:
            temp_model = BuildPipelineRunPackageConfig()
            self.package_config = temp_model.from_map(m['PackageConfig'])
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('PipelineRunId') is not None:
            self.pipeline_run_id = m.get('PipelineRunId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.steps = []
        if m.get('Steps') is not None:
            for k in m.get('Steps'):
                temp_model = BuildPipelineRunSteps()
                self.steps.append(temp_model.from_map(k))
        if m.get('TriggerConfig') is not None:
            temp_model = BuildPipelineRunTriggerConfig()
            self.trigger_config = temp_model.from_map(m['TriggerConfig'])
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        if m.get('WaitDuration') is not None:
            self.wait_duration = m.get('WaitDuration')
        return self


class BuildPipelineRunLogLine(TeaModel):
    def __init__(
        self,
        content: str = None,
        offset: int = None,
    ):
        self.content = content
        self.offset = offset

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.offset is not None:
            result['Offset'] = self.offset
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Offset') is not None:
            self.offset = m.get('Offset')
        return self


class CertConfig(TeaModel):
    def __init__(
        self,
        cert_name: str = None,
        certificate: str = None,
        private_key: str = None,
    ):
        self.cert_name = cert_name
        self.certificate = certificate
        self.private_key = private_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_name is not None:
            result['certName'] = self.cert_name
        if self.certificate is not None:
            result['certificate'] = self.certificate
        if self.private_key is not None:
            result['privateKey'] = self.private_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('certName') is not None:
            self.cert_name = m.get('certName')
        if m.get('certificate') is not None:
            self.certificate = m.get('certificate')
        if m.get('privateKey') is not None:
            self.private_key = m.get('privateKey')
        return self


class RegistryAuthenticationConfig(TeaModel):
    def __init__(
        self,
        password: str = None,
        user_name: str = None,
    ):
        self.password = password
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.password is not None:
            result['Password'] = self.password
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class RegistryCertificateConfig(TeaModel):
    def __init__(
        self,
        cert_base_64: str = None,
        insecure: bool = None,
    ):
        self.cert_base_64 = cert_base_64
        self.insecure = insecure

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_base_64 is not None:
            result['CertBase64'] = self.cert_base_64
        if self.insecure is not None:
            result['Insecure'] = self.insecure
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertBase64') is not None:
            self.cert_base_64 = m.get('CertBase64')
        if m.get('Insecure') is not None:
            self.insecure = m.get('Insecure')
        return self


class ImageRegistryConfig(TeaModel):
    def __init__(
        self,
        auth_config: RegistryAuthenticationConfig = None,
        cert_config: RegistryCertificateConfig = None,
    ):
        self.auth_config = auth_config
        self.cert_config = cert_config

    def validate(self):
        if self.auth_config:
            self.auth_config.validate()
        if self.cert_config:
            self.cert_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_config is not None:
            result['AuthConfig'] = self.auth_config.to_map()
        if self.cert_config is not None:
            result['CertConfig'] = self.cert_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthConfig') is not None:
            temp_model = RegistryAuthenticationConfig()
            self.auth_config = temp_model.from_map(m['AuthConfig'])
        if m.get('CertConfig') is not None:
            temp_model = RegistryCertificateConfig()
            self.cert_config = temp_model.from_map(m['CertConfig'])
        return self


class MetricsCollectConfig(TeaModel):
    def __init__(
        self,
        enable_push_to_user_sls: bool = None,
        logstore_name: str = None,
        project_name: str = None,
    ):
        self.enable_push_to_user_sls = enable_push_to_user_sls
        self.logstore_name = logstore_name
        self.project_name = project_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_push_to_user_sls is not None:
            result['EnablePushToUserSLS'] = self.enable_push_to_user_sls
        if self.logstore_name is not None:
            result['LogstoreName'] = self.logstore_name
        if self.project_name is not None:
            result['ProjectName'] = self.project_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnablePushToUserSLS') is not None:
            self.enable_push_to_user_sls = m.get('EnablePushToUserSLS')
        if m.get('LogstoreName') is not None:
            self.logstore_name = m.get('LogstoreName')
        if m.get('ProjectName') is not None:
            self.project_name = m.get('ProjectName')
        return self


class ContainerResources(TeaModel):
    def __init__(
        self,
        cpu: int = None,
        memory: int = None,
    ):
        # This parameter is required.
        self.cpu = cpu
        # This parameter is required.
        self.memory = memory

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.memory is not None:
            result['Memory'] = self.memory
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        return self


class SLSCollectConfig(TeaModel):
    def __init__(
        self,
        log_path: str = None,
        log_type: str = None,
        logstore_name: str = None,
        logtail_name: str = None,
        machine_group: str = None,
        project_name: str = None,
    ):
        self.log_path = log_path
        self.log_type = log_type
        self.logstore_name = logstore_name
        self.logtail_name = logtail_name
        self.machine_group = machine_group
        self.project_name = project_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.log_path is not None:
            result['LogPath'] = self.log_path
        if self.log_type is not None:
            result['LogType'] = self.log_type
        if self.logstore_name is not None:
            result['LogstoreName'] = self.logstore_name
        if self.logtail_name is not None:
            result['LogtailName'] = self.logtail_name
        if self.machine_group is not None:
            result['MachineGroup'] = self.machine_group
        if self.project_name is not None:
            result['ProjectName'] = self.project_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LogPath') is not None:
            self.log_path = m.get('LogPath')
        if m.get('LogType') is not None:
            self.log_type = m.get('LogType')
        if m.get('LogstoreName') is not None:
            self.logstore_name = m.get('LogstoreName')
        if m.get('LogtailName') is not None:
            self.logtail_name = m.get('LogtailName')
        if m.get('MachineGroup') is not None:
            self.machine_group = m.get('MachineGroup')
        if m.get('ProjectName') is not None:
            self.project_name = m.get('ProjectName')
        return self


class SLSCollectConfigs(TeaModel):
    def __init__(
        self,
        collect_configs: List[SLSCollectConfig] = None,
    ):
        self.collect_configs = collect_configs

    def validate(self):
        if self.collect_configs:
            for k in self.collect_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CollectConfigs'] = []
        if self.collect_configs is not None:
            for k in self.collect_configs:
                result['CollectConfigs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.collect_configs = []
        if m.get('CollectConfigs') is not None:
            for k in m.get('CollectConfigs'):
                temp_model = SLSCollectConfig()
                self.collect_configs.append(temp_model.from_map(k))
        return self


class HTTPHeader(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        self.name = name
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class HTTPGetAction(TeaModel):
    def __init__(
        self,
        host: str = None,
        http_headers: List[HTTPHeader] = None,
        path: str = None,
        port: int = None,
        scheme: str = None,
    ):
        self.host = host
        self.http_headers = http_headers
        self.path = path
        self.port = port
        self.scheme = scheme

    def validate(self):
        if self.http_headers:
            for k in self.http_headers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host is not None:
            result['Host'] = self.host
        result['HttpHeaders'] = []
        if self.http_headers is not None:
            for k in self.http_headers:
                result['HttpHeaders'].append(k.to_map() if k else None)
        if self.path is not None:
            result['Path'] = self.path
        if self.port is not None:
            result['Port'] = self.port
        if self.scheme is not None:
            result['Scheme'] = self.scheme
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Host') is not None:
            self.host = m.get('Host')
        self.http_headers = []
        if m.get('HttpHeaders') is not None:
            for k in m.get('HttpHeaders'):
                temp_model = HTTPHeader()
                self.http_headers.append(temp_model.from_map(k))
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Scheme') is not None:
            self.scheme = m.get('Scheme')
        return self


class TCPSocketAction(TeaModel):
    def __init__(
        self,
        host: str = None,
        port: int = None,
    ):
        self.host = host
        self.port = port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host is not None:
            result['Host'] = self.host
        if self.port is not None:
            result['Port'] = self.port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        return self


class ProbeHandler(TeaModel):
    def __init__(
        self,
        http_get: HTTPGetAction = None,
        tcp_socket: TCPSocketAction = None,
    ):
        self.http_get = http_get
        self.tcp_socket = tcp_socket

    def validate(self):
        if self.http_get:
            self.http_get.validate()
        if self.tcp_socket:
            self.tcp_socket.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.http_get is not None:
            result['HttpGet'] = self.http_get.to_map()
        if self.tcp_socket is not None:
            result['TcpSocket'] = self.tcp_socket.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HttpGet') is not None:
            temp_model = HTTPGetAction()
            self.http_get = temp_model.from_map(m['HttpGet'])
        if m.get('TcpSocket') is not None:
            temp_model = TCPSocketAction()
            self.tcp_socket = temp_model.from_map(m['TcpSocket'])
        return self


class StartupProbe(TeaModel):
    def __init__(
        self,
        failure_threshold: int = None,
        initial_delay_seconds: int = None,
        period_seconds: int = None,
        probe_handler: ProbeHandler = None,
        timeout_seconds: int = None,
    ):
        self.failure_threshold = failure_threshold
        self.initial_delay_seconds = initial_delay_seconds
        self.period_seconds = period_seconds
        self.probe_handler = probe_handler
        self.timeout_seconds = timeout_seconds

    def validate(self):
        if self.probe_handler:
            self.probe_handler.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failure_threshold is not None:
            result['FailureThreshold'] = self.failure_threshold
        if self.initial_delay_seconds is not None:
            result['InitialDelaySeconds'] = self.initial_delay_seconds
        if self.period_seconds is not None:
            result['PeriodSeconds'] = self.period_seconds
        if self.probe_handler is not None:
            result['ProbeHandler'] = self.probe_handler.to_map()
        if self.timeout_seconds is not None:
            result['TimeoutSeconds'] = self.timeout_seconds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailureThreshold') is not None:
            self.failure_threshold = m.get('FailureThreshold')
        if m.get('InitialDelaySeconds') is not None:
            self.initial_delay_seconds = m.get('InitialDelaySeconds')
        if m.get('PeriodSeconds') is not None:
            self.period_seconds = m.get('PeriodSeconds')
        if m.get('ProbeHandler') is not None:
            temp_model = ProbeHandler()
            self.probe_handler = temp_model.from_map(m['ProbeHandler'])
        if m.get('TimeoutSeconds') is not None:
            self.timeout_seconds = m.get('TimeoutSeconds')
        return self


class WebNASMountPoint(TeaModel):
    def __init__(
        self,
        mount_dir: str = None,
        nas_addr: str = None,
        nas_path: str = None,
    ):
        self.mount_dir = mount_dir
        self.nas_addr = nas_addr
        self.nas_path = nas_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mount_dir is not None:
            result['MountDir'] = self.mount_dir
        if self.nas_addr is not None:
            result['NasAddr'] = self.nas_addr
        if self.nas_path is not None:
            result['NasPath'] = self.nas_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MountDir') is not None:
            self.mount_dir = m.get('MountDir')
        if m.get('NasAddr') is not None:
            self.nas_addr = m.get('NasAddr')
        if m.get('NasPath') is not None:
            self.nas_path = m.get('NasPath')
        return self


class WebNASConfig(TeaModel):
    def __init__(
        self,
        mount_points: List[WebNASMountPoint] = None,
    ):
        self.mount_points = mount_points

    def validate(self):
        if self.mount_points:
            for k in self.mount_points:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MountPoints'] = []
        if self.mount_points is not None:
            for k in self.mount_points:
                result['MountPoints'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.mount_points = []
        if m.get('MountPoints') is not None:
            for k in m.get('MountPoints'):
                temp_model = WebNASMountPoint()
                self.mount_points.append(temp_model.from_map(k))
        return self


class WebOSSMountPoint(TeaModel):
    def __init__(
        self,
        bucket_name: str = None,
        bucket_path: str = None,
        mount_dir: str = None,
        read_only: bool = None,
    ):
        self.bucket_name = bucket_name
        self.bucket_path = bucket_path
        self.mount_dir = mount_dir
        self.read_only = read_only

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        if self.bucket_path is not None:
            result['BucketPath'] = self.bucket_path
        if self.mount_dir is not None:
            result['MountDir'] = self.mount_dir
        if self.read_only is not None:
            result['ReadOnly'] = self.read_only
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        if m.get('BucketPath') is not None:
            self.bucket_path = m.get('BucketPath')
        if m.get('MountDir') is not None:
            self.mount_dir = m.get('MountDir')
        if m.get('ReadOnly') is not None:
            self.read_only = m.get('ReadOnly')
        return self


class WebOSSConfig(TeaModel):
    def __init__(
        self,
        mount_points: List[WebOSSMountPoint] = None,
    ):
        self.mount_points = mount_points

    def validate(self):
        if self.mount_points:
            for k in self.mount_points:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MountPoints'] = []
        if self.mount_points is not None:
            for k in self.mount_points:
                result['MountPoints'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.mount_points = []
        if m.get('MountPoints') is not None:
            for k in m.get('MountPoints'):
                temp_model = WebOSSMountPoint()
                self.mount_points.append(temp_model.from_map(k))
        return self


class Container(TeaModel):
    def __init__(
        self,
        args: str = None,
        command: str = None,
        environment_variables: Dict[str, str] = None,
        image: str = None,
        image_registry_config: ImageRegistryConfig = None,
        metrics_collect_config: MetricsCollectConfig = None,
        port: int = None,
        request_concurrency: int = None,
        request_timeout: int = None,
        resources: ContainerResources = None,
        slscollect_configs: SLSCollectConfigs = None,
        startup_probe: StartupProbe = None,
        web_nasconfig: WebNASConfig = None,
        web_ossconfig: WebOSSConfig = None,
    ):
        self.args = args
        self.command = command
        self.environment_variables = environment_variables
        # This parameter is required.
        self.image = image
        self.image_registry_config = image_registry_config
        self.metrics_collect_config = metrics_collect_config
        self.port = port
        self.request_concurrency = request_concurrency
        self.request_timeout = request_timeout
        # This parameter is required.
        self.resources = resources
        self.slscollect_configs = slscollect_configs
        self.startup_probe = startup_probe
        self.web_nasconfig = web_nasconfig
        self.web_ossconfig = web_ossconfig

    def validate(self):
        if self.image_registry_config:
            self.image_registry_config.validate()
        if self.metrics_collect_config:
            self.metrics_collect_config.validate()
        if self.resources:
            self.resources.validate()
        if self.slscollect_configs:
            self.slscollect_configs.validate()
        if self.startup_probe:
            self.startup_probe.validate()
        if self.web_nasconfig:
            self.web_nasconfig.validate()
        if self.web_ossconfig:
            self.web_ossconfig.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.args is not None:
            result['Args'] = self.args
        if self.command is not None:
            result['Command'] = self.command
        if self.environment_variables is not None:
            result['EnvironmentVariables'] = self.environment_variables
        if self.image is not None:
            result['Image'] = self.image
        if self.image_registry_config is not None:
            result['ImageRegistryConfig'] = self.image_registry_config.to_map()
        if self.metrics_collect_config is not None:
            result['MetricsCollectConfig'] = self.metrics_collect_config.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.request_concurrency is not None:
            result['RequestConcurrency'] = self.request_concurrency
        if self.request_timeout is not None:
            result['RequestTimeout'] = self.request_timeout
        if self.resources is not None:
            result['Resources'] = self.resources.to_map()
        if self.slscollect_configs is not None:
            result['SLSCollectConfigs'] = self.slscollect_configs.to_map()
        if self.startup_probe is not None:
            result['StartupProbe'] = self.startup_probe.to_map()
        if self.web_nasconfig is not None:
            result['WebNASConfig'] = self.web_nasconfig.to_map()
        if self.web_ossconfig is not None:
            result['WebOSSConfig'] = self.web_ossconfig.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Args') is not None:
            self.args = m.get('Args')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('EnvironmentVariables') is not None:
            self.environment_variables = m.get('EnvironmentVariables')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ImageRegistryConfig') is not None:
            temp_model = ImageRegistryConfig()
            self.image_registry_config = temp_model.from_map(m['ImageRegistryConfig'])
        if m.get('MetricsCollectConfig') is not None:
            temp_model = MetricsCollectConfig()
            self.metrics_collect_config = temp_model.from_map(m['MetricsCollectConfig'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('RequestConcurrency') is not None:
            self.request_concurrency = m.get('RequestConcurrency')
        if m.get('RequestTimeout') is not None:
            self.request_timeout = m.get('RequestTimeout')
        if m.get('Resources') is not None:
            temp_model = ContainerResources()
            self.resources = temp_model.from_map(m['Resources'])
        if m.get('SLSCollectConfigs') is not None:
            temp_model = SLSCollectConfigs()
            self.slscollect_configs = temp_model.from_map(m['SLSCollectConfigs'])
        if m.get('StartupProbe') is not None:
            temp_model = StartupProbe()
            self.startup_probe = temp_model.from_map(m['StartupProbe'])
        if m.get('WebNASConfig') is not None:
            temp_model = WebNASConfig()
            self.web_nasconfig = temp_model.from_map(m['WebNASConfig'])
        if m.get('WebOSSConfig') is not None:
            temp_model = WebOSSConfig()
            self.web_ossconfig = temp_model.from_map(m['WebOSSConfig'])
        return self


class InputCodeLocation(TeaModel):
    def __init__(
        self,
        oss_bucket_name: str = None,
        oss_object_name: str = None,
        zip_file: str = None,
    ):
        self.oss_bucket_name = oss_bucket_name
        self.oss_object_name = oss_object_name
        self.zip_file = zip_file

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.oss_bucket_name is not None:
            result['ossBucketName'] = self.oss_bucket_name
        if self.oss_object_name is not None:
            result['ossObjectName'] = self.oss_object_name
        if self.zip_file is not None:
            result['zipFile'] = self.zip_file
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ossBucketName') is not None:
            self.oss_bucket_name = m.get('ossBucketName')
        if m.get('ossObjectName') is not None:
            self.oss_object_name = m.get('ossObjectName')
        if m.get('zipFile') is not None:
            self.zip_file = m.get('zipFile')
        return self


class CreateApplicationInput(TeaModel):
    def __init__(
        self,
        application_name: str = None,
        args: str = None,
        ca_port: int = None,
        code: InputCodeLocation = None,
        command: str = None,
        cpu: float = None,
        custom_dns: CustomDNS = None,
        custom_health_check_config: CustomHealthCheckConfig = None,
        custom_host_alias: CustomHostAlias = None,
        custom_runtime_config: CustomRuntimeConfig = None,
        description: str = None,
        disk_size: int = None,
        enable_app_metric: bool = None,
        environment_variables: Dict[str, str] = None,
        gpu_memory_size: int = None,
        handler: str = None,
        http_trigger_config: HTTPTriggerConfig = None,
        image_config: ImageConfig = None,
        initialization_timeout: int = None,
        initializer: str = None,
        instance_concurrency: int = None,
        instance_lifecycle_config: InstanceLifecycleConfig = None,
        instance_soft_concurrency: int = None,
        instance_type: str = None,
        internet_access: bool = None,
        layers: List[str] = None,
        liveness_probe: Probe = None,
        log_config: LogConfig = None,
        memory_size: int = None,
        namespace_id: str = None,
        nas_config: NASConfig = None,
        oss_mount_config: OSSMountConfig = None,
        programming_language: str = None,
        runtime: str = None,
        scale_config: ScaleConfig = None,
        sls_config: SLSConfig = None,
        startup_probe: Probe = None,
        timeout: int = None,
        tracing_config: TracingConfig = None,
        vpc_config: VPCConfig = None,
    ):
        self.application_name = application_name
        self.args = args
        self.ca_port = ca_port
        self.code = code
        self.command = command
        self.cpu = cpu
        self.custom_dns = custom_dns
        self.custom_health_check_config = custom_health_check_config
        self.custom_host_alias = custom_host_alias
        self.custom_runtime_config = custom_runtime_config
        self.description = description
        self.disk_size = disk_size
        self.enable_app_metric = enable_app_metric
        self.environment_variables = environment_variables
        self.gpu_memory_size = gpu_memory_size
        self.handler = handler
        self.http_trigger_config = http_trigger_config
        self.image_config = image_config
        self.initialization_timeout = initialization_timeout
        self.initializer = initializer
        self.instance_concurrency = instance_concurrency
        self.instance_lifecycle_config = instance_lifecycle_config
        self.instance_soft_concurrency = instance_soft_concurrency
        self.instance_type = instance_type
        self.internet_access = internet_access
        self.layers = layers
        self.liveness_probe = liveness_probe
        self.log_config = log_config
        self.memory_size = memory_size
        self.namespace_id = namespace_id
        self.nas_config = nas_config
        self.oss_mount_config = oss_mount_config
        self.programming_language = programming_language
        self.runtime = runtime
        self.scale_config = scale_config
        self.sls_config = sls_config
        self.startup_probe = startup_probe
        self.timeout = timeout
        self.tracing_config = tracing_config
        self.vpc_config = vpc_config

    def validate(self):
        if self.code:
            self.code.validate()
        if self.custom_dns:
            self.custom_dns.validate()
        if self.custom_health_check_config:
            self.custom_health_check_config.validate()
        if self.custom_host_alias:
            self.custom_host_alias.validate()
        if self.custom_runtime_config:
            self.custom_runtime_config.validate()
        if self.http_trigger_config:
            self.http_trigger_config.validate()
        if self.image_config:
            self.image_config.validate()
        if self.instance_lifecycle_config:
            self.instance_lifecycle_config.validate()
        if self.liveness_probe:
            self.liveness_probe.validate()
        if self.log_config:
            self.log_config.validate()
        if self.nas_config:
            self.nas_config.validate()
        if self.oss_mount_config:
            self.oss_mount_config.validate()
        if self.scale_config:
            self.scale_config.validate()
        if self.sls_config:
            self.sls_config.validate()
        if self.startup_probe:
            self.startup_probe.validate()
        if self.tracing_config:
            self.tracing_config.validate()
        if self.vpc_config:
            self.vpc_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_name is not None:
            result['applicationName'] = self.application_name
        if self.args is not None:
            result['args'] = self.args
        if self.ca_port is not None:
            result['caPort'] = self.ca_port
        if self.code is not None:
            result['code'] = self.code.to_map()
        if self.command is not None:
            result['command'] = self.command
        if self.cpu is not None:
            result['cpu'] = self.cpu
        if self.custom_dns is not None:
            result['customDNS'] = self.custom_dns.to_map()
        if self.custom_health_check_config is not None:
            result['customHealthCheckConfig'] = self.custom_health_check_config.to_map()
        if self.custom_host_alias is not None:
            result['customHostAlias'] = self.custom_host_alias.to_map()
        if self.custom_runtime_config is not None:
            result['customRuntimeConfig'] = self.custom_runtime_config.to_map()
        if self.description is not None:
            result['description'] = self.description
        if self.disk_size is not None:
            result['diskSize'] = self.disk_size
        if self.enable_app_metric is not None:
            result['enableAppMetric'] = self.enable_app_metric
        if self.environment_variables is not None:
            result['environmentVariables'] = self.environment_variables
        if self.gpu_memory_size is not None:
            result['gpuMemorySize'] = self.gpu_memory_size
        if self.handler is not None:
            result['handler'] = self.handler
        if self.http_trigger_config is not None:
            result['httpTriggerConfig'] = self.http_trigger_config.to_map()
        if self.image_config is not None:
            result['imageConfig'] = self.image_config.to_map()
        if self.initialization_timeout is not None:
            result['initializationTimeout'] = self.initialization_timeout
        if self.initializer is not None:
            result['initializer'] = self.initializer
        if self.instance_concurrency is not None:
            result['instanceConcurrency'] = self.instance_concurrency
        if self.instance_lifecycle_config is not None:
            result['instanceLifecycleConfig'] = self.instance_lifecycle_config.to_map()
        if self.instance_soft_concurrency is not None:
            result['instanceSoftConcurrency'] = self.instance_soft_concurrency
        if self.instance_type is not None:
            result['instanceType'] = self.instance_type
        if self.internet_access is not None:
            result['internetAccess'] = self.internet_access
        if self.layers is not None:
            result['layers'] = self.layers
        if self.liveness_probe is not None:
            result['livenessProbe'] = self.liveness_probe.to_map()
        if self.log_config is not None:
            result['logConfig'] = self.log_config.to_map()
        if self.memory_size is not None:
            result['memorySize'] = self.memory_size
        if self.namespace_id is not None:
            result['namespaceID'] = self.namespace_id
        if self.nas_config is not None:
            result['nasConfig'] = self.nas_config.to_map()
        if self.oss_mount_config is not None:
            result['ossMountConfig'] = self.oss_mount_config.to_map()
        if self.programming_language is not None:
            result['programmingLanguage'] = self.programming_language
        if self.runtime is not None:
            result['runtime'] = self.runtime
        if self.scale_config is not None:
            result['scaleConfig'] = self.scale_config.to_map()
        if self.sls_config is not None:
            result['slsConfig'] = self.sls_config.to_map()
        if self.startup_probe is not None:
            result['startupProbe'] = self.startup_probe.to_map()
        if self.timeout is not None:
            result['timeout'] = self.timeout
        if self.tracing_config is not None:
            result['tracingConfig'] = self.tracing_config.to_map()
        if self.vpc_config is not None:
            result['vpcConfig'] = self.vpc_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('applicationName') is not None:
            self.application_name = m.get('applicationName')
        if m.get('args') is not None:
            self.args = m.get('args')
        if m.get('caPort') is not None:
            self.ca_port = m.get('caPort')
        if m.get('code') is not None:
            temp_model = InputCodeLocation()
            self.code = temp_model.from_map(m['code'])
        if m.get('command') is not None:
            self.command = m.get('command')
        if m.get('cpu') is not None:
            self.cpu = m.get('cpu')
        if m.get('customDNS') is not None:
            temp_model = CustomDNS()
            self.custom_dns = temp_model.from_map(m['customDNS'])
        if m.get('customHealthCheckConfig') is not None:
            temp_model = CustomHealthCheckConfig()
            self.custom_health_check_config = temp_model.from_map(m['customHealthCheckConfig'])
        if m.get('customHostAlias') is not None:
            temp_model = CustomHostAlias()
            self.custom_host_alias = temp_model.from_map(m['customHostAlias'])
        if m.get('customRuntimeConfig') is not None:
            temp_model = CustomRuntimeConfig()
            self.custom_runtime_config = temp_model.from_map(m['customRuntimeConfig'])
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('diskSize') is not None:
            self.disk_size = m.get('diskSize')
        if m.get('enableAppMetric') is not None:
            self.enable_app_metric = m.get('enableAppMetric')
        if m.get('environmentVariables') is not None:
            self.environment_variables = m.get('environmentVariables')
        if m.get('gpuMemorySize') is not None:
            self.gpu_memory_size = m.get('gpuMemorySize')
        if m.get('handler') is not None:
            self.handler = m.get('handler')
        if m.get('httpTriggerConfig') is not None:
            temp_model = HTTPTriggerConfig()
            self.http_trigger_config = temp_model.from_map(m['httpTriggerConfig'])
        if m.get('imageConfig') is not None:
            temp_model = ImageConfig()
            self.image_config = temp_model.from_map(m['imageConfig'])
        if m.get('initializationTimeout') is not None:
            self.initialization_timeout = m.get('initializationTimeout')
        if m.get('initializer') is not None:
            self.initializer = m.get('initializer')
        if m.get('instanceConcurrency') is not None:
            self.instance_concurrency = m.get('instanceConcurrency')
        if m.get('instanceLifecycleConfig') is not None:
            temp_model = InstanceLifecycleConfig()
            self.instance_lifecycle_config = temp_model.from_map(m['instanceLifecycleConfig'])
        if m.get('instanceSoftConcurrency') is not None:
            self.instance_soft_concurrency = m.get('instanceSoftConcurrency')
        if m.get('instanceType') is not None:
            self.instance_type = m.get('instanceType')
        if m.get('internetAccess') is not None:
            self.internet_access = m.get('internetAccess')
        if m.get('layers') is not None:
            self.layers = m.get('layers')
        if m.get('livenessProbe') is not None:
            temp_model = Probe()
            self.liveness_probe = temp_model.from_map(m['livenessProbe'])
        if m.get('logConfig') is not None:
            temp_model = LogConfig()
            self.log_config = temp_model.from_map(m['logConfig'])
        if m.get('memorySize') is not None:
            self.memory_size = m.get('memorySize')
        if m.get('namespaceID') is not None:
            self.namespace_id = m.get('namespaceID')
        if m.get('nasConfig') is not None:
            temp_model = NASConfig()
            self.nas_config = temp_model.from_map(m['nasConfig'])
        if m.get('ossMountConfig') is not None:
            temp_model = OSSMountConfig()
            self.oss_mount_config = temp_model.from_map(m['ossMountConfig'])
        if m.get('programmingLanguage') is not None:
            self.programming_language = m.get('programmingLanguage')
        if m.get('runtime') is not None:
            self.runtime = m.get('runtime')
        if m.get('scaleConfig') is not None:
            temp_model = ScaleConfig()
            self.scale_config = temp_model.from_map(m['scaleConfig'])
        if m.get('slsConfig') is not None:
            temp_model = SLSConfig()
            self.sls_config = temp_model.from_map(m['slsConfig'])
        if m.get('startupProbe') is not None:
            temp_model = Probe()
            self.startup_probe = temp_model.from_map(m['startupProbe'])
        if m.get('timeout') is not None:
            self.timeout = m.get('timeout')
        if m.get('tracingConfig') is not None:
            temp_model = TracingConfig()
            self.tracing_config = temp_model.from_map(m['tracingConfig'])
        if m.get('vpcConfig') is not None:
            temp_model = VPCConfig()
            self.vpc_config = temp_model.from_map(m['vpcConfig'])
        return self


class TLSConfig(TeaModel):
    def __init__(
        self,
        cipher_suites: List[str] = None,
        max_version: str = None,
        min_version: str = None,
    ):
        self.cipher_suites = cipher_suites
        self.max_version = max_version
        self.min_version = min_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cipher_suites is not None:
            result['cipherSuites'] = self.cipher_suites
        if self.max_version is not None:
            result['maxVersion'] = self.max_version
        if self.min_version is not None:
            result['minVersion'] = self.min_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cipherSuites') is not None:
            self.cipher_suites = m.get('cipherSuites')
        if m.get('maxVersion') is not None:
            self.max_version = m.get('maxVersion')
        if m.get('minVersion') is not None:
            self.min_version = m.get('minVersion')
        return self


class WAFConfig(TeaModel):
    def __init__(
        self,
        enable_waf: bool = None,
    ):
        self.enable_waf = enable_waf

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_waf is not None:
            result['enableWAF'] = self.enable_waf
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enableWAF') is not None:
            self.enable_waf = m.get('enableWAF')
        return self


class CreateCustomDomainInput(TeaModel):
    def __init__(
        self,
        application_name: str = None,
        cert_config: CertConfig = None,
        domain_name: str = None,
        keep_full_path: bool = None,
        namespace_id: str = None,
        protocol: str = None,
        tls_config: TLSConfig = None,
        waf_config: WAFConfig = None,
    ):
        self.application_name = application_name
        self.cert_config = cert_config
        self.domain_name = domain_name
        self.keep_full_path = keep_full_path
        self.namespace_id = namespace_id
        self.protocol = protocol
        self.tls_config = tls_config
        self.waf_config = waf_config

    def validate(self):
        if self.cert_config:
            self.cert_config.validate()
        if self.tls_config:
            self.tls_config.validate()
        if self.waf_config:
            self.waf_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_name is not None:
            result['applicationName'] = self.application_name
        if self.cert_config is not None:
            result['certConfig'] = self.cert_config.to_map()
        if self.domain_name is not None:
            result['domainName'] = self.domain_name
        if self.keep_full_path is not None:
            result['keepFullPath'] = self.keep_full_path
        if self.namespace_id is not None:
            result['namespaceID'] = self.namespace_id
        if self.protocol is not None:
            result['protocol'] = self.protocol
        if self.tls_config is not None:
            result['tlsConfig'] = self.tls_config.to_map()
        if self.waf_config is not None:
            result['wafConfig'] = self.waf_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('applicationName') is not None:
            self.application_name = m.get('applicationName')
        if m.get('certConfig') is not None:
            temp_model = CertConfig()
            self.cert_config = temp_model.from_map(m['certConfig'])
        if m.get('domainName') is not None:
            self.domain_name = m.get('domainName')
        if m.get('keepFullPath') is not None:
            self.keep_full_path = m.get('keepFullPath')
        if m.get('namespaceID') is not None:
            self.namespace_id = m.get('namespaceID')
        if m.get('protocol') is not None:
            self.protocol = m.get('protocol')
        if m.get('tlsConfig') is not None:
            temp_model = TLSConfig()
            self.tls_config = temp_model.from_map(m['tlsConfig'])
        if m.get('wafConfig') is not None:
            temp_model = WAFConfig()
            self.waf_config = temp_model.from_map(m['wafConfig'])
        return self


class CreateSlsIndexRequest(TeaModel):
    def __init__(
        self,
        logstore: str = None,
        project: str = None,
    ):
        self.logstore = logstore
        self.project = project

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logstore is not None:
            result['logstore'] = self.logstore
        if self.project is not None:
            result['project'] = self.project
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('logstore') is not None:
            self.logstore = m.get('logstore')
        if m.get('project') is not None:
            self.project = m.get('project')
        return self


class CreateSlsIndexResponse(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        log_store: str = None,
        project: str = None,
    ):
        self.request_id = request_id
        self.log_store = log_store
        self.project = project

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.log_store is not None:
            result['logStore'] = self.log_store
        if self.project is not None:
            result['project'] = self.project
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('logStore') is not None:
            self.log_store = m.get('logStore')
        if m.get('project') is not None:
            self.project = m.get('project')
        return self


class CreateSlsResourceResponse(TeaModel):
    def __init__(
        self,
        log_store: str = None,
        project: str = None,
        request_id: str = None,
    ):
        self.log_store = log_store
        self.project = project
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.log_store is not None:
            result['logStore'] = self.log_store
        if self.project is not None:
            result['project'] = self.project
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('logStore') is not None:
            self.log_store = m.get('logStore')
        if m.get('project') is not None:
            self.project = m.get('project')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class WebNetworkConfig(TeaModel):
    def __init__(
        self,
        internet_access: bool = None,
        security_group_id: str = None,
        v_switch_ids: List[str] = None,
    ):
        self.internet_access = internet_access
        self.security_group_id = security_group_id
        self.v_switch_ids = v_switch_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.internet_access is not None:
            result['InternetAccess'] = self.internet_access
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.v_switch_ids is not None:
            result['VSwitchIds'] = self.v_switch_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InternetAccess') is not None:
            self.internet_access = m.get('InternetAccess')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('VSwitchIds') is not None:
            self.v_switch_ids = m.get('VSwitchIds')
        return self


class RevisionConfig(TeaModel):
    def __init__(
        self,
        containers: List[Container] = None,
        enable_arms_metrics: bool = None,
        web_network_config: WebNetworkConfig = None,
    ):
        # This parameter is required.
        self.containers = containers
        self.enable_arms_metrics = enable_arms_metrics
        self.web_network_config = web_network_config

    def validate(self):
        if self.containers:
            for k in self.containers:
                if k:
                    k.validate()
        if self.web_network_config:
            self.web_network_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Containers'] = []
        if self.containers is not None:
            for k in self.containers:
                result['Containers'].append(k.to_map() if k else None)
        if self.enable_arms_metrics is not None:
            result['EnableArmsMetrics'] = self.enable_arms_metrics
        if self.web_network_config is not None:
            result['WebNetworkConfig'] = self.web_network_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.containers = []
        if m.get('Containers') is not None:
            for k in m.get('Containers'):
                temp_model = Container()
                self.containers.append(temp_model.from_map(k))
        if m.get('EnableArmsMetrics') is not None:
            self.enable_arms_metrics = m.get('EnableArmsMetrics')
        if m.get('WebNetworkConfig') is not None:
            temp_model = WebNetworkConfig()
            self.web_network_config = temp_model.from_map(m['WebNetworkConfig'])
        return self


class WebScalingConfig(TeaModel):
    def __init__(
        self,
        maximum_instance_count: int = None,
        minimum_instance_count: int = None,
    ):
        self.maximum_instance_count = maximum_instance_count
        self.minimum_instance_count = minimum_instance_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.maximum_instance_count is not None:
            result['MaximumInstanceCount'] = self.maximum_instance_count
        if self.minimum_instance_count is not None:
            result['MinimumInstanceCount'] = self.minimum_instance_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaximumInstanceCount') is not None:
            self.maximum_instance_count = m.get('MaximumInstanceCount')
        if m.get('MinimumInstanceCount') is not None:
            self.minimum_instance_count = m.get('MinimumInstanceCount')
        return self


class WebAclEntryConfig(TeaModel):
    def __init__(
        self,
        entry: str = None,
    ):
        # This parameter is required.
        self.entry = entry

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entry is not None:
            result['Entry'] = self.entry
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Entry') is not None:
            self.entry = m.get('Entry')
        return self


class WebAclConfig(TeaModel):
    def __init__(
        self,
        web_acl_entries: List[WebAclEntryConfig] = None,
    ):
        # This parameter is required.
        self.web_acl_entries = web_acl_entries

    def validate(self):
        if self.web_acl_entries:
            for k in self.web_acl_entries:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WebAclEntries'] = []
        if self.web_acl_entries is not None:
            for k in self.web_acl_entries:
                result['WebAclEntries'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.web_acl_entries = []
        if m.get('WebAclEntries') is not None:
            for k in m.get('WebAclEntries'):
                temp_model = WebAclEntryConfig()
                self.web_acl_entries.append(temp_model.from_map(k))
        return self


class WebTrafficConfig(TeaModel):
    def __init__(
        self,
        auth_type: str = None,
        disable_internet_url: bool = None,
        revisions_traffic_weight: Dict[str, float] = None,
        web_acl_config: WebAclConfig = None,
    ):
        self.auth_type = auth_type
        self.disable_internet_url = disable_internet_url
        self.revisions_traffic_weight = revisions_traffic_weight
        self.web_acl_config = web_acl_config

    def validate(self):
        if self.web_acl_config:
            self.web_acl_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_type is not None:
            result['AuthType'] = self.auth_type
        if self.disable_internet_url is not None:
            result['DisableInternetURL'] = self.disable_internet_url
        if self.revisions_traffic_weight is not None:
            result['RevisionsTrafficWeight'] = self.revisions_traffic_weight
        if self.web_acl_config is not None:
            result['WebAclConfig'] = self.web_acl_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthType') is not None:
            self.auth_type = m.get('AuthType')
        if m.get('DisableInternetURL') is not None:
            self.disable_internet_url = m.get('DisableInternetURL')
        if m.get('RevisionsTrafficWeight') is not None:
            self.revisions_traffic_weight = m.get('RevisionsTrafficWeight')
        if m.get('WebAclConfig') is not None:
            temp_model = WebAclConfig()
            self.web_acl_config = temp_model.from_map(m['WebAclConfig'])
        return self


class CreateWebApplicationInput(TeaModel):
    def __init__(
        self,
        application_name: str = None,
        description: str = None,
        revision_config: RevisionConfig = None,
        web_network_config: WebNetworkConfig = None,
        web_scaling_config: WebScalingConfig = None,
        web_traffic_config: WebTrafficConfig = None,
    ):
        # This parameter is required.
        self.application_name = application_name
        self.description = description
        # This parameter is required.
        self.revision_config = revision_config
        self.web_network_config = web_network_config
        self.web_scaling_config = web_scaling_config
        self.web_traffic_config = web_traffic_config

    def validate(self):
        if self.revision_config:
            self.revision_config.validate()
        if self.web_network_config:
            self.web_network_config.validate()
        if self.web_scaling_config:
            self.web_scaling_config.validate()
        if self.web_traffic_config:
            self.web_traffic_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        if self.description is not None:
            result['Description'] = self.description
        if self.revision_config is not None:
            result['RevisionConfig'] = self.revision_config.to_map()
        if self.web_network_config is not None:
            result['WebNetworkConfig'] = self.web_network_config.to_map()
        if self.web_scaling_config is not None:
            result['WebScalingConfig'] = self.web_scaling_config.to_map()
        if self.web_traffic_config is not None:
            result['WebTrafficConfig'] = self.web_traffic_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RevisionConfig') is not None:
            temp_model = RevisionConfig()
            self.revision_config = temp_model.from_map(m['RevisionConfig'])
        if m.get('WebNetworkConfig') is not None:
            temp_model = WebNetworkConfig()
            self.web_network_config = temp_model.from_map(m['WebNetworkConfig'])
        if m.get('WebScalingConfig') is not None:
            temp_model = WebScalingConfig()
            self.web_scaling_config = temp_model.from_map(m['WebScalingConfig'])
        if m.get('WebTrafficConfig') is not None:
            temp_model = WebTrafficConfig()
            self.web_traffic_config = temp_model.from_map(m['WebTrafficConfig'])
        return self


class PathConfig(TeaModel):
    def __init__(
        self,
        application_name: str = None,
        path: str = None,
    ):
        self.application_name = application_name
        self.path = path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_name is not None:
            result['applicationName'] = self.application_name
        if self.path is not None:
            result['path'] = self.path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('applicationName') is not None:
            self.application_name = m.get('applicationName')
        if m.get('path') is not None:
            self.path = m.get('path')
        return self


class RouteConfig(TeaModel):
    def __init__(
        self,
        routes: List[PathConfig] = None,
    ):
        self.routes = routes

    def validate(self):
        if self.routes:
            for k in self.routes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['routes'] = []
        if self.routes is not None:
            for k in self.routes:
                result['routes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.routes = []
        if m.get('routes') is not None:
            for k in m.get('routes'):
                temp_model = PathConfig()
                self.routes.append(temp_model.from_map(k))
        return self


class WebCertConfig(TeaModel):
    def __init__(
        self,
        cert_name: str = None,
        certificate: str = None,
        private_key: str = None,
    ):
        self.cert_name = cert_name
        self.certificate = certificate
        self.private_key = private_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_name is not None:
            result['CertName'] = self.cert_name
        if self.certificate is not None:
            result['Certificate'] = self.certificate
        if self.private_key is not None:
            result['PrivateKey'] = self.private_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertName') is not None:
            self.cert_name = m.get('CertName')
        if m.get('Certificate') is not None:
            self.certificate = m.get('Certificate')
        if m.get('PrivateKey') is not None:
            self.private_key = m.get('PrivateKey')
        return self


class WebTLSConfig(TeaModel):
    def __init__(
        self,
        cipher_suites: List[str] = None,
        max_version: str = None,
        min_version: str = None,
    ):
        self.cipher_suites = cipher_suites
        self.max_version = max_version
        self.min_version = min_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cipher_suites is not None:
            result['CipherSuites'] = self.cipher_suites
        if self.max_version is not None:
            result['MaxVersion'] = self.max_version
        if self.min_version is not None:
            result['MinVersion'] = self.min_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CipherSuites') is not None:
            self.cipher_suites = m.get('CipherSuites')
        if m.get('MaxVersion') is not None:
            self.max_version = m.get('MaxVersion')
        if m.get('MinVersion') is not None:
            self.min_version = m.get('MinVersion')
        return self


class WebWAFConfig(TeaModel):
    def __init__(
        self,
        enable_waf: bool = None,
    ):
        self.enable_waf = enable_waf

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_waf is not None:
            result['EnableWAF'] = self.enable_waf
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableWAF') is not None:
            self.enable_waf = m.get('EnableWAF')
        return self


class CreateWebCustomDomainInput(TeaModel):
    def __init__(
        self,
        default_forwarding_app_name: str = None,
        domain_name: str = None,
        protocol: str = None,
        route_config: RouteConfig = None,
        web_cert_config: WebCertConfig = None,
        web_tlsconfig: WebTLSConfig = None,
        web_wafconfig: WebWAFConfig = None,
    ):
        self.default_forwarding_app_name = default_forwarding_app_name
        # This parameter is required.
        self.domain_name = domain_name
        self.protocol = protocol
        self.route_config = route_config
        self.web_cert_config = web_cert_config
        self.web_tlsconfig = web_tlsconfig
        self.web_wafconfig = web_wafconfig

    def validate(self):
        if self.route_config:
            self.route_config.validate()
        if self.web_cert_config:
            self.web_cert_config.validate()
        if self.web_tlsconfig:
            self.web_tlsconfig.validate()
        if self.web_wafconfig:
            self.web_wafconfig.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_forwarding_app_name is not None:
            result['DefaultForwardingAppName'] = self.default_forwarding_app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.route_config is not None:
            result['RouteConfig'] = self.route_config.to_map()
        if self.web_cert_config is not None:
            result['WebCertConfig'] = self.web_cert_config.to_map()
        if self.web_tlsconfig is not None:
            result['WebTLSConfig'] = self.web_tlsconfig.to_map()
        if self.web_wafconfig is not None:
            result['WebWAFConfig'] = self.web_wafconfig.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DefaultForwardingAppName') is not None:
            self.default_forwarding_app_name = m.get('DefaultForwardingAppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('RouteConfig') is not None:
            temp_model = RouteConfig()
            self.route_config = temp_model.from_map(m['RouteConfig'])
        if m.get('WebCertConfig') is not None:
            temp_model = WebCertConfig()
            self.web_cert_config = temp_model.from_map(m['WebCertConfig'])
        if m.get('WebTLSConfig') is not None:
            temp_model = WebTLSConfig()
            self.web_tlsconfig = temp_model.from_map(m['WebTLSConfig'])
        if m.get('WebWAFConfig') is not None:
            temp_model = WebWAFConfig()
            self.web_wafconfig = temp_model.from_map(m['WebWAFConfig'])
        return self


class CustomDomain(TeaModel):
    def __init__(
        self,
        account_id: str = None,
        api_version: str = None,
        cert_config: CertConfig = None,
        created_time: str = None,
        domain_name: str = None,
        keep_full_path: bool = None,
        last_modified_time: str = None,
        namespace_id: str = None,
        protocol: str = None,
        request_id: str = None,
        route_config: RouteConfig = None,
        subdomain_count: str = None,
        tls_config: TLSConfig = None,
        waf_config: WAFConfig = None,
    ):
        self.account_id = account_id
        self.api_version = api_version
        self.cert_config = cert_config
        self.created_time = created_time
        self.domain_name = domain_name
        self.keep_full_path = keep_full_path
        self.last_modified_time = last_modified_time
        self.namespace_id = namespace_id
        self.protocol = protocol
        self.request_id = request_id
        self.route_config = route_config
        self.subdomain_count = subdomain_count
        self.tls_config = tls_config
        self.waf_config = waf_config

    def validate(self):
        if self.cert_config:
            self.cert_config.validate()
        if self.route_config:
            self.route_config.validate()
        if self.tls_config:
            self.tls_config.validate()
        if self.waf_config:
            self.waf_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        if self.api_version is not None:
            result['apiVersion'] = self.api_version
        if self.cert_config is not None:
            result['certConfig'] = self.cert_config.to_map()
        if self.created_time is not None:
            result['createdTime'] = self.created_time
        if self.domain_name is not None:
            result['domainName'] = self.domain_name
        if self.keep_full_path is not None:
            result['keepFullPath'] = self.keep_full_path
        if self.last_modified_time is not None:
            result['lastModifiedTime'] = self.last_modified_time
        if self.namespace_id is not None:
            result['namespaceID'] = self.namespace_id
        if self.protocol is not None:
            result['protocol'] = self.protocol
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.route_config is not None:
            result['routeConfig'] = self.route_config.to_map()
        if self.subdomain_count is not None:
            result['subdomainCount'] = self.subdomain_count
        if self.tls_config is not None:
            result['tlsConfig'] = self.tls_config.to_map()
        if self.waf_config is not None:
            result['wafConfig'] = self.waf_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        if m.get('apiVersion') is not None:
            self.api_version = m.get('apiVersion')
        if m.get('certConfig') is not None:
            temp_model = CertConfig()
            self.cert_config = temp_model.from_map(m['certConfig'])
        if m.get('createdTime') is not None:
            self.created_time = m.get('createdTime')
        if m.get('domainName') is not None:
            self.domain_name = m.get('domainName')
        if m.get('keepFullPath') is not None:
            self.keep_full_path = m.get('keepFullPath')
        if m.get('lastModifiedTime') is not None:
            self.last_modified_time = m.get('lastModifiedTime')
        if m.get('namespaceID') is not None:
            self.namespace_id = m.get('namespaceID')
        if m.get('protocol') is not None:
            self.protocol = m.get('protocol')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('routeConfig') is not None:
            temp_model = RouteConfig()
            self.route_config = temp_model.from_map(m['routeConfig'])
        if m.get('subdomainCount') is not None:
            self.subdomain_count = m.get('subdomainCount')
        if m.get('tlsConfig') is not None:
            temp_model = TLSConfig()
            self.tls_config = temp_model.from_map(m['tlsConfig'])
        if m.get('wafConfig') is not None:
            temp_model = WAFConfig()
            self.waf_config = temp_model.from_map(m['wafConfig'])
        return self


class WebLogEntry(TeaModel):
    def __init__(
        self,
        message: str = None,
    ):
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class DescribeInstanceLogsOutput(TeaModel):
    def __init__(
        self,
        web_log_entrys: List[WebLogEntry] = None,
    ):
        self.web_log_entrys = web_log_entrys

    def validate(self):
        if self.web_log_entrys:
            for k in self.web_log_entrys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WebLogEntrys'] = []
        if self.web_log_entrys is not None:
            for k in self.web_log_entrys:
                result['WebLogEntrys'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.web_log_entrys = []
        if m.get('WebLogEntrys') is not None:
            for k in m.get('WebLogEntrys'):
                temp_model = WebLogEntry()
                self.web_log_entrys.append(temp_model.from_map(k))
        return self


class WebStaticsInfo(TeaModel):
    def __init__(
        self,
        cpu_usage: int = None,
        internet_traffic_out: int = None,
        invocations: int = None,
        memory_usage: int = None,
    ):
        self.cpu_usage = cpu_usage
        self.internet_traffic_out = internet_traffic_out
        self.invocations = invocations
        self.memory_usage = memory_usage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu_usage is not None:
            result['CpuUsage'] = self.cpu_usage
        if self.internet_traffic_out is not None:
            result['InternetTrafficOut'] = self.internet_traffic_out
        if self.invocations is not None:
            result['Invocations'] = self.invocations
        if self.memory_usage is not None:
            result['MemoryUsage'] = self.memory_usage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CpuUsage') is not None:
            self.cpu_usage = m.get('CpuUsage')
        if m.get('InternetTrafficOut') is not None:
            self.internet_traffic_out = m.get('InternetTrafficOut')
        if m.get('Invocations') is not None:
            self.invocations = m.get('Invocations')
        if m.get('MemoryUsage') is not None:
            self.memory_usage = m.get('MemoryUsage')
        return self


class DescribeWebAppStaticsOutput(TeaModel):
    def __init__(
        self,
        length: int = None,
        web_app_statics: List[WebStaticsInfo] = None,
    ):
        self.length = length
        self.web_app_statics = web_app_statics

    def validate(self):
        if self.web_app_statics:
            for k in self.web_app_statics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.length is not None:
            result['Length'] = self.length
        result['WebAppStatics'] = []
        if self.web_app_statics is not None:
            for k in self.web_app_statics:
                result['WebAppStatics'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Length') is not None:
            self.length = m.get('Length')
        self.web_app_statics = []
        if m.get('WebAppStatics') is not None:
            for k in m.get('WebAppStatics'):
                temp_model = WebStaticsInfo()
                self.web_app_statics.append(temp_model.from_map(k))
        return self


class DescribeWebStaticsQueryOutput(TeaModel):
    def __init__(
        self,
        length: int = None,
        web_statics: List[WebStaticsInfo] = None,
    ):
        self.length = length
        self.web_statics = web_statics

    def validate(self):
        if self.web_statics:
            for k in self.web_statics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.length is not None:
            result['Length'] = self.length
        result['WebStatics'] = []
        if self.web_statics is not None:
            for k in self.web_statics:
                result['WebStatics'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Length') is not None:
            self.length = m.get('Length')
        self.web_statics = []
        if m.get('WebStatics') is not None:
            for k in m.get('WebStatics'):
                temp_model = WebStaticsInfo()
                self.web_statics.append(temp_model.from_map(k))
        return self


class ExecAction(TeaModel):
    def __init__(
        self,
        command: List[str] = None,
    ):
        self.command = command

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['command'] = self.command
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('command') is not None:
            self.command = m.get('command')
        return self


class ExternalErrorSAEWeb(TeaModel):
    def __init__(
        self,
        code: int = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GRPCAction(TeaModel):
    def __init__(
        self,
        port: int = None,
        service: str = None,
    ):
        self.port = port
        self.service = service

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.port is not None:
            result['port'] = self.port
        if self.service is not None:
            result['service'] = self.service
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('port') is not None:
            self.port = m.get('port')
        if m.get('service') is not None:
            self.service = m.get('service')
        return self


class GetApplicationLogsInput(TeaModel):
    def __init__(
        self,
        backward_line: int = None,
        end_time: int = None,
        forward_line: int = None,
        instance_id: str = None,
        is_tail: bool = None,
        match: str = None,
        message: str = None,
        offset: int = None,
        pack_id: str = None,
        pack_meta: str = None,
        start_time: int = None,
        timestamp: str = None,
        version_id: str = None,
    ):
        self.backward_line = backward_line
        # This parameter is required.
        self.end_time = end_time
        self.forward_line = forward_line
        self.instance_id = instance_id
        self.is_tail = is_tail
        self.match = match
        self.message = message
        self.offset = offset
        self.pack_id = pack_id
        self.pack_meta = pack_meta
        # This parameter is required.
        self.start_time = start_time
        self.timestamp = timestamp
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backward_line is not None:
            result['backwardLine'] = self.backward_line
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.forward_line is not None:
            result['forwardLine'] = self.forward_line
        if self.instance_id is not None:
            result['instanceID'] = self.instance_id
        if self.is_tail is not None:
            result['isTail'] = self.is_tail
        if self.match is not None:
            result['match'] = self.match
        if self.message is not None:
            result['message'] = self.message
        if self.offset is not None:
            result['offset'] = self.offset
        if self.pack_id is not None:
            result['packID'] = self.pack_id
        if self.pack_meta is not None:
            result['packMeta'] = self.pack_meta
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.timestamp is not None:
            result['timestamp'] = self.timestamp
        if self.version_id is not None:
            result['versionID'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('backwardLine') is not None:
            self.backward_line = m.get('backwardLine')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('forwardLine') is not None:
            self.forward_line = m.get('forwardLine')
        if m.get('instanceID') is not None:
            self.instance_id = m.get('instanceID')
        if m.get('isTail') is not None:
            self.is_tail = m.get('isTail')
        if m.get('match') is not None:
            self.match = m.get('match')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('offset') is not None:
            self.offset = m.get('offset')
        if m.get('packID') is not None:
            self.pack_id = m.get('packID')
        if m.get('packMeta') is not None:
            self.pack_meta = m.get('packMeta')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('timestamp') is not None:
            self.timestamp = m.get('timestamp')
        if m.get('versionID') is not None:
            self.version_id = m.get('versionID')
        return self


class LogEntry(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        message: str = None,
        offset: int = None,
        pack_id: str = None,
        pack_meta: str = None,
        qualifier: str = None,
        timestamp: int = None,
        version_id: str = None,
    ):
        self.instance_id = instance_id
        self.message = message
        self.offset = offset
        self.pack_id = pack_id
        self.pack_meta = pack_meta
        self.qualifier = qualifier
        self.timestamp = timestamp
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['instanceID'] = self.instance_id
        if self.message is not None:
            result['message'] = self.message
        if self.offset is not None:
            result['offset'] = self.offset
        if self.pack_id is not None:
            result['packID'] = self.pack_id
        if self.pack_meta is not None:
            result['packMeta'] = self.pack_meta
        if self.qualifier is not None:
            result['qualifier'] = self.qualifier
        if self.timestamp is not None:
            result['timestamp'] = self.timestamp
        if self.version_id is not None:
            result['versionID'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('instanceID') is not None:
            self.instance_id = m.get('instanceID')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('offset') is not None:
            self.offset = m.get('offset')
        if m.get('packID') is not None:
            self.pack_id = m.get('packID')
        if m.get('packMeta') is not None:
            self.pack_meta = m.get('packMeta')
        if m.get('qualifier') is not None:
            self.qualifier = m.get('qualifier')
        if m.get('timestamp') is not None:
            self.timestamp = m.get('timestamp')
        if m.get('versionID') is not None:
            self.version_id = m.get('versionID')
        return self


class GetApplicationLogsOutput(TeaModel):
    def __init__(
        self,
        log_entrys: List[LogEntry] = None,
        next_offset: int = None,
        request_id: str = None,
    ):
        self.log_entrys = log_entrys
        self.next_offset = next_offset
        self.request_id = request_id

    def validate(self):
        if self.log_entrys:
            for k in self.log_entrys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['logEntrys'] = []
        if self.log_entrys is not None:
            for k in self.log_entrys:
                result['logEntrys'].append(k.to_map() if k else None)
        if self.next_offset is not None:
            result['nextOffset'] = self.next_offset
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.log_entrys = []
        if m.get('logEntrys') is not None:
            for k in m.get('logEntrys'):
                temp_model = LogEntry()
                self.log_entrys.append(temp_model.from_map(k))
        if m.get('nextOffset') is not None:
            self.next_offset = m.get('nextOffset')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetInstanceLogsInput(TeaModel):
    def __init__(
        self,
        backward_line: int = None,
        end_time: int = None,
        forward_line: int = None,
        is_tail: bool = None,
        match: str = None,
        message: str = None,
        offset: int = None,
        pack_id: str = None,
        pack_meta: str = None,
        start_time: int = None,
        timestamp: str = None,
        version_id: str = None,
    ):
        self.backward_line = backward_line
        # This parameter is required.
        self.end_time = end_time
        self.forward_line = forward_line
        self.is_tail = is_tail
        self.match = match
        self.message = message
        self.offset = offset
        self.pack_id = pack_id
        self.pack_meta = pack_meta
        # This parameter is required.
        self.start_time = start_time
        self.timestamp = timestamp
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backward_line is not None:
            result['backwardLine'] = self.backward_line
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.forward_line is not None:
            result['forwardLine'] = self.forward_line
        if self.is_tail is not None:
            result['isTail'] = self.is_tail
        if self.match is not None:
            result['match'] = self.match
        if self.message is not None:
            result['message'] = self.message
        if self.offset is not None:
            result['offset'] = self.offset
        if self.pack_id is not None:
            result['packID'] = self.pack_id
        if self.pack_meta is not None:
            result['packMeta'] = self.pack_meta
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.timestamp is not None:
            result['timestamp'] = self.timestamp
        if self.version_id is not None:
            result['versionID'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('backwardLine') is not None:
            self.backward_line = m.get('backwardLine')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('forwardLine') is not None:
            self.forward_line = m.get('forwardLine')
        if m.get('isTail') is not None:
            self.is_tail = m.get('isTail')
        if m.get('match') is not None:
            self.match = m.get('match')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('offset') is not None:
            self.offset = m.get('offset')
        if m.get('packID') is not None:
            self.pack_id = m.get('packID')
        if m.get('packMeta') is not None:
            self.pack_meta = m.get('packMeta')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('timestamp') is not None:
            self.timestamp = m.get('timestamp')
        if m.get('versionID') is not None:
            self.version_id = m.get('versionID')
        return self


class GetInstanceLogsOutput(TeaModel):
    def __init__(
        self,
        data: str = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetPerRequestLogsInput(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        error_type: str = None,
        forward_line: int = None,
        instance_id: str = None,
        is_cold_start: bool = None,
        request_id: str = None,
        start_time: int = None,
        timestamp: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        self.error_type = error_type
        self.forward_line = forward_line
        self.instance_id = instance_id
        self.is_cold_start = is_cold_start
        # This parameter is required.
        self.request_id = request_id
        # This parameter is required.
        self.start_time = start_time
        self.timestamp = timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.error_type is not None:
            result['errorType'] = self.error_type
        if self.forward_line is not None:
            result['forwardLine'] = self.forward_line
        if self.instance_id is not None:
            result['instanceID'] = self.instance_id
        if self.is_cold_start is not None:
            result['isColdStart'] = self.is_cold_start
        if self.request_id is not None:
            result['requestID'] = self.request_id
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.timestamp is not None:
            result['timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('errorType') is not None:
            self.error_type = m.get('errorType')
        if m.get('forwardLine') is not None:
            self.forward_line = m.get('forwardLine')
        if m.get('instanceID') is not None:
            self.instance_id = m.get('instanceID')
        if m.get('isColdStart') is not None:
            self.is_cold_start = m.get('isColdStart')
        if m.get('requestID') is not None:
            self.request_id = m.get('requestID')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('timestamp') is not None:
            self.timestamp = m.get('timestamp')
        return self


class GetPerRequestLogsOutput(TeaModel):
    def __init__(
        self,
        data: str = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetQuotaOutput(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        instance_limit: int = None,
        instance_used: int = None,
    ):
        self.request_id = request_id
        self.instance_limit = instance_limit
        self.instance_used = instance_used

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.instance_limit is not None:
            result['instanceLimit'] = self.instance_limit
        if self.instance_used is not None:
            result['instanceUsed'] = self.instance_used
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('instanceLimit') is not None:
            self.instance_limit = m.get('instanceLimit')
        if m.get('instanceUsed') is not None:
            self.instance_used = m.get('instanceUsed')
        return self


class HttpApiRouteDomains(TeaModel):
    def __init__(
        self,
        domain_id: str = None,
        domain_name: str = None,
    ):
        self.domain_id = domain_id
        self.domain_name = domain_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['DomainId'] = self.domain_id
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainId') is not None:
            self.domain_id = m.get('DomainId')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        return self


class HttpApiRoutePoliciesFallbackDestinations(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        service_id: str = None,
        service_name: str = None,
        service_port: int = None,
        service_protocol: str = None,
    ):
        self.app_id = app_id
        self.app_name = app_name
        self.service_id = service_id
        self.service_name = service_name
        self.service_port = service_port
        self.service_protocol = service_protocol

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.service_id is not None:
            result['ServiceId'] = self.service_id
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        if self.service_port is not None:
            result['ServicePort'] = self.service_port
        if self.service_protocol is not None:
            result['ServiceProtocol'] = self.service_protocol
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ServiceId') is not None:
            self.service_id = m.get('ServiceId')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        if m.get('ServicePort') is not None:
            self.service_port = m.get('ServicePort')
        if m.get('ServiceProtocol') is not None:
            self.service_protocol = m.get('ServiceProtocol')
        return self


class HttpApiRoutePoliciesFallback(TeaModel):
    def __init__(
        self,
        destinations: List[HttpApiRoutePoliciesFallbackDestinations] = None,
        enable: bool = None,
    ):
        self.destinations = destinations
        self.enable = enable

    def validate(self):
        if self.destinations:
            for k in self.destinations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Destinations'] = []
        if self.destinations is not None:
            for k in self.destinations:
                result['Destinations'].append(k.to_map() if k else None)
        if self.enable is not None:
            result['Enable'] = self.enable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.destinations = []
        if m.get('Destinations') is not None:
            for k in m.get('Destinations'):
                temp_model = HttpApiRoutePoliciesFallbackDestinations()
                self.destinations.append(temp_model.from_map(k))
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        return self


class HttpApiRoutePoliciesRetry(TeaModel):
    def __init__(
        self,
        attempts: int = None,
        enable: bool = None,
        http_codes: List[str] = None,
        retry_on: List[str] = None,
    ):
        self.attempts = attempts
        self.enable = enable
        self.http_codes = http_codes
        self.retry_on = retry_on

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attempts is not None:
            result['Attempts'] = self.attempts
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.http_codes is not None:
            result['HttpCodes'] = self.http_codes
        if self.retry_on is not None:
            result['RetryOn'] = self.retry_on
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Attempts') is not None:
            self.attempts = m.get('Attempts')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('HttpCodes') is not None:
            self.http_codes = m.get('HttpCodes')
        if m.get('RetryOn') is not None:
            self.retry_on = m.get('RetryOn')
        return self


class HttpApiRoutePoliciesTimeout(TeaModel):
    def __init__(
        self,
        enable: bool = None,
        time_unit: str = None,
        unit_num: int = None,
    ):
        self.enable = enable
        self.time_unit = time_unit
        self.unit_num = unit_num

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.time_unit is not None:
            result['TimeUnit'] = self.time_unit
        if self.unit_num is not None:
            result['UnitNum'] = self.unit_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('TimeUnit') is not None:
            self.time_unit = m.get('TimeUnit')
        if m.get('UnitNum') is not None:
            self.unit_num = m.get('UnitNum')
        return self


class HttpApiRoutePolicies(TeaModel):
    def __init__(
        self,
        fallback: HttpApiRoutePoliciesFallback = None,
        retry: HttpApiRoutePoliciesRetry = None,
        timeout: HttpApiRoutePoliciesTimeout = None,
    ):
        self.fallback = fallback
        self.retry = retry
        self.timeout = timeout

    def validate(self):
        if self.fallback:
            self.fallback.validate()
        if self.retry:
            self.retry.validate()
        if self.timeout:
            self.timeout.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fallback is not None:
            result['Fallback'] = self.fallback.to_map()
        if self.retry is not None:
            result['Retry'] = self.retry.to_map()
        if self.timeout is not None:
            result['Timeout'] = self.timeout.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Fallback') is not None:
            temp_model = HttpApiRoutePoliciesFallback()
            self.fallback = temp_model.from_map(m['Fallback'])
        if m.get('Retry') is not None:
            temp_model = HttpApiRoutePoliciesRetry()
            self.retry = temp_model.from_map(m['Retry'])
        if m.get('Timeout') is not None:
            temp_model = HttpApiRoutePoliciesTimeout()
            self.timeout = temp_model.from_map(m['Timeout'])
        return self


class HttpApiRoutePredicatesHeaderPredicates(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        value: str = None,
    ):
        self.name = name
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class HttpApiRoutePredicatesPathPredicates(TeaModel):
    def __init__(
        self,
        ignore_case: bool = None,
        path: str = None,
        type: str = None,
    ):
        self.ignore_case = ignore_case
        self.path = path
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ignore_case is not None:
            result['IgnoreCase'] = self.ignore_case
        if self.path is not None:
            result['Path'] = self.path
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IgnoreCase') is not None:
            self.ignore_case = m.get('IgnoreCase')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class HttpApiRoutePredicatesQueryPredicates(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        value: str = None,
    ):
        self.name = name
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class HttpApiRoutePredicates(TeaModel):
    def __init__(
        self,
        header_predicates: List[HttpApiRoutePredicatesHeaderPredicates] = None,
        method_predicates: List[str] = None,
        path_predicates: HttpApiRoutePredicatesPathPredicates = None,
        query_predicates: List[HttpApiRoutePredicatesQueryPredicates] = None,
    ):
        self.header_predicates = header_predicates
        self.method_predicates = method_predicates
        self.path_predicates = path_predicates
        self.query_predicates = query_predicates

    def validate(self):
        if self.header_predicates:
            for k in self.header_predicates:
                if k:
                    k.validate()
        if self.path_predicates:
            self.path_predicates.validate()
        if self.query_predicates:
            for k in self.query_predicates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['HeaderPredicates'] = []
        if self.header_predicates is not None:
            for k in self.header_predicates:
                result['HeaderPredicates'].append(k.to_map() if k else None)
        if self.method_predicates is not None:
            result['MethodPredicates'] = self.method_predicates
        if self.path_predicates is not None:
            result['PathPredicates'] = self.path_predicates.to_map()
        result['QueryPredicates'] = []
        if self.query_predicates is not None:
            for k in self.query_predicates:
                result['QueryPredicates'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.header_predicates = []
        if m.get('HeaderPredicates') is not None:
            for k in m.get('HeaderPredicates'):
                temp_model = HttpApiRoutePredicatesHeaderPredicates()
                self.header_predicates.append(temp_model.from_map(k))
        if m.get('MethodPredicates') is not None:
            self.method_predicates = m.get('MethodPredicates')
        if m.get('PathPredicates') is not None:
            temp_model = HttpApiRoutePredicatesPathPredicates()
            self.path_predicates = temp_model.from_map(m['PathPredicates'])
        self.query_predicates = []
        if m.get('QueryPredicates') is not None:
            for k in m.get('QueryPredicates'):
                temp_model = HttpApiRoutePredicatesQueryPredicates()
                self.query_predicates.append(temp_model.from_map(k))
        return self


class HttpApiRouteServices(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        service_id: str = None,
        service_name: str = None,
        service_port: int = None,
        service_protocol: str = None,
        service_weight: int = None,
    ):
        self.app_id = app_id
        self.app_name = app_name
        self.service_id = service_id
        self.service_name = service_name
        self.service_port = service_port
        self.service_protocol = service_protocol
        self.service_weight = service_weight

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.service_id is not None:
            result['ServiceId'] = self.service_id
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        if self.service_port is not None:
            result['ServicePort'] = self.service_port
        if self.service_protocol is not None:
            result['ServiceProtocol'] = self.service_protocol
        if self.service_weight is not None:
            result['ServiceWeight'] = self.service_weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ServiceId') is not None:
            self.service_id = m.get('ServiceId')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        if m.get('ServicePort') is not None:
            self.service_port = m.get('ServicePort')
        if m.get('ServiceProtocol') is not None:
            self.service_protocol = m.get('ServiceProtocol')
        if m.get('ServiceWeight') is not None:
            self.service_weight = m.get('ServiceWeight')
        return self


class HttpApiRoute(TeaModel):
    def __init__(
        self,
        address_type: str = None,
        deploy_status: str = None,
        destination_type: str = None,
        domains: List[HttpApiRouteDomains] = None,
        environment_id: str = None,
        gateway_id: str = None,
        http_api_id: str = None,
        http_api_name: str = None,
        http_api_type: str = None,
        ingress_id: int = None,
        nacos_instance_id: str = None,
        nacos_namespace_id: str = None,
        name: str = None,
        namespace_id: str = None,
        policies: HttpApiRoutePolicies = None,
        predicates: HttpApiRoutePredicates = None,
        route_id: str = None,
        services: List[HttpApiRouteServices] = None,
        source_type: str = None,
    ):
        self.address_type = address_type
        self.deploy_status = deploy_status
        self.destination_type = destination_type
        self.domains = domains
        self.environment_id = environment_id
        self.gateway_id = gateway_id
        self.http_api_id = http_api_id
        self.http_api_name = http_api_name
        self.http_api_type = http_api_type
        self.ingress_id = ingress_id
        self.nacos_instance_id = nacos_instance_id
        self.nacos_namespace_id = nacos_namespace_id
        self.name = name
        self.namespace_id = namespace_id
        self.policies = policies
        self.predicates = predicates
        self.route_id = route_id
        self.services = services
        self.source_type = source_type

    def validate(self):
        if self.domains:
            for k in self.domains:
                if k:
                    k.validate()
        if self.policies:
            self.policies.validate()
        if self.predicates:
            self.predicates.validate()
        if self.services:
            for k in self.services:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_type is not None:
            result['AddressType'] = self.address_type
        if self.deploy_status is not None:
            result['DeployStatus'] = self.deploy_status
        if self.destination_type is not None:
            result['DestinationType'] = self.destination_type
        result['Domains'] = []
        if self.domains is not None:
            for k in self.domains:
                result['Domains'].append(k.to_map() if k else None)
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.gateway_id is not None:
            result['GatewayId'] = self.gateway_id
        if self.http_api_id is not None:
            result['HttpApiId'] = self.http_api_id
        if self.http_api_name is not None:
            result['HttpApiName'] = self.http_api_name
        if self.http_api_type is not None:
            result['HttpApiType'] = self.http_api_type
        if self.ingress_id is not None:
            result['IngressId'] = self.ingress_id
        if self.nacos_instance_id is not None:
            result['NacosInstanceId'] = self.nacos_instance_id
        if self.nacos_namespace_id is not None:
            result['NacosNamespaceId'] = self.nacos_namespace_id
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.policies is not None:
            result['Policies'] = self.policies.to_map()
        if self.predicates is not None:
            result['Predicates'] = self.predicates.to_map()
        if self.route_id is not None:
            result['RouteId'] = self.route_id
        result['Services'] = []
        if self.services is not None:
            for k in self.services:
                result['Services'].append(k.to_map() if k else None)
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressType') is not None:
            self.address_type = m.get('AddressType')
        if m.get('DeployStatus') is not None:
            self.deploy_status = m.get('DeployStatus')
        if m.get('DestinationType') is not None:
            self.destination_type = m.get('DestinationType')
        self.domains = []
        if m.get('Domains') is not None:
            for k in m.get('Domains'):
                temp_model = HttpApiRouteDomains()
                self.domains.append(temp_model.from_map(k))
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('GatewayId') is not None:
            self.gateway_id = m.get('GatewayId')
        if m.get('HttpApiId') is not None:
            self.http_api_id = m.get('HttpApiId')
        if m.get('HttpApiName') is not None:
            self.http_api_name = m.get('HttpApiName')
        if m.get('HttpApiType') is not None:
            self.http_api_type = m.get('HttpApiType')
        if m.get('IngressId') is not None:
            self.ingress_id = m.get('IngressId')
        if m.get('NacosInstanceId') is not None:
            self.nacos_instance_id = m.get('NacosInstanceId')
        if m.get('NacosNamespaceId') is not None:
            self.nacos_namespace_id = m.get('NacosNamespaceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('Policies') is not None:
            temp_model = HttpApiRoutePolicies()
            self.policies = temp_model.from_map(m['Policies'])
        if m.get('Predicates') is not None:
            temp_model = HttpApiRoutePredicates()
            self.predicates = temp_model.from_map(m['Predicates'])
        if m.get('RouteId') is not None:
            self.route_id = m.get('RouteId')
        self.services = []
        if m.get('Services') is not None:
            for k in m.get('Services'):
                temp_model = HttpApiRouteServices()
                self.services.append(temp_model.from_map(k))
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        return self


class InitContainerConfig(TeaModel):
    def __init__(
        self,
        command: str = None,
        command_args: str = None,
        config_map_mount_desc: str = None,
        envs: str = None,
        image_url: str = None,
        name: str = None,
    ):
        self.command = command
        self.command_args = command_args
        self.config_map_mount_desc = config_map_mount_desc
        self.envs = envs
        self.image_url = image_url
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        if self.config_map_mount_desc is not None:
            result['ConfigMapMountDesc'] = self.config_map_mount_desc
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        if m.get('ConfigMapMountDesc') is not None:
            self.config_map_mount_desc = m.get('ConfigMapMountDesc')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class InstanceExecAuthorizationInputOptions(TeaModel):
    def __init__(
        self,
        command: List[str] = None,
        stderr: bool = None,
        stdin: bool = None,
        stdout: bool = None,
        tty: bool = None,
    ):
        self.command = command
        self.stderr = stderr
        self.stdin = stdin
        self.stdout = stdout
        self.tty = tty

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['command'] = self.command
        if self.stderr is not None:
            result['stderr'] = self.stderr
        if self.stdin is not None:
            result['stdin'] = self.stdin
        if self.stdout is not None:
            result['stdout'] = self.stdout
        if self.tty is not None:
            result['tty'] = self.tty
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('command') is not None:
            self.command = m.get('command')
        if m.get('stderr') is not None:
            self.stderr = m.get('stderr')
        if m.get('stdin') is not None:
            self.stdin = m.get('stdin')
        if m.get('stdout') is not None:
            self.stdout = m.get('stdout')
        if m.get('tty') is not None:
            self.tty = m.get('tty')
        return self


class InstanceExecAuthorizationInput(TeaModel):
    def __init__(
        self,
        options: InstanceExecAuthorizationInputOptions = None,
    ):
        self.options = options

    def validate(self):
        if self.options:
            self.options.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.options is not None:
            result['options'] = self.options.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('options') is not None:
            temp_model = InstanceExecAuthorizationInputOptions()
            self.options = temp_model.from_map(m['options'])
        return self


class InstanceExecAuthorizationOutput(TeaModel):
    def __init__(
        self,
        access_key_id: str = None,
        account_id: str = None,
        authorization: str = None,
        date: str = None,
        endpoint: str = None,
        request_id: str = None,
    ):
        self.access_key_id = access_key_id
        self.account_id = account_id
        self.authorization = authorization
        self.date = date
        self.endpoint = endpoint
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_key_id is not None:
            result['accessKeyId'] = self.access_key_id
        if self.account_id is not None:
            result['accountId'] = self.account_id
        if self.authorization is not None:
            result['authorization'] = self.authorization
        if self.date is not None:
            result['date'] = self.date
        if self.endpoint is not None:
            result['endpoint'] = self.endpoint
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessKeyId') is not None:
            self.access_key_id = m.get('accessKeyId')
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        if m.get('authorization') is not None:
            self.authorization = m.get('authorization')
        if m.get('date') is not None:
            self.date = m.get('date')
        if m.get('endpoint') is not None:
            self.endpoint = m.get('endpoint')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class InstanceInfo(TeaModel):
    def __init__(
        self,
        image_url: str = None,
        instance_id: str = None,
        status: str = None,
        version_id: str = None,
    ):
        self.image_url = image_url
        self.instance_id = instance_id
        self.status = status
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_url is not None:
            result['imageUrl'] = self.image_url
        if self.instance_id is not None:
            result['instanceId'] = self.instance_id
        if self.status is not None:
            result['status'] = self.status
        if self.version_id is not None:
            result['versionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('imageUrl') is not None:
            self.image_url = m.get('imageUrl')
        if m.get('instanceId') is not None:
            self.instance_id = m.get('instanceId')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('versionId') is not None:
            self.version_id = m.get('versionId')
        return self


class InstanceMetricInfo(TeaModel):
    def __init__(
        self,
        application_id: str = None,
        cpu_percent: float = None,
        cpu_quota_percent: float = None,
        instance_id: str = None,
        memory_limit_mb: float = None,
        memory_usage_mb: float = None,
        timestamp: int = None,
    ):
        self.application_id = application_id
        self.cpu_percent = cpu_percent
        self.cpu_quota_percent = cpu_quota_percent
        self.instance_id = instance_id
        self.memory_limit_mb = memory_limit_mb
        self.memory_usage_mb = memory_usage_mb
        self.timestamp = timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_id is not None:
            result['applicationID'] = self.application_id
        if self.cpu_percent is not None:
            result['cpuPercent'] = self.cpu_percent
        if self.cpu_quota_percent is not None:
            result['cpuQuotaPercent'] = self.cpu_quota_percent
        if self.instance_id is not None:
            result['instanceID'] = self.instance_id
        if self.memory_limit_mb is not None:
            result['memoryLimitMB'] = self.memory_limit_mb
        if self.memory_usage_mb is not None:
            result['memoryUsageMB'] = self.memory_usage_mb
        if self.timestamp is not None:
            result['timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('applicationID') is not None:
            self.application_id = m.get('applicationID')
        if m.get('cpuPercent') is not None:
            self.cpu_percent = m.get('cpuPercent')
        if m.get('cpuQuotaPercent') is not None:
            self.cpu_quota_percent = m.get('cpuQuotaPercent')
        if m.get('instanceID') is not None:
            self.instance_id = m.get('instanceID')
        if m.get('memoryLimitMB') is not None:
            self.memory_limit_mb = m.get('memoryLimitMB')
        if m.get('memoryUsageMB') is not None:
            self.memory_usage_mb = m.get('memoryUsageMB')
        if m.get('timestamp') is not None:
            self.timestamp = m.get('timestamp')
        return self


class ListApplicationVersionsOutput(TeaModel):
    def __init__(
        self,
        direction: str = None,
        next_token: str = None,
        request_id: str = None,
        versions: List[Version] = None,
    ):
        self.direction = direction
        self.next_token = next_token
        self.request_id = request_id
        self.versions = versions

    def validate(self):
        if self.versions:
            for k in self.versions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.direction is not None:
            result['direction'] = self.direction
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['versions'] = []
        if self.versions is not None:
            for k in self.versions:
                result['versions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('direction') is not None:
            self.direction = m.get('direction')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.versions = []
        if m.get('versions') is not None:
            for k in m.get('versions'):
                temp_model = Version()
                self.versions.append(temp_model.from_map(k))
        return self


class ListApplicationsOutput(TeaModel):
    def __init__(
        self,
        applications: List[Application] = None,
        next_token: str = None,
        request_id: str = None,
    ):
        self.applications = applications
        self.next_token = next_token
        self.request_id = request_id

    def validate(self):
        if self.applications:
            for k in self.applications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['applications'] = []
        if self.applications is not None:
            for k in self.applications:
                result['applications'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.applications = []
        if m.get('applications') is not None:
            for k in m.get('applications'):
                temp_model = Application()
                self.applications.append(temp_model.from_map(k))
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ListApplicationsWithStatusOutput(TeaModel):
    def __init__(
        self,
        applications: List[ApplicationWithStatus] = None,
        next_token: str = None,
        request_id: str = None,
    ):
        self.applications = applications
        self.next_token = next_token
        self.request_id = request_id

    def validate(self):
        if self.applications:
            for k in self.applications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['applications'] = []
        if self.applications is not None:
            for k in self.applications:
                result['applications'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.applications = []
        if m.get('applications') is not None:
            for k in m.get('applications'):
                temp_model = ApplicationWithStatus()
                self.applications.append(temp_model.from_map(k))
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ListCustomDomainOutput(TeaModel):
    def __init__(
        self,
        custom_domains: List[CustomDomain] = None,
        next_token: str = None,
        request_id: str = None,
    ):
        self.custom_domains = custom_domains
        self.next_token = next_token
        self.request_id = request_id

    def validate(self):
        if self.custom_domains:
            for k in self.custom_domains:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['customDomains'] = []
        if self.custom_domains is not None:
            for k in self.custom_domains:
                result['customDomains'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.custom_domains = []
        if m.get('customDomains') is not None:
            for k in m.get('customDomains'):
                temp_model = CustomDomain()
                self.custom_domains.append(temp_model.from_map(k))
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ListInstancesMetricsOutput(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        metrics_list: List[InstanceMetricInfo] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.request_id = request_id
        self.metrics_list = metrics_list
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.metrics_list:
            for k in self.metrics_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['metricsList'] = []
        if self.metrics_list is not None:
            for k in self.metrics_list:
                result['metricsList'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.metrics_list = []
        if m.get('metricsList') is not None:
            for k in m.get('metricsList'):
                temp_model = InstanceMetricInfo()
                self.metrics_list.append(temp_model.from_map(k))
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class VersionStatus(TeaModel):
    def __init__(
        self,
        error_message: str = None,
        status: str = None,
    ):
        self.error_message = error_message
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class ListInstancesOutput(TeaModel):
    def __init__(
        self,
        current_error: str = None,
        instances: List[InstanceInfo] = None,
        request_id: str = None,
        version_status: Dict[str, VersionStatus] = None,
    ):
        self.current_error = current_error
        self.instances = instances
        self.request_id = request_id
        self.version_status = version_status

    def validate(self):
        if self.instances:
            for k in self.instances:
                if k:
                    k.validate()
        if self.version_status:
            for v in self.version_status.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_error is not None:
            result['currentError'] = self.current_error
        result['instances'] = []
        if self.instances is not None:
            for k in self.instances:
                result['instances'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['versionStatus'] = {}
        if self.version_status is not None:
            for k, v in self.version_status.items():
                result['versionStatus'][k] = v.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('currentError') is not None:
            self.current_error = m.get('currentError')
        self.instances = []
        if m.get('instances') is not None:
            for k in m.get('instances'):
                temp_model = InstanceInfo()
                self.instances.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.version_status = {}
        if m.get('versionStatus') is not None:
            for k, v in m.get('versionStatus').items():
                temp_model = VersionStatus()
                self.version_status[k] = temp_model.from_map(v)
        return self


class MetricInfo(TeaModel):
    def __init__(
        self,
        average: float = None,
        count: float = None,
        maximum: float = None,
        minimum: float = None,
        sum: float = None,
        timestamp: int = None,
        value: float = None,
    ):
        self.average = average
        self.count = count
        self.maximum = maximum
        self.minimum = minimum
        self.sum = sum
        self.timestamp = timestamp
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average is not None:
            result['Average'] = self.average
        if self.count is not None:
            result['Count'] = self.count
        if self.maximum is not None:
            result['Maximum'] = self.maximum
        if self.minimum is not None:
            result['Minimum'] = self.minimum
        if self.sum is not None:
            result['Sum'] = self.sum
        if self.timestamp is not None:
            result['timestamp'] = self.timestamp
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Average') is not None:
            self.average = m.get('Average')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Maximum') is not None:
            self.maximum = m.get('Maximum')
        if m.get('Minimum') is not None:
            self.minimum = m.get('Minimum')
        if m.get('Sum') is not None:
            self.sum = m.get('Sum')
        if m.get('timestamp') is not None:
            self.timestamp = m.get('timestamp')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListMetricsOutput(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        metrics: Dict[str, List[MetricInfo]] = None,
    ):
        self.request_id = request_id
        self.metrics = metrics

    def validate(self):
        if self.metrics:
            for v in self.metrics.values():
                for k1 in v:
                    if k1:
                        k1.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['metrics'] = {}
        if self.metrics is not None:
            for k, v in self.metrics.items():
                l1 = []
                for k1 in v:
                    l1.append(k1.to_map() if k1 else None)
                result['metrics'][k] = l1
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.metrics = {}
        if m.get('metrics') is not None:
            for k, v in m.get('metrics').items():
                l1 = []
                for k1 in v:
                    temp_model = MetricInfo()
                    l1.append(temp_model.from_map(k1))
                self.metrics['k'] = l1
        return self


class StaticsInfo(TeaModel):
    def __init__(
        self,
        active_cpuusage: int = None,
        cost: float = None,
        disk_usage: int = None,
        function_name: str = None,
        gpu_usage: int = None,
        idle_cpuusage: int = None,
        instance_traffic_out: int = None,
        invocations: int = None,
        invoke_cdnout: int = None,
        invoke_internet_out: int = None,
        memory_usage: int = None,
        region: str = None,
        service_name: str = None,
    ):
        self.active_cpuusage = active_cpuusage
        self.cost = cost
        self.disk_usage = disk_usage
        self.function_name = function_name
        self.gpu_usage = gpu_usage
        self.idle_cpuusage = idle_cpuusage
        self.instance_traffic_out = instance_traffic_out
        self.invocations = invocations
        self.invoke_cdnout = invoke_cdnout
        self.invoke_internet_out = invoke_internet_out
        self.memory_usage = memory_usage
        self.region = region
        self.service_name = service_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_cpuusage is not None:
            result['activeCPUUsage'] = self.active_cpuusage
        if self.cost is not None:
            result['cost'] = self.cost
        if self.disk_usage is not None:
            result['diskUsage'] = self.disk_usage
        if self.function_name is not None:
            result['functionName'] = self.function_name
        if self.gpu_usage is not None:
            result['gpuUsage'] = self.gpu_usage
        if self.idle_cpuusage is not None:
            result['idleCPUUsage'] = self.idle_cpuusage
        if self.instance_traffic_out is not None:
            result['instanceTrafficOut'] = self.instance_traffic_out
        if self.invocations is not None:
            result['invocations'] = self.invocations
        if self.invoke_cdnout is not None:
            result['invokeCDNOut'] = self.invoke_cdnout
        if self.invoke_internet_out is not None:
            result['invokeInternetOut'] = self.invoke_internet_out
        if self.memory_usage is not None:
            result['memoryUsage'] = self.memory_usage
        if self.region is not None:
            result['region'] = self.region
        if self.service_name is not None:
            result['serviceName'] = self.service_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('activeCPUUsage') is not None:
            self.active_cpuusage = m.get('activeCPUUsage')
        if m.get('cost') is not None:
            self.cost = m.get('cost')
        if m.get('diskUsage') is not None:
            self.disk_usage = m.get('diskUsage')
        if m.get('functionName') is not None:
            self.function_name = m.get('functionName')
        if m.get('gpuUsage') is not None:
            self.gpu_usage = m.get('gpuUsage')
        if m.get('idleCPUUsage') is not None:
            self.idle_cpuusage = m.get('idleCPUUsage')
        if m.get('instanceTrafficOut') is not None:
            self.instance_traffic_out = m.get('instanceTrafficOut')
        if m.get('invocations') is not None:
            self.invocations = m.get('invocations')
        if m.get('invokeCDNOut') is not None:
            self.invoke_cdnout = m.get('invokeCDNOut')
        if m.get('invokeInternetOut') is not None:
            self.invoke_internet_out = m.get('invokeInternetOut')
        if m.get('memoryUsage') is not None:
            self.memory_usage = m.get('memoryUsage')
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('serviceName') is not None:
            self.service_name = m.get('serviceName')
        return self


class ListStaticsQueryResponse(TeaModel):
    def __init__(
        self,
        length: int = None,
        sort: str = None,
        statics: List[StaticsInfo] = None,
    ):
        self.length = length
        self.sort = sort
        self.statics = statics

    def validate(self):
        if self.statics:
            for k in self.statics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.length is not None:
            result['length'] = self.length
        if self.sort is not None:
            result['sort'] = self.sort
        result['statics'] = []
        if self.statics is not None:
            for k in self.statics:
                result['statics'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('length') is not None:
            self.length = m.get('length')
        if m.get('sort') is not None:
            self.sort = m.get('sort')
        self.statics = []
        if m.get('statics') is not None:
            for k in m.get('statics'):
                temp_model = StaticsInfo()
                self.statics.append(temp_model.from_map(k))
        return self


class WebInstanceInfo(TeaModel):
    def __init__(
        self,
        image_url: str = None,
        instance_id: str = None,
        status: str = None,
        version_id: str = None,
    ):
        self.image_url = image_url
        self.instance_id = instance_id
        self.status = status
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.status is not None:
            result['Status'] = self.status
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class WebVersionStatus(TeaModel):
    def __init__(
        self,
        error_message: str = None,
        status: str = None,
    ):
        self.error_message = error_message
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListWebInstancesOutput(TeaModel):
    def __init__(
        self,
        current_error: str = None,
        web_instances: List[WebInstanceInfo] = None,
        web_version_status: Dict[str, WebVersionStatus] = None,
    ):
        self.current_error = current_error
        self.web_instances = web_instances
        self.web_version_status = web_version_status

    def validate(self):
        if self.web_instances:
            for k in self.web_instances:
                if k:
                    k.validate()
        if self.web_version_status:
            for v in self.web_version_status.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_error is not None:
            result['CurrentError'] = self.current_error
        result['WebInstances'] = []
        if self.web_instances is not None:
            for k in self.web_instances:
                result['WebInstances'].append(k.to_map() if k else None)
        result['WebVersionStatus'] = {}
        if self.web_version_status is not None:
            for k, v in self.web_version_status.items():
                result['WebVersionStatus'][k] = v.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentError') is not None:
            self.current_error = m.get('CurrentError')
        self.web_instances = []
        if m.get('WebInstances') is not None:
            for k in m.get('WebInstances'):
                temp_model = WebInstanceInfo()
                self.web_instances.append(temp_model.from_map(k))
        self.web_version_status = {}
        if m.get('WebVersionStatus') is not None:
            for k, v in m.get('WebVersionStatus').items():
                temp_model = WebVersionStatus()
                self.web_version_status[k] = temp_model.from_map(v)
        return self


class ListWebApplicationInstancesBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: ListWebInstancesOutput = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListWebInstancesOutput()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class Revision(TeaModel):
    def __init__(
        self,
        created_time: str = None,
        description: str = None,
        revision_config: RevisionConfig = None,
        revision_id: str = None,
        weight: float = None,
    ):
        self.created_time = created_time
        self.description = description
        self.revision_config = revision_config
        self.revision_id = revision_id
        self.weight = weight

    def validate(self):
        if self.revision_config:
            self.revision_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.description is not None:
            result['Description'] = self.description
        if self.revision_config is not None:
            result['RevisionConfig'] = self.revision_config.to_map()
        if self.revision_id is not None:
            result['RevisionId'] = self.revision_id
        if self.weight is not None:
            result['Weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RevisionConfig') is not None:
            temp_model = RevisionConfig()
            self.revision_config = temp_model.from_map(m['RevisionConfig'])
        if m.get('RevisionId') is not None:
            self.revision_id = m.get('RevisionId')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        return self


class ListWebApplicationRevisionsOutput(TeaModel):
    def __init__(
        self,
        next_token: str = None,
        revisions: List[Revision] = None,
    ):
        self.next_token = next_token
        self.revisions = revisions

    def validate(self):
        if self.revisions:
            for k in self.revisions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        result['Revisions'] = []
        if self.revisions is not None:
            for k in self.revisions:
                result['Revisions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        self.revisions = []
        if m.get('Revisions') is not None:
            for k in m.get('Revisions'):
                temp_model = Revision()
                self.revisions.append(temp_model.from_map(k))
        return self


class ListWebApplicationRevisionsBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: ListWebApplicationRevisionsOutput = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListWebApplicationRevisionsOutput()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class WebApplication(TeaModel):
    def __init__(
        self,
        application_id: str = None,
        application_name: str = None,
        created_time: str = None,
        description: str = None,
        internet_url: str = None,
        intranet_url: str = None,
        last_modified_time: str = None,
        namespace_id: str = None,
        revision_config: RevisionConfig = None,
        vpc_id: str = None,
        web_scaling_config: WebScalingConfig = None,
        web_traffic_config: WebTrafficConfig = None,
    ):
        # This parameter is required.
        self.application_id = application_id
        # This parameter is required.
        self.application_name = application_name
        self.created_time = created_time
        self.description = description
        self.internet_url = internet_url
        self.intranet_url = intranet_url
        self.last_modified_time = last_modified_time
        self.namespace_id = namespace_id
        self.revision_config = revision_config
        self.vpc_id = vpc_id
        self.web_scaling_config = web_scaling_config
        self.web_traffic_config = web_traffic_config

    def validate(self):
        if self.revision_config:
            self.revision_config.validate()
        if self.web_scaling_config:
            self.web_scaling_config.validate()
        if self.web_traffic_config:
            self.web_traffic_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_id is not None:
            result['ApplicationId'] = self.application_id
        if self.application_name is not None:
            result['ApplicationName'] = self.application_name
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.description is not None:
            result['Description'] = self.description
        if self.internet_url is not None:
            result['InternetURL'] = self.internet_url
        if self.intranet_url is not None:
            result['IntranetURL'] = self.intranet_url
        if self.last_modified_time is not None:
            result['LastModifiedTime'] = self.last_modified_time
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.revision_config is not None:
            result['RevisionConfig'] = self.revision_config.to_map()
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.web_scaling_config is not None:
            result['WebScalingConfig'] = self.web_scaling_config.to_map()
        if self.web_traffic_config is not None:
            result['WebTrafficConfig'] = self.web_traffic_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationId') is not None:
            self.application_id = m.get('ApplicationId')
        if m.get('ApplicationName') is not None:
            self.application_name = m.get('ApplicationName')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InternetURL') is not None:
            self.internet_url = m.get('InternetURL')
        if m.get('IntranetURL') is not None:
            self.intranet_url = m.get('IntranetURL')
        if m.get('LastModifiedTime') is not None:
            self.last_modified_time = m.get('LastModifiedTime')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('RevisionConfig') is not None:
            temp_model = RevisionConfig()
            self.revision_config = temp_model.from_map(m['RevisionConfig'])
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('WebScalingConfig') is not None:
            temp_model = WebScalingConfig()
            self.web_scaling_config = temp_model.from_map(m['WebScalingConfig'])
        if m.get('WebTrafficConfig') is not None:
            temp_model = WebTrafficConfig()
            self.web_traffic_config = temp_model.from_map(m['WebTrafficConfig'])
        return self


class WebApplicationWithInstanceCount(TeaModel):
    def __init__(
        self,
        instance_count: int = None,
        web_application: WebApplication = None,
    ):
        self.instance_count = instance_count
        self.web_application = web_application

    def validate(self):
        if self.web_application:
            self.web_application.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.web_application is not None:
            result['WebApplication'] = self.web_application.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('WebApplication') is not None:
            temp_model = WebApplication()
            self.web_application = temp_model.from_map(m['WebApplication'])
        return self


class ListWebApplicationsOutput(TeaModel):
    def __init__(
        self,
        next_token: str = None,
        web_application_with_instance_count: List[WebApplicationWithInstanceCount] = None,
    ):
        self.next_token = next_token
        self.web_application_with_instance_count = web_application_with_instance_count

    def validate(self):
        if self.web_application_with_instance_count:
            for k in self.web_application_with_instance_count:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        result['WebApplicationWithInstanceCount'] = []
        if self.web_application_with_instance_count is not None:
            for k in self.web_application_with_instance_count:
                result['WebApplicationWithInstanceCount'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        self.web_application_with_instance_count = []
        if m.get('WebApplicationWithInstanceCount') is not None:
            for k in m.get('WebApplicationWithInstanceCount'):
                temp_model = WebApplicationWithInstanceCount()
                self.web_application_with_instance_count.append(temp_model.from_map(k))
        return self


class ListWebApplicationsBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: ListWebApplicationsOutput = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListWebApplicationsOutput()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class WebCustomDomain(TeaModel):
    def __init__(
        self,
        created_time: str = None,
        default_forwarding_app_name: str = None,
        domain_name: str = None,
        last_modified_time: str = None,
        namespace_id: str = None,
        protocol: str = None,
        route_config: RouteConfig = None,
        web_cert_config: WebCertConfig = None,
        web_tlsconfig: WebTLSConfig = None,
        web_wafconfig: WebWAFConfig = None,
        account_id: str = None,
    ):
        self.created_time = created_time
        self.default_forwarding_app_name = default_forwarding_app_name
        self.domain_name = domain_name
        self.last_modified_time = last_modified_time
        self.namespace_id = namespace_id
        self.protocol = protocol
        self.route_config = route_config
        self.web_cert_config = web_cert_config
        self.web_tlsconfig = web_tlsconfig
        self.web_wafconfig = web_wafconfig
        self.account_id = account_id

    def validate(self):
        if self.route_config:
            self.route_config.validate()
        if self.web_cert_config:
            self.web_cert_config.validate()
        if self.web_tlsconfig:
            self.web_tlsconfig.validate()
        if self.web_wafconfig:
            self.web_wafconfig.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.default_forwarding_app_name is not None:
            result['DefaultForwardingAppName'] = self.default_forwarding_app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.last_modified_time is not None:
            result['LastModifiedTime'] = self.last_modified_time
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.route_config is not None:
            result['RouteConfig'] = self.route_config.to_map()
        if self.web_cert_config is not None:
            result['WebCertConfig'] = self.web_cert_config.to_map()
        if self.web_tlsconfig is not None:
            result['WebTLSConfig'] = self.web_tlsconfig.to_map()
        if self.web_wafconfig is not None:
            result['WebWAFConfig'] = self.web_wafconfig.to_map()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('DefaultForwardingAppName') is not None:
            self.default_forwarding_app_name = m.get('DefaultForwardingAppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('LastModifiedTime') is not None:
            self.last_modified_time = m.get('LastModifiedTime')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('RouteConfig') is not None:
            temp_model = RouteConfig()
            self.route_config = temp_model.from_map(m['RouteConfig'])
        if m.get('WebCertConfig') is not None:
            temp_model = WebCertConfig()
            self.web_cert_config = temp_model.from_map(m['WebCertConfig'])
        if m.get('WebTLSConfig') is not None:
            temp_model = WebTLSConfig()
            self.web_tlsconfig = temp_model.from_map(m['WebTLSConfig'])
        if m.get('WebWAFConfig') is not None:
            temp_model = WebWAFConfig()
            self.web_wafconfig = temp_model.from_map(m['WebWAFConfig'])
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        return self


class ListWebCustomDomainOutput(TeaModel):
    def __init__(
        self,
        next_token: str = None,
        web_custom_domains: List[WebCustomDomain] = None,
    ):
        self.next_token = next_token
        self.web_custom_domains = web_custom_domains

    def validate(self):
        if self.web_custom_domains:
            for k in self.web_custom_domains:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        result['WebCustomDomains'] = []
        if self.web_custom_domains is not None:
            for k in self.web_custom_domains:
                result['WebCustomDomains'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        self.web_custom_domains = []
        if m.get('WebCustomDomains') is not None:
            for k in m.get('WebCustomDomains'):
                temp_model = WebCustomDomain()
                self.web_custom_domains.append(temp_model.from_map(k))
        return self


class ListWebCustomDomainBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: ListWebCustomDomainOutput = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListWebCustomDomainOutput()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PermissionAssistantApi(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        id: int = None,
        name: str = None,
        resource_type: str = None,
        update_time: str = None,
    ):
        self.create_time = create_time
        self.id = id
        self.name = name
        self.resource_type = resource_type
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.resource_type is not None:
            result['resourceType'] = self.resource_type
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('resourceType') is not None:
            self.resource_type = m.get('resourceType')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        return self


class PolicyItem(TeaModel):
    def __init__(
        self,
        key: str = None,
        operator: str = None,
        type: str = None,
        value: str = None,
    ):
        self.key = key
        self.operator = operator
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.operator is not None:
            result['operator'] = self.operator
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class PriceEstimateFeature(TeaModel):
    def __init__(
        self,
        app_count: int = None,
        app_type: str = None,
        cpu_core: float = None,
        cpu_strategy: str = None,
        cpu_util_level: str = None,
        cpu_util_metrics: List[float] = None,
        enable_cpu_idle: bool = None,
        env_type: str = None,
        ephemeral_storage_gi_b: int = None,
        high_load_instance_count: int = None,
        high_load_qps: float = None,
        high_load_seconds: int = None,
        instance_qps: float = None,
        internet_outbound_gi_b: float = None,
        low_load_instance_count: int = None,
        low_load_qps: float = None,
        low_load_seconds: int = None,
        max_instance_count: int = None,
        memory_gi_b: float = None,
        min_instance_count: int = None,
        new_sae_version: str = None,
        none_load_instance_count: int = None,
        none_load_seconds: int = None,
        region_id: str = None,
        resource_type: str = None,
    ):
        self.app_count = app_count
        # This parameter is required.
        self.app_type = app_type
        # This parameter is required.
        self.cpu_core = cpu_core
        # This parameter is required.
        self.cpu_strategy = cpu_strategy
        self.cpu_util_level = cpu_util_level
        self.cpu_util_metrics = cpu_util_metrics
        self.enable_cpu_idle = enable_cpu_idle
        # This parameter is required.
        self.env_type = env_type
        self.ephemeral_storage_gi_b = ephemeral_storage_gi_b
        self.high_load_instance_count = high_load_instance_count
        self.high_load_qps = high_load_qps
        self.high_load_seconds = high_load_seconds
        self.instance_qps = instance_qps
        self.internet_outbound_gi_b = internet_outbound_gi_b
        self.low_load_instance_count = low_load_instance_count
        self.low_load_qps = low_load_qps
        self.low_load_seconds = low_load_seconds
        self.max_instance_count = max_instance_count
        # This parameter is required.
        self.memory_gi_b = memory_gi_b
        self.min_instance_count = min_instance_count
        self.new_sae_version = new_sae_version
        self.none_load_instance_count = none_load_instance_count
        self.none_load_seconds = none_load_seconds
        # This parameter is required.
        self.region_id = region_id
        self.resource_type = resource_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_count is not None:
            result['AppCount'] = self.app_count
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.cpu_core is not None:
            result['CpuCore'] = self.cpu_core
        if self.cpu_strategy is not None:
            result['CpuStrategy'] = self.cpu_strategy
        if self.cpu_util_level is not None:
            result['CpuUtilLevel'] = self.cpu_util_level
        if self.cpu_util_metrics is not None:
            result['CpuUtilMetrics'] = self.cpu_util_metrics
        if self.enable_cpu_idle is not None:
            result['EnableCpuIdle'] = self.enable_cpu_idle
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.ephemeral_storage_gi_b is not None:
            result['EphemeralStorageGiB'] = self.ephemeral_storage_gi_b
        if self.high_load_instance_count is not None:
            result['HighLoadInstanceCount'] = self.high_load_instance_count
        if self.high_load_qps is not None:
            result['HighLoadQps'] = self.high_load_qps
        if self.high_load_seconds is not None:
            result['HighLoadSeconds'] = self.high_load_seconds
        if self.instance_qps is not None:
            result['InstanceQps'] = self.instance_qps
        if self.internet_outbound_gi_b is not None:
            result['InternetOutboundGiB'] = self.internet_outbound_gi_b
        if self.low_load_instance_count is not None:
            result['LowLoadInstanceCount'] = self.low_load_instance_count
        if self.low_load_qps is not None:
            result['LowLoadQps'] = self.low_load_qps
        if self.low_load_seconds is not None:
            result['LowLoadSeconds'] = self.low_load_seconds
        if self.max_instance_count is not None:
            result['MaxInstanceCount'] = self.max_instance_count
        if self.memory_gi_b is not None:
            result['MemoryGiB'] = self.memory_gi_b
        if self.min_instance_count is not None:
            result['MinInstanceCount'] = self.min_instance_count
        if self.new_sae_version is not None:
            result['NewSaeVersion'] = self.new_sae_version
        if self.none_load_instance_count is not None:
            result['NoneLoadInstanceCount'] = self.none_load_instance_count
        if self.none_load_seconds is not None:
            result['NoneLoadSeconds'] = self.none_load_seconds
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppCount') is not None:
            self.app_count = m.get('AppCount')
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('CpuCore') is not None:
            self.cpu_core = m.get('CpuCore')
        if m.get('CpuStrategy') is not None:
            self.cpu_strategy = m.get('CpuStrategy')
        if m.get('CpuUtilLevel') is not None:
            self.cpu_util_level = m.get('CpuUtilLevel')
        if m.get('CpuUtilMetrics') is not None:
            self.cpu_util_metrics = m.get('CpuUtilMetrics')
        if m.get('EnableCpuIdle') is not None:
            self.enable_cpu_idle = m.get('EnableCpuIdle')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('EphemeralStorageGiB') is not None:
            self.ephemeral_storage_gi_b = m.get('EphemeralStorageGiB')
        if m.get('HighLoadInstanceCount') is not None:
            self.high_load_instance_count = m.get('HighLoadInstanceCount')
        if m.get('HighLoadQps') is not None:
            self.high_load_qps = m.get('HighLoadQps')
        if m.get('HighLoadSeconds') is not None:
            self.high_load_seconds = m.get('HighLoadSeconds')
        if m.get('InstanceQps') is not None:
            self.instance_qps = m.get('InstanceQps')
        if m.get('InternetOutboundGiB') is not None:
            self.internet_outbound_gi_b = m.get('InternetOutboundGiB')
        if m.get('LowLoadInstanceCount') is not None:
            self.low_load_instance_count = m.get('LowLoadInstanceCount')
        if m.get('LowLoadQps') is not None:
            self.low_load_qps = m.get('LowLoadQps')
        if m.get('LowLoadSeconds') is not None:
            self.low_load_seconds = m.get('LowLoadSeconds')
        if m.get('MaxInstanceCount') is not None:
            self.max_instance_count = m.get('MaxInstanceCount')
        if m.get('MemoryGiB') is not None:
            self.memory_gi_b = m.get('MemoryGiB')
        if m.get('MinInstanceCount') is not None:
            self.min_instance_count = m.get('MinInstanceCount')
        if m.get('NewSaeVersion') is not None:
            self.new_sae_version = m.get('NewSaeVersion')
        if m.get('NoneLoadInstanceCount') is not None:
            self.none_load_instance_count = m.get('NoneLoadInstanceCount')
        if m.get('NoneLoadSeconds') is not None:
            self.none_load_seconds = m.get('NoneLoadSeconds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class PriceEstimateOutputAppsUsages(TeaModel):
    def __init__(
        self,
        amount: float = None,
        id: str = None,
        unit: str = None,
    ):
        self.amount = amount
        self.id = id
        self.unit = unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amount is not None:
            result['Amount'] = self.amount
        if self.id is not None:
            result['Id'] = self.id
        if self.unit is not None:
            result['Unit'] = self.unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Amount') is not None:
            self.amount = m.get('Amount')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        return self


class PriceEstimateOutputApps(TeaModel):
    def __init__(
        self,
        feature: PriceEstimateFeature = None,
        id: int = None,
        usages: List[PriceEstimateOutputAppsUsages] = None,
    ):
        self.feature = feature
        self.id = id
        self.usages = usages

    def validate(self):
        if self.feature:
            self.feature.validate()
        if self.usages:
            for k in self.usages:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.feature is not None:
            result['Feature'] = self.feature.to_map()
        if self.id is not None:
            result['Id'] = self.id
        result['Usages'] = []
        if self.usages is not None:
            for k in self.usages:
                result['Usages'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Feature') is not None:
            temp_model = PriceEstimateFeature()
            self.feature = temp_model.from_map(m['Feature'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        self.usages = []
        if m.get('Usages') is not None:
            for k in m.get('Usages'):
                temp_model = PriceEstimateOutputAppsUsages()
                self.usages.append(temp_model.from_map(k))
        return self


class PriceEstimateOutputItemsSteps(TeaModel):
    def __init__(
        self,
        begin: int = None,
        end: int = None,
        price: float = None,
        region_ids: List[str] = None,
        unit: str = None,
    ):
        self.begin = begin
        self.end = end
        self.price = price
        self.region_ids = region_ids
        self.unit = unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin is not None:
            result['Begin'] = self.begin
        if self.end is not None:
            result['End'] = self.end
        if self.price is not None:
            result['Price'] = self.price
        if self.region_ids is not None:
            result['RegionIds'] = self.region_ids
        if self.unit is not None:
            result['Unit'] = self.unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Begin') is not None:
            self.begin = m.get('Begin')
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Price') is not None:
            self.price = m.get('Price')
        if m.get('RegionIds') is not None:
            self.region_ids = m.get('RegionIds')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        return self


class PriceEstimateOutputItems(TeaModel):
    def __init__(
        self,
        amount: float = None,
        count: int = None,
        id: str = None,
        price: float = None,
        steps: List[PriceEstimateOutputItemsSteps] = None,
        type: str = None,
        unit: str = None,
    ):
        self.amount = amount
        self.count = count
        self.id = id
        self.price = price
        self.steps = steps
        self.type = type
        self.unit = unit

    def validate(self):
        if self.steps:
            for k in self.steps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amount is not None:
            result['Amount'] = self.amount
        if self.count is not None:
            result['Count'] = self.count
        if self.id is not None:
            result['Id'] = self.id
        if self.price is not None:
            result['Price'] = self.price
        result['Steps'] = []
        if self.steps is not None:
            for k in self.steps:
                result['Steps'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        if self.unit is not None:
            result['Unit'] = self.unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Amount') is not None:
            self.amount = m.get('Amount')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Price') is not None:
            self.price = m.get('Price')
        self.steps = []
        if m.get('Steps') is not None:
            for k in m.get('Steps'):
                temp_model = PriceEstimateOutputItemsSteps()
                self.steps.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        return self


class PriceEstimateOutputPostPayItemsSteps(TeaModel):
    def __init__(
        self,
        begin: int = None,
        end: int = None,
        price: float = None,
        region_ids: List[str] = None,
        unit: str = None,
    ):
        self.begin = begin
        self.end = end
        self.price = price
        self.region_ids = region_ids
        self.unit = unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin is not None:
            result['Begin'] = self.begin
        if self.end is not None:
            result['End'] = self.end
        if self.price is not None:
            result['Price'] = self.price
        if self.region_ids is not None:
            result['RegionIds'] = self.region_ids
        if self.unit is not None:
            result['Unit'] = self.unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Begin') is not None:
            self.begin = m.get('Begin')
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Price') is not None:
            self.price = m.get('Price')
        if m.get('RegionIds') is not None:
            self.region_ids = m.get('RegionIds')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        return self


class PriceEstimateOutputPostPayItems(TeaModel):
    def __init__(
        self,
        amount: float = None,
        count: int = None,
        id: str = None,
        price: float = None,
        steps: List[PriceEstimateOutputPostPayItemsSteps] = None,
        type: str = None,
        unit: str = None,
    ):
        self.amount = amount
        self.count = count
        self.id = id
        self.price = price
        self.steps = steps
        self.type = type
        self.unit = unit

    def validate(self):
        if self.steps:
            for k in self.steps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amount is not None:
            result['Amount'] = self.amount
        if self.count is not None:
            result['Count'] = self.count
        if self.id is not None:
            result['Id'] = self.id
        if self.price is not None:
            result['Price'] = self.price
        result['Steps'] = []
        if self.steps is not None:
            for k in self.steps:
                result['Steps'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        if self.unit is not None:
            result['Unit'] = self.unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Amount') is not None:
            self.amount = m.get('Amount')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Price') is not None:
            self.price = m.get('Price')
        self.steps = []
        if m.get('Steps') is not None:
            for k in m.get('Steps'):
                temp_model = PriceEstimateOutputPostPayItemsSteps()
                self.steps.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        return self


class PriceEstimateOutput(TeaModel):
    def __init__(
        self,
        apps: List[PriceEstimateOutputApps] = None,
        items: List[PriceEstimateOutputItems] = None,
        post_pay_items: List[PriceEstimateOutputPostPayItems] = None,
        post_pay_total_price: float = None,
        total_price: float = None,
    ):
        self.apps = apps
        self.items = items
        self.post_pay_items = post_pay_items
        self.post_pay_total_price = post_pay_total_price
        self.total_price = total_price

    def validate(self):
        if self.apps:
            for k in self.apps:
                if k:
                    k.validate()
        if self.items:
            for k in self.items:
                if k:
                    k.validate()
        if self.post_pay_items:
            for k in self.post_pay_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Apps'] = []
        if self.apps is not None:
            for k in self.apps:
                result['Apps'].append(k.to_map() if k else None)
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        result['PostPayItems'] = []
        if self.post_pay_items is not None:
            for k in self.post_pay_items:
                result['PostPayItems'].append(k.to_map() if k else None)
        if self.post_pay_total_price is not None:
            result['PostPayTotalPrice'] = self.post_pay_total_price
        if self.total_price is not None:
            result['TotalPrice'] = self.total_price
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.apps = []
        if m.get('Apps') is not None:
            for k in m.get('Apps'):
                temp_model = PriceEstimateOutputApps()
                self.apps.append(temp_model.from_map(k))
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = PriceEstimateOutputItems()
                self.items.append(temp_model.from_map(k))
        self.post_pay_items = []
        if m.get('PostPayItems') is not None:
            for k in m.get('PostPayItems'):
                temp_model = PriceEstimateOutputPostPayItems()
                self.post_pay_items.append(temp_model.from_map(k))
        if m.get('PostPayTotalPrice') is not None:
            self.post_pay_total_price = m.get('PostPayTotalPrice')
        if m.get('TotalPrice') is not None:
            self.total_price = m.get('TotalPrice')
        return self


class PublishApplicationVersionInput(TeaModel):
    def __init__(
        self,
        description: str = None,
    ):
        self.description = description

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        return self


class PublishWebApplicationRevisionInput(TeaModel):
    def __init__(
        self,
        containers: List[Container] = None,
        description: str = None,
        enable_arms_metrics: bool = None,
        take_effect: bool = None,
    ):
        # This parameter is required.
        self.containers = containers
        self.description = description
        self.enable_arms_metrics = enable_arms_metrics
        self.take_effect = take_effect

    def validate(self):
        if self.containers:
            for k in self.containers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Containers'] = []
        if self.containers is not None:
            for k in self.containers:
                result['Containers'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.enable_arms_metrics is not None:
            result['EnableArmsMetrics'] = self.enable_arms_metrics
        if self.take_effect is not None:
            result['TakeEffect'] = self.take_effect
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.containers = []
        if m.get('Containers') is not None:
            for k in m.get('Containers'):
                temp_model = Container()
                self.containers.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnableArmsMetrics') is not None:
            self.enable_arms_metrics = m.get('EnableArmsMetrics')
        if m.get('TakeEffect') is not None:
            self.take_effect = m.get('TakeEffect')
        return self


class RoutePolicy(TeaModel):
    def __init__(
        self,
        condition: str = None,
        policy_items: List[PolicyItem] = None,
    ):
        self.condition = condition
        self.policy_items = policy_items

    def validate(self):
        if self.policy_items:
            for k in self.policy_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['condition'] = self.condition
        result['policyItems'] = []
        if self.policy_items is not None:
            for k in self.policy_items:
                result['policyItems'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        self.policy_items = []
        if m.get('policyItems') is not None:
            for k in m.get('policyItems'):
                temp_model = PolicyItem()
                self.policy_items.append(temp_model.from_map(k))
        return self


class SidecarContainerConfig(TeaModel):
    def __init__(
        self,
        acr_instance_id: str = None,
        command: str = None,
        command_args: str = None,
        config_map_mount_desc: str = None,
        cpu: int = None,
        empty_dir_desc: str = None,
        envs: str = None,
        image_url: str = None,
        memory: int = None,
        name: str = None,
    ):
        self.acr_instance_id = acr_instance_id
        self.command = command
        self.command_args = command_args
        self.config_map_mount_desc = config_map_mount_desc
        self.cpu = cpu
        self.empty_dir_desc = empty_dir_desc
        self.envs = envs
        self.image_url = image_url
        self.memory = memory
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acr_instance_id is not None:
            result['AcrInstanceId'] = self.acr_instance_id
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        if self.config_map_mount_desc is not None:
            result['ConfigMapMountDesc'] = self.config_map_mount_desc
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.empty_dir_desc is not None:
            result['EmptyDirDesc'] = self.empty_dir_desc
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcrInstanceId') is not None:
            self.acr_instance_id = m.get('AcrInstanceId')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        if m.get('ConfigMapMountDesc') is not None:
            self.config_map_mount_desc = m.get('ConfigMapMountDesc')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('EmptyDirDesc') is not None:
            self.empty_dir_desc = m.get('EmptyDirDesc')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class SourceCodeAccountOrganizations(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        id: str = None,
        name: str = None,
    ):
        self.avatar_url = avatar_url
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['AvatarUrl'] = self.avatar_url
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarUrl') is not None:
            self.avatar_url = m.get('AvatarUrl')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class SourceCodeAccount(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        id: str = None,
        name: str = None,
        organizations: List[SourceCodeAccountOrganizations] = None,
    ):
        self.avatar_url = avatar_url
        self.id = id
        self.name = name
        self.organizations = organizations

    def validate(self):
        if self.organizations:
            for k in self.organizations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['AvatarUrl'] = self.avatar_url
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        result['Organizations'] = []
        if self.organizations is not None:
            for k in self.organizations:
                result['Organizations'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvatarUrl') is not None:
            self.avatar_url = m.get('AvatarUrl')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.organizations = []
        if m.get('Organizations') is not None:
            for k in m.get('Organizations'):
                temp_model = SourceCodeAccountOrganizations()
                self.organizations.append(temp_model.from_map(k))
        return self


class SourceCodeRepo(TeaModel):
    def __init__(
        self,
        full_name: str = None,
        id: str = None,
        name: str = None,
    ):
        self.full_name = full_name
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.full_name is not None:
            result['FullName'] = self.full_name
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FullName') is not None:
            self.full_name = m.get('FullName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class SourceCodeRepoBranch(TeaModel):
    def __init__(
        self,
        commit_id: str = None,
        name: str = None,
    ):
        self.commit_id = commit_id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commit_id is not None:
            result['CommitId'] = self.commit_id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommitId') is not None:
            self.commit_id = m.get('CommitId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class SubmenuItems(TeaModel):
    def __init__(
        self,
        default_selected: bool = None,
        item_desc: str = None,
        item_type: str = None,
        relating_items: List[str] = None,
    ):
        self.default_selected = default_selected
        self.item_desc = item_desc
        self.item_type = item_type
        self.relating_items = relating_items

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_selected is not None:
            result['DefaultSelected'] = self.default_selected
        if self.item_desc is not None:
            result['ItemDesc'] = self.item_desc
        if self.item_type is not None:
            result['ItemType'] = self.item_type
        if self.relating_items is not None:
            result['RelatingItems'] = self.relating_items
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DefaultSelected') is not None:
            self.default_selected = m.get('DefaultSelected')
        if m.get('ItemDesc') is not None:
            self.item_desc = m.get('ItemDesc')
        if m.get('ItemType') is not None:
            self.item_type = m.get('ItemType')
        if m.get('RelatingItems') is not None:
            self.relating_items = m.get('RelatingItems')
        return self


class Submenu(TeaModel):
    def __init__(
        self,
        items: List[SubmenuItems] = None,
        submenu_desc: str = None,
        submenu_type: str = None,
        submenus: List['Submenu'] = None,
    ):
        self.items = items
        self.submenu_desc = submenu_desc
        self.submenu_type = submenu_type
        self.submenus = submenus

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()
        if self.submenus:
            for k in self.submenus:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        if self.submenu_desc is not None:
            result['SubmenuDesc'] = self.submenu_desc
        if self.submenu_type is not None:
            result['SubmenuType'] = self.submenu_type
        result['Submenus'] = []
        if self.submenus is not None:
            for k in self.submenus:
                result['Submenus'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = SubmenuItems()
                self.items.append(temp_model.from_map(k))
        if m.get('SubmenuDesc') is not None:
            self.submenu_desc = m.get('SubmenuDesc')
        if m.get('SubmenuType') is not None:
            self.submenu_type = m.get('SubmenuType')
        self.submenus = []
        if m.get('Submenus') is not None:
            for k in m.get('Submenus'):
                temp_model = Submenu()
                self.submenus.append(temp_model.from_map(k))
        return self


class TrafficConfig(TeaModel):
    def __init__(
        self,
        additional_version_weight: Dict[str, float] = None,
        created_time: str = None,
        last_modified_time: str = None,
        request_id: str = None,
        resolve_policy: str = None,
        route_policy: RoutePolicy = None,
        version_id: str = None,
    ):
        self.additional_version_weight = additional_version_weight
        self.created_time = created_time
        self.last_modified_time = last_modified_time
        self.request_id = request_id
        self.resolve_policy = resolve_policy
        self.route_policy = route_policy
        self.version_id = version_id

    def validate(self):
        if self.route_policy:
            self.route_policy.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.additional_version_weight is not None:
            result['additionalVersionWeight'] = self.additional_version_weight
        if self.created_time is not None:
            result['createdTime'] = self.created_time
        if self.last_modified_time is not None:
            result['lastModifiedTime'] = self.last_modified_time
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.resolve_policy is not None:
            result['resolvePolicy'] = self.resolve_policy
        if self.route_policy is not None:
            result['routePolicy'] = self.route_policy.to_map()
        if self.version_id is not None:
            result['versionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('additionalVersionWeight') is not None:
            self.additional_version_weight = m.get('additionalVersionWeight')
        if m.get('createdTime') is not None:
            self.created_time = m.get('createdTime')
        if m.get('lastModifiedTime') is not None:
            self.last_modified_time = m.get('lastModifiedTime')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resolvePolicy') is not None:
            self.resolve_policy = m.get('resolvePolicy')
        if m.get('routePolicy') is not None:
            temp_model = RoutePolicy()
            self.route_policy = temp_model.from_map(m['routePolicy'])
        if m.get('versionId') is not None:
            self.version_id = m.get('versionId')
        return self


class UpdateApplicationInput(TeaModel):
    def __init__(
        self,
        args: str = None,
        ca_port: int = None,
        code: InputCodeLocation = None,
        command: str = None,
        cpu: float = None,
        custom_dns: CustomDNS = None,
        custom_health_check_config: CustomHealthCheckConfig = None,
        custom_host_alias: CustomHostAlias = None,
        custom_runtime_config: CustomRuntimeConfig = None,
        description: str = None,
        disk_size: int = None,
        effective_immediately: bool = None,
        enable_app_metric: bool = None,
        environment_variables: Dict[str, str] = None,
        gpu_memory_size: int = None,
        handler: str = None,
        http_trigger_config: HTTPTriggerConfig = None,
        image_config: ImageConfig = None,
        initialization_timeout: int = None,
        initializer: str = None,
        instance_concurrency: int = None,
        instance_lifecycle_config: InstanceLifecycleConfig = None,
        instance_soft_concurrency: int = None,
        instance_type: str = None,
        internet_access: bool = None,
        layers: List[str] = None,
        liveness_probe: Probe = None,
        log_config: LogConfig = None,
        memory_size: int = None,
        namespace_id: str = None,
        nas_config: NASConfig = None,
        oss_mount_config: OSSMountConfig = None,
        programming_language: str = None,
        runtime: str = None,
        scale_config: ScaleConfig = None,
        sls_config: SLSConfig = None,
        startup_probe: Probe = None,
        timeout: int = None,
        tracing_config: TracingConfig = None,
        vpc_config: VPCConfig = None,
    ):
        self.args = args
        self.ca_port = ca_port
        self.code = code
        self.command = command
        self.cpu = cpu
        self.custom_dns = custom_dns
        self.custom_health_check_config = custom_health_check_config
        self.custom_host_alias = custom_host_alias
        self.custom_runtime_config = custom_runtime_config
        self.description = description
        self.disk_size = disk_size
        self.effective_immediately = effective_immediately
        self.enable_app_metric = enable_app_metric
        self.environment_variables = environment_variables
        self.gpu_memory_size = gpu_memory_size
        self.handler = handler
        self.http_trigger_config = http_trigger_config
        self.image_config = image_config
        self.initialization_timeout = initialization_timeout
        self.initializer = initializer
        self.instance_concurrency = instance_concurrency
        self.instance_lifecycle_config = instance_lifecycle_config
        self.instance_soft_concurrency = instance_soft_concurrency
        self.instance_type = instance_type
        self.internet_access = internet_access
        self.layers = layers
        self.liveness_probe = liveness_probe
        self.log_config = log_config
        self.memory_size = memory_size
        self.namespace_id = namespace_id
        self.nas_config = nas_config
        self.oss_mount_config = oss_mount_config
        self.programming_language = programming_language
        self.runtime = runtime
        self.scale_config = scale_config
        self.sls_config = sls_config
        self.startup_probe = startup_probe
        self.timeout = timeout
        self.tracing_config = tracing_config
        self.vpc_config = vpc_config

    def validate(self):
        if self.code:
            self.code.validate()
        if self.custom_dns:
            self.custom_dns.validate()
        if self.custom_health_check_config:
            self.custom_health_check_config.validate()
        if self.custom_host_alias:
            self.custom_host_alias.validate()
        if self.custom_runtime_config:
            self.custom_runtime_config.validate()
        if self.http_trigger_config:
            self.http_trigger_config.validate()
        if self.image_config:
            self.image_config.validate()
        if self.instance_lifecycle_config:
            self.instance_lifecycle_config.validate()
        if self.liveness_probe:
            self.liveness_probe.validate()
        if self.log_config:
            self.log_config.validate()
        if self.nas_config:
            self.nas_config.validate()
        if self.oss_mount_config:
            self.oss_mount_config.validate()
        if self.scale_config:
            self.scale_config.validate()
        if self.sls_config:
            self.sls_config.validate()
        if self.startup_probe:
            self.startup_probe.validate()
        if self.tracing_config:
            self.tracing_config.validate()
        if self.vpc_config:
            self.vpc_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.args is not None:
            result['args'] = self.args
        if self.ca_port is not None:
            result['caPort'] = self.ca_port
        if self.code is not None:
            result['code'] = self.code.to_map()
        if self.command is not None:
            result['command'] = self.command
        if self.cpu is not None:
            result['cpu'] = self.cpu
        if self.custom_dns is not None:
            result['customDNS'] = self.custom_dns.to_map()
        if self.custom_health_check_config is not None:
            result['customHealthCheckConfig'] = self.custom_health_check_config.to_map()
        if self.custom_host_alias is not None:
            result['customHostAlias'] = self.custom_host_alias.to_map()
        if self.custom_runtime_config is not None:
            result['customRuntimeConfig'] = self.custom_runtime_config.to_map()
        if self.description is not None:
            result['description'] = self.description
        if self.disk_size is not None:
            result['diskSize'] = self.disk_size
        if self.effective_immediately is not None:
            result['effectiveImmediately'] = self.effective_immediately
        if self.enable_app_metric is not None:
            result['enableAppMetric'] = self.enable_app_metric
        if self.environment_variables is not None:
            result['environmentVariables'] = self.environment_variables
        if self.gpu_memory_size is not None:
            result['gpuMemorySize'] = self.gpu_memory_size
        if self.handler is not None:
            result['handler'] = self.handler
        if self.http_trigger_config is not None:
            result['httpTriggerConfig'] = self.http_trigger_config.to_map()
        if self.image_config is not None:
            result['imageConfig'] = self.image_config.to_map()
        if self.initialization_timeout is not None:
            result['initializationTimeout'] = self.initialization_timeout
        if self.initializer is not None:
            result['initializer'] = self.initializer
        if self.instance_concurrency is not None:
            result['instanceConcurrency'] = self.instance_concurrency
        if self.instance_lifecycle_config is not None:
            result['instanceLifecycleConfig'] = self.instance_lifecycle_config.to_map()
        if self.instance_soft_concurrency is not None:
            result['instanceSoftConcurrency'] = self.instance_soft_concurrency
        if self.instance_type is not None:
            result['instanceType'] = self.instance_type
        if self.internet_access is not None:
            result['internetAccess'] = self.internet_access
        if self.layers is not None:
            result['layers'] = self.layers
        if self.liveness_probe is not None:
            result['livenessProbe'] = self.liveness_probe.to_map()
        if self.log_config is not None:
            result['logConfig'] = self.log_config.to_map()
        if self.memory_size is not None:
            result['memorySize'] = self.memory_size
        if self.namespace_id is not None:
            result['namespaceID'] = self.namespace_id
        if self.nas_config is not None:
            result['nasConfig'] = self.nas_config.to_map()
        if self.oss_mount_config is not None:
            result['ossMountConfig'] = self.oss_mount_config.to_map()
        if self.programming_language is not None:
            result['programmingLanguage'] = self.programming_language
        if self.runtime is not None:
            result['runtime'] = self.runtime
        if self.scale_config is not None:
            result['scaleConfig'] = self.scale_config.to_map()
        if self.sls_config is not None:
            result['slsConfig'] = self.sls_config.to_map()
        if self.startup_probe is not None:
            result['startupProbe'] = self.startup_probe.to_map()
        if self.timeout is not None:
            result['timeout'] = self.timeout
        if self.tracing_config is not None:
            result['tracingConfig'] = self.tracing_config.to_map()
        if self.vpc_config is not None:
            result['vpcConfig'] = self.vpc_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('args') is not None:
            self.args = m.get('args')
        if m.get('caPort') is not None:
            self.ca_port = m.get('caPort')
        if m.get('code') is not None:
            temp_model = InputCodeLocation()
            self.code = temp_model.from_map(m['code'])
        if m.get('command') is not None:
            self.command = m.get('command')
        if m.get('cpu') is not None:
            self.cpu = m.get('cpu')
        if m.get('customDNS') is not None:
            temp_model = CustomDNS()
            self.custom_dns = temp_model.from_map(m['customDNS'])
        if m.get('customHealthCheckConfig') is not None:
            temp_model = CustomHealthCheckConfig()
            self.custom_health_check_config = temp_model.from_map(m['customHealthCheckConfig'])
        if m.get('customHostAlias') is not None:
            temp_model = CustomHostAlias()
            self.custom_host_alias = temp_model.from_map(m['customHostAlias'])
        if m.get('customRuntimeConfig') is not None:
            temp_model = CustomRuntimeConfig()
            self.custom_runtime_config = temp_model.from_map(m['customRuntimeConfig'])
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('diskSize') is not None:
            self.disk_size = m.get('diskSize')
        if m.get('effectiveImmediately') is not None:
            self.effective_immediately = m.get('effectiveImmediately')
        if m.get('enableAppMetric') is not None:
            self.enable_app_metric = m.get('enableAppMetric')
        if m.get('environmentVariables') is not None:
            self.environment_variables = m.get('environmentVariables')
        if m.get('gpuMemorySize') is not None:
            self.gpu_memory_size = m.get('gpuMemorySize')
        if m.get('handler') is not None:
            self.handler = m.get('handler')
        if m.get('httpTriggerConfig') is not None:
            temp_model = HTTPTriggerConfig()
            self.http_trigger_config = temp_model.from_map(m['httpTriggerConfig'])
        if m.get('imageConfig') is not None:
            temp_model = ImageConfig()
            self.image_config = temp_model.from_map(m['imageConfig'])
        if m.get('initializationTimeout') is not None:
            self.initialization_timeout = m.get('initializationTimeout')
        if m.get('initializer') is not None:
            self.initializer = m.get('initializer')
        if m.get('instanceConcurrency') is not None:
            self.instance_concurrency = m.get('instanceConcurrency')
        if m.get('instanceLifecycleConfig') is not None:
            temp_model = InstanceLifecycleConfig()
            self.instance_lifecycle_config = temp_model.from_map(m['instanceLifecycleConfig'])
        if m.get('instanceSoftConcurrency') is not None:
            self.instance_soft_concurrency = m.get('instanceSoftConcurrency')
        if m.get('instanceType') is not None:
            self.instance_type = m.get('instanceType')
        if m.get('internetAccess') is not None:
            self.internet_access = m.get('internetAccess')
        if m.get('layers') is not None:
            self.layers = m.get('layers')
        if m.get('livenessProbe') is not None:
            temp_model = Probe()
            self.liveness_probe = temp_model.from_map(m['livenessProbe'])
        if m.get('logConfig') is not None:
            temp_model = LogConfig()
            self.log_config = temp_model.from_map(m['logConfig'])
        if m.get('memorySize') is not None:
            self.memory_size = m.get('memorySize')
        if m.get('namespaceID') is not None:
            self.namespace_id = m.get('namespaceID')
        if m.get('nasConfig') is not None:
            temp_model = NASConfig()
            self.nas_config = temp_model.from_map(m['nasConfig'])
        if m.get('ossMountConfig') is not None:
            temp_model = OSSMountConfig()
            self.oss_mount_config = temp_model.from_map(m['ossMountConfig'])
        if m.get('programmingLanguage') is not None:
            self.programming_language = m.get('programmingLanguage')
        if m.get('runtime') is not None:
            self.runtime = m.get('runtime')
        if m.get('scaleConfig') is not None:
            temp_model = ScaleConfig()
            self.scale_config = temp_model.from_map(m['scaleConfig'])
        if m.get('slsConfig') is not None:
            temp_model = SLSConfig()
            self.sls_config = temp_model.from_map(m['slsConfig'])
        if m.get('startupProbe') is not None:
            temp_model = Probe()
            self.startup_probe = temp_model.from_map(m['startupProbe'])
        if m.get('timeout') is not None:
            self.timeout = m.get('timeout')
        if m.get('tracingConfig') is not None:
            temp_model = TracingConfig()
            self.tracing_config = temp_model.from_map(m['tracingConfig'])
        if m.get('vpcConfig') is not None:
            temp_model = VPCConfig()
            self.vpc_config = temp_model.from_map(m['vpcConfig'])
        return self


class UpdateApplicationScaleConfigInput(TeaModel):
    def __init__(
        self,
        always_allocate_cpu: bool = None,
        maximum_instance_count: int = None,
        minimum_instance_count: int = None,
    ):
        self.always_allocate_cpu = always_allocate_cpu
        self.maximum_instance_count = maximum_instance_count
        self.minimum_instance_count = minimum_instance_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.always_allocate_cpu is not None:
            result['alwaysAllocateCPU'] = self.always_allocate_cpu
        if self.maximum_instance_count is not None:
            result['maximumInstanceCount'] = self.maximum_instance_count
        if self.minimum_instance_count is not None:
            result['minimumInstanceCount'] = self.minimum_instance_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alwaysAllocateCPU') is not None:
            self.always_allocate_cpu = m.get('alwaysAllocateCPU')
        if m.get('maximumInstanceCount') is not None:
            self.maximum_instance_count = m.get('maximumInstanceCount')
        if m.get('minimumInstanceCount') is not None:
            self.minimum_instance_count = m.get('minimumInstanceCount')
        return self


class UpdateApplicationTrafficConfigInput(TeaModel):
    def __init__(
        self,
        additional_version_weight: Dict[str, float] = None,
        resolve_policy: str = None,
        route_policy: RoutePolicy = None,
        version_id: str = None,
    ):
        self.additional_version_weight = additional_version_weight
        self.resolve_policy = resolve_policy
        self.route_policy = route_policy
        self.version_id = version_id

    def validate(self):
        if self.route_policy:
            self.route_policy.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.additional_version_weight is not None:
            result['additionalVersionWeight'] = self.additional_version_weight
        if self.resolve_policy is not None:
            result['resolvePolicy'] = self.resolve_policy
        if self.route_policy is not None:
            result['routePolicy'] = self.route_policy.to_map()
        if self.version_id is not None:
            result['versionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('additionalVersionWeight') is not None:
            self.additional_version_weight = m.get('additionalVersionWeight')
        if m.get('resolvePolicy') is not None:
            self.resolve_policy = m.get('resolvePolicy')
        if m.get('routePolicy') is not None:
            temp_model = RoutePolicy()
            self.route_policy = temp_model.from_map(m['routePolicy'])
        if m.get('versionId') is not None:
            self.version_id = m.get('versionId')
        return self


class UpdateAttributesInput(TeaModel):
    def __init__(
        self,
        description: str = None,
        http_trigger_config: HTTPTriggerConfig = None,
        version_id: str = None,
    ):
        self.description = description
        self.http_trigger_config = http_trigger_config
        self.version_id = version_id

    def validate(self):
        if self.http_trigger_config:
            self.http_trigger_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.http_trigger_config is not None:
            result['httpTriggerConfig'] = self.http_trigger_config.to_map()
        if self.version_id is not None:
            result['versionID'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('httpTriggerConfig') is not None:
            temp_model = HTTPTriggerConfig()
            self.http_trigger_config = temp_model.from_map(m['httpTriggerConfig'])
        if m.get('versionID') is not None:
            self.version_id = m.get('versionID')
        return self


class UpdateCustomDomainInput(TeaModel):
    def __init__(
        self,
        application_id: str = None,
        application_name: str = None,
        cert_config: CertConfig = None,
        keep_full_path: bool = None,
        namespace_id: str = None,
        protocol: str = None,
        tls_config: TLSConfig = None,
        waf_config: WAFConfig = None,
    ):
        self.application_id = application_id
        self.application_name = application_name
        self.cert_config = cert_config
        self.keep_full_path = keep_full_path
        self.namespace_id = namespace_id
        self.protocol = protocol
        self.tls_config = tls_config
        self.waf_config = waf_config

    def validate(self):
        if self.cert_config:
            self.cert_config.validate()
        if self.tls_config:
            self.tls_config.validate()
        if self.waf_config:
            self.waf_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_id is not None:
            result['applicationID'] = self.application_id
        if self.application_name is not None:
            result['applicationName'] = self.application_name
        if self.cert_config is not None:
            result['certConfig'] = self.cert_config.to_map()
        if self.keep_full_path is not None:
            result['keepFullPath'] = self.keep_full_path
        if self.namespace_id is not None:
            result['namespaceID'] = self.namespace_id
        if self.protocol is not None:
            result['protocol'] = self.protocol
        if self.tls_config is not None:
            result['tlsConfig'] = self.tls_config.to_map()
        if self.waf_config is not None:
            result['wafConfig'] = self.waf_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('applicationID') is not None:
            self.application_id = m.get('applicationID')
        if m.get('applicationName') is not None:
            self.application_name = m.get('applicationName')
        if m.get('certConfig') is not None:
            temp_model = CertConfig()
            self.cert_config = temp_model.from_map(m['certConfig'])
        if m.get('keepFullPath') is not None:
            self.keep_full_path = m.get('keepFullPath')
        if m.get('namespaceID') is not None:
            self.namespace_id = m.get('namespaceID')
        if m.get('protocol') is not None:
            self.protocol = m.get('protocol')
        if m.get('tlsConfig') is not None:
            temp_model = TLSConfig()
            self.tls_config = temp_model.from_map(m['tlsConfig'])
        if m.get('wafConfig') is not None:
            temp_model = WAFConfig()
            self.waf_config = temp_model.from_map(m['wafConfig'])
        return self


class UpdateWebApplicationInput(TeaModel):
    def __init__(
        self,
        description: str = None,
        web_network_config: WebNetworkConfig = None,
    ):
        self.description = description
        self.web_network_config = web_network_config

    def validate(self):
        if self.web_network_config:
            self.web_network_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.web_network_config is not None:
            result['WebNetworkConfig'] = self.web_network_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('WebNetworkConfig') is not None:
            temp_model = WebNetworkConfig()
            self.web_network_config = temp_model.from_map(m['WebNetworkConfig'])
        return self


class UpdateWebApplicationScalingConfigInput(TeaModel):
    def __init__(
        self,
        maximum_instance_count: int = None,
        minimum_instance_count: int = None,
    ):
        # This parameter is required.
        self.maximum_instance_count = maximum_instance_count
        # This parameter is required.
        self.minimum_instance_count = minimum_instance_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.maximum_instance_count is not None:
            result['MaximumInstanceCount'] = self.maximum_instance_count
        if self.minimum_instance_count is not None:
            result['MinimumInstanceCount'] = self.minimum_instance_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaximumInstanceCount') is not None:
            self.maximum_instance_count = m.get('MaximumInstanceCount')
        if m.get('MinimumInstanceCount') is not None:
            self.minimum_instance_count = m.get('MinimumInstanceCount')
        return self


class UpdateWebApplicationTrafficConfigInput(TeaModel):
    def __init__(
        self,
        auth_type: str = None,
        disable_urlinternet: bool = None,
        revisions_traffic_weight: Dict[str, float] = None,
        web_acl_config: WebAclConfig = None,
    ):
        self.auth_type = auth_type
        self.disable_urlinternet = disable_urlinternet
        self.revisions_traffic_weight = revisions_traffic_weight
        self.web_acl_config = web_acl_config

    def validate(self):
        if self.web_acl_config:
            self.web_acl_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_type is not None:
            result['AuthType'] = self.auth_type
        if self.disable_urlinternet is not None:
            result['DisableURLInternet'] = self.disable_urlinternet
        if self.revisions_traffic_weight is not None:
            result['RevisionsTrafficWeight'] = self.revisions_traffic_weight
        if self.web_acl_config is not None:
            result['WebAclConfig'] = self.web_acl_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthType') is not None:
            self.auth_type = m.get('AuthType')
        if m.get('DisableURLInternet') is not None:
            self.disable_urlinternet = m.get('DisableURLInternet')
        if m.get('RevisionsTrafficWeight') is not None:
            self.revisions_traffic_weight = m.get('RevisionsTrafficWeight')
        if m.get('WebAclConfig') is not None:
            temp_model = WebAclConfig()
            self.web_acl_config = temp_model.from_map(m['WebAclConfig'])
        return self


class UpdateWebCustomDomainInput(TeaModel):
    def __init__(
        self,
        default_forwarding_app_name: str = None,
        protocol: str = None,
        route_config: RouteConfig = None,
        web_cert_config: WebCertConfig = None,
        web_tlsconfig: WebTLSConfig = None,
        web_wafconfig: WebWAFConfig = None,
    ):
        self.default_forwarding_app_name = default_forwarding_app_name
        self.protocol = protocol
        self.route_config = route_config
        self.web_cert_config = web_cert_config
        self.web_tlsconfig = web_tlsconfig
        self.web_wafconfig = web_wafconfig

    def validate(self):
        if self.route_config:
            self.route_config.validate()
        if self.web_cert_config:
            self.web_cert_config.validate()
        if self.web_tlsconfig:
            self.web_tlsconfig.validate()
        if self.web_wafconfig:
            self.web_wafconfig.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_forwarding_app_name is not None:
            result['DefaultForwardingAppName'] = self.default_forwarding_app_name
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.route_config is not None:
            result['RouteConfig'] = self.route_config.to_map()
        if self.web_cert_config is not None:
            result['WebCertConfig'] = self.web_cert_config.to_map()
        if self.web_tlsconfig is not None:
            result['WebTLSConfig'] = self.web_tlsconfig.to_map()
        if self.web_wafconfig is not None:
            result['WebWAFConfig'] = self.web_wafconfig.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DefaultForwardingAppName') is not None:
            self.default_forwarding_app_name = m.get('DefaultForwardingAppName')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('RouteConfig') is not None:
            temp_model = RouteConfig()
            self.route_config = temp_model.from_map(m['RouteConfig'])
        if m.get('WebCertConfig') is not None:
            temp_model = WebCertConfig()
            self.web_cert_config = temp_model.from_map(m['WebCertConfig'])
        if m.get('WebTLSConfig') is not None:
            temp_model = WebTLSConfig()
            self.web_tlsconfig = temp_model.from_map(m['WebTLSConfig'])
        if m.get('WebWAFConfig') is not None:
            temp_model = WebWAFConfig()
            self.web_wafconfig = temp_model.from_map(m['WebWAFConfig'])
        return self


class WebApplicationBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: WebApplication = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = WebApplication()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class WebApplicationInstanceLogsBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: DescribeInstanceLogsOutput = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeInstanceLogsOutput()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class WebApplicationResourceStaticsBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: DescribeWebAppStaticsOutput = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeWebAppStaticsOutput()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class WebApplicationRevisionBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: Revision = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = Revision()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class WebApplicationScalingConfigBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: WebScalingConfig = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = WebScalingConfig()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class WebApplicationStatus(TeaModel):
    def __init__(
        self,
        instance_count: int = None,
        web_scaling_config: WebScalingConfig = None,
    ):
        self.instance_count = instance_count
        self.web_scaling_config = web_scaling_config

    def validate(self):
        if self.web_scaling_config:
            self.web_scaling_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.web_scaling_config is not None:
            result['WebScalingConfig'] = self.web_scaling_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('WebScalingConfig') is not None:
            temp_model = WebScalingConfig()
            self.web_scaling_config = temp_model.from_map(m['WebScalingConfig'])
        return self


class WebApplicationTrafficConfigBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: WebTrafficConfig = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = WebTrafficConfig()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class WebApplicationWithStatus(TeaModel):
    def __init__(
        self,
        status: WebApplicationStatus = None,
        web_application: WebApplication = None,
    ):
        self.status = status
        self.web_application = web_application

    def validate(self):
        if self.status:
            self.status.validate()
        if self.web_application:
            self.web_application.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status.to_map()
        if self.web_application is not None:
            result['WebApplication'] = self.web_application.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Status') is not None:
            temp_model = WebApplicationStatus()
            self.status = temp_model.from_map(m['Status'])
        if m.get('WebApplication') is not None:
            temp_model = WebApplication()
            self.web_application = temp_model.from_map(m['WebApplication'])
        return self


class WebCustomDomainBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: WebCustomDomain = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = WebCustomDomain()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DataInstancesValueListenersValue(TeaModel):
    def __init__(
        self,
        protocol: str = None,
        port: int = None,
        status: str = None,
        target_port: int = None,
        cert_ids: str = None,
    ):
        # The listener protocol.
        self.protocol = protocol
        # The listener port of the NLB instance.
        self.port = port
        # The status of the NLB listener.
        # 
        # *   **Creating**: The listener is being created.
        # *   **Configuring**: The listener is being configured.
        # *   **Bounded**: The listener runs as expected.
        # *   **Unbinding**: The listener is being deleted.
        # *   **Failed**: The listener is unavailable.
        self.status = status
        # The open ports of the NLB instance.
        self.target_port = target_port
        # The server certificates.
        self.cert_ids = cert_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.port is not None:
            result['Port'] = self.port
        if self.status is not None:
            result['Status'] = self.status
        if self.target_port is not None:
            result['TargetPort'] = self.target_port
        if self.cert_ids is not None:
            result['CertIds'] = self.cert_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TargetPort') is not None:
            self.target_port = m.get('TargetPort')
        if m.get('CertIds') is not None:
            self.cert_ids = m.get('CertIds')
        return self


class DataInstancesValue(TeaModel):
    def __init__(
        self,
        dns_name: str = None,
        listeners: Dict[str, DataInstancesValueListenersValue] = None,
        created_by_sae: bool = None,
    ):
        # The domain name.
        self.dns_name = dns_name
        # The listeners.
        self.listeners = listeners
        # Indicates whether the instance is created by SAE.
        # 
        # *   **true**: The instance is created by SAE.
        # *   **false**: The existing instance is reused.
        self.created_by_sae = created_by_sae

    def validate(self):
        if self.listeners:
            for v in self.listeners.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dns_name is not None:
            result['DnsName'] = self.dns_name
        result['Listeners'] = {}
        if self.listeners is not None:
            for k, v in self.listeners.items():
                result['Listeners'][k] = v.to_map()
        if self.created_by_sae is not None:
            result['CreatedBySae'] = self.created_by_sae
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DnsName') is not None:
            self.dns_name = m.get('DnsName')
        self.listeners = {}
        if m.get('Listeners') is not None:
            for k, v in m.get('Listeners').items():
                temp_model = DataInstancesValueListenersValue()
                self.listeners[k] = temp_model.from_map(v)
        if m.get('CreatedBySae') is not None:
            self.created_by_sae = m.get('CreatedBySae')
        return self


class AbortAndRollbackChangeOrderRequest(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order.
        # 
        # This parameter is required.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class AbortAndRollbackChangeOrderResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class AbortAndRollbackChangeOrderResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: AbortAndRollbackChangeOrderResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The details of the change order.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the change order was terminated. Valid values:
        # 
        # *   **true**: The change order was terminated.
        # *   **false**: The change order failed to be terminated.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = AbortAndRollbackChangeOrderResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class AbortAndRollbackChangeOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AbortAndRollbackChangeOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AbortAndRollbackChangeOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AbortChangeOrderRequest(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        rollback: bool = None,
    ):
        # The ID of the change order.
        # 
        # This parameter is required.
        self.change_order_id = change_order_id
        self.rollback = rollback

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.rollback is not None:
            result['Rollback'] = self.rollback
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('Rollback') is not None:
            self.rollback = m.get('Rollback')
        return self


class AbortChangeOrderResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class AbortChangeOrderResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: AbortChangeOrderResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The request was successful.
        # *   **3xx**: The request was redirected.
        # *   **4xx**: The request failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The data returned.
        self.data = data
        # The error code. Value values:
        # 
        # *   **ErrorCode** is not returned if a request is successful.
        # *   **ErrorCode** is returned if a request failed. For more information, see **Error code** section of this topic.
        self.error_code = error_code
        # The message returned for the operation.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the change order was terminated. Valid values:
        # 
        # *   **true**: The change order was terminated.
        # *   **false**: The change order failed to be terminated.
        self.success = success
        # The ID of the trace.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = AbortChangeOrderResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class AbortChangeOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AbortChangeOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AbortChangeOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchStartApplicationsRequest(TeaModel):
    def __init__(
        self,
        app_ids: str = None,
        namespace_id: str = None,
        version: str = None,
    ):
        # The IDs of the applications that you want to start. Separate multiple IDs with commas (,).
        self.app_ids = app_ids
        # The ID of the request.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # The application version.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_ids is not None:
            result['AppIds'] = self.app_ids
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppIds') is not None:
            self.app_ids = m.get('AppIds')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class BatchStartApplicationsResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class BatchStartApplicationsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BatchStartApplicationsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Take note of the following rules:
        # 
        # - **2xx**: The call was successful.
        # - **3xx**: The call was redirected.
        # - **4xx**: The call failed.
        # - **5xx**: A server error occurred.
        self.code = code
        # The error code.
        # 
        # *   If the request is successful, this parameter is not returned.****\
        # *   This parameter is returned only if the request failed.**** For more information, see **Error codes** in this topic.
        self.data = data
        # The error code returned if the request failed. Take note of the following rules:
        # 
        # - The ErrorCode parameter is not returned if the request succeeds.
        # - If the call fails, the ErrorCode parameter is returned. For more information, see the "Error codes" section of this topic.
        self.error_code = error_code
        # The returned data.
        self.message = message
        # The ID of the trace. It is used to query the details of a request.
        self.request_id = request_id
        # Indicates whether the application deployment is successful. Take note of the following rules:
        # 
        # - **true**\
        # - **false**\
        self.success = success
        # The ID of the change order.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BatchStartApplicationsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class BatchStartApplicationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchStartApplicationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchStartApplicationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchStopApplicationsRequest(TeaModel):
    def __init__(
        self,
        app_ids: str = None,
        namespace_id: str = None,
        version: str = None,
    ):
        # The ID of the application that you want to stop.
        # 
        # > If you want to stop multiple applications at the same time, separate the IDs with commas (,).
        self.app_ids = app_ids
        # ebf491f0-c1a5-45e2-b2c4-710dbe2a\\*\\*\\*\\*,ebf491f0-c1a5-45e2-b2c4-71025e2a\\*\\*\\*\\*\
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # The application version.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_ids is not None:
            result['AppIds'] = self.app_ids
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppIds') is not None:
            self.app_ids = m.get('AppIds')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class BatchStopApplicationsResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The error code.
        # 
        # *   If the request is successful, this parameter is not returned.****\
        # *   This parameter is returned only if the request failed.**** For more information, see the "**Error codes**" section in this topic.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class BatchStopApplicationsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BatchStopApplicationsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Take note of the following rules:
        # 
        # - **2xx**: The call was successful.
        # - **3xx**: The call was redirected.
        # - **4xx**: The call failed.
        # - **5xx**: A server error occurred.
        self.code = code
        # The ID of the change order.
        self.data = data
        # The error code returned if the request failed. Take note of the following rules:
        # 
        # - The ErrorCode parameter is not returned if the request succeeds.
        # - If the call fails, the ErrorCode parameter is returned. For more information, see the "Error codes" section of this topic.
        self.error_code = error_code
        # The ID of the trace. It can be used to query the details of a request.
        self.message = message
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.request_id = request_id
        # Indicates whether the application is created. Valid values
        # 
        # - **true**\
        # - **false**\
        self.success = success
        # The returned data.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BatchStopApplicationsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class BatchStopApplicationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchStopApplicationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchStopApplicationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindNlbRequest(TeaModel):
    def __init__(
        self,
        address_type: str = None,
        app_id: str = None,
        listeners: str = None,
        nlb_id: str = None,
        zone_mappings: str = None,
    ):
        # The type of the IP addresses. Valid values:
        # 
        # *   Internet: public endpoint.
        # *   Intranet: private endpoint.
        self.address_type = address_type
        # The ID of the application to which the NLB instance is bound.
        self.app_id = app_id
        # The listener that you want to manage. The value is a string that consists of JSON arrays. Each listener contains the following fields:
        # 
        # *   **port**: the port number of the NLB listener. This field is required. Data type: integer. Valid values: 0 to 65535.
        # *   **TargetPort**: the port number of the container listener. This field is required. Data type: integer. Valid values: 0 to 65535.
        # *   **Protocol**: the listener protocol. This field is required. Data type: string. Valid values: TCP, UDP, and TCPSSL.
        # *   **CertIds**: the IDs of the server certificates. This field is optional. Data type: string. This field is supported only by TCPSSL listeners.
        self.listeners = listeners
        # The ID of the NLB instance.
        self.nlb_id = nlb_id
        # The mappings between zones and vSwitches. The value is a JSON string. You can specify at most 10 zones. If the region supports two or more zones, specify at least two zones. A ZoneMapping contains the following fields:
        # 
        # *   The ID of the vSwitch in the zone. Each zone can contain only one vSwitch and one subnet. Data type: string.
        # *   The zone ID of the NLB instance. Data type: string.
        self.zone_mappings = zone_mappings

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_type is not None:
            result['AddressType'] = self.address_type
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.listeners is not None:
            result['Listeners'] = self.listeners
        if self.nlb_id is not None:
            result['NlbId'] = self.nlb_id
        if self.zone_mappings is not None:
            result['ZoneMappings'] = self.zone_mappings
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressType') is not None:
            self.address_type = m.get('AddressType')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Listeners') is not None:
            self.listeners = m.get('Listeners')
        if m.get('NlbId') is not None:
            self.nlb_id = m.get('NlbId')
        if m.get('ZoneMappings') is not None:
            self.zone_mappings = m.get('ZoneMappings')
        return self


class BindNlbResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order. The ID can be used to query the status of the change task.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class BindNlbResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BindNlbResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The request was successful.
        # *   **3xx**: The request was redirected.
        # *   **4xx**: The request failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The status code. Value values:
        # 
        # *   If the request was successful, **ErrorCode** is not returned.
        # *   If the request failed, **ErrorCode** is returned. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The message returned. Valid values:
        # 
        # *   If the request was successful, **success** is returned.
        # *   If the request failed, an error code is returned.
        self.message = message
        # Id of the request
        self.request_id = request_id
        # Indicates whether the applications were stopped. Valid values:
        # 
        # *   **true**: The applications were stopped.
        # *   **false**: The applications failed to be stopped.
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BindNlbResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class BindNlbResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindNlbResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindNlbResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindSlbRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        internet: str = None,
        internet_slb_charge_type: str = None,
        internet_slb_id: str = None,
        intranet: str = None,
        intranet_slb_charge_type: str = None,
        intranet_slb_id: str = None,
    ):
        # 0099b7be-5f5b-4512-a7fc-56049ef1\\*\\*\\*\\*\
        # 
        # This parameter is required.
        self.app_id = app_id
        # [{"port":80,"targetPort":8080,"protocol":"TCP"}]
        self.internet = internet
        # The billing method of an Internet-facing SLB instance. The following billing methods are supported:
        # 
        # *   **PayBySpec**: Pay-by-specification.
        # *   **PayByCLCU**: Pay-by-CLCU.
        self.internet_slb_charge_type = internet_slb_charge_type
        # lb-bp1tg0k6d9nqaw7l1\\*\\*\\*\\*\
        self.internet_slb_id = internet_slb_id
        # [{"port":80,"targetPort":8080,"protocol":"TCP"}]
        self.intranet = intranet
        # The billing method of an Internal-facing SLB instance. The following billing methods are supported:
        # 
        # *   **PayBySpec**: Pay-by-specification.
        # *   **PayByCLCU**: Pay-by-CLCU.
        self.intranet_slb_charge_type = intranet_slb_charge_type
        # lb-bp1tg0k6d9nqaw7l1\\*\\*\\*\\*\
        self.intranet_slb_id = intranet_slb_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.internet is not None:
            result['Internet'] = self.internet
        if self.internet_slb_charge_type is not None:
            result['InternetSlbChargeType'] = self.internet_slb_charge_type
        if self.internet_slb_id is not None:
            result['InternetSlbId'] = self.internet_slb_id
        if self.intranet is not None:
            result['Intranet'] = self.intranet
        if self.intranet_slb_charge_type is not None:
            result['IntranetSlbChargeType'] = self.intranet_slb_charge_type
        if self.intranet_slb_id is not None:
            result['IntranetSlbId'] = self.intranet_slb_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Internet') is not None:
            self.internet = m.get('Internet')
        if m.get('InternetSlbChargeType') is not None:
            self.internet_slb_charge_type = m.get('InternetSlbChargeType')
        if m.get('InternetSlbId') is not None:
            self.internet_slb_id = m.get('InternetSlbId')
        if m.get('Intranet') is not None:
            self.intranet = m.get('Intranet')
        if m.get('IntranetSlbChargeType') is not None:
            self.intranet_slb_charge_type = m.get('IntranetSlbChargeType')
        if m.get('IntranetSlbId') is not None:
            self.intranet_slb_id = m.get('IntranetSlbId')
        return self


class BindSlbResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order. It can be used to query the task status.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class BindSlbResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BindSlbResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the SLB instance was successfully associated with the application. Valid values:
        # 
        # *   **true**: The SLB instance was successfully associated with the application.
        # *   **false**: The SLB instance could not be associated with the application.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BindSlbResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class BindSlbResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindSlbResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindSlbResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ConfirmPipelineBatchRequest(TeaModel):
    def __init__(
        self,
        confirm: bool = None,
        pipeline_id: str = None,
    ):
        # true
        # 
        # This parameter is required.
        self.confirm = confirm
        # The ID of the batch. You can call the [DescribeChangeOrder](https://www.alibabacloud.com/help/zh/sae/serverless-app-engine-classic/developer-reference/api-sae-2019-05-06-describechangeorder-old?spm=a2c63.p38356.help-menu-search-118957.d_0) operation to obtain the ID.
        # 
        # This parameter is required.
        self.pipeline_id = pipeline_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.confirm is not None:
            result['Confirm'] = self.confirm
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Confirm') is not None:
            self.confirm = m.get('Confirm')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        return self


class ConfirmPipelineBatchResponseBodyData(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
    ):
        # The ID of the batch.
        self.pipeline_id = pipeline_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        return self


class ConfirmPipelineBatchResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ConfirmPipelineBatchResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The batch information.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the processing of the next batch started as required. Valid values:
        # 
        # *   **true**: The processing started.
        # *   **false**: The processing could not start.
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ConfirmPipelineBatchResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ConfirmPipelineBatchResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ConfirmPipelineBatchResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ConfirmPipelineBatchResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateApplicationRequest(TeaModel):
    def __init__(
        self,
        acr_assume_role_arn: str = None,
        acr_instance_id: str = None,
        app_description: str = None,
        app_name: str = None,
        app_source: str = None,
        associate_eip: bool = None,
        auto_config: bool = None,
        base_app_id: str = None,
        command: str = None,
        command_args: str = None,
        config_map_mount_desc: str = None,
        cpu: int = None,
        custom_host_alias: str = None,
        custom_image_network_type: str = None,
        deploy: bool = None,
        disk_size: int = None,
        dotnet: str = None,
        edas_container_version: str = None,
        enable_cpu_burst: bool = None,
        enable_ebpf: str = None,
        enable_new_arms: bool = None,
        enable_prometheus: bool = None,
        enable_sidecar_resource_isolated: bool = None,
        envs: str = None,
        gpu_config: str = None,
        html: str = None,
        image_pull_secrets: str = None,
        image_url: str = None,
        init_containers_config: List[InitContainerConfig] = None,
        is_stateful: bool = None,
        jar_start_args: str = None,
        jar_start_options: str = None,
        jdk: str = None,
        kafka_configs: str = None,
        liveness: str = None,
        memory: int = None,
        micro_registration: str = None,
        micro_registration_config: str = None,
        microservice_engine_config: str = None,
        mount_desc: str = None,
        mount_host: str = None,
        namespace_id: str = None,
        nas_configs: str = None,
        nas_id: str = None,
        new_sae_version: str = None,
        oidc_role_name: str = None,
        oss_ak_id: str = None,
        oss_ak_secret: str = None,
        oss_mount_descs: str = None,
        package_type: str = None,
        package_url: str = None,
        package_version: str = None,
        php: str = None,
        php_arms_config_location: str = None,
        php_config: str = None,
        php_config_location: str = None,
        post_start: str = None,
        pre_stop: str = None,
        programming_language: str = None,
        pvtz_discovery_svc: str = None,
        python: str = None,
        python_modules: str = None,
        readiness: str = None,
        replicas: int = None,
        resource_type: str = None,
        sae_version: str = None,
        secret_mount_desc: str = None,
        security_group_id: str = None,
        service_tags: str = None,
        sidecar_containers_config: List[SidecarContainerConfig] = None,
        sls_configs: str = None,
        startup_probe: str = None,
        termination_grace_period_seconds: int = None,
        timezone: str = None,
        tomcat_config: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
        war_start_options: str = None,
        web_container: str = None,
    ):
        # The Alibaba Cloud Resource Name (ARN) required for a RAM role to obtain images across accounts. For more information, see [Grant permissions across Alibaba Cloud accounts by using a RAM role](https://help.aliyun.com/document_detail/223585.html).
        self.acr_assume_role_arn = acr_assume_role_arn
        # The ID of Container Registry Enterprise Edition instance N. This parameter is required when the **ImageUrl** parameter is set to the URL of an image in an ACR Enterprise Edition instance.
        self.acr_instance_id = acr_instance_id
        # The description of the template. The description cannot exceed 1,024 characters in length.
        self.app_description = app_description
        # The name of the application. The name can contain digits, letters, and hyphens (-). The name must start with a letter and cannot end with a hyphen (-). It cannot exceed 36 characters in length.
        # 
        # This parameter is required.
        self.app_name = app_name
        # Select micro_service, which is the application.
        self.app_source = app_source
        # Specifies whether to associate an EIP with the node pool. Take note of the following rules:
        # 
        # *   **true**: The EIP is associated with the application instance.
        # *   **false**: The EIP is not associated with the application instance.
        self.associate_eip = associate_eip
        # Specifies whether to automatically configure the network environment. Valid values:
        # 
        # *   **true**: SAE automatically configures the network environment when you create the application. If you set this parameter to true, the values of the **NamespaceId**, **VpcId**, **vSwitchId**, and **SecurityGroupId** parameters are ignored.
        # *   **false**: SAE configures the network environment based on your settings when you create the application.
        # 
        # >  If you select **true**, other **NamespaceId** will be ignored.
        self.auto_config = auto_config
        # The ID of the basic application.
        self.base_app_id = base_app_id
        # The command that is used to start the image. The command must be an existing executable object in the container. Sample statements:
        # 
        #     command:
        #           - echo
        #           - abc
        #           - >
        #           - file0
        # 
        # In this example, the Command parameter is set to `Command="echo", CommandArgs=["abc", ">", "file0"]`.
        self.command = command
        # The parameters of the image startup command. The CommandArgs parameter specifies the parameters that are required for the **Command** parameter. You can specify the name in one of the following formats:
        # 
        # `["a","b"]`
        # 
        # In the preceding example, the CommandArgs parameter is set to `CommandArgs=["abc", ">", "file0"]`. The data type of `["abc", ">", "file0"]` must be an array of strings in the JSON format. This parameter is optional.
        self.command_args = command_args
        # The description of the **ConfigMap** instance mounted to the application. Use configurations created on the Configuration Items page to configure containers. The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **congfigMapId**: the ID of the ConfigMap instance. You can call the [ListNamespacedConfigMaps](https://help.aliyun.com/document_detail/176917.html) operation to obtain the ID.
        # *   **key**: the key.
        # 
        # > You can use `sae-sys-configmap-all` to mount all keys.
        # 
        # *   **mountPath**: the mount path in the container.
        self.config_map_mount_desc = config_map_mount_desc
        # The CPU specifications that are required for each instance. Unit: millicores. This parameter cannot be set to 0. Valid values:
        # 
        # *   **500**\
        # *   **1000**\
        # *   **2000**\
        # *   **4000**\
        # *   **8000**\
        # *   **12000**\
        # *   **16000**\
        # *   **32000**\
        self.cpu = cpu
        # The custom mappings between hostnames and IP addresses in the container. Take note of the following rules:
        # 
        # *   **hostName**: the domain name or hostname.
        # *   **ip**: the IP address.
        self.custom_host_alias = custom_host_alias
        # Custom image type. To it to empty string to use pre-built image.
        # 
        # - internet: Public network image
        # 
        # - intranet: Private network image
        self.custom_image_network_type = custom_image_network_type
        # Whether to deploy now.
        # 
        # *   **true** (default): Deploy now.
        # *   **false**: Deploy later.
        self.deploy = deploy
        # The disk size. Unit: GB.
        self.disk_size = disk_size
        # . NET Framework version number:
        # 
        # *   .NET 3.1
        # *   .NET 5.0
        # *   .NET 6.0
        # *   .NET 7.0
        # *   .NET 8.0
        self.dotnet = dotnet
        # The version of the container in HSF.
        self.edas_container_version = edas_container_version
        # Enable CPU Burst.
        # - true: enable
        # - false: disable
        self.enable_cpu_burst = enable_cpu_burst
        # Enable application monitoring for non-Java applications based on eBPF technology. The value options are as follows:
        # 
        # - true: Enable.
        # - false: Disable (default).
        self.enable_ebpf = enable_ebpf
        # Indicates whether to enable the new ARMS feature:
        # 
        # *   true: enables this parameter.
        # *   false: disables this parameter.
        self.enable_new_arms = enable_new_arms
        self.enable_prometheus = enable_prometheus
        # Enable Sidecar resource isolation.
        # 
        # - true: enable
        # - false: disable
        self.enable_sidecar_resource_isolated = enable_sidecar_resource_isolated
        # The environment variables. You can configure custom environment variables or reference a ConfigMap. Before you can reference a ConfigMap, you must create a ConfigMap. For more information, see [CreateConfigMap](https://help.aliyun.com/document_detail/176914.html). Valid values:
        # 
        # *   Custom configuration
        # 
        #     *   **name**: the name of the environment variable.
        #     *   **value**: the value of the environment variable. The priority of the custom configuration is higher than valueFrom.
        # 
        # *   Reference a ConfigMap (valueFrom)
        # 
        #     *   **name**: the name of the environment variable. You can reference one or all keys. To reference all keys, specify `sae-sys-configmap-all-<ConfigMap name>`. Example: `sae-sys-configmap-all-test1`.
        #     *   **valueFrom**: the reference of the environment variable. Valid value: `configMapRef`.
        #     *   **configMapId**: the ID of the ConfigMap.
        #     *   **key**: the key. If you want to reference all key values, you do not need to configure this parameter.
        self.envs = envs
        self.gpu_config = gpu_config
        self.html = html
        # The ID of the corresponding Secret.
        self.image_pull_secrets = image_pull_secrets
        # The URL of the image. This parameter is required if you set the `PackageType` parameter to `Image`.
        self.image_url = image_url
        # Initialize container configuration.
        self.init_containers_config = init_containers_config
        self.is_stateful = is_stateful
        # The arguments in the JAR package. The arguments are used to start the application container. The default startup command is `$JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs`.
        self.jar_start_args = jar_start_args
        # The option settings in the JAR package. The settings are used to start the application container. The default startup command for application deployment is `$JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs`.
        self.jar_start_options = jar_start_options
        # The version of the Java development kit (JDK) on which the deployment package of the application depends. The following versions are supported:
        # 
        # *   **Open JDK 8**\
        # *   **Open JDK 7**\
        # *   **Dragonwell 11**\
        # *   **Dragonwell 8**\
        # *   **openjdk-8u191-jdk-alpine3.9**\
        # *   **openjdk-7u201-jdk-alpine3.9**\
        # 
        # This parameter is not returned if the **PackageType** parameter is set to **Image**.
        self.jdk = jdk
        # The logging configurations of Message Queue for Apache Kafka. Take note of the following rules:
        # 
        # *   **kafkaEndpoint**: the endpoint of the Message Queue for Apache Kafka API.
        # *   **kafkaInstanceId**: the ID of the Message Queue for Apache Kafka instance.
        # *   **kafkaConfigs**: One or more logging configurations of Message Queue for Apache Kafka. For information about sample values and parameters, see the request parameter **KafkaLogfileConfig** in this topic.
        self.kafka_configs = kafka_configs
        # Container health check. If the container fails this check, it will be revoked and relaunch again. Use one of the following methods to perform the health check:
        # 
        # *   Example of **exec**: `{"exec":{"command":["sh","-c","cat/home/admin/start.sh"]},"initialDelaySeconds":30,"periodSeconds":30,"timeoutSeconds":2}`
        # *   Sample code of the **httpGet** method: `{"httpGet":{"path":"/","port":18091,"scheme":"HTTP","isContainKeyWord":true,"keyWord":"SAE"},"initialDelaySeconds":11,"periodSeconds":10,"timeoutSeconds":1}`
        # *   Sample code of the **tcpSocket** method: `{"tcpSocket":{"port":18091},"initialDelaySeconds":11,"periodSeconds":10,"timeoutSeconds":1}`
        # 
        # > You can use only one method to perform the health check.
        # 
        # The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **exec.command**: the health check command.
        # *   **httpGet.path**: the request path.
        # *   **httpGet.scheme**: the protocol that is used to perform the health check. Valid values: **HTTP** and **HTTPS**.
        # *   **httpGet.isContainKeyWord**: indicates whether the response contains keywords. Valid values: **true** and **false**. If this field is not returned, the advanced settings are not used.
        # *   **httpGet.keyWord**: the custom keyword. This parameter is available only if the **isContainKeyWord** field is returned.
        # *   **tcpSocket.port**: the port that is used to check the status of TCP connections.
        # *   **initialDelaySeconds**: the delay of the health check. Default value: 10. Unit: seconds.
        # *   **periodSeconds**: the interval at which health checks are performed. Default value: 30. Unit: seconds.
        # *   **timeoutSeconds**: the timeout period of the health check. Default value: 1. Unit: seconds. If you set this parameter to 0 or leave this parameter empty, the timeout period is automatically set to 1 second.
        self.liveness = liveness
        # The memory size that is required by each instance. Unit: MB. This parameter cannot be set to 0. The values of this parameter correspond to the values of the Cpu parameter:
        # 
        # *   This parameter is set to **1024** if the Cpu parameter is set to 500 or 1000.
        # *   This parameter is set to **2048** if the Cpu parameter is set to 500, 1000, or 2000.
        # *   This parameter is set to **4096** if the Cpu parameter is set to 1000, 2000, or 4000.
        # *   This parameter is set to **8192** if the Cpu parameter is set to 2000, 4000, or 8,000.
        # *   This parameter is set to **12288** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **16384** if the Cpu parameter is set to 4000, 8000, or 16000.
        # *   This parameter is set to **24576** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **32768** if the Cpu parameter is set to 16000.
        # *   This parameter is set to **65536** if the Cpu parameter is set to 8000, 16000, or 32000.
        # *   This parameter is set to **131072** if the Cpu parameter is set to 32000.
        self.memory = memory
        # The Nacos registry. Valid values:
        # 
        # *   **0**: SAE built-in Nacos registry
        # *   **1**: self-managed Nacos registry
        # *   **2** : MSE enterprise edition Nacos registry
        self.micro_registration = micro_registration
        # The Registry configurations.
        self.micro_registration_config = micro_registration_config
        # Configure microservices governance
        # 
        # Whether to enable microservices governance (enable):
        # - true: Enable
        # - false: Disable
        # 
        # Configure lossless online/offline deployment (mseLosslessRule):
        # 
        # delayTime: Delay duration (unit: seconds)
        # 
        # enable: Whether to enable lossless deployment
        # 
        # - true: Enable
        # 
        # - false: Disable
        # 
        # notice: Whether to enable notifications
        # 
        # - true: Enable
        # 
        # - false: Disable
        # 
        # warmupTime: Small-traffic warm-up duration (unit: seconds)
        self.microservice_engine_config = microservice_engine_config
        # It is not recommended to configure this field; configuring NasConfigs instead. This field specifies the NAS mount description. When deploying, if the configuration has not changed, you do not need to set this parameter (i.e., the MountDesc field does not need to be included in the request). If you need to clear the NAS configuration, set the value of this field to an empty string in the request (i.e., set the value of the MountDesc field to "").
        self.mount_desc = mount_desc
        # It is not recommended to configure this field; configuring NasConfigs instead. This field specifies the NAS mount point within the application\\"s VPC. When deploying, if the configuration has not changed, you do not need to set this parameter (i.e., the MountHost field does not need to be included in the request). If you need to clear the NAS configuration, set the value of this field to an empty string in the request (i.e., set the value of the MountHost field to "").
        self.mount_host = mount_host
        # SAE namespace ID. Only namespaces consisting of lowercase letters and hyphens (-) are supported, and the name must start with a letter.
        self.namespace_id = namespace_id
        # The configurations of mounting the NAS file system. Take note of the following rules:
        # 
        # *   **mountPath**: the mount path of the container.
        # *   **readOnly**: If you set the value to **false**, the application has the read and write permissions.
        # *   **nasId**: the ID of the NAS file system.
        # *   **mountDomain**: the domain name of the mount target. For more information, see [DescribeMountTargets](https://help.aliyun.com/document_detail/62626.html).
        # *   **nasPath**: the directory in the NAS file system.
        self.nas_configs = nas_configs
        # It is not recommended to configure this field; configuring NasConfigs instead. The ID of the mounted NAS must be in the same region as the cluster. The NAS must have available mount point quota or its mount point must already be on a switch within the VPC. If this field is not specified and the mountDescs field exists, a NAS will be automatically purchased and mounted to a switch within the VPC by default.
        # 
        # When deploying, if the configuration has not changed, you do not need to set this parameter (i.e., the NASId field does not need to be included in the request). If you need to clear the NAS configuration, set the value of this field to an empty string in the request (i.e., set the value of the NASId field to "").
        self.nas_id = nas_id
        # SAE edition.
        # 
        # - lite: the lightweight edition.
        # 
        # - std: the standard edition.
        # 
        # - pro: the professional edition.
        self.new_sae_version = new_sae_version
        # The name of the RAM role used to authenticate the user identity.
        # 
        # >  You need to create an OpenID Connect (OIDC) identity provider (IdP) and an identity provider (IdP) for role-based single sign-on (SSO) in advance. For more information, see [Creates an OpenID Connect (OIDC) identity provider (IdP)](https://help.aliyun.com/document_detail/2331022.html) and [Creates an identity provider (IdP) for role-based single sign-on (SSO)](https://help.aliyun.com/document_detail/2331016.html).
        self.oidc_role_name = oidc_role_name
        # The Accesskey ID that the OSS reads and writes from.
        self.oss_ak_id = oss_ak_id
        # The AccessKey Secret that the OSS reads and writes from.
        self.oss_ak_secret = oss_ak_secret
        # Information of the Object Storage Service (OSS) bucket mounted to the application. The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **bucketName**: the name of the OSS bucket.
        # 
        # *   **bucketPath**: the directory or object in OSS. If the specified directory or object does not exist, an error is returned.
        # 
        # *   **mountPath**: the directory of the container in SAE. If the path already exists, the newly specified path overwrites the previous one. If the path does not exist, it is created.
        # 
        # *   **readOnly**: specifies whether to only allow the container path to read data from the OSS directory. Valid values:
        # 
        #     *   **true**: The container path only has read permission on the OSS directory.
        #     *   **false**: The application has read and write permissions.
        self.oss_mount_descs = oss_mount_descs
        # The type of the deployment package. Take note of the following rules:
        # 
        # *   If you deploy the application by using a Java Archive (JAR) package, you can set this parameter to **FatJar**, **War**, or **Image**.
        # *   If you deploy the application by using a PHP package, you can set this parameter to one of the following values:
        # 
        # **PhpZip** **IMAGE_PHP_5_4** **IMAGE_PHP_5_4_ALPINE** **IMAGE_PHP_5_5** **IMAGE_PHP_5_5_ALPINE** **IMAGE_PHP_5_6** **IMAGE_PHP_5_6_ALPINE** **IMAGE_PHP_7_0** **IMAGE_PHP_7_0_ALPINE** **IMAGE_PHP_7_1** **IMAGE_PHP_7_1_ALPINE** **IMAGE_PHP_7_2** **IMAGE_PHP_7_2_ALPINE** **IMAGE_PHP_7_3** **IMAGE_PHP_7_3_ALPINE**\
        # 
        # *   If you deploy the application by using a **Python** package, you can set this parameter to **PythonZip** or **Image**:
        # 
        # This parameter is required.
        self.package_type = package_type
        # The address of the deployment package. This parameter is required if you set **PackageType** to **FatJar**, **War**, or **PythonZip**.
        self.package_url = package_url
        # The version of the deployment package. This parameter is required when the **PackageType** parameter is set to **FatJar**, **War**, or **PythonZip**.
        self.package_version = package_version
        # The dependent PHP version of PHP package. Image is not supported.
        self.php = php
        # The path on which the PHP configuration file for application monitoring is mounted. Make sure that the PHP server loads the configuration file. SAE automatically generates the corresponding configuration file. No manual operations are required.
        self.php_arms_config_location = php_arms_config_location
        # The details of the PHP configuration file.
        self.php_config = php_config
        # The path on which the PHP configuration file for application startup is mounted. Make sure that the PHP server uses this configuration file during the startup.
        self.php_config_location = php_config_location
        # Control whether to run a script after the container is initialized. Example: {"exec":{"command":["cat","/etc/group"]}}
        self.post_start = post_start
        # To controle whether to run a script before the container stops. Example: {"exec":{"command":["cat","/etc/group"]}}
        self.pre_stop = pre_stop
        # The programming language for the application’s technology stack. The value options are as follows:
        # 
        # - java: Java language
        # - php: PHP language
        # - python: Python language
        # - dotnet: .NET Core language
        # - other: Multi-language, such as C++, Go, Node.js, etc.
        self.programming_language = programming_language
        # The configurations of Kubernetes Service-based service registration and discovery. Take note of the following rules:
        # 
        # *   **serviceName**: the name of the Alibaba Cloud service. Format: `<Custom content>-<Namespace ID>`. `-<Namespace ID>` is automatically specified based on the namespace in which an application resides and cannot be changed. For example, if you select the default namespace in the China (Beijing) region, `-cn-beijing-default` is automatically specified.
        # *   **namespaceId**: the namespace ID.
        # *   **portAndProtocol**: the port number and protocol. Valid values of the port number: 1 to 65535. Valid values of the protocol: **TCP** and **UDP**.
        # *   **enable**: enables the Kubernetes Service-based registration and discovery feature.
        self.pvtz_discovery_svc = pvtz_discovery_svc
        # The Python environment. Set the value to **PYTHON 3.9.15**.
        self.python = python
        # The configurations for installing custom module dependencies. By default, the dependencies defined by the requirements.txt file in the root directory are installed. If the package does not contain this file and you do not configure custom dependencies in the package, specify the dependencies that you want to install in the text box.
        self.python_modules = python_modules
        # Check the launch status of the container. Containers that fail health checks more than once will not receive traffic from Server Load Balancer (SLB) instances any loner. You can use the **exec**, **httpGet**, or **tcpSocket** method to perform health checks. For more information, see the description of the **Liveness** parameter.
        # 
        # > You can use only one method to perform the health check.
        self.readiness = readiness
        # The number of instances when initialized.
        # 
        # This parameter is required.
        self.replicas = replicas
        # The resource type. Supports NULL (default) and haiguang (haiguang server).
        self.resource_type = resource_type
        # The SAE version. Supported versions:
        # 
        # *   **v1**\
        # *   **v2**\
        self.sae_version = sae_version
        # Secret Mount Description
        # Use the secret dictionaries created in the Namespace Secret Dictionary page to inject information into containers. Parameter descriptions are as follows:
        # 
        # - secretId: Secret instance ID. Obtain via the ListSecrets interface.
        # 
        # - key: Key-value pair. Note: Set the parameter sae-sys-secret-all to mount all keys.
        # 
        # - mountPath: Mount path.
        self.secret_mount_desc = secret_mount_desc
        # Security group ID.
        self.security_group_id = security_group_id
        # The canary tag configured for the application.
        self.service_tags = service_tags
        # The configuration of the container.
        self.sidecar_containers_config = sidecar_containers_config
        # The logging configurations of Log Service.
        # 
        # *   To use Log Service resources that are automatically created by SAE, set this parameter to `[{"logDir":"","logType":"stdout"},{"logDir":"/tmp/a.log"}]`.
        # *   To use custom Log Service resources, set this parameter to `[{"projectName":"test-sls","logType":"stdout","logDir":"","logstoreName":"sae","logtailName":""},{"projectName":"test","logDir":"/tmp/a.log","logstoreName":"sae","logtailName":""}]`.
        # 
        # The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **projectName**: the name of the Log Service project.
        # *   **logDir**: the path in which logs are stored.
        # *   **logType**: the log type. **stdout**: the standard output log of the container. You can specify only one stdout value for this parameter. If you leave this parameter empty, file logs are collected.
        # *   **logstoreName**: the name of the Logstore in Log Service.
        # *   **logtailName**: the name of the Logtail configuration in Log Service. If you do not configure this parameter, a new Logtail configuration is created.
        # 
        # If you do not need to modify the logging configurations when you deploy the application, configure the **SlsConfigs** parameter only in the first request. You do not need to include this parameter in subsequent requests. If you no longer need to use Log Service, leave the **SlsConfigs** parameter empty in the request.
        # 
        # > A Log Service project that is automatically created by SAE when you create an application is deleted when the application is deleted. Therefore, when you create an application, you cannot select a Log Service project that is automatically created by SAE for log collection.
        self.sls_configs = sls_configs
        # Enable application startup probe.
        # 
        # Check succeeded: Indicates that the application has started successfully. If you have configured Liveness and Readiness checks, they will be performed after the application startup is successful.
        # Check failed: Indicates that the application failed to start; an exception will be reported and the application will be automatically restarted.
        # 
        # > - exec, httpGet, and tcpSocket methods are supported. For specific examples, see the Liveness parameter documentation.
        # > - Only one health check method can be selected.
        self.startup_probe = startup_probe
        # The timeout period for a graceful shutdown. Default value: 30. Unit: seconds. Valid values: 1 to 300.
        self.termination_grace_period_seconds = termination_grace_period_seconds
        # Time zone. Default to time zone of Asia/Shanghai.
        self.timezone = timezone
        # The Tomcat configuration. If you want to cancel this configuration, set this parameter to "" or "{}". The following variables are included in the configuration: Take note of the following rules:
        # 
        # *   **port**: the port number. The port number ranges from 1024 to 65535. Though the admin permissions are configured for the container, the root permissions are required to perform operations on ports whose number is smaller than 1024. Enter a value that ranges from 1025 to 65535 because the container has only the admin permissions. If you do not specify this parameter, the default port number 8080 is used.
        # *   **contextPath**: the path. Default value: /. This value indicates the root directory.
        # *   **maxThreads**: the maximum number of connections in the connection pool. Default value: 400.
        # *   **uriEncoding**: the URI encoding scheme in the Tomcat container. Valid values: UTF-8, ISO-8859-1, GBK, and GB2312.************ If you do not specify this parameter, the default value **ISO-8859-1** is used.
        # *   **useBodyEncoding**: specifies whether to use the encoding scheme specified in the request body for URI query parameters. Default value: true.
        self.tomcat_config = tomcat_config
        # The vSwitch to which the elastic network interface (ENI) of the application instance is connected. The vSwitch must be located in the VPC specified by the VpcId parameter. The SAE namespace is bound with this vSwitch. The default value is the ID of the vSwitch that is bound to the namespace.
        self.v_switch_id = v_switch_id
        # The ID of the virtual private cloud (VPC) that corresponds to the SAE namespace. In SAE, once correspondence is configured between a namespace and a VPC, the namespace cannot correspond to other VPCs. When the SAE application is created within the namespace, the application is bound with the VPC. Multiple namespaces can correspond to the same VPC. The default value is the ID of the VPC that is bound to the namespace.
        self.vpc_id = vpc_id
        # The startup command of the WAR package. For information about how to configure the startup command, see [Configure startup commands](https://help.aliyun.com/document_detail/96677.html).
        self.war_start_options = war_start_options
        # The version of the Tomcat container on which the deployment package depends. Valid values:
        # 
        # *   **apache-tomcat-7.0.91**\
        # *   **apache-tomcat-8.5.42**\
        # 
        # This parameter is not returned if the **PackageType** parameter is set to **Image**.
        self.web_container = web_container

    def validate(self):
        if self.init_containers_config:
            for k in self.init_containers_config:
                if k:
                    k.validate()
        if self.sidecar_containers_config:
            for k in self.sidecar_containers_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acr_assume_role_arn is not None:
            result['AcrAssumeRoleArn'] = self.acr_assume_role_arn
        if self.acr_instance_id is not None:
            result['AcrInstanceId'] = self.acr_instance_id
        if self.app_description is not None:
            result['AppDescription'] = self.app_description
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.app_source is not None:
            result['AppSource'] = self.app_source
        if self.associate_eip is not None:
            result['AssociateEip'] = self.associate_eip
        if self.auto_config is not None:
            result['AutoConfig'] = self.auto_config
        if self.base_app_id is not None:
            result['BaseAppId'] = self.base_app_id
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        if self.config_map_mount_desc is not None:
            result['ConfigMapMountDesc'] = self.config_map_mount_desc
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.custom_host_alias is not None:
            result['CustomHostAlias'] = self.custom_host_alias
        if self.custom_image_network_type is not None:
            result['CustomImageNetworkType'] = self.custom_image_network_type
        if self.deploy is not None:
            result['Deploy'] = self.deploy
        if self.disk_size is not None:
            result['DiskSize'] = self.disk_size
        if self.dotnet is not None:
            result['Dotnet'] = self.dotnet
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        if self.enable_cpu_burst is not None:
            result['EnableCpuBurst'] = self.enable_cpu_burst
        if self.enable_ebpf is not None:
            result['EnableEbpf'] = self.enable_ebpf
        if self.enable_new_arms is not None:
            result['EnableNewArms'] = self.enable_new_arms
        if self.enable_prometheus is not None:
            result['EnablePrometheus'] = self.enable_prometheus
        if self.enable_sidecar_resource_isolated is not None:
            result['EnableSidecarResourceIsolated'] = self.enable_sidecar_resource_isolated
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.gpu_config is not None:
            result['GpuConfig'] = self.gpu_config
        if self.html is not None:
            result['Html'] = self.html
        if self.image_pull_secrets is not None:
            result['ImagePullSecrets'] = self.image_pull_secrets
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        result['InitContainersConfig'] = []
        if self.init_containers_config is not None:
            for k in self.init_containers_config:
                result['InitContainersConfig'].append(k.to_map() if k else None)
        if self.is_stateful is not None:
            result['IsStateful'] = self.is_stateful
        if self.jar_start_args is not None:
            result['JarStartArgs'] = self.jar_start_args
        if self.jar_start_options is not None:
            result['JarStartOptions'] = self.jar_start_options
        if self.jdk is not None:
            result['Jdk'] = self.jdk
        if self.kafka_configs is not None:
            result['KafkaConfigs'] = self.kafka_configs
        if self.liveness is not None:
            result['Liveness'] = self.liveness
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.micro_registration is not None:
            result['MicroRegistration'] = self.micro_registration
        if self.micro_registration_config is not None:
            result['MicroRegistrationConfig'] = self.micro_registration_config
        if self.microservice_engine_config is not None:
            result['MicroserviceEngineConfig'] = self.microservice_engine_config
        if self.mount_desc is not None:
            result['MountDesc'] = self.mount_desc
        if self.mount_host is not None:
            result['MountHost'] = self.mount_host
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.nas_configs is not None:
            result['NasConfigs'] = self.nas_configs
        if self.nas_id is not None:
            result['NasId'] = self.nas_id
        if self.new_sae_version is not None:
            result['NewSaeVersion'] = self.new_sae_version
        if self.oidc_role_name is not None:
            result['OidcRoleName'] = self.oidc_role_name
        if self.oss_ak_id is not None:
            result['OssAkId'] = self.oss_ak_id
        if self.oss_ak_secret is not None:
            result['OssAkSecret'] = self.oss_ak_secret
        if self.oss_mount_descs is not None:
            result['OssMountDescs'] = self.oss_mount_descs
        if self.package_type is not None:
            result['PackageType'] = self.package_type
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.php is not None:
            result['Php'] = self.php
        if self.php_arms_config_location is not None:
            result['PhpArmsConfigLocation'] = self.php_arms_config_location
        if self.php_config is not None:
            result['PhpConfig'] = self.php_config
        if self.php_config_location is not None:
            result['PhpConfigLocation'] = self.php_config_location
        if self.post_start is not None:
            result['PostStart'] = self.post_start
        if self.pre_stop is not None:
            result['PreStop'] = self.pre_stop
        if self.programming_language is not None:
            result['ProgrammingLanguage'] = self.programming_language
        if self.pvtz_discovery_svc is not None:
            result['PvtzDiscoverySvc'] = self.pvtz_discovery_svc
        if self.python is not None:
            result['Python'] = self.python
        if self.python_modules is not None:
            result['PythonModules'] = self.python_modules
        if self.readiness is not None:
            result['Readiness'] = self.readiness
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.sae_version is not None:
            result['SaeVersion'] = self.sae_version
        if self.secret_mount_desc is not None:
            result['SecretMountDesc'] = self.secret_mount_desc
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.service_tags is not None:
            result['ServiceTags'] = self.service_tags
        result['SidecarContainersConfig'] = []
        if self.sidecar_containers_config is not None:
            for k in self.sidecar_containers_config:
                result['SidecarContainersConfig'].append(k.to_map() if k else None)
        if self.sls_configs is not None:
            result['SlsConfigs'] = self.sls_configs
        if self.startup_probe is not None:
            result['StartupProbe'] = self.startup_probe
        if self.termination_grace_period_seconds is not None:
            result['TerminationGracePeriodSeconds'] = self.termination_grace_period_seconds
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.tomcat_config is not None:
            result['TomcatConfig'] = self.tomcat_config
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.war_start_options is not None:
            result['WarStartOptions'] = self.war_start_options
        if self.web_container is not None:
            result['WebContainer'] = self.web_container
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcrAssumeRoleArn') is not None:
            self.acr_assume_role_arn = m.get('AcrAssumeRoleArn')
        if m.get('AcrInstanceId') is not None:
            self.acr_instance_id = m.get('AcrInstanceId')
        if m.get('AppDescription') is not None:
            self.app_description = m.get('AppDescription')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AppSource') is not None:
            self.app_source = m.get('AppSource')
        if m.get('AssociateEip') is not None:
            self.associate_eip = m.get('AssociateEip')
        if m.get('AutoConfig') is not None:
            self.auto_config = m.get('AutoConfig')
        if m.get('BaseAppId') is not None:
            self.base_app_id = m.get('BaseAppId')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        if m.get('ConfigMapMountDesc') is not None:
            self.config_map_mount_desc = m.get('ConfigMapMountDesc')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CustomHostAlias') is not None:
            self.custom_host_alias = m.get('CustomHostAlias')
        if m.get('CustomImageNetworkType') is not None:
            self.custom_image_network_type = m.get('CustomImageNetworkType')
        if m.get('Deploy') is not None:
            self.deploy = m.get('Deploy')
        if m.get('DiskSize') is not None:
            self.disk_size = m.get('DiskSize')
        if m.get('Dotnet') is not None:
            self.dotnet = m.get('Dotnet')
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        if m.get('EnableCpuBurst') is not None:
            self.enable_cpu_burst = m.get('EnableCpuBurst')
        if m.get('EnableEbpf') is not None:
            self.enable_ebpf = m.get('EnableEbpf')
        if m.get('EnableNewArms') is not None:
            self.enable_new_arms = m.get('EnableNewArms')
        if m.get('EnablePrometheus') is not None:
            self.enable_prometheus = m.get('EnablePrometheus')
        if m.get('EnableSidecarResourceIsolated') is not None:
            self.enable_sidecar_resource_isolated = m.get('EnableSidecarResourceIsolated')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('GpuConfig') is not None:
            self.gpu_config = m.get('GpuConfig')
        if m.get('Html') is not None:
            self.html = m.get('Html')
        if m.get('ImagePullSecrets') is not None:
            self.image_pull_secrets = m.get('ImagePullSecrets')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        self.init_containers_config = []
        if m.get('InitContainersConfig') is not None:
            for k in m.get('InitContainersConfig'):
                temp_model = InitContainerConfig()
                self.init_containers_config.append(temp_model.from_map(k))
        if m.get('IsStateful') is not None:
            self.is_stateful = m.get('IsStateful')
        if m.get('JarStartArgs') is not None:
            self.jar_start_args = m.get('JarStartArgs')
        if m.get('JarStartOptions') is not None:
            self.jar_start_options = m.get('JarStartOptions')
        if m.get('Jdk') is not None:
            self.jdk = m.get('Jdk')
        if m.get('KafkaConfigs') is not None:
            self.kafka_configs = m.get('KafkaConfigs')
        if m.get('Liveness') is not None:
            self.liveness = m.get('Liveness')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('MicroRegistration') is not None:
            self.micro_registration = m.get('MicroRegistration')
        if m.get('MicroRegistrationConfig') is not None:
            self.micro_registration_config = m.get('MicroRegistrationConfig')
        if m.get('MicroserviceEngineConfig') is not None:
            self.microservice_engine_config = m.get('MicroserviceEngineConfig')
        if m.get('MountDesc') is not None:
            self.mount_desc = m.get('MountDesc')
        if m.get('MountHost') is not None:
            self.mount_host = m.get('MountHost')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NasConfigs') is not None:
            self.nas_configs = m.get('NasConfigs')
        if m.get('NasId') is not None:
            self.nas_id = m.get('NasId')
        if m.get('NewSaeVersion') is not None:
            self.new_sae_version = m.get('NewSaeVersion')
        if m.get('OidcRoleName') is not None:
            self.oidc_role_name = m.get('OidcRoleName')
        if m.get('OssAkId') is not None:
            self.oss_ak_id = m.get('OssAkId')
        if m.get('OssAkSecret') is not None:
            self.oss_ak_secret = m.get('OssAkSecret')
        if m.get('OssMountDescs') is not None:
            self.oss_mount_descs = m.get('OssMountDescs')
        if m.get('PackageType') is not None:
            self.package_type = m.get('PackageType')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('Php') is not None:
            self.php = m.get('Php')
        if m.get('PhpArmsConfigLocation') is not None:
            self.php_arms_config_location = m.get('PhpArmsConfigLocation')
        if m.get('PhpConfig') is not None:
            self.php_config = m.get('PhpConfig')
        if m.get('PhpConfigLocation') is not None:
            self.php_config_location = m.get('PhpConfigLocation')
        if m.get('PostStart') is not None:
            self.post_start = m.get('PostStart')
        if m.get('PreStop') is not None:
            self.pre_stop = m.get('PreStop')
        if m.get('ProgrammingLanguage') is not None:
            self.programming_language = m.get('ProgrammingLanguage')
        if m.get('PvtzDiscoverySvc') is not None:
            self.pvtz_discovery_svc = m.get('PvtzDiscoverySvc')
        if m.get('Python') is not None:
            self.python = m.get('Python')
        if m.get('PythonModules') is not None:
            self.python_modules = m.get('PythonModules')
        if m.get('Readiness') is not None:
            self.readiness = m.get('Readiness')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('SaeVersion') is not None:
            self.sae_version = m.get('SaeVersion')
        if m.get('SecretMountDesc') is not None:
            self.secret_mount_desc = m.get('SecretMountDesc')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('ServiceTags') is not None:
            self.service_tags = m.get('ServiceTags')
        self.sidecar_containers_config = []
        if m.get('SidecarContainersConfig') is not None:
            for k in m.get('SidecarContainersConfig'):
                temp_model = SidecarContainerConfig()
                self.sidecar_containers_config.append(temp_model.from_map(k))
        if m.get('SlsConfigs') is not None:
            self.sls_configs = m.get('SlsConfigs')
        if m.get('StartupProbe') is not None:
            self.startup_probe = m.get('StartupProbe')
        if m.get('TerminationGracePeriodSeconds') is not None:
            self.termination_grace_period_seconds = m.get('TerminationGracePeriodSeconds')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('TomcatConfig') is not None:
            self.tomcat_config = m.get('TomcatConfig')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('WarStartOptions') is not None:
            self.war_start_options = m.get('WarStartOptions')
        if m.get('WebContainer') is not None:
            self.web_container = m.get('WebContainer')
        return self


class CreateApplicationShrinkRequest(TeaModel):
    def __init__(
        self,
        acr_assume_role_arn: str = None,
        acr_instance_id: str = None,
        app_description: str = None,
        app_name: str = None,
        app_source: str = None,
        associate_eip: bool = None,
        auto_config: bool = None,
        base_app_id: str = None,
        command: str = None,
        command_args: str = None,
        config_map_mount_desc: str = None,
        cpu: int = None,
        custom_host_alias: str = None,
        custom_image_network_type: str = None,
        deploy: bool = None,
        disk_size: int = None,
        dotnet: str = None,
        edas_container_version: str = None,
        enable_cpu_burst: bool = None,
        enable_ebpf: str = None,
        enable_new_arms: bool = None,
        enable_prometheus: bool = None,
        enable_sidecar_resource_isolated: bool = None,
        envs: str = None,
        gpu_config: str = None,
        html: str = None,
        image_pull_secrets: str = None,
        image_url: str = None,
        init_containers_config_shrink: str = None,
        is_stateful: bool = None,
        jar_start_args: str = None,
        jar_start_options: str = None,
        jdk: str = None,
        kafka_configs: str = None,
        liveness: str = None,
        memory: int = None,
        micro_registration: str = None,
        micro_registration_config: str = None,
        microservice_engine_config: str = None,
        mount_desc: str = None,
        mount_host: str = None,
        namespace_id: str = None,
        nas_configs: str = None,
        nas_id: str = None,
        new_sae_version: str = None,
        oidc_role_name: str = None,
        oss_ak_id: str = None,
        oss_ak_secret: str = None,
        oss_mount_descs: str = None,
        package_type: str = None,
        package_url: str = None,
        package_version: str = None,
        php: str = None,
        php_arms_config_location: str = None,
        php_config: str = None,
        php_config_location: str = None,
        post_start: str = None,
        pre_stop: str = None,
        programming_language: str = None,
        pvtz_discovery_svc: str = None,
        python: str = None,
        python_modules: str = None,
        readiness: str = None,
        replicas: int = None,
        resource_type: str = None,
        sae_version: str = None,
        secret_mount_desc: str = None,
        security_group_id: str = None,
        service_tags: str = None,
        sidecar_containers_config_shrink: str = None,
        sls_configs: str = None,
        startup_probe: str = None,
        termination_grace_period_seconds: int = None,
        timezone: str = None,
        tomcat_config: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
        war_start_options: str = None,
        web_container: str = None,
    ):
        # The Alibaba Cloud Resource Name (ARN) required for a RAM role to obtain images across accounts. For more information, see [Grant permissions across Alibaba Cloud accounts by using a RAM role](https://help.aliyun.com/document_detail/223585.html).
        self.acr_assume_role_arn = acr_assume_role_arn
        # The ID of Container Registry Enterprise Edition instance N. This parameter is required when the **ImageUrl** parameter is set to the URL of an image in an ACR Enterprise Edition instance.
        self.acr_instance_id = acr_instance_id
        # The description of the template. The description cannot exceed 1,024 characters in length.
        self.app_description = app_description
        # The name of the application. The name can contain digits, letters, and hyphens (-). The name must start with a letter and cannot end with a hyphen (-). It cannot exceed 36 characters in length.
        # 
        # This parameter is required.
        self.app_name = app_name
        # Select micro_service, which is the application.
        self.app_source = app_source
        # Specifies whether to associate an EIP with the node pool. Take note of the following rules:
        # 
        # *   **true**: The EIP is associated with the application instance.
        # *   **false**: The EIP is not associated with the application instance.
        self.associate_eip = associate_eip
        # Specifies whether to automatically configure the network environment. Valid values:
        # 
        # *   **true**: SAE automatically configures the network environment when you create the application. If you set this parameter to true, the values of the **NamespaceId**, **VpcId**, **vSwitchId**, and **SecurityGroupId** parameters are ignored.
        # *   **false**: SAE configures the network environment based on your settings when you create the application.
        # 
        # >  If you select **true**, other **NamespaceId** will be ignored.
        self.auto_config = auto_config
        # The ID of the basic application.
        self.base_app_id = base_app_id
        # The command that is used to start the image. The command must be an existing executable object in the container. Sample statements:
        # 
        #     command:
        #           - echo
        #           - abc
        #           - >
        #           - file0
        # 
        # In this example, the Command parameter is set to `Command="echo", CommandArgs=["abc", ">", "file0"]`.
        self.command = command
        # The parameters of the image startup command. The CommandArgs parameter specifies the parameters that are required for the **Command** parameter. You can specify the name in one of the following formats:
        # 
        # `["a","b"]`
        # 
        # In the preceding example, the CommandArgs parameter is set to `CommandArgs=["abc", ">", "file0"]`. The data type of `["abc", ">", "file0"]` must be an array of strings in the JSON format. This parameter is optional.
        self.command_args = command_args
        # The description of the **ConfigMap** instance mounted to the application. Use configurations created on the Configuration Items page to configure containers. The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **congfigMapId**: the ID of the ConfigMap instance. You can call the [ListNamespacedConfigMaps](https://help.aliyun.com/document_detail/176917.html) operation to obtain the ID.
        # *   **key**: the key.
        # 
        # > You can use `sae-sys-configmap-all` to mount all keys.
        # 
        # *   **mountPath**: the mount path in the container.
        self.config_map_mount_desc = config_map_mount_desc
        # The CPU specifications that are required for each instance. Unit: millicores. This parameter cannot be set to 0. Valid values:
        # 
        # *   **500**\
        # *   **1000**\
        # *   **2000**\
        # *   **4000**\
        # *   **8000**\
        # *   **12000**\
        # *   **16000**\
        # *   **32000**\
        self.cpu = cpu
        # The custom mappings between hostnames and IP addresses in the container. Take note of the following rules:
        # 
        # *   **hostName**: the domain name or hostname.
        # *   **ip**: the IP address.
        self.custom_host_alias = custom_host_alias
        # Custom image type. To it to empty string to use pre-built image.
        # 
        # - internet: Public network image
        # 
        # - intranet: Private network image
        self.custom_image_network_type = custom_image_network_type
        # Whether to deploy now.
        # 
        # *   **true** (default): Deploy now.
        # *   **false**: Deploy later.
        self.deploy = deploy
        # The disk size. Unit: GB.
        self.disk_size = disk_size
        # . NET Framework version number:
        # 
        # *   .NET 3.1
        # *   .NET 5.0
        # *   .NET 6.0
        # *   .NET 7.0
        # *   .NET 8.0
        self.dotnet = dotnet
        # The version of the container in HSF.
        self.edas_container_version = edas_container_version
        # Enable CPU Burst.
        # - true: enable
        # - false: disable
        self.enable_cpu_burst = enable_cpu_burst
        # Enable application monitoring for non-Java applications based on eBPF technology. The value options are as follows:
        # 
        # - true: Enable.
        # - false: Disable (default).
        self.enable_ebpf = enable_ebpf
        # Indicates whether to enable the new ARMS feature:
        # 
        # *   true: enables this parameter.
        # *   false: disables this parameter.
        self.enable_new_arms = enable_new_arms
        self.enable_prometheus = enable_prometheus
        # Enable Sidecar resource isolation.
        # 
        # - true: enable
        # - false: disable
        self.enable_sidecar_resource_isolated = enable_sidecar_resource_isolated
        # The environment variables. You can configure custom environment variables or reference a ConfigMap. Before you can reference a ConfigMap, you must create a ConfigMap. For more information, see [CreateConfigMap](https://help.aliyun.com/document_detail/176914.html). Valid values:
        # 
        # *   Custom configuration
        # 
        #     *   **name**: the name of the environment variable.
        #     *   **value**: the value of the environment variable. The priority of the custom configuration is higher than valueFrom.
        # 
        # *   Reference a ConfigMap (valueFrom)
        # 
        #     *   **name**: the name of the environment variable. You can reference one or all keys. To reference all keys, specify `sae-sys-configmap-all-<ConfigMap name>`. Example: `sae-sys-configmap-all-test1`.
        #     *   **valueFrom**: the reference of the environment variable. Valid value: `configMapRef`.
        #     *   **configMapId**: the ID of the ConfigMap.
        #     *   **key**: the key. If you want to reference all key values, you do not need to configure this parameter.
        self.envs = envs
        self.gpu_config = gpu_config
        self.html = html
        # The ID of the corresponding Secret.
        self.image_pull_secrets = image_pull_secrets
        # The URL of the image. This parameter is required if you set the `PackageType` parameter to `Image`.
        self.image_url = image_url
        # Initialize container configuration.
        self.init_containers_config_shrink = init_containers_config_shrink
        self.is_stateful = is_stateful
        # The arguments in the JAR package. The arguments are used to start the application container. The default startup command is `$JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs`.
        self.jar_start_args = jar_start_args
        # The option settings in the JAR package. The settings are used to start the application container. The default startup command for application deployment is `$JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs`.
        self.jar_start_options = jar_start_options
        # The version of the Java development kit (JDK) on which the deployment package of the application depends. The following versions are supported:
        # 
        # *   **Open JDK 8**\
        # *   **Open JDK 7**\
        # *   **Dragonwell 11**\
        # *   **Dragonwell 8**\
        # *   **openjdk-8u191-jdk-alpine3.9**\
        # *   **openjdk-7u201-jdk-alpine3.9**\
        # 
        # This parameter is not returned if the **PackageType** parameter is set to **Image**.
        self.jdk = jdk
        # The logging configurations of Message Queue for Apache Kafka. Take note of the following rules:
        # 
        # *   **kafkaEndpoint**: the endpoint of the Message Queue for Apache Kafka API.
        # *   **kafkaInstanceId**: the ID of the Message Queue for Apache Kafka instance.
        # *   **kafkaConfigs**: One or more logging configurations of Message Queue for Apache Kafka. For information about sample values and parameters, see the request parameter **KafkaLogfileConfig** in this topic.
        self.kafka_configs = kafka_configs
        # Container health check. If the container fails this check, it will be revoked and relaunch again. Use one of the following methods to perform the health check:
        # 
        # *   Example of **exec**: `{"exec":{"command":["sh","-c","cat/home/admin/start.sh"]},"initialDelaySeconds":30,"periodSeconds":30,"timeoutSeconds":2}`
        # *   Sample code of the **httpGet** method: `{"httpGet":{"path":"/","port":18091,"scheme":"HTTP","isContainKeyWord":true,"keyWord":"SAE"},"initialDelaySeconds":11,"periodSeconds":10,"timeoutSeconds":1}`
        # *   Sample code of the **tcpSocket** method: `{"tcpSocket":{"port":18091},"initialDelaySeconds":11,"periodSeconds":10,"timeoutSeconds":1}`
        # 
        # > You can use only one method to perform the health check.
        # 
        # The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **exec.command**: the health check command.
        # *   **httpGet.path**: the request path.
        # *   **httpGet.scheme**: the protocol that is used to perform the health check. Valid values: **HTTP** and **HTTPS**.
        # *   **httpGet.isContainKeyWord**: indicates whether the response contains keywords. Valid values: **true** and **false**. If this field is not returned, the advanced settings are not used.
        # *   **httpGet.keyWord**: the custom keyword. This parameter is available only if the **isContainKeyWord** field is returned.
        # *   **tcpSocket.port**: the port that is used to check the status of TCP connections.
        # *   **initialDelaySeconds**: the delay of the health check. Default value: 10. Unit: seconds.
        # *   **periodSeconds**: the interval at which health checks are performed. Default value: 30. Unit: seconds.
        # *   **timeoutSeconds**: the timeout period of the health check. Default value: 1. Unit: seconds. If you set this parameter to 0 or leave this parameter empty, the timeout period is automatically set to 1 second.
        self.liveness = liveness
        # The memory size that is required by each instance. Unit: MB. This parameter cannot be set to 0. The values of this parameter correspond to the values of the Cpu parameter:
        # 
        # *   This parameter is set to **1024** if the Cpu parameter is set to 500 or 1000.
        # *   This parameter is set to **2048** if the Cpu parameter is set to 500, 1000, or 2000.
        # *   This parameter is set to **4096** if the Cpu parameter is set to 1000, 2000, or 4000.
        # *   This parameter is set to **8192** if the Cpu parameter is set to 2000, 4000, or 8,000.
        # *   This parameter is set to **12288** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **16384** if the Cpu parameter is set to 4000, 8000, or 16000.
        # *   This parameter is set to **24576** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **32768** if the Cpu parameter is set to 16000.
        # *   This parameter is set to **65536** if the Cpu parameter is set to 8000, 16000, or 32000.
        # *   This parameter is set to **131072** if the Cpu parameter is set to 32000.
        self.memory = memory
        # The Nacos registry. Valid values:
        # 
        # *   **0**: SAE built-in Nacos registry
        # *   **1**: self-managed Nacos registry
        # *   **2** : MSE enterprise edition Nacos registry
        self.micro_registration = micro_registration
        # The Registry configurations.
        self.micro_registration_config = micro_registration_config
        # Configure microservices governance
        # 
        # Whether to enable microservices governance (enable):
        # - true: Enable
        # - false: Disable
        # 
        # Configure lossless online/offline deployment (mseLosslessRule):
        # 
        # delayTime: Delay duration (unit: seconds)
        # 
        # enable: Whether to enable lossless deployment
        # 
        # - true: Enable
        # 
        # - false: Disable
        # 
        # notice: Whether to enable notifications
        # 
        # - true: Enable
        # 
        # - false: Disable
        # 
        # warmupTime: Small-traffic warm-up duration (unit: seconds)
        self.microservice_engine_config = microservice_engine_config
        # It is not recommended to configure this field; configuring NasConfigs instead. This field specifies the NAS mount description. When deploying, if the configuration has not changed, you do not need to set this parameter (i.e., the MountDesc field does not need to be included in the request). If you need to clear the NAS configuration, set the value of this field to an empty string in the request (i.e., set the value of the MountDesc field to "").
        self.mount_desc = mount_desc
        # It is not recommended to configure this field; configuring NasConfigs instead. This field specifies the NAS mount point within the application\\"s VPC. When deploying, if the configuration has not changed, you do not need to set this parameter (i.e., the MountHost field does not need to be included in the request). If you need to clear the NAS configuration, set the value of this field to an empty string in the request (i.e., set the value of the MountHost field to "").
        self.mount_host = mount_host
        # SAE namespace ID. Only namespaces consisting of lowercase letters and hyphens (-) are supported, and the name must start with a letter.
        self.namespace_id = namespace_id
        # The configurations of mounting the NAS file system. Take note of the following rules:
        # 
        # *   **mountPath**: the mount path of the container.
        # *   **readOnly**: If you set the value to **false**, the application has the read and write permissions.
        # *   **nasId**: the ID of the NAS file system.
        # *   **mountDomain**: the domain name of the mount target. For more information, see [DescribeMountTargets](https://help.aliyun.com/document_detail/62626.html).
        # *   **nasPath**: the directory in the NAS file system.
        self.nas_configs = nas_configs
        # It is not recommended to configure this field; configuring NasConfigs instead. The ID of the mounted NAS must be in the same region as the cluster. The NAS must have available mount point quota or its mount point must already be on a switch within the VPC. If this field is not specified and the mountDescs field exists, a NAS will be automatically purchased and mounted to a switch within the VPC by default.
        # 
        # When deploying, if the configuration has not changed, you do not need to set this parameter (i.e., the NASId field does not need to be included in the request). If you need to clear the NAS configuration, set the value of this field to an empty string in the request (i.e., set the value of the NASId field to "").
        self.nas_id = nas_id
        # SAE edition.
        # 
        # - lite: the lightweight edition.
        # 
        # - std: the standard edition.
        # 
        # - pro: the professional edition.
        self.new_sae_version = new_sae_version
        # The name of the RAM role used to authenticate the user identity.
        # 
        # >  You need to create an OpenID Connect (OIDC) identity provider (IdP) and an identity provider (IdP) for role-based single sign-on (SSO) in advance. For more information, see [Creates an OpenID Connect (OIDC) identity provider (IdP)](https://help.aliyun.com/document_detail/2331022.html) and [Creates an identity provider (IdP) for role-based single sign-on (SSO)](https://help.aliyun.com/document_detail/2331016.html).
        self.oidc_role_name = oidc_role_name
        # The Accesskey ID that the OSS reads and writes from.
        self.oss_ak_id = oss_ak_id
        # The AccessKey Secret that the OSS reads and writes from.
        self.oss_ak_secret = oss_ak_secret
        # Information of the Object Storage Service (OSS) bucket mounted to the application. The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **bucketName**: the name of the OSS bucket.
        # 
        # *   **bucketPath**: the directory or object in OSS. If the specified directory or object does not exist, an error is returned.
        # 
        # *   **mountPath**: the directory of the container in SAE. If the path already exists, the newly specified path overwrites the previous one. If the path does not exist, it is created.
        # 
        # *   **readOnly**: specifies whether to only allow the container path to read data from the OSS directory. Valid values:
        # 
        #     *   **true**: The container path only has read permission on the OSS directory.
        #     *   **false**: The application has read and write permissions.
        self.oss_mount_descs = oss_mount_descs
        # The type of the deployment package. Take note of the following rules:
        # 
        # *   If you deploy the application by using a Java Archive (JAR) package, you can set this parameter to **FatJar**, **War**, or **Image**.
        # *   If you deploy the application by using a PHP package, you can set this parameter to one of the following values:
        # 
        # **PhpZip** **IMAGE_PHP_5_4** **IMAGE_PHP_5_4_ALPINE** **IMAGE_PHP_5_5** **IMAGE_PHP_5_5_ALPINE** **IMAGE_PHP_5_6** **IMAGE_PHP_5_6_ALPINE** **IMAGE_PHP_7_0** **IMAGE_PHP_7_0_ALPINE** **IMAGE_PHP_7_1** **IMAGE_PHP_7_1_ALPINE** **IMAGE_PHP_7_2** **IMAGE_PHP_7_2_ALPINE** **IMAGE_PHP_7_3** **IMAGE_PHP_7_3_ALPINE**\
        # 
        # *   If you deploy the application by using a **Python** package, you can set this parameter to **PythonZip** or **Image**:
        # 
        # This parameter is required.
        self.package_type = package_type
        # The address of the deployment package. This parameter is required if you set **PackageType** to **FatJar**, **War**, or **PythonZip**.
        self.package_url = package_url
        # The version of the deployment package. This parameter is required when the **PackageType** parameter is set to **FatJar**, **War**, or **PythonZip**.
        self.package_version = package_version
        # The dependent PHP version of PHP package. Image is not supported.
        self.php = php
        # The path on which the PHP configuration file for application monitoring is mounted. Make sure that the PHP server loads the configuration file. SAE automatically generates the corresponding configuration file. No manual operations are required.
        self.php_arms_config_location = php_arms_config_location
        # The details of the PHP configuration file.
        self.php_config = php_config
        # The path on which the PHP configuration file for application startup is mounted. Make sure that the PHP server uses this configuration file during the startup.
        self.php_config_location = php_config_location
        # Control whether to run a script after the container is initialized. Example: {"exec":{"command":["cat","/etc/group"]}}
        self.post_start = post_start
        # To controle whether to run a script before the container stops. Example: {"exec":{"command":["cat","/etc/group"]}}
        self.pre_stop = pre_stop
        # The programming language for the application’s technology stack. The value options are as follows:
        # 
        # - java: Java language
        # - php: PHP language
        # - python: Python language
        # - dotnet: .NET Core language
        # - other: Multi-language, such as C++, Go, Node.js, etc.
        self.programming_language = programming_language
        # The configurations of Kubernetes Service-based service registration and discovery. Take note of the following rules:
        # 
        # *   **serviceName**: the name of the Alibaba Cloud service. Format: `<Custom content>-<Namespace ID>`. `-<Namespace ID>` is automatically specified based on the namespace in which an application resides and cannot be changed. For example, if you select the default namespace in the China (Beijing) region, `-cn-beijing-default` is automatically specified.
        # *   **namespaceId**: the namespace ID.
        # *   **portAndProtocol**: the port number and protocol. Valid values of the port number: 1 to 65535. Valid values of the protocol: **TCP** and **UDP**.
        # *   **enable**: enables the Kubernetes Service-based registration and discovery feature.
        self.pvtz_discovery_svc = pvtz_discovery_svc
        # The Python environment. Set the value to **PYTHON 3.9.15**.
        self.python = python
        # The configurations for installing custom module dependencies. By default, the dependencies defined by the requirements.txt file in the root directory are installed. If the package does not contain this file and you do not configure custom dependencies in the package, specify the dependencies that you want to install in the text box.
        self.python_modules = python_modules
        # Check the launch status of the container. Containers that fail health checks more than once will not receive traffic from Server Load Balancer (SLB) instances any loner. You can use the **exec**, **httpGet**, or **tcpSocket** method to perform health checks. For more information, see the description of the **Liveness** parameter.
        # 
        # > You can use only one method to perform the health check.
        self.readiness = readiness
        # The number of instances when initialized.
        # 
        # This parameter is required.
        self.replicas = replicas
        # The resource type. Supports NULL (default) and haiguang (haiguang server).
        self.resource_type = resource_type
        # The SAE version. Supported versions:
        # 
        # *   **v1**\
        # *   **v2**\
        self.sae_version = sae_version
        # Secret Mount Description
        # Use the secret dictionaries created in the Namespace Secret Dictionary page to inject information into containers. Parameter descriptions are as follows:
        # 
        # - secretId: Secret instance ID. Obtain via the ListSecrets interface.
        # 
        # - key: Key-value pair. Note: Set the parameter sae-sys-secret-all to mount all keys.
        # 
        # - mountPath: Mount path.
        self.secret_mount_desc = secret_mount_desc
        # Security group ID.
        self.security_group_id = security_group_id
        # The canary tag configured for the application.
        self.service_tags = service_tags
        # The configuration of the container.
        self.sidecar_containers_config_shrink = sidecar_containers_config_shrink
        # The logging configurations of Log Service.
        # 
        # *   To use Log Service resources that are automatically created by SAE, set this parameter to `[{"logDir":"","logType":"stdout"},{"logDir":"/tmp/a.log"}]`.
        # *   To use custom Log Service resources, set this parameter to `[{"projectName":"test-sls","logType":"stdout","logDir":"","logstoreName":"sae","logtailName":""},{"projectName":"test","logDir":"/tmp/a.log","logstoreName":"sae","logtailName":""}]`.
        # 
        # The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **projectName**: the name of the Log Service project.
        # *   **logDir**: the path in which logs are stored.
        # *   **logType**: the log type. **stdout**: the standard output log of the container. You can specify only one stdout value for this parameter. If you leave this parameter empty, file logs are collected.
        # *   **logstoreName**: the name of the Logstore in Log Service.
        # *   **logtailName**: the name of the Logtail configuration in Log Service. If you do not configure this parameter, a new Logtail configuration is created.
        # 
        # If you do not need to modify the logging configurations when you deploy the application, configure the **SlsConfigs** parameter only in the first request. You do not need to include this parameter in subsequent requests. If you no longer need to use Log Service, leave the **SlsConfigs** parameter empty in the request.
        # 
        # > A Log Service project that is automatically created by SAE when you create an application is deleted when the application is deleted. Therefore, when you create an application, you cannot select a Log Service project that is automatically created by SAE for log collection.
        self.sls_configs = sls_configs
        # Enable application startup probe.
        # 
        # Check succeeded: Indicates that the application has started successfully. If you have configured Liveness and Readiness checks, they will be performed after the application startup is successful.
        # Check failed: Indicates that the application failed to start; an exception will be reported and the application will be automatically restarted.
        # 
        # > - exec, httpGet, and tcpSocket methods are supported. For specific examples, see the Liveness parameter documentation.
        # > - Only one health check method can be selected.
        self.startup_probe = startup_probe
        # The timeout period for a graceful shutdown. Default value: 30. Unit: seconds. Valid values: 1 to 300.
        self.termination_grace_period_seconds = termination_grace_period_seconds
        # Time zone. Default to time zone of Asia/Shanghai.
        self.timezone = timezone
        # The Tomcat configuration. If you want to cancel this configuration, set this parameter to "" or "{}". The following variables are included in the configuration: Take note of the following rules:
        # 
        # *   **port**: the port number. The port number ranges from 1024 to 65535. Though the admin permissions are configured for the container, the root permissions are required to perform operations on ports whose number is smaller than 1024. Enter a value that ranges from 1025 to 65535 because the container has only the admin permissions. If you do not specify this parameter, the default port number 8080 is used.
        # *   **contextPath**: the path. Default value: /. This value indicates the root directory.
        # *   **maxThreads**: the maximum number of connections in the connection pool. Default value: 400.
        # *   **uriEncoding**: the URI encoding scheme in the Tomcat container. Valid values: UTF-8, ISO-8859-1, GBK, and GB2312.************ If you do not specify this parameter, the default value **ISO-8859-1** is used.
        # *   **useBodyEncoding**: specifies whether to use the encoding scheme specified in the request body for URI query parameters. Default value: true.
        self.tomcat_config = tomcat_config
        # The vSwitch to which the elastic network interface (ENI) of the application instance is connected. The vSwitch must be located in the VPC specified by the VpcId parameter. The SAE namespace is bound with this vSwitch. The default value is the ID of the vSwitch that is bound to the namespace.
        self.v_switch_id = v_switch_id
        # The ID of the virtual private cloud (VPC) that corresponds to the SAE namespace. In SAE, once correspondence is configured between a namespace and a VPC, the namespace cannot correspond to other VPCs. When the SAE application is created within the namespace, the application is bound with the VPC. Multiple namespaces can correspond to the same VPC. The default value is the ID of the VPC that is bound to the namespace.
        self.vpc_id = vpc_id
        # The startup command of the WAR package. For information about how to configure the startup command, see [Configure startup commands](https://help.aliyun.com/document_detail/96677.html).
        self.war_start_options = war_start_options
        # The version of the Tomcat container on which the deployment package depends. Valid values:
        # 
        # *   **apache-tomcat-7.0.91**\
        # *   **apache-tomcat-8.5.42**\
        # 
        # This parameter is not returned if the **PackageType** parameter is set to **Image**.
        self.web_container = web_container

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acr_assume_role_arn is not None:
            result['AcrAssumeRoleArn'] = self.acr_assume_role_arn
        if self.acr_instance_id is not None:
            result['AcrInstanceId'] = self.acr_instance_id
        if self.app_description is not None:
            result['AppDescription'] = self.app_description
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.app_source is not None:
            result['AppSource'] = self.app_source
        if self.associate_eip is not None:
            result['AssociateEip'] = self.associate_eip
        if self.auto_config is not None:
            result['AutoConfig'] = self.auto_config
        if self.base_app_id is not None:
            result['BaseAppId'] = self.base_app_id
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        if self.config_map_mount_desc is not None:
            result['ConfigMapMountDesc'] = self.config_map_mount_desc
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.custom_host_alias is not None:
            result['CustomHostAlias'] = self.custom_host_alias
        if self.custom_image_network_type is not None:
            result['CustomImageNetworkType'] = self.custom_image_network_type
        if self.deploy is not None:
            result['Deploy'] = self.deploy
        if self.disk_size is not None:
            result['DiskSize'] = self.disk_size
        if self.dotnet is not None:
            result['Dotnet'] = self.dotnet
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        if self.enable_cpu_burst is not None:
            result['EnableCpuBurst'] = self.enable_cpu_burst
        if self.enable_ebpf is not None:
            result['EnableEbpf'] = self.enable_ebpf
        if self.enable_new_arms is not None:
            result['EnableNewArms'] = self.enable_new_arms
        if self.enable_prometheus is not None:
            result['EnablePrometheus'] = self.enable_prometheus
        if self.enable_sidecar_resource_isolated is not None:
            result['EnableSidecarResourceIsolated'] = self.enable_sidecar_resource_isolated
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.gpu_config is not None:
            result['GpuConfig'] = self.gpu_config
        if self.html is not None:
            result['Html'] = self.html
        if self.image_pull_secrets is not None:
            result['ImagePullSecrets'] = self.image_pull_secrets
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.init_containers_config_shrink is not None:
            result['InitContainersConfig'] = self.init_containers_config_shrink
        if self.is_stateful is not None:
            result['IsStateful'] = self.is_stateful
        if self.jar_start_args is not None:
            result['JarStartArgs'] = self.jar_start_args
        if self.jar_start_options is not None:
            result['JarStartOptions'] = self.jar_start_options
        if self.jdk is not None:
            result['Jdk'] = self.jdk
        if self.kafka_configs is not None:
            result['KafkaConfigs'] = self.kafka_configs
        if self.liveness is not None:
            result['Liveness'] = self.liveness
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.micro_registration is not None:
            result['MicroRegistration'] = self.micro_registration
        if self.micro_registration_config is not None:
            result['MicroRegistrationConfig'] = self.micro_registration_config
        if self.microservice_engine_config is not None:
            result['MicroserviceEngineConfig'] = self.microservice_engine_config
        if self.mount_desc is not None:
            result['MountDesc'] = self.mount_desc
        if self.mount_host is not None:
            result['MountHost'] = self.mount_host
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.nas_configs is not None:
            result['NasConfigs'] = self.nas_configs
        if self.nas_id is not None:
            result['NasId'] = self.nas_id
        if self.new_sae_version is not None:
            result['NewSaeVersion'] = self.new_sae_version
        if self.oidc_role_name is not None:
            result['OidcRoleName'] = self.oidc_role_name
        if self.oss_ak_id is not None:
            result['OssAkId'] = self.oss_ak_id
        if self.oss_ak_secret is not None:
            result['OssAkSecret'] = self.oss_ak_secret
        if self.oss_mount_descs is not None:
            result['OssMountDescs'] = self.oss_mount_descs
        if self.package_type is not None:
            result['PackageType'] = self.package_type
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.php is not None:
            result['Php'] = self.php
        if self.php_arms_config_location is not None:
            result['PhpArmsConfigLocation'] = self.php_arms_config_location
        if self.php_config is not None:
            result['PhpConfig'] = self.php_config
        if self.php_config_location is not None:
            result['PhpConfigLocation'] = self.php_config_location
        if self.post_start is not None:
            result['PostStart'] = self.post_start
        if self.pre_stop is not None:
            result['PreStop'] = self.pre_stop
        if self.programming_language is not None:
            result['ProgrammingLanguage'] = self.programming_language
        if self.pvtz_discovery_svc is not None:
            result['PvtzDiscoverySvc'] = self.pvtz_discovery_svc
        if self.python is not None:
            result['Python'] = self.python
        if self.python_modules is not None:
            result['PythonModules'] = self.python_modules
        if self.readiness is not None:
            result['Readiness'] = self.readiness
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.sae_version is not None:
            result['SaeVersion'] = self.sae_version
        if self.secret_mount_desc is not None:
            result['SecretMountDesc'] = self.secret_mount_desc
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.service_tags is not None:
            result['ServiceTags'] = self.service_tags
        if self.sidecar_containers_config_shrink is not None:
            result['SidecarContainersConfig'] = self.sidecar_containers_config_shrink
        if self.sls_configs is not None:
            result['SlsConfigs'] = self.sls_configs
        if self.startup_probe is not None:
            result['StartupProbe'] = self.startup_probe
        if self.termination_grace_period_seconds is not None:
            result['TerminationGracePeriodSeconds'] = self.termination_grace_period_seconds
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.tomcat_config is not None:
            result['TomcatConfig'] = self.tomcat_config
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.war_start_options is not None:
            result['WarStartOptions'] = self.war_start_options
        if self.web_container is not None:
            result['WebContainer'] = self.web_container
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcrAssumeRoleArn') is not None:
            self.acr_assume_role_arn = m.get('AcrAssumeRoleArn')
        if m.get('AcrInstanceId') is not None:
            self.acr_instance_id = m.get('AcrInstanceId')
        if m.get('AppDescription') is not None:
            self.app_description = m.get('AppDescription')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AppSource') is not None:
            self.app_source = m.get('AppSource')
        if m.get('AssociateEip') is not None:
            self.associate_eip = m.get('AssociateEip')
        if m.get('AutoConfig') is not None:
            self.auto_config = m.get('AutoConfig')
        if m.get('BaseAppId') is not None:
            self.base_app_id = m.get('BaseAppId')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        if m.get('ConfigMapMountDesc') is not None:
            self.config_map_mount_desc = m.get('ConfigMapMountDesc')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CustomHostAlias') is not None:
            self.custom_host_alias = m.get('CustomHostAlias')
        if m.get('CustomImageNetworkType') is not None:
            self.custom_image_network_type = m.get('CustomImageNetworkType')
        if m.get('Deploy') is not None:
            self.deploy = m.get('Deploy')
        if m.get('DiskSize') is not None:
            self.disk_size = m.get('DiskSize')
        if m.get('Dotnet') is not None:
            self.dotnet = m.get('Dotnet')
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        if m.get('EnableCpuBurst') is not None:
            self.enable_cpu_burst = m.get('EnableCpuBurst')
        if m.get('EnableEbpf') is not None:
            self.enable_ebpf = m.get('EnableEbpf')
        if m.get('EnableNewArms') is not None:
            self.enable_new_arms = m.get('EnableNewArms')
        if m.get('EnablePrometheus') is not None:
            self.enable_prometheus = m.get('EnablePrometheus')
        if m.get('EnableSidecarResourceIsolated') is not None:
            self.enable_sidecar_resource_isolated = m.get('EnableSidecarResourceIsolated')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('GpuConfig') is not None:
            self.gpu_config = m.get('GpuConfig')
        if m.get('Html') is not None:
            self.html = m.get('Html')
        if m.get('ImagePullSecrets') is not None:
            self.image_pull_secrets = m.get('ImagePullSecrets')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('InitContainersConfig') is not None:
            self.init_containers_config_shrink = m.get('InitContainersConfig')
        if m.get('IsStateful') is not None:
            self.is_stateful = m.get('IsStateful')
        if m.get('JarStartArgs') is not None:
            self.jar_start_args = m.get('JarStartArgs')
        if m.get('JarStartOptions') is not None:
            self.jar_start_options = m.get('JarStartOptions')
        if m.get('Jdk') is not None:
            self.jdk = m.get('Jdk')
        if m.get('KafkaConfigs') is not None:
            self.kafka_configs = m.get('KafkaConfigs')
        if m.get('Liveness') is not None:
            self.liveness = m.get('Liveness')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('MicroRegistration') is not None:
            self.micro_registration = m.get('MicroRegistration')
        if m.get('MicroRegistrationConfig') is not None:
            self.micro_registration_config = m.get('MicroRegistrationConfig')
        if m.get('MicroserviceEngineConfig') is not None:
            self.microservice_engine_config = m.get('MicroserviceEngineConfig')
        if m.get('MountDesc') is not None:
            self.mount_desc = m.get('MountDesc')
        if m.get('MountHost') is not None:
            self.mount_host = m.get('MountHost')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NasConfigs') is not None:
            self.nas_configs = m.get('NasConfigs')
        if m.get('NasId') is not None:
            self.nas_id = m.get('NasId')
        if m.get('NewSaeVersion') is not None:
            self.new_sae_version = m.get('NewSaeVersion')
        if m.get('OidcRoleName') is not None:
            self.oidc_role_name = m.get('OidcRoleName')
        if m.get('OssAkId') is not None:
            self.oss_ak_id = m.get('OssAkId')
        if m.get('OssAkSecret') is not None:
            self.oss_ak_secret = m.get('OssAkSecret')
        if m.get('OssMountDescs') is not None:
            self.oss_mount_descs = m.get('OssMountDescs')
        if m.get('PackageType') is not None:
            self.package_type = m.get('PackageType')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('Php') is not None:
            self.php = m.get('Php')
        if m.get('PhpArmsConfigLocation') is not None:
            self.php_arms_config_location = m.get('PhpArmsConfigLocation')
        if m.get('PhpConfig') is not None:
            self.php_config = m.get('PhpConfig')
        if m.get('PhpConfigLocation') is not None:
            self.php_config_location = m.get('PhpConfigLocation')
        if m.get('PostStart') is not None:
            self.post_start = m.get('PostStart')
        if m.get('PreStop') is not None:
            self.pre_stop = m.get('PreStop')
        if m.get('ProgrammingLanguage') is not None:
            self.programming_language = m.get('ProgrammingLanguage')
        if m.get('PvtzDiscoverySvc') is not None:
            self.pvtz_discovery_svc = m.get('PvtzDiscoverySvc')
        if m.get('Python') is not None:
            self.python = m.get('Python')
        if m.get('PythonModules') is not None:
            self.python_modules = m.get('PythonModules')
        if m.get('Readiness') is not None:
            self.readiness = m.get('Readiness')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('SaeVersion') is not None:
            self.sae_version = m.get('SaeVersion')
        if m.get('SecretMountDesc') is not None:
            self.secret_mount_desc = m.get('SecretMountDesc')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('ServiceTags') is not None:
            self.service_tags = m.get('ServiceTags')
        if m.get('SidecarContainersConfig') is not None:
            self.sidecar_containers_config_shrink = m.get('SidecarContainersConfig')
        if m.get('SlsConfigs') is not None:
            self.sls_configs = m.get('SlsConfigs')
        if m.get('StartupProbe') is not None:
            self.startup_probe = m.get('StartupProbe')
        if m.get('TerminationGracePeriodSeconds') is not None:
            self.termination_grace_period_seconds = m.get('TerminationGracePeriodSeconds')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('TomcatConfig') is not None:
            self.tomcat_config = m.get('TomcatConfig')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('WarStartOptions') is not None:
            self.war_start_options = m.get('WarStartOptions')
        if m.get('WebContainer') is not None:
            self.web_container = m.get('WebContainer')
        return self


class CreateApplicationResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        change_order_id: str = None,
    ):
        # The ID of the application that is created.
        self.app_id = app_id
        # The ID of the change order. It can be used to query the task status.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class CreateApplicationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateApplicationResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code. Valid values:
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message. Valid values:
        # 
        # *   If the request was successful, a success message is returned.
        # *   If the request failed, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the application is created. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateApplicationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class CreateApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateApplicationScalingRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        enable_idle: bool = None,
        min_ready_instance_ratio: int = None,
        min_ready_instances: int = None,
        scaling_rule_enable: bool = None,
        scaling_rule_metric: str = None,
        scaling_rule_name: str = None,
        scaling_rule_timer: str = None,
        scaling_rule_type: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.enable_idle = enable_idle
        self.min_ready_instance_ratio = min_ready_instance_ratio
        self.min_ready_instances = min_ready_instances
        self.scaling_rule_enable = scaling_rule_enable
        self.scaling_rule_metric = scaling_rule_metric
        # This parameter is required.
        self.scaling_rule_name = scaling_rule_name
        self.scaling_rule_timer = scaling_rule_timer
        # This parameter is required.
        self.scaling_rule_type = scaling_rule_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.enable_idle is not None:
            result['EnableIdle'] = self.enable_idle
        if self.min_ready_instance_ratio is not None:
            result['MinReadyInstanceRatio'] = self.min_ready_instance_ratio
        if self.min_ready_instances is not None:
            result['MinReadyInstances'] = self.min_ready_instances
        if self.scaling_rule_enable is not None:
            result['ScalingRuleEnable'] = self.scaling_rule_enable
        if self.scaling_rule_metric is not None:
            result['ScalingRuleMetric'] = self.scaling_rule_metric
        if self.scaling_rule_name is not None:
            result['ScalingRuleName'] = self.scaling_rule_name
        if self.scaling_rule_timer is not None:
            result['ScalingRuleTimer'] = self.scaling_rule_timer
        if self.scaling_rule_type is not None:
            result['ScalingRuleType'] = self.scaling_rule_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EnableIdle') is not None:
            self.enable_idle = m.get('EnableIdle')
        if m.get('MinReadyInstanceRatio') is not None:
            self.min_ready_instance_ratio = m.get('MinReadyInstanceRatio')
        if m.get('MinReadyInstances') is not None:
            self.min_ready_instances = m.get('MinReadyInstances')
        if m.get('ScalingRuleEnable') is not None:
            self.scaling_rule_enable = m.get('ScalingRuleEnable')
        if m.get('ScalingRuleMetric') is not None:
            self.scaling_rule_metric = m.get('ScalingRuleMetric')
        if m.get('ScalingRuleName') is not None:
            self.scaling_rule_name = m.get('ScalingRuleName')
        if m.get('ScalingRuleTimer') is not None:
            self.scaling_rule_timer = m.get('ScalingRuleTimer')
        if m.get('ScalingRuleType') is not None:
            self.scaling_rule_type = m.get('ScalingRuleType')
        return self


class CreateApplicationScalingRuleResponseBodyDataMetricMetrics(TeaModel):
    def __init__(
        self,
        metric_target_average_utilization: int = None,
        metric_type: str = None,
        slb_id: str = None,
        slb_logstore: str = None,
        slb_project: str = None,
        vport: str = None,
    ):
        self.metric_target_average_utilization = metric_target_average_utilization
        self.metric_type = metric_type
        self.slb_id = slb_id
        self.slb_logstore = slb_logstore
        self.slb_project = slb_project
        self.vport = vport

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_target_average_utilization is not None:
            result['MetricTargetAverageUtilization'] = self.metric_target_average_utilization
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.slb_id is not None:
            result['SlbId'] = self.slb_id
        if self.slb_logstore is not None:
            result['SlbLogstore'] = self.slb_logstore
        if self.slb_project is not None:
            result['SlbProject'] = self.slb_project
        if self.vport is not None:
            result['Vport'] = self.vport
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetricTargetAverageUtilization') is not None:
            self.metric_target_average_utilization = m.get('MetricTargetAverageUtilization')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('SlbId') is not None:
            self.slb_id = m.get('SlbId')
        if m.get('SlbLogstore') is not None:
            self.slb_logstore = m.get('SlbLogstore')
        if m.get('SlbProject') is not None:
            self.slb_project = m.get('SlbProject')
        if m.get('Vport') is not None:
            self.vport = m.get('Vport')
        return self


class CreateApplicationScalingRuleResponseBodyDataMetric(TeaModel):
    def __init__(
        self,
        max_replicas: int = None,
        metrics: List[CreateApplicationScalingRuleResponseBodyDataMetricMetrics] = None,
        min_replicas: int = None,
    ):
        self.max_replicas = max_replicas
        self.metrics = metrics
        self.min_replicas = min_replicas

    def validate(self):
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        result['Metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['Metrics'].append(k.to_map() if k else None)
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        self.metrics = []
        if m.get('Metrics') is not None:
            for k in m.get('Metrics'):
                temp_model = CreateApplicationScalingRuleResponseBodyDataMetricMetrics()
                self.metrics.append(temp_model.from_map(k))
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        return self


class CreateApplicationScalingRuleResponseBodyDataTimerSchedules(TeaModel):
    def __init__(
        self,
        at_time: str = None,
        max_replicas: int = None,
        min_replicas: int = None,
        target_replicas: int = None,
    ):
        self.at_time = at_time
        self.max_replicas = max_replicas
        self.min_replicas = min_replicas
        self.target_replicas = target_replicas

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.at_time is not None:
            result['AtTime'] = self.at_time
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        if self.target_replicas is not None:
            result['TargetReplicas'] = self.target_replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AtTime') is not None:
            self.at_time = m.get('AtTime')
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        if m.get('TargetReplicas') is not None:
            self.target_replicas = m.get('TargetReplicas')
        return self


class CreateApplicationScalingRuleResponseBodyDataTimer(TeaModel):
    def __init__(
        self,
        begin_date: str = None,
        end_date: str = None,
        period: str = None,
        schedules: List[CreateApplicationScalingRuleResponseBodyDataTimerSchedules] = None,
    ):
        self.begin_date = begin_date
        self.end_date = end_date
        self.period = period
        self.schedules = schedules

    def validate(self):
        if self.schedules:
            for k in self.schedules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_date is not None:
            result['BeginDate'] = self.begin_date
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.period is not None:
            result['Period'] = self.period
        result['Schedules'] = []
        if self.schedules is not None:
            for k in self.schedules:
                result['Schedules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BeginDate') is not None:
            self.begin_date = m.get('BeginDate')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        self.schedules = []
        if m.get('Schedules') is not None:
            for k in m.get('Schedules'):
                temp_model = CreateApplicationScalingRuleResponseBodyDataTimerSchedules()
                self.schedules.append(temp_model.from_map(k))
        return self


class CreateApplicationScalingRuleResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        create_time: int = None,
        enable_idle: bool = None,
        last_disable_time: int = None,
        metric: CreateApplicationScalingRuleResponseBodyDataMetric = None,
        scale_rule_enabled: bool = None,
        scale_rule_name: str = None,
        scale_rule_type: str = None,
        timer: CreateApplicationScalingRuleResponseBodyDataTimer = None,
        update_time: int = None,
    ):
        self.app_id = app_id
        self.create_time = create_time
        self.enable_idle = enable_idle
        self.last_disable_time = last_disable_time
        self.metric = metric
        self.scale_rule_enabled = scale_rule_enabled
        self.scale_rule_name = scale_rule_name
        self.scale_rule_type = scale_rule_type
        self.timer = timer
        self.update_time = update_time

    def validate(self):
        if self.metric:
            self.metric.validate()
        if self.timer:
            self.timer.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.enable_idle is not None:
            result['EnableIdle'] = self.enable_idle
        if self.last_disable_time is not None:
            result['LastDisableTime'] = self.last_disable_time
        if self.metric is not None:
            result['Metric'] = self.metric.to_map()
        if self.scale_rule_enabled is not None:
            result['ScaleRuleEnabled'] = self.scale_rule_enabled
        if self.scale_rule_name is not None:
            result['ScaleRuleName'] = self.scale_rule_name
        if self.scale_rule_type is not None:
            result['ScaleRuleType'] = self.scale_rule_type
        if self.timer is not None:
            result['Timer'] = self.timer.to_map()
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('EnableIdle') is not None:
            self.enable_idle = m.get('EnableIdle')
        if m.get('LastDisableTime') is not None:
            self.last_disable_time = m.get('LastDisableTime')
        if m.get('Metric') is not None:
            temp_model = CreateApplicationScalingRuleResponseBodyDataMetric()
            self.metric = temp_model.from_map(m['Metric'])
        if m.get('ScaleRuleEnabled') is not None:
            self.scale_rule_enabled = m.get('ScaleRuleEnabled')
        if m.get('ScaleRuleName') is not None:
            self.scale_rule_name = m.get('ScaleRuleName')
        if m.get('ScaleRuleType') is not None:
            self.scale_rule_type = m.get('ScaleRuleType')
        if m.get('Timer') is not None:
            temp_model = CreateApplicationScalingRuleResponseBodyDataTimer()
            self.timer = temp_model.from_map(m['Timer'])
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class CreateApplicationScalingRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateApplicationScalingRuleResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateApplicationScalingRuleResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class CreateApplicationScalingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateApplicationScalingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateApplicationScalingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateConfigMapRequest(TeaModel):
    def __init__(
        self,
        data: str = None,
        description: str = None,
        name: str = None,
        namespace_id: str = None,
    ):
        # The ConfigMap data.
        # 
        # This parameter is required.
        self.data = data
        # The key-value pairs of the ConfigMap in the JSON format. Format:
        # 
        # {"Data":"{"k1":"v1", "k2":"v2"}"}
        # 
        # k specifies a key and v specifies a value. For more information, see [Manage a Kubernetes ConfigMap](https://help.aliyun.com/document_detail/171326.html).
        self.description = description
        # The name of the ConfigMap. The name can contain digits, letters, and underscores (_). The name must start with a letter.
        # 
        # This parameter is required.
        self.name = name
        # The ID of the namespace to which the ConfigMap instance belongs.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class CreateConfigMapResponseBodyData(TeaModel):
    def __init__(
        self,
        config_map_id: int = None,
    ):
        # The returned result.
        self.config_map_id = config_map_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        return self


class CreateConfigMapResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateConfigMapResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # Empty
        self.code = code
        # The trace ID that is used to query the details of the request.
        self.data = data
        # The ID of the ConfigMap that was created.
        self.error_code = error_code
        # The request ID.
        self.message = message
        # The returned data.
        self.request_id = request_id
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.success = success
        # The returned message.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateConfigMapResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class CreateConfigMapResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateConfigMapResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateConfigMapResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateGreyTagRouteRequest(TeaModel):
    def __init__(
        self,
        alb_rules: str = None,
        app_id: str = None,
        description: str = None,
        dubbo_rules: str = None,
        name: str = None,
        sc_rules: str = None,
    ):
        # The canary release rule of the application for which Application Load Balancer (ALB) gateway routing is configured.
        self.alb_rules = alb_rules
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The description of the canary release rule. The name must be 1 to 64 characters in length.
        self.description = description
        # The canary release rule that you created for Dubbo applications. If your application uses the Dubbo framework, you must configure this parameter. You do not need to configure the **ScRules** parameter.
        self.dubbo_rules = dubbo_rules
        # The name of the canary release rule. The name must start with a lowercase letter and end with a digit or a lowercase letter. The name can contain only lowercase letters, Chinese characters, digits, and hyphens (-). The name must be 1 to 64 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # The canary release rule that you created for Spring Cloud application. If your application uses the Spring Cloud framework, you must configure this parameter. You do not need to configure the **DubboRules** parameter.
        self.sc_rules = sc_rules

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alb_rules is not None:
            result['AlbRules'] = self.alb_rules
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.description is not None:
            result['Description'] = self.description
        if self.dubbo_rules is not None:
            result['DubboRules'] = self.dubbo_rules
        if self.name is not None:
            result['Name'] = self.name
        if self.sc_rules is not None:
            result['ScRules'] = self.sc_rules
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlbRules') is not None:
            self.alb_rules = m.get('AlbRules')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DubboRules') is not None:
            self.dubbo_rules = m.get('DubboRules')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ScRules') is not None:
            self.sc_rules = m.get('ScRules')
        return self


class CreateGreyTagRouteResponseBodyData(TeaModel):
    def __init__(
        self,
        grey_tag_route_id: int = None,
    ):
        # The ID of the canary release rule. The ID is globally unique.
        self.grey_tag_route_id = grey_tag_route_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grey_tag_route_id is not None:
            result['GreyTagRouteId'] = self.grey_tag_route_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GreyTagRouteId') is not None:
            self.grey_tag_route_id = m.get('GreyTagRouteId')
        return self


class CreateGreyTagRouteResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateGreyTagRouteResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The request was successful.
        # *   **3xx**: The request was redirected.
        # *   **4xx**: The request failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The information about the canary release rule.
        self.data = data
        # The error code. Valid values:
        # 
        # *   **ErrorCode** is not returned if a request is successful.
        # *   **ErrorCode** is returned if a request failed. For more information, see **Error code** section of this topic.
        self.error_code = error_code
        # The message returned for the operation.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the information of the change order was queried. Valid values:
        # 
        # *   **true**: The information was queried.
        # *   **false**: The information failed to be queried.
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateGreyTagRouteResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class CreateGreyTagRouteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateGreyTagRouteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateGreyTagRouteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateIngressRequest(TeaModel):
    def __init__(
        self,
        address_type: str = None,
        cert_id: str = None,
        cert_ids: str = None,
        cors_config: str = None,
        default_rule: str = None,
        description: str = None,
        enable_xforwarded_for: bool = None,
        enable_xforwarded_for_client_src_port: bool = None,
        enable_xforwarded_for_proto: bool = None,
        enable_xforwarded_for_slb_id: bool = None,
        enable_xforwarded_for_slb_port: bool = None,
        idle_timeout: int = None,
        listener_port: int = None,
        listener_protocol: str = None,
        load_balance_type: str = None,
        load_balancer_edition: str = None,
        namespace_id: str = None,
        request_timeout: int = None,
        rules: str = None,
        security_policy_id: str = None,
        slb_id: str = None,
        zone_mappings: str = None,
    ):
        self.address_type = address_type
        # The ID of the certificate that is associated with the **CLB** instance.
        # 
        # *   If you set **LoadBalanceType** to **clb**, you can use CertId to configure a certificate for the HTTPS listener.
        # 
        # For more information about how to manage the SSL certificate IDs that are used by CLB instances, see [Overview](https://help.aliyun.com/document_detail/90792.html).
        self.cert_id = cert_id
        # The IDs of the certificates that are associated with the **ALB** instance.
        # 
        # *   If you set **LoadBalanceType** to **alb**, you can use CertIds to configure multiple certificates for the HTTPS listener. Separate multiple certificate IDs with commas (,).
        # *   The ID of the SSL certificate that is used by an ALB instance can be obtained from Certificate Management Service. For example, if you specify `756***-cn-hangzhou`, `756***` is the certificate ID that is obtained from the service page, and `-cn-hangzhou` is the fixed suffix. For more information, see [Manage certificates](https://help.aliyun.com/document_detail/209076.html).
        self.cert_ids = cert_ids
        self.cors_config = cors_config
        # Default forwarding rule. Traffic is forwarded to the specified application through a designated port based on the IP address. Parameter descriptions are as follows:
        # - **appId**: Application ID. - **containerPort**: Application instance port.
        # > All requests that do not match or do not meet the **Rules** for forwarding will be directed to this specified application.
        # 
        # This parameter is required.
        self.default_rule = default_rule
        # Route rule name.
        self.description = description
        self.enable_xforwarded_for = enable_xforwarded_for
        self.enable_xforwarded_for_client_src_port = enable_xforwarded_for_client_src_port
        self.enable_xforwarded_for_proto = enable_xforwarded_for_proto
        self.enable_xforwarded_for_slb_id = enable_xforwarded_for_slb_id
        self.enable_xforwarded_for_slb_port = enable_xforwarded_for_slb_port
        # The timeout period of an idle connection. Unit: seconds Valid values: 1 to 60. If no requests are received within the specified timeout period, ALB closes the current connection. When a new request is received, ALB establishes a new connection.
        self.idle_timeout = idle_timeout
        # SThe frontend port that is used by the ALB instance.
        # Valid values: 1 to 65535.
        # 
        # This parameter is required.
        self.listener_port = listener_port
        # Request forwarding protocol. The value description is as follows:
        # - **HTTP**: Suitable for applications that need to identify data content. - **HTTPS**: Suitable for applications that require encrypted transmission.
        self.listener_protocol = listener_protocol
        # The type of the SLB instance. The instance type can be specified only when you create a routing rule. You cannot change the instance type when you update the routing rule. Valid values:
        # 
        # *   **clb**\
        # *   **alb**\
        self.load_balance_type = load_balance_type
        self.load_balancer_edition = load_balancer_edition
        # The ID of the namespace where the application is located. Currently, cross-namespace applications are not supported.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # The timeout period of a request. Unit: seconds. Valid values: 1 to 180. If no response is received from the backend server within the specified timeout period, ALB stops waiting for the response and returns an HTTP 504 error code to the client.
        self.request_timeout = request_timeout
        # The forwarding rules. You can specify a port and an application in a forwarding rule to forward traffic based on the specified domain name and request path. The following list describes the involved parameters:
        # 
        # *   **appId**: the ID of the application.
        # *   **containerPort**: the container port of the application.
        # *   **domain**: the domain name.
        # *   **path**: the request path.
        # *   **backendProtocol**: the backend service protocol. Valid values: http, https, and grpc. Default value: http.
        # *   **rewritePath**: the rewrite path.
        # 
        # >  The path rewrite feature is supported only by ALB instances.
        # 
        # This parameter is required.
        self.rules = rules
        # The ID of a security policy.
        self.security_policy_id = security_policy_id
        # The Server Load Balancer (SLB) instance that is used by the routing rule.
        # 
        # >  The SLB instance can be a Classic Load Balancer (CLB) instance or an Application Load Balancer (ALB) instance.
        self.slb_id = slb_id
        self.zone_mappings = zone_mappings

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_type is not None:
            result['AddressType'] = self.address_type
        if self.cert_id is not None:
            result['CertId'] = self.cert_id
        if self.cert_ids is not None:
            result['CertIds'] = self.cert_ids
        if self.cors_config is not None:
            result['CorsConfig'] = self.cors_config
        if self.default_rule is not None:
            result['DefaultRule'] = self.default_rule
        if self.description is not None:
            result['Description'] = self.description
        if self.enable_xforwarded_for is not None:
            result['EnableXForwardedFor'] = self.enable_xforwarded_for
        if self.enable_xforwarded_for_client_src_port is not None:
            result['EnableXForwardedForClientSrcPort'] = self.enable_xforwarded_for_client_src_port
        if self.enable_xforwarded_for_proto is not None:
            result['EnableXForwardedForProto'] = self.enable_xforwarded_for_proto
        if self.enable_xforwarded_for_slb_id is not None:
            result['EnableXForwardedForSlbId'] = self.enable_xforwarded_for_slb_id
        if self.enable_xforwarded_for_slb_port is not None:
            result['EnableXForwardedForSlbPort'] = self.enable_xforwarded_for_slb_port
        if self.idle_timeout is not None:
            result['IdleTimeout'] = self.idle_timeout
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.listener_protocol is not None:
            result['ListenerProtocol'] = self.listener_protocol
        if self.load_balance_type is not None:
            result['LoadBalanceType'] = self.load_balance_type
        if self.load_balancer_edition is not None:
            result['LoadBalancerEdition'] = self.load_balancer_edition
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.request_timeout is not None:
            result['RequestTimeout'] = self.request_timeout
        if self.rules is not None:
            result['Rules'] = self.rules
        if self.security_policy_id is not None:
            result['SecurityPolicyId'] = self.security_policy_id
        if self.slb_id is not None:
            result['SlbId'] = self.slb_id
        if self.zone_mappings is not None:
            result['ZoneMappings'] = self.zone_mappings
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddressType') is not None:
            self.address_type = m.get('AddressType')
        if m.get('CertId') is not None:
            self.cert_id = m.get('CertId')
        if m.get('CertIds') is not None:
            self.cert_ids = m.get('CertIds')
        if m.get('CorsConfig') is not None:
            self.cors_config = m.get('CorsConfig')
        if m.get('DefaultRule') is not None:
            self.default_rule = m.get('DefaultRule')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnableXForwardedFor') is not None:
            self.enable_xforwarded_for = m.get('EnableXForwardedFor')
        if m.get('EnableXForwardedForClientSrcPort') is not None:
            self.enable_xforwarded_for_client_src_port = m.get('EnableXForwardedForClientSrcPort')
        if m.get('EnableXForwardedForProto') is not None:
            self.enable_xforwarded_for_proto = m.get('EnableXForwardedForProto')
        if m.get('EnableXForwardedForSlbId') is not None:
            self.enable_xforwarded_for_slb_id = m.get('EnableXForwardedForSlbId')
        if m.get('EnableXForwardedForSlbPort') is not None:
            self.enable_xforwarded_for_slb_port = m.get('EnableXForwardedForSlbPort')
        if m.get('IdleTimeout') is not None:
            self.idle_timeout = m.get('IdleTimeout')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('ListenerProtocol') is not None:
            self.listener_protocol = m.get('ListenerProtocol')
        if m.get('LoadBalanceType') is not None:
            self.load_balance_type = m.get('LoadBalanceType')
        if m.get('LoadBalancerEdition') is not None:
            self.load_balancer_edition = m.get('LoadBalancerEdition')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('RequestTimeout') is not None:
            self.request_timeout = m.get('RequestTimeout')
        if m.get('Rules') is not None:
            self.rules = m.get('Rules')
        if m.get('SecurityPolicyId') is not None:
            self.security_policy_id = m.get('SecurityPolicyId')
        if m.get('SlbId') is not None:
            self.slb_id = m.get('SlbId')
        if m.get('ZoneMappings') is not None:
            self.zone_mappings = m.get('ZoneMappings')
        return self


class CreateIngressResponseBodyData(TeaModel):
    def __init__(
        self,
        ingress_id: int = None,
    ):
        # The ID of the routing rule.
        self.ingress_id = ingress_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ingress_id is not None:
            result['IngressId'] = self.ingress_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IngressId') is not None:
            self.ingress_id = m.get('IngressId')
        return self


class CreateIngressResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateIngressResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The response.
        self.data = data
        # The error code returned. Take note of the following rules:
        # 
        # *   The **ErrorCode** parameter is not returned if the request succeeds.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The additional information that is returned. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the Secret is successfully deleted. Valid values:
        # 
        # *   **true**: The instance was deleted.
        # *   **false**: The instance failed to be deleted.
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateIngressResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class CreateIngressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateIngressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateIngressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateJobRequest(TeaModel):
    def __init__(
        self,
        acr_assume_role_arn: str = None,
        acr_instance_id: str = None,
        app_description: str = None,
        app_name: str = None,
        auto_config: bool = None,
        backoff_limit: int = None,
        command: str = None,
        command_args: str = None,
        concurrency_policy: str = None,
        config_map_mount_desc: str = None,
        cpu: int = None,
        custom_host_alias: str = None,
        edas_container_version: str = None,
        enable_image_accl: bool = None,
        envs: str = None,
        image_pull_secrets: str = None,
        image_url: str = None,
        jar_start_args: str = None,
        jar_start_options: str = None,
        jdk: str = None,
        memory: int = None,
        mount_desc: str = None,
        mount_host: str = None,
        namespace_id: str = None,
        nas_id: str = None,
        oss_ak_id: str = None,
        oss_ak_secret: str = None,
        oss_mount_descs: str = None,
        package_type: str = None,
        package_url: str = None,
        package_version: str = None,
        php_config: str = None,
        php_config_location: str = None,
        post_start: str = None,
        pre_stop: str = None,
        programming_language: str = None,
        python: str = None,
        python_modules: str = None,
        ref_app_id: str = None,
        replicas: int = None,
        security_group_id: str = None,
        slice: bool = None,
        slice_envs: str = None,
        sls_configs: str = None,
        termination_grace_period_seconds: int = None,
        timeout: int = None,
        timezone: str = None,
        tomcat_config: str = None,
        trigger_config: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
        war_start_options: str = None,
        web_container: str = None,
        workload: str = None,
    ):
        # The Alibaba Cloud Resource Name (ARN) required for a RAM role to obtain images across accounts. For more information, see [Grant permissions across Alibaba Cloud accounts by using a RAM role](https://help.aliyun.com/document_detail/223585.html).
        self.acr_assume_role_arn = acr_assume_role_arn
        # The ID of Container Registry Enterprise Edition instance N. This parameter is required when the **ImageUrl** parameter is set to the URL of an image in an ACR Enterprise Edition instance.
        self.acr_instance_id = acr_instance_id
        # The description of the template. The description cannot exceed 1,024 characters in length.
        self.app_description = app_description
        # The name of the job template. The name can contain digits, letters, and hyphens (-). The name must start with a letter and cannot exceed 36 characters in length.
        # 
        # This parameter is required.
        self.app_name = app_name
        # Specifies whether to automatically configure the network environment. Take note of the following rules:
        # 
        # *   **true**: The network environment is automatically configured by SAE when the application is created. In this case, the values of the **NamespaceId**, **VpcId**, **vSwitchId**, and **SecurityGroupId** parameters are ignored.
        # *   **false**: The network environment is manually configured based on your settings when the application is created.
        self.auto_config = auto_config
        # The number of times the job is retried.
        self.backoff_limit = backoff_limit
        # The command that is used to start the image. The command must be an existing executable object in the container. Sample statements:
        # 
        #     command:
        #           - echo
        #           - abc
        #           - >
        #           - file0
        # 
        # In this example, the Command parameter is set to `Command="echo", CommandArgs=["abc", ">", "file0"]`.
        self.command = command
        # The parameters of the image startup command. The CommandArgs parameter specifies the parameters that are required for the **Command** parameter. You can specify the name in one of the following formats:
        # 
        # `["a","b"]`
        # 
        # In the preceding example, the CommandArgs parameter is set to `CommandArgs=["abc", ">", "file0"]`. The data type of `["abc", ">", "file0"]` must be an array of strings in the JSON format. This parameter is optional.
        self.command_args = command_args
        # The concurrency policy of the job. Take note of the following rules:
        # 
        # *   **Forbid**: Prohibits concurrent running. If the previous job is not completed, no new job is created.
        # *   **Allow**: Allows concurrent running.
        # *   **Replace**: If the previous job is not completed when the time to create a new job is reached, the new job replaces the previous job.
        self.concurrency_policy = concurrency_policy
        # The description of the **ConfigMap** instance mounted to the application. Use configurations created on the Configuration Items page to configure containers. The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **congfigMapId**: the ID of the ConfigMap instance. You can call the [ListNamespacedConfigMaps](https://help.aliyun.com/document_detail/176917.html) operation to obtain the ID.
        # *   **key**: the key.
        # 
        # > You can use the `sae-sys-configmap-all` key to mount all keys.
        # 
        # *   **mountPath**: the mount path in the container.
        self.config_map_mount_desc = config_map_mount_desc
        # The CPU specifications that are required for each instance. Unit: millicores. You cannot set this parameter to 0. Valid values:
        # 
        # *   500
        # *   1000
        # *   2000
        # *   4000
        # *   8000
        # *   16000
        # *   32000
        self.cpu = cpu
        # The custom mappings between hostnames and IP addresses in the container. Take note of the following rules:
        # 
        # *   **hostName**: the domain name or hostname.
        # *   **ip**: the IP address.
        self.custom_host_alias = custom_host_alias
        # The version of the container, such as Ali-Tomcat, in which an application developed based on High-speed Service Framework (HSF) is deployed.
        self.edas_container_version = edas_container_version
        self.enable_image_accl = enable_image_accl
        # The environment variables. You can configure custom environment variables or reference a ConfigMap. If you want to reference a ConfigMap, you must first create a ConfigMap. For more information, see [CreateConfigMap](https://help.aliyun.com/document_detail/176914.html). Take note of the following rules:
        # 
        # *   Customize
        # 
        #     *   **name**: the name of the environment variable.
        #     *   **value**: the value of the environment variable.
        # 
        # *   Reference ConfigMap
        # 
        #     *   **name**: the name of the environment variable. You can reference one or all keys. If you want to reference all keys, specify `sae-sys-configmap-all-<ConfigMap name>`. Example: `sae-sys-configmap-all-test1`.
        #     *   **valueFrom**: the reference of the environment variable. Set the value to `configMapRef`.
        #     *   **configMapId**: the ConfigMap ID.
        #     *   **key**: the key. If you want to reference all keys, do not configure this parameter.
        self.envs = envs
        # The ID of the corresponding Secret.
        self.image_pull_secrets = image_pull_secrets
        # The URL of the image. This parameter is returned only if the **PackageType** parameter is set to **Image**.
        self.image_url = image_url
        # The arguments in the JAR package. The arguments are used to start the application container. The default startup command is `$JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs`.
        self.jar_start_args = jar_start_args
        # The option settings in the JAR package. The settings are used to start the application container. The default startup command for application deployment is `$JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs`.
        self.jar_start_options = jar_start_options
        # The version of the Java development kit (JDK) on which the deployment package of the application depends. The following versions are supported:
        # 
        # *   **Open JDK 8**\
        # *   **Open JDK 7**\
        # *   **Dragonwell 11**\
        # *   **Dragonwell 8**\
        # *   **openjdk-8u191-jdk-alpine3.9**\
        # *   **openjdk-7u201-jdk-alpine3.9**\
        # 
        # This parameter is not returned if the **PackageType** parameter is set to **Image**.
        self.jdk = jdk
        # The size of memory required by each instance. Unit: MB. You cannot set this parameter to 0. The values of this parameter correspond to the values of the Cpu parameter:
        # 
        # *   Set the value to 1024 when Cpu is set to 500 or 1000.
        # *   Set the value to 2048 when Cpu is set to 500, 1000 or 2000.
        # *   Set the value to 4096 when Cpu is set to 1000, 2000, or 4000.
        # *   Set the value to 8192 when Cpu is set to 2000, 4000, or 8000.
        # *   Set the value to 12288 when Cpu is set to 12000.
        # *   Set the value to 16384 when Cpu is set to 4000, 8000, or 16000.
        # *   Set the value to 24576 when Cpu is set to 12000.
        # *   Set the value to 32768 when Cpu is set to 16000.
        # *   Set the value to 65536 when Cpu is set to 8000, 16000, or 32000.
        # *   Set the value to 131072 when Cpu is set to 32000.
        self.memory = memory
        # The configurations for mounting the NAS file system. After the application is created, you may want to call other operations to manage the application. If you do not want to change the NAS configurations in these subsequent operations, you can omit the **MountDesc** parameter in the requests. If you want to unmount the NAS file system, you must set the **MountDesc** values in the subsequent requests to an empty string ("").
        self.mount_desc = mount_desc
        # The mount target of the NAS file system in the VPC where the application is deployed. If you do not need to modify this configuration during the deployment, configure the **MountHost** parameter only in the first request. You do not need to include this parameter in subsequent requests. If you need to remove this configuration, leave the **MountHost** parameter empty in the request.
        self.mount_host = mount_host
        # The ID of the Serverless App Engine (SAE) namespace. The ID can contain only lowercase letters and hyphens (-). It must start with a lowercase letter.
        self.namespace_id = namespace_id
        # The ID of the Apsara File Storage NAS file system. After the application is created, you may want to call other operations to manage the application. If you do not want to change the NAS configurations in these subsequent operations, you can omit the **NasId** parameter in the requests. If you want to unmount the NAS file system, you must set the **NasId** values in the subsequent requests to an empty string ("").
        self.nas_id = nas_id
        # The AccessKey ID that is used to read data from and write data to Object Storage Service (OSS) buckets.
        self.oss_ak_id = oss_ak_id
        # The AccessKey secret that is used to read data from and write data to OSS buckets.
        self.oss_ak_secret = oss_ak_secret
        # Information of the Object Storage Service (OSS) bucket mounted to the application. The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **bucketName**: the name of the OSS bucket.
        # 
        # *   **bucketPath**: the directory or object in OSS. If the specified directory or object does not exist, an error is returned.
        # 
        # *   **mountPath**: the directory of the container in SAE. If the path already exists, the newly specified path overwrites the previous one. If the path does not exist, it is created.
        # 
        # *   **readOnly**: specifies whether to only allow the container path to read data from the OSS directory. Valid values:
        # 
        #     *   **true**: The container path only has read permission on the OSS directory.
        #     *   **false**: The application has read and write permissions.
        self.oss_mount_descs = oss_mount_descs
        # The type of the deployment package. Take note of the following rules:
        # 
        # *   If you deploy the application by using a Java Archive (JAR) package, you can set this parameter to **FatJar**, **War**, or **Image**.
        # *   If you deploy the application by using a PHP package, you can set this parameter to one of the following values:
        # 
        # **PhpZip** **IMAGE_PHP_5_4** **IMAGE_PHP_5_4_ALPINE** **IMAGE_PHP_5_5** **IMAGE_PHP_5_5_ALPINE** **IMAGE_PHP_5_6** **IMAGE_PHP_5_6_ALPINE** **IMAGE_PHP_7_0** **IMAGE_PHP_7_0_ALPINE** **IMAGE_PHP_7_1** **IMAGE_PHP_7_1_ALPINE** **IMAGE_PHP_7_2** **IMAGE_PHP_7_2_ALPINE** **IMAGE_PHP_7_3** **IMAGE_PHP_7_3_ALPINE**\
        # 
        # *   If you deploy the application by using a **Python** package, you can set this parameter to **PythonZip** or **Image**:
        # 
        # This parameter is required.
        self.package_type = package_type
        # The address of the deployment package. This parameter is required if you set **PackageType** to **FatJar**, **War**, or **PythonZip**.
        self.package_url = package_url
        # The version of the deployment package. This parameter is required if you set **PackageType** to **FatJar**, **War**, or **PythonZip**.
        self.package_version = package_version
        # The details of the PHP configuration file.
        self.php_config = php_config
        # The path on which the PHP configuration file for application startup is mounted. Make sure that the PHP server uses this configuration file during the startup.
        self.php_config_location = php_config_location
        # The script that is run immediately after the container is started. Example: `{"exec":{"command":["sh","-c","echo hello"\\]}}`
        self.post_start = post_start
        # The script that is run before the container is stopped. Example: `{"exec":{"command":["sh","-c","echo hello"\\]}}`
        self.pre_stop = pre_stop
        # The programming language. Valid values: **java**, **php**, **python**, and **shell**.
        self.programming_language = programming_language
        # The Python environment. Set the value to **PYTHON 3.9.15**.
        self.python = python
        # The configurations for installing custom module dependencies. By default, the dependencies defined by the requirements.txt file in the root directory are installed. If the package does not contain this file and you do not configure custom dependencies in the package, specify the dependencies that you want to install in the text box.
        self.python_modules = python_modules
        # The ID of the job that you reference.
        self.ref_app_id = ref_app_id
        # The number of concurrent instances.
        # 
        # This parameter is required.
        self.replicas = replicas
        # The ID of the security group.
        self.security_group_id = security_group_id
        # Specifies whether to enable job sharding.
        self.slice = slice
        # The parameters of job sharding.
        self.slice_envs = slice_envs
        # The logging configurations of Log Service.
        # 
        # *   To use Log Service resources that are automatically created by SAE, set this parameter to `[{"logDir":"","logType":"stdout"},{"logDir":"/tmp/a.log"}]`.
        # *   To use custom Log Service resources, set this parameter to `[{"projectName":"test-sls","logType":"stdout","logDir":"","logstoreName":"sae","logtailName":""},{"projectName":"test","logDir":"/tmp/a.log","logstoreName":"sae","logtailName":""}]`.
        # 
        # The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **projectName**: the name of the Log Service project.
        # *   **logDir**: the path in which logs are stored.
        # *   **logType**: the log type. **stdout**: the standard output log of the container. You can specify only one stdout value for this parameter. If you leave this parameter empty, file logs are collected.
        # *   **logstoreName**: the name of the Logstore in Log Service.
        # *   **logtailName**: the name of the Logtail configuration in Log Service. If you do not configure this parameter, a new Logtail configuration is created.
        # 
        # If you do not need to modify the logging configurations when you deploy the application, configure the **SlsConfigs** parameter only in the first request. You do not need to include this parameter in subsequent requests. If you no longer need to use Log Service, leave the **SlsConfigs** parameter empty in the request.
        # 
        # > A Log Service project that is automatically created by SAE when you create an application is deleted when the application is deleted. Therefore, when you create an application, you cannot select a Log Service project that is automatically created by SAE for log collection.
        self.sls_configs = sls_configs
        # The timeout period for a graceful shutdown. Default value: 30. Unit: seconds. Valid values: 1 to 300.
        self.termination_grace_period_seconds = termination_grace_period_seconds
        # The timeout period. Unit: seconds.
        self.timeout = timeout
        # The time zone. Default value: **Asia/Shanghai**.
        self.timezone = timezone
        # The Tomcat configuration. If you want to cancel this configuration, set this parameter to "" or "{}". The following variables are included in the configuration: Take note of the following rules:
        # 
        # *   **port**: the port number. The port number ranges from 1024 to 65535. Though the admin permissions are configured for the container, the root permissions are required to perform operations on ports whose number is smaller than 1024. Enter a value that ranges from 1025 to 65535 because the container has only the admin permissions. If you do not specify this parameter, the default port number 8080 is used.
        # *   **contextPath**: the path. Default value: /. This value indicates the root directory.
        # *   **maxThreads**: the maximum number of connections in the connection pool. Default value: 400.
        # *   **uriEncoding**: the URI encoding scheme in the Tomcat container. Valid values: UTF-8, ISO-8859-1, GBK, and GB2312.************ If you do not specify this parameter, the default value **ISO-8859-1** is used.
        # *   **useBodyEncoding**: specifies whether to use the encoding scheme specified in the request body for URI query parameters. Default value: true.
        self.tomcat_config = tomcat_config
        self.trigger_config = trigger_config
        # The vSwitch to which the elastic network interface (ENI) of the application instance is connected. The vSwitch must be located in the VPC specified by the VpcId parameter. The SAE namespace is bound with this vSwitch. The default value is the ID of the vSwitch that is bound to the namespace.
        self.v_switch_id = v_switch_id
        # The ID of the virtual private cloud (VPC) that corresponds to the SAE namespace. In SAE, once correspondence is configured between a namespace and a VPC, the namespace cannot correspond to other VPCs. When the SAE application is created within the namespace, the application is bound with the VPC. Multiple namespaces can correspond to the same VPC. The default value is the ID of the VPC that is bound to the namespace.
        self.vpc_id = vpc_id
        # The startup command of the WAR package. For information about how to configure the startup command, see [Configure startup commands](https://help.aliyun.com/document_detail/96677.html).
        self.war_start_options = war_start_options
        # The version of the Tomcat container on which the deployment package depends. Valid values:
        # 
        # *   **apache-tomcat-7.0.91**\
        # *   **apache-tomcat-8.5.42**\
        # 
        # This parameter is not returned if the **PackageType** parameter is set to **Image**.
        self.web_container = web_container
        # Set the value to `job`.
        # 
        # This parameter is required.
        self.workload = workload

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acr_assume_role_arn is not None:
            result['AcrAssumeRoleArn'] = self.acr_assume_role_arn
        if self.acr_instance_id is not None:
            result['AcrInstanceId'] = self.acr_instance_id
        if self.app_description is not None:
            result['AppDescription'] = self.app_description
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.auto_config is not None:
            result['AutoConfig'] = self.auto_config
        if self.backoff_limit is not None:
            result['BackoffLimit'] = self.backoff_limit
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        if self.concurrency_policy is not None:
            result['ConcurrencyPolicy'] = self.concurrency_policy
        if self.config_map_mount_desc is not None:
            result['ConfigMapMountDesc'] = self.config_map_mount_desc
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.custom_host_alias is not None:
            result['CustomHostAlias'] = self.custom_host_alias
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        if self.enable_image_accl is not None:
            result['EnableImageAccl'] = self.enable_image_accl
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.image_pull_secrets is not None:
            result['ImagePullSecrets'] = self.image_pull_secrets
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.jar_start_args is not None:
            result['JarStartArgs'] = self.jar_start_args
        if self.jar_start_options is not None:
            result['JarStartOptions'] = self.jar_start_options
        if self.jdk is not None:
            result['Jdk'] = self.jdk
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.mount_desc is not None:
            result['MountDesc'] = self.mount_desc
        if self.mount_host is not None:
            result['MountHost'] = self.mount_host
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.nas_id is not None:
            result['NasId'] = self.nas_id
        if self.oss_ak_id is not None:
            result['OssAkId'] = self.oss_ak_id
        if self.oss_ak_secret is not None:
            result['OssAkSecret'] = self.oss_ak_secret
        if self.oss_mount_descs is not None:
            result['OssMountDescs'] = self.oss_mount_descs
        if self.package_type is not None:
            result['PackageType'] = self.package_type
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.php_config is not None:
            result['PhpConfig'] = self.php_config
        if self.php_config_location is not None:
            result['PhpConfigLocation'] = self.php_config_location
        if self.post_start is not None:
            result['PostStart'] = self.post_start
        if self.pre_stop is not None:
            result['PreStop'] = self.pre_stop
        if self.programming_language is not None:
            result['ProgrammingLanguage'] = self.programming_language
        if self.python is not None:
            result['Python'] = self.python
        if self.python_modules is not None:
            result['PythonModules'] = self.python_modules
        if self.ref_app_id is not None:
            result['RefAppId'] = self.ref_app_id
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.slice is not None:
            result['Slice'] = self.slice
        if self.slice_envs is not None:
            result['SliceEnvs'] = self.slice_envs
        if self.sls_configs is not None:
            result['SlsConfigs'] = self.sls_configs
        if self.termination_grace_period_seconds is not None:
            result['TerminationGracePeriodSeconds'] = self.termination_grace_period_seconds
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.tomcat_config is not None:
            result['TomcatConfig'] = self.tomcat_config
        if self.trigger_config is not None:
            result['TriggerConfig'] = self.trigger_config
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.war_start_options is not None:
            result['WarStartOptions'] = self.war_start_options
        if self.web_container is not None:
            result['WebContainer'] = self.web_container
        if self.workload is not None:
            result['Workload'] = self.workload
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcrAssumeRoleArn') is not None:
            self.acr_assume_role_arn = m.get('AcrAssumeRoleArn')
        if m.get('AcrInstanceId') is not None:
            self.acr_instance_id = m.get('AcrInstanceId')
        if m.get('AppDescription') is not None:
            self.app_description = m.get('AppDescription')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AutoConfig') is not None:
            self.auto_config = m.get('AutoConfig')
        if m.get('BackoffLimit') is not None:
            self.backoff_limit = m.get('BackoffLimit')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        if m.get('ConcurrencyPolicy') is not None:
            self.concurrency_policy = m.get('ConcurrencyPolicy')
        if m.get('ConfigMapMountDesc') is not None:
            self.config_map_mount_desc = m.get('ConfigMapMountDesc')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CustomHostAlias') is not None:
            self.custom_host_alias = m.get('CustomHostAlias')
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        if m.get('EnableImageAccl') is not None:
            self.enable_image_accl = m.get('EnableImageAccl')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('ImagePullSecrets') is not None:
            self.image_pull_secrets = m.get('ImagePullSecrets')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('JarStartArgs') is not None:
            self.jar_start_args = m.get('JarStartArgs')
        if m.get('JarStartOptions') is not None:
            self.jar_start_options = m.get('JarStartOptions')
        if m.get('Jdk') is not None:
            self.jdk = m.get('Jdk')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('MountDesc') is not None:
            self.mount_desc = m.get('MountDesc')
        if m.get('MountHost') is not None:
            self.mount_host = m.get('MountHost')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NasId') is not None:
            self.nas_id = m.get('NasId')
        if m.get('OssAkId') is not None:
            self.oss_ak_id = m.get('OssAkId')
        if m.get('OssAkSecret') is not None:
            self.oss_ak_secret = m.get('OssAkSecret')
        if m.get('OssMountDescs') is not None:
            self.oss_mount_descs = m.get('OssMountDescs')
        if m.get('PackageType') is not None:
            self.package_type = m.get('PackageType')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('PhpConfig') is not None:
            self.php_config = m.get('PhpConfig')
        if m.get('PhpConfigLocation') is not None:
            self.php_config_location = m.get('PhpConfigLocation')
        if m.get('PostStart') is not None:
            self.post_start = m.get('PostStart')
        if m.get('PreStop') is not None:
            self.pre_stop = m.get('PreStop')
        if m.get('ProgrammingLanguage') is not None:
            self.programming_language = m.get('ProgrammingLanguage')
        if m.get('Python') is not None:
            self.python = m.get('Python')
        if m.get('PythonModules') is not None:
            self.python_modules = m.get('PythonModules')
        if m.get('RefAppId') is not None:
            self.ref_app_id = m.get('RefAppId')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('Slice') is not None:
            self.slice = m.get('Slice')
        if m.get('SliceEnvs') is not None:
            self.slice_envs = m.get('SliceEnvs')
        if m.get('SlsConfigs') is not None:
            self.sls_configs = m.get('SlsConfigs')
        if m.get('TerminationGracePeriodSeconds') is not None:
            self.termination_grace_period_seconds = m.get('TerminationGracePeriodSeconds')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('TomcatConfig') is not None:
            self.tomcat_config = m.get('TomcatConfig')
        if m.get('TriggerConfig') is not None:
            self.trigger_config = m.get('TriggerConfig')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('WarStartOptions') is not None:
            self.war_start_options = m.get('WarStartOptions')
        if m.get('WebContainer') is not None:
            self.web_container = m.get('WebContainer')
        if m.get('Workload') is not None:
            self.workload = m.get('Workload')
        return self


class CreateJobResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        change_order_id: str = None,
    ):
        # The application ID.
        self.app_id = app_id
        # The ID of the change order. It can be used to query the task status.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class CreateJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateJobResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Take note of the following rules:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The response.
        self.data = data
        # The error code returned if the request failed. Take note of the following rules:
        # 
        # *   The **ErrorCode** parameter is not returned if the request succeeds.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The additional information that is returned. Take note of the following rules:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the application deployment is successful. Take note of the following rules:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class CreateJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateNamespaceRequest(TeaModel):
    def __init__(
        self,
        enable_micro_registration: bool = None,
        name_space_short_id: str = None,
        namespace_description: str = None,
        namespace_id: str = None,
        namespace_name: str = None,
    ):
        # Indicates whether to enable SAE built-in registry:
        # 
        # *   **true**\
        # *   **false**\
        # 
        # Default value: true. If you do not use the built-in registry, you can set this parameter to false to accelerate the creation of a namespace.
        self.enable_micro_registration = enable_micro_registration
        # The trace ID that is used to query the details of the request.
        self.name_space_short_id = name_space_short_id
        # The message returned for the operation.
        self.namespace_description = namespace_description
        # The data returned.
        self.namespace_id = namespace_id
        # The ID of the request.
        # 
        # This parameter is required.
        self.namespace_name = namespace_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_micro_registration is not None:
            result['EnableMicroRegistration'] = self.enable_micro_registration
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_description is not None:
            result['NamespaceDescription'] = self.namespace_description
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.namespace_name is not None:
            result['NamespaceName'] = self.namespace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableMicroRegistration') is not None:
            self.enable_micro_registration = m.get('EnableMicroRegistration')
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceDescription') is not None:
            self.namespace_description = m.get('NamespaceDescription')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NamespaceName') is not None:
            self.namespace_name = m.get('NamespaceName')
        return self


class CreateNamespaceResponseBodyData(TeaModel):
    def __init__(
        self,
        enable_micro_registration: bool = None,
        name_space_short_id: str = None,
        namespace_description: str = None,
        namespace_id: str = None,
        namespace_name: str = None,
        region_id: str = None,
    ):
        # Indicates whether the SAE built-in registry is enabled:
        # 
        # *   **true**\
        # *   **false**\
        self.enable_micro_registration = enable_micro_registration
        # Indicates whether the namespace was created. Valid values:
        # 
        # *   **true**: The instance was created.
        # *   **false**: The call failed to be created.
        self.name_space_short_id = name_space_short_id
        # The short ID of the namespace.
        self.namespace_description = namespace_description
        # The error code returned. Take note of the following rules:
        # 
        # *   The **ErrorCode** parameter is not returned if the request succeeds.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.namespace_id = namespace_id
        # Null
        self.namespace_name = namespace_name
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_micro_registration is not None:
            result['EnableMicroRegistration'] = self.enable_micro_registration
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_description is not None:
            result['NamespaceDescription'] = self.namespace_description
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.namespace_name is not None:
            result['NamespaceName'] = self.namespace_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableMicroRegistration') is not None:
            self.enable_micro_registration = m.get('EnableMicroRegistration')
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceDescription') is not None:
            self.namespace_description = m.get('NamespaceDescription')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NamespaceName') is not None:
            self.namespace_name = m.get('NamespaceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateNamespaceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateNamespaceResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # bucketPath
        self.code = code
        # The information about a namespace.
        self.data = data
        # http://sae_pop_pre/#vpc
        self.error_code = error_code
        # The ID of the namespace.
        self.message = message
        # The description of the custom namespace.
        self.request_id = request_id
        # mountDir
        self.success = success
        # The name of the namespace.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateNamespaceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class CreateNamespaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateNamespaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateNamespaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOrUpdateSwimmingLaneRequestAppEntryRuleConditions(TeaModel):
    def __init__(
        self,
        condition: str = None,
        name: str = None,
        type: str = None,
        value: str = None,
    ):
        self.condition = condition
        self.name = name
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateOrUpdateSwimmingLaneRequestAppEntryRule(TeaModel):
    def __init__(
        self,
        condition_joiner: str = None,
        conditions: List[CreateOrUpdateSwimmingLaneRequestAppEntryRuleConditions] = None,
        independent_percentage_enable: bool = None,
        paths: List[str] = None,
        percentage: int = None,
        percentage_by_path: Dict[str, int] = None,
    ):
        self.condition_joiner = condition_joiner
        self.conditions = conditions
        self.independent_percentage_enable = independent_percentage_enable
        self.paths = paths
        self.percentage = percentage
        self.percentage_by_path = percentage_by_path

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition_joiner is not None:
            result['ConditionJoiner'] = self.condition_joiner
        result['Conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['Conditions'].append(k.to_map() if k else None)
        if self.independent_percentage_enable is not None:
            result['IndependentPercentageEnable'] = self.independent_percentage_enable
        if self.paths is not None:
            result['Paths'] = self.paths
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        if self.percentage_by_path is not None:
            result['PercentageByPath'] = self.percentage_by_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConditionJoiner') is not None:
            self.condition_joiner = m.get('ConditionJoiner')
        self.conditions = []
        if m.get('Conditions') is not None:
            for k in m.get('Conditions'):
                temp_model = CreateOrUpdateSwimmingLaneRequestAppEntryRuleConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('IndependentPercentageEnable') is not None:
            self.independent_percentage_enable = m.get('IndependentPercentageEnable')
        if m.get('Paths') is not None:
            self.paths = m.get('Paths')
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        if m.get('PercentageByPath') is not None:
            self.percentage_by_path = m.get('PercentageByPath')
        return self


class CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRuleConditions(TeaModel):
    def __init__(
        self,
        condition: str = None,
        name: str = None,
        type: str = None,
        value: str = None,
    ):
        self.condition = condition
        self.name = name
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRule(TeaModel):
    def __init__(
        self,
        condition_joiner: str = None,
        conditions: List[CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRuleConditions] = None,
        independent_percentage_enable: bool = None,
        percentage: int = None,
        percentage_by_route: Dict[str, int] = None,
        route_ids: List[int] = None,
    ):
        self.condition_joiner = condition_joiner
        self.conditions = conditions
        self.independent_percentage_enable = independent_percentage_enable
        self.percentage = percentage
        self.percentage_by_route = percentage_by_route
        self.route_ids = route_ids

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition_joiner is not None:
            result['ConditionJoiner'] = self.condition_joiner
        result['Conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['Conditions'].append(k.to_map() if k else None)
        if self.independent_percentage_enable is not None:
            result['IndependentPercentageEnable'] = self.independent_percentage_enable
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        if self.percentage_by_route is not None:
            result['PercentageByRoute'] = self.percentage_by_route
        if self.route_ids is not None:
            result['RouteIds'] = self.route_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConditionJoiner') is not None:
            self.condition_joiner = m.get('ConditionJoiner')
        self.conditions = []
        if m.get('Conditions') is not None:
            for k in m.get('Conditions'):
                temp_model = CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRuleConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('IndependentPercentageEnable') is not None:
            self.independent_percentage_enable = m.get('IndependentPercentageEnable')
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        if m.get('PercentageByRoute') is not None:
            self.percentage_by_route = m.get('PercentageByRoute')
        if m.get('RouteIds') is not None:
            self.route_ids = m.get('RouteIds')
        return self


class CreateOrUpdateSwimmingLaneRequest(TeaModel):
    def __init__(
        self,
        app_entry_rule: CreateOrUpdateSwimmingLaneRequestAppEntryRule = None,
        canary_model: int = None,
        enable: bool = None,
        group_id: int = None,
        lane_id: int = None,
        lane_name: str = None,
        lane_tag: str = None,
        mse_gateway_entry_rule: CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRule = None,
        namespace_id: str = None,
    ):
        self.app_entry_rule = app_entry_rule
        self.canary_model = canary_model
        self.enable = enable
        self.group_id = group_id
        self.lane_id = lane_id
        self.lane_name = lane_name
        self.lane_tag = lane_tag
        self.mse_gateway_entry_rule = mse_gateway_entry_rule
        self.namespace_id = namespace_id

    def validate(self):
        if self.app_entry_rule:
            self.app_entry_rule.validate()
        if self.mse_gateway_entry_rule:
            self.mse_gateway_entry_rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_entry_rule is not None:
            result['AppEntryRule'] = self.app_entry_rule.to_map()
        if self.canary_model is not None:
            result['CanaryModel'] = self.canary_model
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lane_id is not None:
            result['LaneId'] = self.lane_id
        if self.lane_name is not None:
            result['LaneName'] = self.lane_name
        if self.lane_tag is not None:
            result['LaneTag'] = self.lane_tag
        if self.mse_gateway_entry_rule is not None:
            result['MseGatewayEntryRule'] = self.mse_gateway_entry_rule.to_map()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppEntryRule') is not None:
            temp_model = CreateOrUpdateSwimmingLaneRequestAppEntryRule()
            self.app_entry_rule = temp_model.from_map(m['AppEntryRule'])
        if m.get('CanaryModel') is not None:
            self.canary_model = m.get('CanaryModel')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('LaneId') is not None:
            self.lane_id = m.get('LaneId')
        if m.get('LaneName') is not None:
            self.lane_name = m.get('LaneName')
        if m.get('LaneTag') is not None:
            self.lane_tag = m.get('LaneTag')
        if m.get('MseGatewayEntryRule') is not None:
            temp_model = CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRule()
            self.mse_gateway_entry_rule = temp_model.from_map(m['MseGatewayEntryRule'])
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class CreateOrUpdateSwimmingLaneShrinkRequest(TeaModel):
    def __init__(
        self,
        app_entry_rule_shrink: str = None,
        canary_model: int = None,
        enable: bool = None,
        group_id: int = None,
        lane_id: int = None,
        lane_name: str = None,
        lane_tag: str = None,
        mse_gateway_entry_rule_shrink: str = None,
        namespace_id: str = None,
    ):
        self.app_entry_rule_shrink = app_entry_rule_shrink
        self.canary_model = canary_model
        self.enable = enable
        self.group_id = group_id
        self.lane_id = lane_id
        self.lane_name = lane_name
        self.lane_tag = lane_tag
        self.mse_gateway_entry_rule_shrink = mse_gateway_entry_rule_shrink
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_entry_rule_shrink is not None:
            result['AppEntryRule'] = self.app_entry_rule_shrink
        if self.canary_model is not None:
            result['CanaryModel'] = self.canary_model
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lane_id is not None:
            result['LaneId'] = self.lane_id
        if self.lane_name is not None:
            result['LaneName'] = self.lane_name
        if self.lane_tag is not None:
            result['LaneTag'] = self.lane_tag
        if self.mse_gateway_entry_rule_shrink is not None:
            result['MseGatewayEntryRule'] = self.mse_gateway_entry_rule_shrink
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppEntryRule') is not None:
            self.app_entry_rule_shrink = m.get('AppEntryRule')
        if m.get('CanaryModel') is not None:
            self.canary_model = m.get('CanaryModel')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('LaneId') is not None:
            self.lane_id = m.get('LaneId')
        if m.get('LaneName') is not None:
            self.lane_name = m.get('LaneName')
        if m.get('LaneTag') is not None:
            self.lane_tag = m.get('LaneTag')
        if m.get('MseGatewayEntryRule') is not None:
            self.mse_gateway_entry_rule_shrink = m.get('MseGatewayEntryRule')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class CreateOrUpdateSwimmingLaneResponseBodyData(TeaModel):
    def __init__(
        self,
        lane_id: int = None,
    ):
        self.lane_id = lane_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lane_id is not None:
            result['LaneId'] = self.lane_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LaneId') is not None:
            self.lane_id = m.get('LaneId')
        return self


class CreateOrUpdateSwimmingLaneResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateOrUpdateSwimmingLaneResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateOrUpdateSwimmingLaneResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class CreateOrUpdateSwimmingLaneResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOrUpdateSwimmingLaneResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOrUpdateSwimmingLaneResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOrUpdateSwimmingLaneGroupRequest(TeaModel):
    def __init__(
        self,
        app_ids: List[str] = None,
        entry_app_id: str = None,
        entry_app_type: str = None,
        group_id: int = None,
        group_name: str = None,
        namespace_id: str = None,
        swim_version: str = None,
    ):
        self.app_ids = app_ids
        self.entry_app_id = entry_app_id
        self.entry_app_type = entry_app_type
        self.group_id = group_id
        self.group_name = group_name
        self.namespace_id = namespace_id
        self.swim_version = swim_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_ids is not None:
            result['AppIds'] = self.app_ids
        if self.entry_app_id is not None:
            result['EntryAppId'] = self.entry_app_id
        if self.entry_app_type is not None:
            result['EntryAppType'] = self.entry_app_type
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.swim_version is not None:
            result['SwimVersion'] = self.swim_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppIds') is not None:
            self.app_ids = m.get('AppIds')
        if m.get('EntryAppId') is not None:
            self.entry_app_id = m.get('EntryAppId')
        if m.get('EntryAppType') is not None:
            self.entry_app_type = m.get('EntryAppType')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('SwimVersion') is not None:
            self.swim_version = m.get('SwimVersion')
        return self


class CreateOrUpdateSwimmingLaneGroupShrinkRequest(TeaModel):
    def __init__(
        self,
        app_ids_shrink: str = None,
        entry_app_id: str = None,
        entry_app_type: str = None,
        group_id: int = None,
        group_name: str = None,
        namespace_id: str = None,
        swim_version: str = None,
    ):
        self.app_ids_shrink = app_ids_shrink
        self.entry_app_id = entry_app_id
        self.entry_app_type = entry_app_type
        self.group_id = group_id
        self.group_name = group_name
        self.namespace_id = namespace_id
        self.swim_version = swim_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_ids_shrink is not None:
            result['AppIds'] = self.app_ids_shrink
        if self.entry_app_id is not None:
            result['EntryAppId'] = self.entry_app_id
        if self.entry_app_type is not None:
            result['EntryAppType'] = self.entry_app_type
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.swim_version is not None:
            result['SwimVersion'] = self.swim_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppIds') is not None:
            self.app_ids_shrink = m.get('AppIds')
        if m.get('EntryAppId') is not None:
            self.entry_app_id = m.get('EntryAppId')
        if m.get('EntryAppType') is not None:
            self.entry_app_type = m.get('EntryAppType')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('SwimVersion') is not None:
            self.swim_version = m.get('SwimVersion')
        return self


class CreateOrUpdateSwimmingLaneGroupResponseBodyData(TeaModel):
    def __init__(
        self,
        group_id: int = None,
    ):
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class CreateOrUpdateSwimmingLaneGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateOrUpdateSwimmingLaneGroupResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateOrUpdateSwimmingLaneGroupResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class CreateOrUpdateSwimmingLaneGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOrUpdateSwimmingLaneGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOrUpdateSwimmingLaneGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSecretRequestSecretData(TeaModel):
    def __init__(
        self,
        secret_data: str = None,
    ):
        # The information about the key-value pairs of the Secret. This parameter is required. The following formats are supported:
        # 
        # {"Data":"{"k1":"v1", "k2":"v2"}"}
        # 
        # k specifies a key and v specifies a value.
        # 
        # This parameter is required.
        self.secret_data = secret_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.secret_data is not None:
            result['SecretData'] = self.secret_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SecretData') is not None:
            self.secret_data = m.get('SecretData')
        return self


class CreateSecretRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
        secret_data: CreateSecretRequestSecretData = None,
        secret_name: str = None,
        secret_type: str = None,
    ):
        # The ID of the namespace where the Secret resides. If the namespace is the default namespace, you need to only enter the region ID, such as `cn-beijing`.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # The Secret data.
        # 
        # This parameter is required.
        self.secret_data = secret_data
        # This parameter is required.
        self.secret_name = secret_name
        # This parameter is required.
        self.secret_type = secret_type

    def validate(self):
        if self.secret_data:
            self.secret_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.secret_data is not None:
            result['SecretData'] = self.secret_data.to_map()
        if self.secret_name is not None:
            result['SecretName'] = self.secret_name
        if self.secret_type is not None:
            result['SecretType'] = self.secret_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('SecretData') is not None:
            temp_model = CreateSecretRequestSecretData()
            self.secret_data = temp_model.from_map(m['SecretData'])
        if m.get('SecretName') is not None:
            self.secret_name = m.get('SecretName')
        if m.get('SecretType') is not None:
            self.secret_type = m.get('SecretType')
        return self


class CreateSecretShrinkRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
        secret_data_shrink: str = None,
        secret_name: str = None,
        secret_type: str = None,
    ):
        # The ID of the namespace where the Secret resides. If the namespace is the default namespace, you need to only enter the region ID, such as `cn-beijing`.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # The Secret data.
        # 
        # This parameter is required.
        self.secret_data_shrink = secret_data_shrink
        # This parameter is required.
        self.secret_name = secret_name
        # This parameter is required.
        self.secret_type = secret_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.secret_data_shrink is not None:
            result['SecretData'] = self.secret_data_shrink
        if self.secret_name is not None:
            result['SecretName'] = self.secret_name
        if self.secret_type is not None:
            result['SecretType'] = self.secret_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('SecretData') is not None:
            self.secret_data_shrink = m.get('SecretData')
        if m.get('SecretName') is not None:
            self.secret_name = m.get('SecretName')
        if m.get('SecretType') is not None:
            self.secret_type = m.get('SecretType')
        return self


class CreateSecretResponseBodyData(TeaModel):
    def __init__(
        self,
        secret_id: int = None,
    ):
        self.secret_id = secret_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.secret_id is not None:
            result['SecretId'] = self.secret_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SecretId') is not None:
            self.secret_id = m.get('SecretId')
        return self


class CreateSecretResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateSecretResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateSecretResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class CreateSecretResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSecretResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSecretResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateWebApplicationRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
        body: CreateWebApplicationInput = None,
    ):
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # The information about the application.
        # 
        # This parameter is required.
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('body') is not None:
            temp_model = CreateWebApplicationInput()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateWebApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WebApplicationBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WebApplicationBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateWebCustomDomainRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
        body: CreateWebCustomDomainInput = None,
    ):
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # The information about custom domain name.
        # 
        # This parameter is required.
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('body') is not None:
            temp_model = CreateWebCustomDomainInput()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateWebCustomDomainResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WebCustomDomainBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WebCustomDomainBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DeleteApplicationResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order. The ID can be used to query the status of the change task.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class DeleteApplicationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DeleteApplicationResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The request was successful.
        # *   **3xx**: The request was redirected.
        # *   **4xx**: The request failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The result returned.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the request was successful, **ErrorCode** is not returned.
        # *   If the request failed, **ErrorCode** is returned. For more information, see **Error codes** section of this topic.
        self.error_code = error_code
        # The message returned. Valid values:
        # 
        # *   If the request was successful, **success** is returned.
        # *   If the request failed, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the application is deleted. Valid values:
        # 
        # *   **true**: The applications were deleted
        # *   **false**: The applications failed to be deleted.
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DeleteApplicationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteApplicationScalingRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        scaling_rule_name: str = None,
    ):
        # The ID of the request.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the trace. The ID is used to query the details of a request.
        # 
        # This parameter is required.
        self.scaling_rule_name = scaling_rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.scaling_rule_name is not None:
            result['ScalingRuleName'] = self.scaling_rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ScalingRuleName') is not None:
            self.scaling_rule_name = m.get('ScalingRuleName')
        return self


class DeleteApplicationScalingRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The request was successful.
        # *   **3xx**: The request was redirected.
        # *   **4xx**: The request failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The error code. Valid values:
        # 
        # *   If the request was successful, **ErrorCode** is not returned.
        # *   If the request failed, **ErrorCode** is returned. For more information, see **Error codes** section of this topic.
        self.error_code = error_code
        # The message returned. Valid values:
        # 
        # *   If the request was successful, **success** is returned.
        # *   If the request failed, an error code is returned.
        self.message = message
        self.request_id = request_id
        # Indicates whether the auto scaling policy was deleted. Valid values:
        # 
        # *   **true**: The policy was deleted.
        # *   **false**: The policy failed to be deleted.
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteApplicationScalingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteApplicationScalingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteApplicationScalingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteConfigMapRequest(TeaModel):
    def __init__(
        self,
        config_map_id: int = None,
    ):
        # The ID of the ConfigMap that you want to delete. You can call the [ListNamespacedConfigMaps](https://help.aliyun.com/document_detail/176917.html) operation to obtain the ID of a ConfigMap.
        # 
        # This parameter is required.
        self.config_map_id = config_map_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        return self


class DeleteConfigMapResponseBodyData(TeaModel):
    def __init__(
        self,
        config_map_id: int = None,
    ):
        # The ID of the deleted ConfigMap.
        self.config_map_id = config_map_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        return self


class DeleteConfigMapResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DeleteConfigMapResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The returned result.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the ConfigMap was deleted. Valid values:
        # 
        # *   **true**: The ConfigMap was deleted.
        # *   **false**: The ConfigMap failed to be deleted.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DeleteConfigMapResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteConfigMapResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteConfigMapResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteConfigMapResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteGreyTagRouteRequest(TeaModel):
    def __init__(
        self,
        grey_tag_route_id: int = None,
    ):
        # The rule ID.
        # 
        # This parameter is required.
        self.grey_tag_route_id = grey_tag_route_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grey_tag_route_id is not None:
            result['GreyTagRouteId'] = self.grey_tag_route_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GreyTagRouteId') is not None:
            self.grey_tag_route_id = m.get('GreyTagRouteId')
        return self


class DeleteGreyTagRouteResponseBodyData(TeaModel):
    def __init__(
        self,
        grey_tag_route_id: int = None,
    ):
        # The ID of the canary release rule. The ID is globally unique.
        self.grey_tag_route_id = grey_tag_route_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grey_tag_route_id is not None:
            result['GreyTagRouteId'] = self.grey_tag_route_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GreyTagRouteId') is not None:
            self.grey_tag_route_id = m.get('GreyTagRouteId')
        return self


class DeleteGreyTagRouteResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DeleteGreyTagRouteResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The information about the canary release rule.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the information of the change order was queried. Valid values:
        # 
        # *   **true**: The information was queried.
        # *   **false**: The information failed to be queried.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DeleteGreyTagRouteResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteGreyTagRouteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteGreyTagRouteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteGreyTagRouteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteHistoryJobRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        job_id: str = None,
    ):
        # The ID of the job template to which the job that you want to delete belongs.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the job.
        # 
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class DeleteHistoryJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The result returned.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section in this topic.
        self.error_code = error_code
        # The returned information. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the job was deleted. Valid values:
        # 
        # *   **true**: The job was deleted.
        # *   **false**: The job failed to be deleted.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteHistoryJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteHistoryJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteHistoryJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteIngressRequest(TeaModel):
    def __init__(
        self,
        ingress_id: int = None,
    ):
        # The ID of the routing rule that you want to delete. You can call the [ListIngresses](https://help.aliyun.com/document_detail/153934.html) operation to obtain the ID of a routing rule.
        # 
        # This parameter is required.
        self.ingress_id = ingress_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ingress_id is not None:
            result['IngressId'] = self.ingress_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IngressId') is not None:
            self.ingress_id = m.get('IngressId')
        return self


class DeleteIngressResponseBodyData(TeaModel):
    def __init__(
        self,
        ingress_id: int = None,
    ):
        # The ID of the deleted routing rule.
        self.ingress_id = ingress_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ingress_id is not None:
            result['IngressId'] = self.ingress_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IngressId') is not None:
            self.ingress_id = m.get('IngressId')
        return self


class DeleteIngressResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DeleteIngressResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The returned result.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the routing rule was deleted. Valid values:
        # 
        # *   **true**: The routing rule was deleted.
        # *   **false**: The routing rule failed to be deleted.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DeleteIngressResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteIngressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteIngressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteIngressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteInstancesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        instance_ids: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.instance_ids = instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        return self


class DeleteInstancesResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class DeleteInstancesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DeleteInstancesResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DeleteInstancesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteJobRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the job template that you want to delete.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DeleteJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The result returned.
        self.data = data
        # The error code that is returned. Take note of the following rules:
        # 
        # *   The **ErrorCode** parameter is not returned if the request is successful.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The additional information that is returned. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the application is deleted. Valid values:
        # 
        # *   **true**: The namespaces were obtained.
        # *   **false**: no
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteNamespaceRequest(TeaModel):
    def __init__(
        self,
        name_space_short_id: str = None,
        namespace_id: str = None,
    ):
        self.name_space_short_id = name_space_short_id
        # cn-beijing:test
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class DeleteNamespaceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the namespace was deleted. Valid values:
        # 
        # *   **true**: indicates that the namespace was deleted.
        # *   **false**: indicates that the namespace could not be deleted.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteNamespaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteNamespaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteNamespaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSecretRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
        secret_id: int = None,
    ):
        # The ID of the namespace in which the Secret resides. By default, the namespace ID is the same as the region ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # The ID of the Secret to be deleted. You can call the [ListSecrets](https://help.aliyun.com/document_detail/466929.html) operation to view the Secret IDs.
        # 
        # This parameter is required.
        self.secret_id = secret_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.secret_id is not None:
            result['SecretId'] = self.secret_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('SecretId') is not None:
            self.secret_id = m.get('SecretId')
        return self


class DeleteSecretResponseBodyData(TeaModel):
    def __init__(
        self,
        secret_id: int = None,
    ):
        # The ID of the deleted Secret.
        self.secret_id = secret_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.secret_id is not None:
            result['SecretId'] = self.secret_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SecretId') is not None:
            self.secret_id = m.get('SecretId')
        return self


class DeleteSecretResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DeleteSecretResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The response.
        self.data = data
        # The error code returned. Valid values:
        # 
        # *   The **ErrorCode** parameter is not returned if the request succeeds.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The additional information that is returned. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the Secret is successfully deleted. Valid values:
        # 
        # *   **true**: The instance was deleted.
        # *   **false**: The instance failed to be deleted.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DeleteSecretResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteSecretResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSecretResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSecretResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSwimmingLaneGroupRequest(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        namespace_id: str = None,
    ):
        self.group_id = group_id
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class DeleteSwimmingLaneGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteSwimmingLaneGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSwimmingLaneGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSwimmingLaneGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteWebApplicationRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
    ):
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class DeleteWebApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WebApplicationBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WebApplicationBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteWebApplicationRevisionRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
    ):
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class DeleteWebApplicationRevisionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WebApplicationRevisionBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WebApplicationRevisionBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteWebCustomDomainRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
    ):
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class DeleteWebCustomDomainResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WebCustomDomainBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WebCustomDomainBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeployApplicationRequest(TeaModel):
    def __init__(
        self,
        acr_assume_role_arn: str = None,
        acr_instance_id: str = None,
        app_id: str = None,
        associate_eip: bool = None,
        auto_enable_application_scaling_rule: bool = None,
        batch_wait_time: int = None,
        change_order_desc: str = None,
        command: str = None,
        command_args: str = None,
        config_map_mount_desc: str = None,
        cpu: int = None,
        custom_host_alias: str = None,
        custom_image_network_type: str = None,
        deploy: str = None,
        dotnet: str = None,
        edas_container_version: str = None,
        enable_ahas: str = None,
        enable_cpu_burst: bool = None,
        enable_grey_tag_route: bool = None,
        enable_new_arms: bool = None,
        enable_prometheus: bool = None,
        enable_sidecar_resource_isolated: bool = None,
        envs: str = None,
        gpu_config: str = None,
        html: str = None,
        image_pull_secrets: str = None,
        image_url: str = None,
        init_containers_config: List[InitContainerConfig] = None,
        jar_start_args: str = None,
        jar_start_options: str = None,
        jdk: str = None,
        kafka_configs: str = None,
        liveness: str = None,
        memory: int = None,
        micro_registration: str = None,
        micro_registration_config: str = None,
        microservice_engine_config: str = None,
        min_ready_instance_ratio: int = None,
        min_ready_instances: int = None,
        mount_desc: str = None,
        mount_host: str = None,
        nas_configs: str = None,
        nas_id: str = None,
        new_sae_version: str = None,
        oidc_role_name: str = None,
        oss_ak_id: str = None,
        oss_ak_secret: str = None,
        oss_mount_descs: str = None,
        package_type: str = None,
        package_url: str = None,
        package_version: str = None,
        php: str = None,
        php_arms_config_location: str = None,
        php_config: str = None,
        php_config_location: str = None,
        post_start: str = None,
        pre_stop: str = None,
        pvtz_discovery_svc: str = None,
        python: str = None,
        python_modules: str = None,
        readiness: str = None,
        replicas: int = None,
        secret_mount_desc: str = None,
        security_group_id: str = None,
        service_tags: str = None,
        sidecar_containers_config: List[SidecarContainerConfig] = None,
        sls_configs: str = None,
        startup_probe: str = None,
        swimlane_pvtz_discovery_svc: str = None,
        termination_grace_period_seconds: int = None,
        timezone: str = None,
        tomcat_config: str = None,
        update_strategy: str = None,
        v_switch_id: str = None,
        war_start_options: str = None,
        web_container: str = None,
    ):
        # The Alibaba Cloud Resource Name (ARN) required for a RAM role to obtain images across accounts. For more information, see [Grant permissions across Alibaba Cloud accounts by using a RAM role](https://help.aliyun.com/document_detail/223585.html).
        self.acr_assume_role_arn = acr_assume_role_arn
        # The ID of Container Registry Enterprise Edition instance N. This parameter is required when the **ImageUrl** parameter is set to the URL of an image in an ACR Enterprise Edition instance.
        self.acr_instance_id = acr_instance_id
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # Specifies whether to associate an EIP with the node pool. Take note of the following rules:
        # 
        # *   **true**: The EIP is associated with the application instance.
        # *   **false**: The EIP is not associated with the application instance.
        self.associate_eip = associate_eip
        # Specifies whether to automatically enable an auto scaling policy for the application. Take note of the following rules:
        # 
        # *   **true**: turns on Logon-free Sharing
        # *   **false**: turns off Logon-free Sharing
        self.auto_enable_application_scaling_rule = auto_enable_application_scaling_rule
        # The interval between batches during a batch release. Unit: minutes.
        self.batch_wait_time = batch_wait_time
        # The description of the change order.
        self.change_order_desc = change_order_desc
        # The command that is used to start the image. The command must be an existing executable object in the container. Sample statements:
        # 
        #     command:
        #           - echo
        #           - abc
        #           - >
        #           - file0
        # 
        # In this example, the Command parameter is set to `Command="echo", CommandArgs=["abc", ">", "file0"]`.
        self.command = command
        # The parameters of the image startup command. The CommandArgs parameter specifies the parameters that are required for the **Command** parameter. You can specify the name in one of the following formats:
        # 
        # `["a","b"]`
        # 
        # In the preceding example, the CommandArgs parameter is set to `CommandArgs=["abc", ">", "file0"]`. The data type of `["abc", ">", "file0"]` must be an array of strings in the JSON format. This parameter is optional.
        self.command_args = command_args
        # The description of the **ConfigMap** instance mounted to the application. Use configurations created on the Configuration Items page to configure containers. The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **congfigMapId**: the ID of the ConfigMap instance. You can call the [ListNamespacedConfigMaps](https://help.aliyun.com/document_detail/176917.html) operation to obtain the ID.
        # *   **key**: the key.
        # 
        # > You can use `sae-sys-configmap-all` to mount all keys.
        # 
        # *   **mountPath**: the mount path in the container.
        self.config_map_mount_desc = config_map_mount_desc
        # The CPU specifications that are required for each instance. Unit: millicores. This parameter cannot be set to 0. Valid values:
        # 
        # *   **500**\
        # *   **1000**\
        # *   **2000**\
        # *   **4000**\
        # *   **8000**\
        # *   **12000**\
        # *   **16000**\
        # *   **32000**\
        self.cpu = cpu
        # The custom mappings between hostnames and IP addresses in the container. Take note of the following rules:
        # 
        # *   **hostName**: the domain name or hostname.
        # *   **ip**: the IP address.
        self.custom_host_alias = custom_host_alias
        # Custom image type. To it to empty string to use pre-built image.
        # 
        # - internet: Public network image
        # 
        # - intranet: Private network image
        self.custom_image_network_type = custom_image_network_type
        # This parameter takes effect only for applications that are in the Stopped state. If you call the **DeployApplication** operation to manage a running application, the application is immediately redeployed.
        # 
        # *   **true** (default): specifies that the system immediately deploys the application, enables new configurations, and pulls application instances.
        # *   **false**: specifies that the system only enables the new configurations.
        self.deploy = deploy
        # The version of .NET
        # 
        # - .NET 3.1
        # - .NET 5.0
        # - .NET 6.0
        # - .NET 7.0
        # - .NET 8.0
        self.dotnet = dotnet
        # The version of the container, such as Ali-Tomcat, in which an application developed based on High-speed Service Framework (HSF) is deployed.
        self.edas_container_version = edas_container_version
        # Indicates whether access to Application High Availability Service (AHAS) is enabled. Take note of the following rules:
        # 
        # *   **true**: Access to AHAS is enabled.
        # *   **false**: Access to AHAS is disabled.
        self.enable_ahas = enable_ahas
        # Enable CPU Burst.
        # 
        # true: enable
        # 
        # false: disable
        self.enable_cpu_burst = enable_cpu_burst
        # Indicates whether canary release rules are enabled. Canary release rules apply only to applications in Spring Cloud and Dubbo frameworks. Take note of the following rules:
        # 
        # *   **true**: The canary release rules are enabled.
        # *   **false**: The canary release rules are disabled.
        self.enable_grey_tag_route = enable_grey_tag_route
        # Enable new ARMS features.
        # 
        # - true: enable
        # 
        # - false: disable
        self.enable_new_arms = enable_new_arms
        self.enable_prometheus = enable_prometheus
        # Enable Sidecar resource isolation.
        # 
        # true: enable
        # 
        # false: disable
        self.enable_sidecar_resource_isolated = enable_sidecar_resource_isolated
        # The environment variables. You can configure custom environment variables or reference a ConfigMap. If you want to reference a ConfigMap, you must first create a ConfigMap. For more information, see [CreateConfigMap](https://help.aliyun.com/document_detail/176914.html). Take note of the following rules:
        # 
        # *   Customize
        # 
        #     *   **name**: the name of the environment variable.
        #     *   **value**: the value of the environment variable.
        # 
        # *   Reference ConfigMap
        # 
        #     *   **name**: the name of the environment variable. You can reference one or all keys. If you want to reference all keys, specify `sae-sys-configmap-all-<ConfigMap name>`. Example: `sae-sys-configmap-all-test1`.
        #     *   **valueFrom**: the reference of the environment variable. Set the value to `configMapRef`.
        #     *   **configMapId**: the ConfigMap ID.
        #     *   **key**: the key. If you want to reference all keys, do not configure this parameter.
        # 
        # *   Reference secret dictionary
        # 
        #     *   **name**: the name of the environment variable. You can reference one or all keys. If you want to reference all keys, specify `sae-sys-secret-all-<Secret dictionary name>`. Example: `sae-sys-secret-all-test1`.
        #     *   **valueFrom**: the reference of the environment variable. Set the value to `secretRef`.
        #     *   **secretId**: the secret dictionary ID.
        #     *   **key**: the key. If you want to reference all keys, do not configure this parameter.
        self.envs = envs
        self.gpu_config = gpu_config
        self.html = html
        # The ID of the corresponding Secret.
        self.image_pull_secrets = image_pull_secrets
        # The URL of the image. This parameter is returned only if the **PackageType** parameter is set to **Image**.
        self.image_url = image_url
        # Initialize container configuration.
        self.init_containers_config = init_containers_config
        # The arguments in the JAR package. The arguments are used to start the application container. The default startup command is `$JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs`.
        self.jar_start_args = jar_start_args
        # The option settings in the JAR package. The settings are used to start the application container. The default startup command for application deployment is `$JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs`.
        self.jar_start_options = jar_start_options
        # The version of the Java development kit (JDK) on which the deployment package of the application depends. The following versions are supported:
        # 
        # *   **Open JDK 8**\
        # *   **Open JDK 7**\
        # *   **Dragonwell 11**\
        # *   **Dragonwell 8**\
        # *   **openjdk-8u191-jdk-alpine3.9**\
        # *   **openjdk-7u201-jdk-alpine3.9**\
        # 
        # This parameter is not returned if the **PackageType** parameter is set to **Image**.
        self.jdk = jdk
        # The logging configurations of Message Queue for Apache Kafka. Take note of the following rules:
        # 
        # *   **kafkaEndpoint**: the endpoint of the Message Queue for Apache Kafka API.
        # *   **kafkaInstanceId**: the ID of the Message Queue for Apache Kafka instance.
        # *   **kafkaConfigs**: One or more logging configurations of Message Queue for Apache Kafka. For information about sample values and parameters, see the request parameter **KafkaLogfileConfig** in this topic.
        self.kafka_configs = kafka_configs
        # The details of the availability check that was performed on the container. If the container fails this health check multiple times, the system disables and restarts the container. You can use one of the following methods to perform the health check:
        # 
        # *   Example of **exec**: `{"exec":{"command":["sh","-c","cat/home/admin/start.sh"]},"initialDelaySeconds":30,"periodSeconds":30,"timeoutSeconds":2}`
        # *   Sample code of the **httpGet** method: `{"httpGet":{"path":"/","port":18091,"scheme":"HTTP","isContainKeyWord":true,"keyWord":"SAE"},"initialDelaySeconds":11,"periodSeconds":10,"timeoutSeconds":1}`
        # *   Sample code of the **tcpSocket** method: `{"tcpSocket":{"port":18091},"initialDelaySeconds":11,"periodSeconds":10,"timeoutSeconds":1}`
        # 
        # > You can use only one method to perform the health check.
        # 
        # The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **exec.command**: the health check command.
        # *   **httpGet.path**: the request path.
        # *   **httpGet.scheme**: the protocol that is used to perform the health check. Valid values: **HTTP** and **HTTPS**.
        # *   **httpGet.isContainKeyWord**: indicates whether the response contains keywords. Valid values: **true** and **false**. If this field is not returned, the advanced settings are not used.
        # *   **httpGet.keyWord**: the custom keyword. This parameter is available only if the **isContainKeyWord** field is returned.
        # *   **tcpSocket.port**: the port that is used to check the status of TCP connections.
        # *   **initialDelaySeconds**: the delay of the health check. Default value: 10. Unit: seconds.
        # *   **periodSeconds**: the interval at which health checks are performed. Default value: 30. Unit: seconds.
        # *   **timeoutSeconds**: the timeout period of the health check. Default value: 1. Unit: seconds. If you set this parameter to 0 or leave this parameter empty, the timeout period is automatically set to 1 second.
        self.liveness = liveness
        # The memory size that is required by each instance. Unit: MB. This parameter cannot be set to 0. The values of this parameter correspond to the values of the Cpu parameter:
        # 
        # *   This parameter is set to **1024** if the Cpu parameter is set to 500 or 1000.
        # *   This parameter is set to **2048** if the Cpu parameter is set to 500, 1000, or 2000.
        # *   This parameter is set to **4096** if the Cpu parameter is set to 1000, 2000, or 4000.
        # *   This parameter is set to **8192** if the Cpu parameter is set to 2000, 4000, or 8,000.
        # *   This parameter is set to **12288** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **16384** if the Cpu parameter is set to 4000, 8000, or 16000.
        # *   This parameter is set to **24576** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **32768** if the Cpu parameter is set to 16000.
        # *   This parameter is set to **65536** if the Cpu parameter is set to 8000, 16000, or 32000.
        # *   This parameter is set to **131072** if the Cpu parameter is set to 32000.
        self.memory = memory
        # The Nacos registry. Valid values:
        # 
        # *   **0**: SAE built-in Nacos registry
        # *   **1**: self-managed Nacos registry
        # *   **2** : MSE Nacos registry
        self.micro_registration = micro_registration
        # Select the edition of Nacos.
        # 
        # - 0: SAE built-in Nacos. Unable to get the configuration of SAE built-in Nacos.
        # 
        # - 1: Self-built Nacos from users.
        # 
        # - 2: MSE enterprise Nacos.
        self.micro_registration_config = micro_registration_config
        # Configure Microservices Governance
        # 
        # Whether to enable microservices governance (enable):
        # - true: Enable
        # - false: Disable
        # 
        # Configure lossless online/offline deployment (mseLosslessRule):
        # 
        # delayTime: Delay duration (unit: seconds)
        # 
        # enable: Whether to enable lossless deployment
        # 
        # - true: Enable
        # 
        # - false: Disable
        # 
        # notice: Whether to enable notifications
        # 
        # - true: Enable
        # 
        # - false: Disable
        # 
        # warmupTime: Small-traffic warm-up duration (unit: seconds)
        self.microservice_engine_config = microservice_engine_config
        # The percentage of the minimum number of available instances. Take note of the following rules:
        # 
        # *   If you set the value to **-1**, the minimum number of available instances is not determined based on this parameter. Default value: -1.
        # *   If you set the value to a number **from 0 to 100**, the minimum number of available instances is calculated by using the following formula: Current number of instances × (Value of MinReadyInstanceRatio × 100%). The value is the nearest integer rounded up from the calculated result. For example, if the percentage is set to **50**% and five instances are available, the minimum number of available instances is 3.
        # 
        # > When both **MinReadyInstance** and **MinReadyInstanceRatio** are specified and **MinReadyInstanceRatio** is set to a number from 0 to 100, the value of **MinReadyInstanceRatio**** takes precedence. For example, if **MinReadyInstances** is set to **5, and **MinReadyInstanceRatio** is set to **50**, the minimum number of available instances is set to the nearest integer rounded up from the calculated result of the following formula: Current number of instances × **50%**.
        self.min_ready_instance_ratio = min_ready_instance_ratio
        # The minimum number of available instances. Special values:
        # 
        # *   If you set the value to **0**, business interruptions occur when the application is updated.
        # *   If you set the value to \\*\\*-1\\*\\*, the minimum number of available instances is automatically set to a system-recommended value. The value is the nearest integer to which the calculated result of the following formula is rounded up: Current number of instances × 25%. For example, if five instances are available, the minimum number of available instances is calculated by using the following formula: 5 × 25% = 1.25. In this case, the minimum number of available instances is 2.
        # 
        # > Make sure that at least one instance is available during application deployment and rollback to prevent business interruptions.
        self.min_ready_instances = min_ready_instances
        # The configurations for mounting the NAS file system. After the application is created, you may want to call other operations to manage the application. If you do not want to change the NAS configurations in these subsequent operations, you can omit the **MountDesc** parameter in the requests. If you want to unmount the NAS file system, you must set the **MountDesc** values in the subsequent requests to an empty string ("").
        self.mount_desc = mount_desc
        # The mount target of the NAS file system in the VPC where the application is deployed. If you do not need to modify this configuration during the deployment, configure the **MountHost** parameter only in the first request. You do not need to include this parameter in subsequent requests. If you need to remove this configuration, leave the **MountHost** parameter empty in the request.
        self.mount_host = mount_host
        # The configurations of mounting the NAS file system. Take note of the following rules:
        # 
        # *   **mountPath**: the mount path of the container.
        # *   **readOnly**: If you set the value to **false**, the application has the read and write permissions.
        # *   **nasId**: the ID of the NAS file system.
        # *   **mountDomain**: the domain name of the mount target. For more information, see [DescribeMountTargets](https://help.aliyun.com/document_detail/62626.html).
        # *   **nasPath**: the directory in the NAS file system.
        self.nas_configs = nas_configs
        # The ID of the File Storage NAS file system. After the application is created, you may want to call other operations to manage the application. If you do not want to change the NAS configurations in these subsequent operations, you can omit the **NasId** parameter in the requests. If you want to unmount the NAS file system, you must set the **NasId** values in the subsequent requests to an empty string ("").
        self.nas_id = nas_id
        # SAE edition.
        # 
        # - lite: the lightweight edition.
        # 
        # - std: the standard edition.
        # 
        # - pro: the professional edition.
        self.new_sae_version = new_sae_version
        # The name of the RAM role used to authenticate the user identity.
        # 
        # >  You need to create an OpenID Connect (OIDC) identity provider (IdP) and an identity provider (IdP) for role-based single sign-on (SSO) in advance. For more information, see [Creates an OpenID Connect (OIDC) identity provider (IdP)](https://help.aliyun.com/document_detail/2331022.html) and [Creates an identity provider (IdP) for role-based single sign-on (SSO)](https://help.aliyun.com/document_detail/2331016.html).
        self.oidc_role_name = oidc_role_name
        # The AccessKey ID that is used to read data from and write data to Object Storage Service (OSS) buckets.
        self.oss_ak_id = oss_ak_id
        # The AccessKey secret that is used to read data from and write data to OSS buckets.
        self.oss_ak_secret = oss_ak_secret
        # Information of the Object Storage Service (OSS) bucket mounted to the application. The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **bucketName**: the name of the OSS bucket.
        # 
        # *   **bucketPath**: the directory or object in OSS. If the specified directory or object does not exist, an error is returned.
        # 
        # *   **mountPath**: the directory of the container in SAE. If the path already exists, the newly specified path overwrites the previous one. If the path does not exist, it is created.
        # 
        # *   **readOnly**: specifies whether to only allow the container path to read data from the OSS directory. Valid values:
        # 
        #     *   **true**: The container path only has read permission on the OSS directory.
        #     *   **false**: The application has read and write permissions.
        self.oss_mount_descs = oss_mount_descs
        # The package type.
        # 
        # When using Java, FatJar, War and Image are supported.
        # When using Python, PythonZip and Image are supported.
        # When using PHP, the followings are supported:
        # - PhpZip
        # - IMAGE_PHP_5_4
        # - IMAGE_PHP_5_4_ALPINE
        # - IMAGE_PHP_5_5
        # - IMAGE_PHP_5_5_ALPINE
        # - IMAGE_PHP_5_6
        # - IMAGE_PHP_5_6_ALPINE
        # - IMAGE_PHP_7_0
        # - IMAGE_PHP_7_0_ALPINE
        # - IMAGE_PHP_7_1
        # - IMAGE_PHP_7_1_ALPINE
        # - IMAGE_PHP_7_2
        # - IMAGE_PHP_7_2_ALPINE
        # - IMAGE_PHP_7_3
        # - IMAGE_PHP_7_3_ALPINE
        self.package_type = package_type
        # The address of the deployment package. This parameter is required when the **PackageType** parameter is set to **FatJar**, **War**, or **PythonZip**.
        self.package_url = package_url
        # The version of the deployment package. This parameter is required when the **PackageType** parameter is set to **FatJar**, **War**, or **PythonZip**.
        self.package_version = package_version
        # The dependent PHP version of PHP package. Image is not supported.
        self.php = php
        # The path on which the PHP configuration file for application monitoring is mounted. Make sure that the PHP server loads the configuration file. SAE automatically generates the corresponding configuration file. No manual operations are required.
        self.php_arms_config_location = php_arms_config_location
        # The details of the PHP configuration file.
        self.php_config = php_config
        # The path on which the PHP configuration file for application startup is mounted. Make sure that the PHP server uses this configuration file during the startup.
        self.php_config_location = php_config_location
        # The script that is run immediately after the container is started. Example: `{"exec":{"command":["sh","-c","echo hello"\\]}}`
        self.post_start = post_start
        # The script that is run before the container is stopped. Example: `{"exec":{"command":["sh","-c","echo hello"\\]}}`
        self.pre_stop = pre_stop
        # The configurations of Kubernetes Service-based service registration and discovery. Take note of the following rules:
        # 
        # *   **serviceName**: the name of the Alibaba Cloud service. Format: `<Custom content>-<Namespace ID>`. `-<Namespace ID>` is automatically specified based on the namespace in which an application resides and cannot be changed. For example, if you select the default namespace in the China (Beijing) region, `-cn-beijing-default` is automatically specified.
        # *   **namespaceId**: the namespace ID.
        # *   **portAndProtocol**: the port number and protocol. Valid values of the port number: 1 to 65535. Valid values of the protocol: **TCP** and **UDP**.
        # *   **enable**: enables the Kubernetes Service-based registration and discovery feature.
        self.pvtz_discovery_svc = pvtz_discovery_svc
        # The Python environment. Set the value to **PYTHON 3.9.15**.
        self.python = python
        # The configurations for installing custom module dependencies. By default, the dependencies defined by the requirements.txt file in the root directory are installed. If the package does not contain this file and you do not configure custom dependencies in the package, specify the dependencies that you want to install in the text box.
        self.python_modules = python_modules
        # The details of the health check that was performed on the container. If the container fails this health check multiple times, the system disables and restarts the container. Containers that fail health checks cannot receive traffic from Server Load Balancer (SLB) instances. You can use the **exec**, **httpGet**, or **tcpSocket** method to perform health checks. For more information, see the description of the **Liveness** parameter.
        # 
        # > You can use only one method to perform the health check.
        self.readiness = readiness
        # The number of instances.
        self.replicas = replicas
        # Secret Mount Description
        # Use the secret dictionaries created in the Namespace Secret Dictionary page to inject information into containers. Parameter descriptions are as follows:
        # 
        # - secretId: Secret instance ID. Obtain via the ListSecrets interface.
        # 
        # - key: Key-value pair. Note: Set the parameter sae-sys-secret-all to mount all keys.
        # 
        # - mountPath: Mount path.
        self.secret_mount_desc = secret_mount_desc
        # Security group ID.
        self.security_group_id = security_group_id
        # The gray-release tag of the application.
        self.service_tags = service_tags
        # The configuration of the container.
        self.sidecar_containers_config = sidecar_containers_config
        # The logging configurations of Log Service.
        # 
        # *   To use Log Service resources that are automatically created by SAE, set this parameter to `[{"logDir":"","logType":"stdout"},{"logDir":"/tmp/a.log"}]`.
        # *   To use custom Log Service resources, set this parameter to `[{"projectName":"test-sls","logType":"stdout","logDir":"","logstoreName":"sae","logtailName":""},{"projectName":"test","logDir":"/tmp/a.log","logstoreName":"sae","logtailName":""}]`.
        # 
        # The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **projectName**: the name of the Log Service project.
        # *   **logDir**: the path in which logs are stored.
        # *   **logType**: the log type. **stdout**: the standard output log of the container. You can specify only one stdout value for this parameter. If you leave this parameter empty, file logs are collected.
        # *   **logstoreName**: the name of the Logstore in Log Service.
        # *   **logtailName**: the name of the Logtail configuration in Log Service. If you do not configure this parameter, a new Logtail configuration is created.
        # 
        # If you do not need to modify the logging configurations when you deploy the application, configure the **SlsConfigs** parameter only in the first request. You do not need to include this parameter in subsequent requests. If you no longer need to use Log Service, leave the **SlsConfigs** parameter empty in the request.
        # 
        # > A Log Service project that is automatically created by SAE when you create an application is deleted when the application is deleted. Therefore, when you create an application, you cannot select a Log Service project that is automatically created by SAE for log collection.
        self.sls_configs = sls_configs
        # Check Failure: Indicates that the application failed to start. The system will report the exception and automatically restart it.
        # 
        # Note: 
        # 
        # Supports exec, httpGet, and tcpSocket methods. For specific examples, see Liveness Parameters.
        # Only one method can be selected for health checks.
        self.startup_probe = startup_probe
        # Configure K8s Service-based Service Registration/Discovery and Full-Chain Grayscale Capabilities
        # 
        # - enable: Whether to enable full-link grayscale based on K8s Service (set to "true" to enable; set to "false" to disable).
        # 
        # - namespaceId: Namespace ID
        # 
        # - portAndProtocol: Listener port and protocol. Format: {"Port:Protocol Type":"Container Port"}
        # - portProtocols: Define service ports and protocols
        # port: Port
        # protocol: Protocol
        # targetPort: Container port
        # 
        # - pvtzDiscoveryName: Service discovery name
        # 
        # - serviceId: Service ID
        # 
        # - serviceName: Service name
        self.swimlane_pvtz_discovery_svc = swimlane_pvtz_discovery_svc
        # The timeout period for a graceful shutdown. Default value: 30. Unit: seconds. Valid values: 1 to 300.
        self.termination_grace_period_seconds = termination_grace_period_seconds
        # The time zone. Default value: **Asia/Shanghai**.
        self.timezone = timezone
        # The Tomcat configuration. If you want to cancel this configuration, set this parameter to "" or "{}". The following variables are included in the configuration: Take note of the following rules:
        # 
        # *   **port**: the port number. The port number ranges from 1024 to 65535. Though the admin permissions are configured for the container, the root permissions are required to perform operations on ports whose number is smaller than 1024. Enter a value that ranges from 1025 to 65535 because the container has only the admin permissions. If you do not specify this parameter, the default port number 8080 is used.
        # *   **contextPath**: the path. Default value: /. This value indicates the root directory.
        # *   **maxThreads**: the maximum number of connections in the connection pool. Default value: 400.
        # *   **uriEncoding**: the URI encoding scheme in the Tomcat container. Valid values: UTF-8, ISO-8859-1, GBK, and GB2312.************ If you do not specify this parameter, the default value **ISO-8859-1** is used.
        # *   **useBodyEncoding**: specifies whether to use the encoding scheme specified in the request body for URI query parameters. Default value: true.
        self.tomcat_config = tomcat_config
        # The deployment policy. If the minimum number of available instances is 1, the value of the **UpdateStrategy** parameter is an empty string (""). If the minimum number of available instances is greater than 1, the following strategies can be configured:
        # 
        # *   The application is deployed on an instance. The remaining instances are automatically classified into two release batches whose interval is set to 1. In this case, the parameter is set to `{"type":"GrayBatchUpdate","batchUpdate":{"batch":2,"releaseType":"auto","batchWaitTime":1},"grayUpdate":{"gray":1}}`.
        # *   The application is deployed on an instance. The remaining instances are manually classified into two release batches. In this case, the parameter is set to `{"type":"GrayBatchUpdate","batchUpdate":{"batch":2,"releaseType":"manual"},"grayUpdate":{"gray":1}}`.
        # *   All instances are automatically classified into two release batches. The application is deployed on the instances of the two batches in parallel. In this case, the parameter is set to `{"type":"BatchUpdate","batchUpdate":{"batch":2,"releaseType":"auto","batchWaitTime":0}}`
        # 
        # The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **type**: the type of the release policy. Valid values: **GrayBatchUpdate** and **BatchUpdate**.
        # 
        # *   **batchUpdate**: the phased release policy.
        # 
        #     *   **batch**: the number of release batches.
        #     *   **releaseType**: the processing method for the batches. Valid values: **auto** and **manual**.
        #     *   **batchWaitTime**: the interval between release batches. Unit: seconds.
        # 
        # *   **grayUpdate**: the number of release batches in the phased release after a canary release. This parameter is returned only if the **type** parameter is set to **GrayBatchUpdate**.
        self.update_strategy = update_strategy
        # The ID of the vSwitch, where the EIP of the application instances resides. The vSwitch must reside in the VPC above.
        self.v_switch_id = v_switch_id
        # The startup command of the WAR package. For information about how to configure the startup command, see [Configure startup commands](https://help.aliyun.com/document_detail/96677.html).
        self.war_start_options = war_start_options
        # The version of the Tomcat container on which the deployment package depends. Valid values:
        # 
        # *   **apache-tomcat-7.0.91**\
        # *   **apache-tomcat-8.5.42**\
        # 
        # This parameter is not returned if the **PackageType** parameter is set to **Image**.
        self.web_container = web_container

    def validate(self):
        if self.init_containers_config:
            for k in self.init_containers_config:
                if k:
                    k.validate()
        if self.sidecar_containers_config:
            for k in self.sidecar_containers_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acr_assume_role_arn is not None:
            result['AcrAssumeRoleArn'] = self.acr_assume_role_arn
        if self.acr_instance_id is not None:
            result['AcrInstanceId'] = self.acr_instance_id
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.associate_eip is not None:
            result['AssociateEip'] = self.associate_eip
        if self.auto_enable_application_scaling_rule is not None:
            result['AutoEnableApplicationScalingRule'] = self.auto_enable_application_scaling_rule
        if self.batch_wait_time is not None:
            result['BatchWaitTime'] = self.batch_wait_time
        if self.change_order_desc is not None:
            result['ChangeOrderDesc'] = self.change_order_desc
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        if self.config_map_mount_desc is not None:
            result['ConfigMapMountDesc'] = self.config_map_mount_desc
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.custom_host_alias is not None:
            result['CustomHostAlias'] = self.custom_host_alias
        if self.custom_image_network_type is not None:
            result['CustomImageNetworkType'] = self.custom_image_network_type
        if self.deploy is not None:
            result['Deploy'] = self.deploy
        if self.dotnet is not None:
            result['Dotnet'] = self.dotnet
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        if self.enable_ahas is not None:
            result['EnableAhas'] = self.enable_ahas
        if self.enable_cpu_burst is not None:
            result['EnableCpuBurst'] = self.enable_cpu_burst
        if self.enable_grey_tag_route is not None:
            result['EnableGreyTagRoute'] = self.enable_grey_tag_route
        if self.enable_new_arms is not None:
            result['EnableNewArms'] = self.enable_new_arms
        if self.enable_prometheus is not None:
            result['EnablePrometheus'] = self.enable_prometheus
        if self.enable_sidecar_resource_isolated is not None:
            result['EnableSidecarResourceIsolated'] = self.enable_sidecar_resource_isolated
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.gpu_config is not None:
            result['GpuConfig'] = self.gpu_config
        if self.html is not None:
            result['Html'] = self.html
        if self.image_pull_secrets is not None:
            result['ImagePullSecrets'] = self.image_pull_secrets
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        result['InitContainersConfig'] = []
        if self.init_containers_config is not None:
            for k in self.init_containers_config:
                result['InitContainersConfig'].append(k.to_map() if k else None)
        if self.jar_start_args is not None:
            result['JarStartArgs'] = self.jar_start_args
        if self.jar_start_options is not None:
            result['JarStartOptions'] = self.jar_start_options
        if self.jdk is not None:
            result['Jdk'] = self.jdk
        if self.kafka_configs is not None:
            result['KafkaConfigs'] = self.kafka_configs
        if self.liveness is not None:
            result['Liveness'] = self.liveness
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.micro_registration is not None:
            result['MicroRegistration'] = self.micro_registration
        if self.micro_registration_config is not None:
            result['MicroRegistrationConfig'] = self.micro_registration_config
        if self.microservice_engine_config is not None:
            result['MicroserviceEngineConfig'] = self.microservice_engine_config
        if self.min_ready_instance_ratio is not None:
            result['MinReadyInstanceRatio'] = self.min_ready_instance_ratio
        if self.min_ready_instances is not None:
            result['MinReadyInstances'] = self.min_ready_instances
        if self.mount_desc is not None:
            result['MountDesc'] = self.mount_desc
        if self.mount_host is not None:
            result['MountHost'] = self.mount_host
        if self.nas_configs is not None:
            result['NasConfigs'] = self.nas_configs
        if self.nas_id is not None:
            result['NasId'] = self.nas_id
        if self.new_sae_version is not None:
            result['NewSaeVersion'] = self.new_sae_version
        if self.oidc_role_name is not None:
            result['OidcRoleName'] = self.oidc_role_name
        if self.oss_ak_id is not None:
            result['OssAkId'] = self.oss_ak_id
        if self.oss_ak_secret is not None:
            result['OssAkSecret'] = self.oss_ak_secret
        if self.oss_mount_descs is not None:
            result['OssMountDescs'] = self.oss_mount_descs
        if self.package_type is not None:
            result['PackageType'] = self.package_type
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.php is not None:
            result['Php'] = self.php
        if self.php_arms_config_location is not None:
            result['PhpArmsConfigLocation'] = self.php_arms_config_location
        if self.php_config is not None:
            result['PhpConfig'] = self.php_config
        if self.php_config_location is not None:
            result['PhpConfigLocation'] = self.php_config_location
        if self.post_start is not None:
            result['PostStart'] = self.post_start
        if self.pre_stop is not None:
            result['PreStop'] = self.pre_stop
        if self.pvtz_discovery_svc is not None:
            result['PvtzDiscoverySvc'] = self.pvtz_discovery_svc
        if self.python is not None:
            result['Python'] = self.python
        if self.python_modules is not None:
            result['PythonModules'] = self.python_modules
        if self.readiness is not None:
            result['Readiness'] = self.readiness
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.secret_mount_desc is not None:
            result['SecretMountDesc'] = self.secret_mount_desc
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.service_tags is not None:
            result['ServiceTags'] = self.service_tags
        result['SidecarContainersConfig'] = []
        if self.sidecar_containers_config is not None:
            for k in self.sidecar_containers_config:
                result['SidecarContainersConfig'].append(k.to_map() if k else None)
        if self.sls_configs is not None:
            result['SlsConfigs'] = self.sls_configs
        if self.startup_probe is not None:
            result['StartupProbe'] = self.startup_probe
        if self.swimlane_pvtz_discovery_svc is not None:
            result['SwimlanePvtzDiscoverySvc'] = self.swimlane_pvtz_discovery_svc
        if self.termination_grace_period_seconds is not None:
            result['TerminationGracePeriodSeconds'] = self.termination_grace_period_seconds
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.tomcat_config is not None:
            result['TomcatConfig'] = self.tomcat_config
        if self.update_strategy is not None:
            result['UpdateStrategy'] = self.update_strategy
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.war_start_options is not None:
            result['WarStartOptions'] = self.war_start_options
        if self.web_container is not None:
            result['WebContainer'] = self.web_container
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcrAssumeRoleArn') is not None:
            self.acr_assume_role_arn = m.get('AcrAssumeRoleArn')
        if m.get('AcrInstanceId') is not None:
            self.acr_instance_id = m.get('AcrInstanceId')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AssociateEip') is not None:
            self.associate_eip = m.get('AssociateEip')
        if m.get('AutoEnableApplicationScalingRule') is not None:
            self.auto_enable_application_scaling_rule = m.get('AutoEnableApplicationScalingRule')
        if m.get('BatchWaitTime') is not None:
            self.batch_wait_time = m.get('BatchWaitTime')
        if m.get('ChangeOrderDesc') is not None:
            self.change_order_desc = m.get('ChangeOrderDesc')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        if m.get('ConfigMapMountDesc') is not None:
            self.config_map_mount_desc = m.get('ConfigMapMountDesc')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CustomHostAlias') is not None:
            self.custom_host_alias = m.get('CustomHostAlias')
        if m.get('CustomImageNetworkType') is not None:
            self.custom_image_network_type = m.get('CustomImageNetworkType')
        if m.get('Deploy') is not None:
            self.deploy = m.get('Deploy')
        if m.get('Dotnet') is not None:
            self.dotnet = m.get('Dotnet')
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        if m.get('EnableAhas') is not None:
            self.enable_ahas = m.get('EnableAhas')
        if m.get('EnableCpuBurst') is not None:
            self.enable_cpu_burst = m.get('EnableCpuBurst')
        if m.get('EnableGreyTagRoute') is not None:
            self.enable_grey_tag_route = m.get('EnableGreyTagRoute')
        if m.get('EnableNewArms') is not None:
            self.enable_new_arms = m.get('EnableNewArms')
        if m.get('EnablePrometheus') is not None:
            self.enable_prometheus = m.get('EnablePrometheus')
        if m.get('EnableSidecarResourceIsolated') is not None:
            self.enable_sidecar_resource_isolated = m.get('EnableSidecarResourceIsolated')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('GpuConfig') is not None:
            self.gpu_config = m.get('GpuConfig')
        if m.get('Html') is not None:
            self.html = m.get('Html')
        if m.get('ImagePullSecrets') is not None:
            self.image_pull_secrets = m.get('ImagePullSecrets')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        self.init_containers_config = []
        if m.get('InitContainersConfig') is not None:
            for k in m.get('InitContainersConfig'):
                temp_model = InitContainerConfig()
                self.init_containers_config.append(temp_model.from_map(k))
        if m.get('JarStartArgs') is not None:
            self.jar_start_args = m.get('JarStartArgs')
        if m.get('JarStartOptions') is not None:
            self.jar_start_options = m.get('JarStartOptions')
        if m.get('Jdk') is not None:
            self.jdk = m.get('Jdk')
        if m.get('KafkaConfigs') is not None:
            self.kafka_configs = m.get('KafkaConfigs')
        if m.get('Liveness') is not None:
            self.liveness = m.get('Liveness')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('MicroRegistration') is not None:
            self.micro_registration = m.get('MicroRegistration')
        if m.get('MicroRegistrationConfig') is not None:
            self.micro_registration_config = m.get('MicroRegistrationConfig')
        if m.get('MicroserviceEngineConfig') is not None:
            self.microservice_engine_config = m.get('MicroserviceEngineConfig')
        if m.get('MinReadyInstanceRatio') is not None:
            self.min_ready_instance_ratio = m.get('MinReadyInstanceRatio')
        if m.get('MinReadyInstances') is not None:
            self.min_ready_instances = m.get('MinReadyInstances')
        if m.get('MountDesc') is not None:
            self.mount_desc = m.get('MountDesc')
        if m.get('MountHost') is not None:
            self.mount_host = m.get('MountHost')
        if m.get('NasConfigs') is not None:
            self.nas_configs = m.get('NasConfigs')
        if m.get('NasId') is not None:
            self.nas_id = m.get('NasId')
        if m.get('NewSaeVersion') is not None:
            self.new_sae_version = m.get('NewSaeVersion')
        if m.get('OidcRoleName') is not None:
            self.oidc_role_name = m.get('OidcRoleName')
        if m.get('OssAkId') is not None:
            self.oss_ak_id = m.get('OssAkId')
        if m.get('OssAkSecret') is not None:
            self.oss_ak_secret = m.get('OssAkSecret')
        if m.get('OssMountDescs') is not None:
            self.oss_mount_descs = m.get('OssMountDescs')
        if m.get('PackageType') is not None:
            self.package_type = m.get('PackageType')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('Php') is not None:
            self.php = m.get('Php')
        if m.get('PhpArmsConfigLocation') is not None:
            self.php_arms_config_location = m.get('PhpArmsConfigLocation')
        if m.get('PhpConfig') is not None:
            self.php_config = m.get('PhpConfig')
        if m.get('PhpConfigLocation') is not None:
            self.php_config_location = m.get('PhpConfigLocation')
        if m.get('PostStart') is not None:
            self.post_start = m.get('PostStart')
        if m.get('PreStop') is not None:
            self.pre_stop = m.get('PreStop')
        if m.get('PvtzDiscoverySvc') is not None:
            self.pvtz_discovery_svc = m.get('PvtzDiscoverySvc')
        if m.get('Python') is not None:
            self.python = m.get('Python')
        if m.get('PythonModules') is not None:
            self.python_modules = m.get('PythonModules')
        if m.get('Readiness') is not None:
            self.readiness = m.get('Readiness')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('SecretMountDesc') is not None:
            self.secret_mount_desc = m.get('SecretMountDesc')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('ServiceTags') is not None:
            self.service_tags = m.get('ServiceTags')
        self.sidecar_containers_config = []
        if m.get('SidecarContainersConfig') is not None:
            for k in m.get('SidecarContainersConfig'):
                temp_model = SidecarContainerConfig()
                self.sidecar_containers_config.append(temp_model.from_map(k))
        if m.get('SlsConfigs') is not None:
            self.sls_configs = m.get('SlsConfigs')
        if m.get('StartupProbe') is not None:
            self.startup_probe = m.get('StartupProbe')
        if m.get('SwimlanePvtzDiscoverySvc') is not None:
            self.swimlane_pvtz_discovery_svc = m.get('SwimlanePvtzDiscoverySvc')
        if m.get('TerminationGracePeriodSeconds') is not None:
            self.termination_grace_period_seconds = m.get('TerminationGracePeriodSeconds')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('TomcatConfig') is not None:
            self.tomcat_config = m.get('TomcatConfig')
        if m.get('UpdateStrategy') is not None:
            self.update_strategy = m.get('UpdateStrategy')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('WarStartOptions') is not None:
            self.war_start_options = m.get('WarStartOptions')
        if m.get('WebContainer') is not None:
            self.web_container = m.get('WebContainer')
        return self


class DeployApplicationShrinkRequest(TeaModel):
    def __init__(
        self,
        acr_assume_role_arn: str = None,
        acr_instance_id: str = None,
        app_id: str = None,
        associate_eip: bool = None,
        auto_enable_application_scaling_rule: bool = None,
        batch_wait_time: int = None,
        change_order_desc: str = None,
        command: str = None,
        command_args: str = None,
        config_map_mount_desc: str = None,
        cpu: int = None,
        custom_host_alias: str = None,
        custom_image_network_type: str = None,
        deploy: str = None,
        dotnet: str = None,
        edas_container_version: str = None,
        enable_ahas: str = None,
        enable_cpu_burst: bool = None,
        enable_grey_tag_route: bool = None,
        enable_new_arms: bool = None,
        enable_prometheus: bool = None,
        enable_sidecar_resource_isolated: bool = None,
        envs: str = None,
        gpu_config: str = None,
        html: str = None,
        image_pull_secrets: str = None,
        image_url: str = None,
        init_containers_config_shrink: str = None,
        jar_start_args: str = None,
        jar_start_options: str = None,
        jdk: str = None,
        kafka_configs: str = None,
        liveness: str = None,
        memory: int = None,
        micro_registration: str = None,
        micro_registration_config: str = None,
        microservice_engine_config: str = None,
        min_ready_instance_ratio: int = None,
        min_ready_instances: int = None,
        mount_desc: str = None,
        mount_host: str = None,
        nas_configs: str = None,
        nas_id: str = None,
        new_sae_version: str = None,
        oidc_role_name: str = None,
        oss_ak_id: str = None,
        oss_ak_secret: str = None,
        oss_mount_descs: str = None,
        package_type: str = None,
        package_url: str = None,
        package_version: str = None,
        php: str = None,
        php_arms_config_location: str = None,
        php_config: str = None,
        php_config_location: str = None,
        post_start: str = None,
        pre_stop: str = None,
        pvtz_discovery_svc: str = None,
        python: str = None,
        python_modules: str = None,
        readiness: str = None,
        replicas: int = None,
        secret_mount_desc: str = None,
        security_group_id: str = None,
        service_tags: str = None,
        sidecar_containers_config_shrink: str = None,
        sls_configs: str = None,
        startup_probe: str = None,
        swimlane_pvtz_discovery_svc: str = None,
        termination_grace_period_seconds: int = None,
        timezone: str = None,
        tomcat_config: str = None,
        update_strategy: str = None,
        v_switch_id: str = None,
        war_start_options: str = None,
        web_container: str = None,
    ):
        # The Alibaba Cloud Resource Name (ARN) required for a RAM role to obtain images across accounts. For more information, see [Grant permissions across Alibaba Cloud accounts by using a RAM role](https://help.aliyun.com/document_detail/223585.html).
        self.acr_assume_role_arn = acr_assume_role_arn
        # The ID of Container Registry Enterprise Edition instance N. This parameter is required when the **ImageUrl** parameter is set to the URL of an image in an ACR Enterprise Edition instance.
        self.acr_instance_id = acr_instance_id
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # Specifies whether to associate an EIP with the node pool. Take note of the following rules:
        # 
        # *   **true**: The EIP is associated with the application instance.
        # *   **false**: The EIP is not associated with the application instance.
        self.associate_eip = associate_eip
        # Specifies whether to automatically enable an auto scaling policy for the application. Take note of the following rules:
        # 
        # *   **true**: turns on Logon-free Sharing
        # *   **false**: turns off Logon-free Sharing
        self.auto_enable_application_scaling_rule = auto_enable_application_scaling_rule
        # The interval between batches during a batch release. Unit: minutes.
        self.batch_wait_time = batch_wait_time
        # The description of the change order.
        self.change_order_desc = change_order_desc
        # The command that is used to start the image. The command must be an existing executable object in the container. Sample statements:
        # 
        #     command:
        #           - echo
        #           - abc
        #           - >
        #           - file0
        # 
        # In this example, the Command parameter is set to `Command="echo", CommandArgs=["abc", ">", "file0"]`.
        self.command = command
        # The parameters of the image startup command. The CommandArgs parameter specifies the parameters that are required for the **Command** parameter. You can specify the name in one of the following formats:
        # 
        # `["a","b"]`
        # 
        # In the preceding example, the CommandArgs parameter is set to `CommandArgs=["abc", ">", "file0"]`. The data type of `["abc", ">", "file0"]` must be an array of strings in the JSON format. This parameter is optional.
        self.command_args = command_args
        # The description of the **ConfigMap** instance mounted to the application. Use configurations created on the Configuration Items page to configure containers. The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **congfigMapId**: the ID of the ConfigMap instance. You can call the [ListNamespacedConfigMaps](https://help.aliyun.com/document_detail/176917.html) operation to obtain the ID.
        # *   **key**: the key.
        # 
        # > You can use `sae-sys-configmap-all` to mount all keys.
        # 
        # *   **mountPath**: the mount path in the container.
        self.config_map_mount_desc = config_map_mount_desc
        # The CPU specifications that are required for each instance. Unit: millicores. This parameter cannot be set to 0. Valid values:
        # 
        # *   **500**\
        # *   **1000**\
        # *   **2000**\
        # *   **4000**\
        # *   **8000**\
        # *   **12000**\
        # *   **16000**\
        # *   **32000**\
        self.cpu = cpu
        # The custom mappings between hostnames and IP addresses in the container. Take note of the following rules:
        # 
        # *   **hostName**: the domain name or hostname.
        # *   **ip**: the IP address.
        self.custom_host_alias = custom_host_alias
        # Custom image type. To it to empty string to use pre-built image.
        # 
        # - internet: Public network image
        # 
        # - intranet: Private network image
        self.custom_image_network_type = custom_image_network_type
        # This parameter takes effect only for applications that are in the Stopped state. If you call the **DeployApplication** operation to manage a running application, the application is immediately redeployed.
        # 
        # *   **true** (default): specifies that the system immediately deploys the application, enables new configurations, and pulls application instances.
        # *   **false**: specifies that the system only enables the new configurations.
        self.deploy = deploy
        # The version of .NET
        # 
        # - .NET 3.1
        # - .NET 5.0
        # - .NET 6.0
        # - .NET 7.0
        # - .NET 8.0
        self.dotnet = dotnet
        # The version of the container, such as Ali-Tomcat, in which an application developed based on High-speed Service Framework (HSF) is deployed.
        self.edas_container_version = edas_container_version
        # Indicates whether access to Application High Availability Service (AHAS) is enabled. Take note of the following rules:
        # 
        # *   **true**: Access to AHAS is enabled.
        # *   **false**: Access to AHAS is disabled.
        self.enable_ahas = enable_ahas
        # Enable CPU Burst.
        # 
        # true: enable
        # 
        # false: disable
        self.enable_cpu_burst = enable_cpu_burst
        # Indicates whether canary release rules are enabled. Canary release rules apply only to applications in Spring Cloud and Dubbo frameworks. Take note of the following rules:
        # 
        # *   **true**: The canary release rules are enabled.
        # *   **false**: The canary release rules are disabled.
        self.enable_grey_tag_route = enable_grey_tag_route
        # Enable new ARMS features.
        # 
        # - true: enable
        # 
        # - false: disable
        self.enable_new_arms = enable_new_arms
        self.enable_prometheus = enable_prometheus
        # Enable Sidecar resource isolation.
        # 
        # true: enable
        # 
        # false: disable
        self.enable_sidecar_resource_isolated = enable_sidecar_resource_isolated
        # The environment variables. You can configure custom environment variables or reference a ConfigMap. If you want to reference a ConfigMap, you must first create a ConfigMap. For more information, see [CreateConfigMap](https://help.aliyun.com/document_detail/176914.html). Take note of the following rules:
        # 
        # *   Customize
        # 
        #     *   **name**: the name of the environment variable.
        #     *   **value**: the value of the environment variable.
        # 
        # *   Reference ConfigMap
        # 
        #     *   **name**: the name of the environment variable. You can reference one or all keys. If you want to reference all keys, specify `sae-sys-configmap-all-<ConfigMap name>`. Example: `sae-sys-configmap-all-test1`.
        #     *   **valueFrom**: the reference of the environment variable. Set the value to `configMapRef`.
        #     *   **configMapId**: the ConfigMap ID.
        #     *   **key**: the key. If you want to reference all keys, do not configure this parameter.
        # 
        # *   Reference secret dictionary
        # 
        #     *   **name**: the name of the environment variable. You can reference one or all keys. If you want to reference all keys, specify `sae-sys-secret-all-<Secret dictionary name>`. Example: `sae-sys-secret-all-test1`.
        #     *   **valueFrom**: the reference of the environment variable. Set the value to `secretRef`.
        #     *   **secretId**: the secret dictionary ID.
        #     *   **key**: the key. If you want to reference all keys, do not configure this parameter.
        self.envs = envs
        self.gpu_config = gpu_config
        self.html = html
        # The ID of the corresponding Secret.
        self.image_pull_secrets = image_pull_secrets
        # The URL of the image. This parameter is returned only if the **PackageType** parameter is set to **Image**.
        self.image_url = image_url
        # Initialize container configuration.
        self.init_containers_config_shrink = init_containers_config_shrink
        # The arguments in the JAR package. The arguments are used to start the application container. The default startup command is `$JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs`.
        self.jar_start_args = jar_start_args
        # The option settings in the JAR package. The settings are used to start the application container. The default startup command for application deployment is `$JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs`.
        self.jar_start_options = jar_start_options
        # The version of the Java development kit (JDK) on which the deployment package of the application depends. The following versions are supported:
        # 
        # *   **Open JDK 8**\
        # *   **Open JDK 7**\
        # *   **Dragonwell 11**\
        # *   **Dragonwell 8**\
        # *   **openjdk-8u191-jdk-alpine3.9**\
        # *   **openjdk-7u201-jdk-alpine3.9**\
        # 
        # This parameter is not returned if the **PackageType** parameter is set to **Image**.
        self.jdk = jdk
        # The logging configurations of Message Queue for Apache Kafka. Take note of the following rules:
        # 
        # *   **kafkaEndpoint**: the endpoint of the Message Queue for Apache Kafka API.
        # *   **kafkaInstanceId**: the ID of the Message Queue for Apache Kafka instance.
        # *   **kafkaConfigs**: One or more logging configurations of Message Queue for Apache Kafka. For information about sample values and parameters, see the request parameter **KafkaLogfileConfig** in this topic.
        self.kafka_configs = kafka_configs
        # The details of the availability check that was performed on the container. If the container fails this health check multiple times, the system disables and restarts the container. You can use one of the following methods to perform the health check:
        # 
        # *   Example of **exec**: `{"exec":{"command":["sh","-c","cat/home/admin/start.sh"]},"initialDelaySeconds":30,"periodSeconds":30,"timeoutSeconds":2}`
        # *   Sample code of the **httpGet** method: `{"httpGet":{"path":"/","port":18091,"scheme":"HTTP","isContainKeyWord":true,"keyWord":"SAE"},"initialDelaySeconds":11,"periodSeconds":10,"timeoutSeconds":1}`
        # *   Sample code of the **tcpSocket** method: `{"tcpSocket":{"port":18091},"initialDelaySeconds":11,"periodSeconds":10,"timeoutSeconds":1}`
        # 
        # > You can use only one method to perform the health check.
        # 
        # The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **exec.command**: the health check command.
        # *   **httpGet.path**: the request path.
        # *   **httpGet.scheme**: the protocol that is used to perform the health check. Valid values: **HTTP** and **HTTPS**.
        # *   **httpGet.isContainKeyWord**: indicates whether the response contains keywords. Valid values: **true** and **false**. If this field is not returned, the advanced settings are not used.
        # *   **httpGet.keyWord**: the custom keyword. This parameter is available only if the **isContainKeyWord** field is returned.
        # *   **tcpSocket.port**: the port that is used to check the status of TCP connections.
        # *   **initialDelaySeconds**: the delay of the health check. Default value: 10. Unit: seconds.
        # *   **periodSeconds**: the interval at which health checks are performed. Default value: 30. Unit: seconds.
        # *   **timeoutSeconds**: the timeout period of the health check. Default value: 1. Unit: seconds. If you set this parameter to 0 or leave this parameter empty, the timeout period is automatically set to 1 second.
        self.liveness = liveness
        # The memory size that is required by each instance. Unit: MB. This parameter cannot be set to 0. The values of this parameter correspond to the values of the Cpu parameter:
        # 
        # *   This parameter is set to **1024** if the Cpu parameter is set to 500 or 1000.
        # *   This parameter is set to **2048** if the Cpu parameter is set to 500, 1000, or 2000.
        # *   This parameter is set to **4096** if the Cpu parameter is set to 1000, 2000, or 4000.
        # *   This parameter is set to **8192** if the Cpu parameter is set to 2000, 4000, or 8,000.
        # *   This parameter is set to **12288** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **16384** if the Cpu parameter is set to 4000, 8000, or 16000.
        # *   This parameter is set to **24576** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **32768** if the Cpu parameter is set to 16000.
        # *   This parameter is set to **65536** if the Cpu parameter is set to 8000, 16000, or 32000.
        # *   This parameter is set to **131072** if the Cpu parameter is set to 32000.
        self.memory = memory
        # The Nacos registry. Valid values:
        # 
        # *   **0**: SAE built-in Nacos registry
        # *   **1**: self-managed Nacos registry
        # *   **2** : MSE Nacos registry
        self.micro_registration = micro_registration
        # Select the edition of Nacos.
        # 
        # - 0: SAE built-in Nacos. Unable to get the configuration of SAE built-in Nacos.
        # 
        # - 1: Self-built Nacos from users.
        # 
        # - 2: MSE enterprise Nacos.
        self.micro_registration_config = micro_registration_config
        # Configure Microservices Governance
        # 
        # Whether to enable microservices governance (enable):
        # - true: Enable
        # - false: Disable
        # 
        # Configure lossless online/offline deployment (mseLosslessRule):
        # 
        # delayTime: Delay duration (unit: seconds)
        # 
        # enable: Whether to enable lossless deployment
        # 
        # - true: Enable
        # 
        # - false: Disable
        # 
        # notice: Whether to enable notifications
        # 
        # - true: Enable
        # 
        # - false: Disable
        # 
        # warmupTime: Small-traffic warm-up duration (unit: seconds)
        self.microservice_engine_config = microservice_engine_config
        # The percentage of the minimum number of available instances. Take note of the following rules:
        # 
        # *   If you set the value to **-1**, the minimum number of available instances is not determined based on this parameter. Default value: -1.
        # *   If you set the value to a number **from 0 to 100**, the minimum number of available instances is calculated by using the following formula: Current number of instances × (Value of MinReadyInstanceRatio × 100%). The value is the nearest integer rounded up from the calculated result. For example, if the percentage is set to **50**% and five instances are available, the minimum number of available instances is 3.
        # 
        # > When both **MinReadyInstance** and **MinReadyInstanceRatio** are specified and **MinReadyInstanceRatio** is set to a number from 0 to 100, the value of **MinReadyInstanceRatio**** takes precedence. For example, if **MinReadyInstances** is set to **5, and **MinReadyInstanceRatio** is set to **50**, the minimum number of available instances is set to the nearest integer rounded up from the calculated result of the following formula: Current number of instances × **50%**.
        self.min_ready_instance_ratio = min_ready_instance_ratio
        # The minimum number of available instances. Special values:
        # 
        # *   If you set the value to **0**, business interruptions occur when the application is updated.
        # *   If you set the value to \\*\\*-1\\*\\*, the minimum number of available instances is automatically set to a system-recommended value. The value is the nearest integer to which the calculated result of the following formula is rounded up: Current number of instances × 25%. For example, if five instances are available, the minimum number of available instances is calculated by using the following formula: 5 × 25% = 1.25. In this case, the minimum number of available instances is 2.
        # 
        # > Make sure that at least one instance is available during application deployment and rollback to prevent business interruptions.
        self.min_ready_instances = min_ready_instances
        # The configurations for mounting the NAS file system. After the application is created, you may want to call other operations to manage the application. If you do not want to change the NAS configurations in these subsequent operations, you can omit the **MountDesc** parameter in the requests. If you want to unmount the NAS file system, you must set the **MountDesc** values in the subsequent requests to an empty string ("").
        self.mount_desc = mount_desc
        # The mount target of the NAS file system in the VPC where the application is deployed. If you do not need to modify this configuration during the deployment, configure the **MountHost** parameter only in the first request. You do not need to include this parameter in subsequent requests. If you need to remove this configuration, leave the **MountHost** parameter empty in the request.
        self.mount_host = mount_host
        # The configurations of mounting the NAS file system. Take note of the following rules:
        # 
        # *   **mountPath**: the mount path of the container.
        # *   **readOnly**: If you set the value to **false**, the application has the read and write permissions.
        # *   **nasId**: the ID of the NAS file system.
        # *   **mountDomain**: the domain name of the mount target. For more information, see [DescribeMountTargets](https://help.aliyun.com/document_detail/62626.html).
        # *   **nasPath**: the directory in the NAS file system.
        self.nas_configs = nas_configs
        # The ID of the File Storage NAS file system. After the application is created, you may want to call other operations to manage the application. If you do not want to change the NAS configurations in these subsequent operations, you can omit the **NasId** parameter in the requests. If you want to unmount the NAS file system, you must set the **NasId** values in the subsequent requests to an empty string ("").
        self.nas_id = nas_id
        # SAE edition.
        # 
        # - lite: the lightweight edition.
        # 
        # - std: the standard edition.
        # 
        # - pro: the professional edition.
        self.new_sae_version = new_sae_version
        # The name of the RAM role used to authenticate the user identity.
        # 
        # >  You need to create an OpenID Connect (OIDC) identity provider (IdP) and an identity provider (IdP) for role-based single sign-on (SSO) in advance. For more information, see [Creates an OpenID Connect (OIDC) identity provider (IdP)](https://help.aliyun.com/document_detail/2331022.html) and [Creates an identity provider (IdP) for role-based single sign-on (SSO)](https://help.aliyun.com/document_detail/2331016.html).
        self.oidc_role_name = oidc_role_name
        # The AccessKey ID that is used to read data from and write data to Object Storage Service (OSS) buckets.
        self.oss_ak_id = oss_ak_id
        # The AccessKey secret that is used to read data from and write data to OSS buckets.
        self.oss_ak_secret = oss_ak_secret
        # Information of the Object Storage Service (OSS) bucket mounted to the application. The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **bucketName**: the name of the OSS bucket.
        # 
        # *   **bucketPath**: the directory or object in OSS. If the specified directory or object does not exist, an error is returned.
        # 
        # *   **mountPath**: the directory of the container in SAE. If the path already exists, the newly specified path overwrites the previous one. If the path does not exist, it is created.
        # 
        # *   **readOnly**: specifies whether to only allow the container path to read data from the OSS directory. Valid values:
        # 
        #     *   **true**: The container path only has read permission on the OSS directory.
        #     *   **false**: The application has read and write permissions.
        self.oss_mount_descs = oss_mount_descs
        # The package type.
        # 
        # When using Java, FatJar, War and Image are supported.
        # When using Python, PythonZip and Image are supported.
        # When using PHP, the followings are supported:
        # - PhpZip
        # - IMAGE_PHP_5_4
        # - IMAGE_PHP_5_4_ALPINE
        # - IMAGE_PHP_5_5
        # - IMAGE_PHP_5_5_ALPINE
        # - IMAGE_PHP_5_6
        # - IMAGE_PHP_5_6_ALPINE
        # - IMAGE_PHP_7_0
        # - IMAGE_PHP_7_0_ALPINE
        # - IMAGE_PHP_7_1
        # - IMAGE_PHP_7_1_ALPINE
        # - IMAGE_PHP_7_2
        # - IMAGE_PHP_7_2_ALPINE
        # - IMAGE_PHP_7_3
        # - IMAGE_PHP_7_3_ALPINE
        self.package_type = package_type
        # The address of the deployment package. This parameter is required when the **PackageType** parameter is set to **FatJar**, **War**, or **PythonZip**.
        self.package_url = package_url
        # The version of the deployment package. This parameter is required when the **PackageType** parameter is set to **FatJar**, **War**, or **PythonZip**.
        self.package_version = package_version
        # The dependent PHP version of PHP package. Image is not supported.
        self.php = php
        # The path on which the PHP configuration file for application monitoring is mounted. Make sure that the PHP server loads the configuration file. SAE automatically generates the corresponding configuration file. No manual operations are required.
        self.php_arms_config_location = php_arms_config_location
        # The details of the PHP configuration file.
        self.php_config = php_config
        # The path on which the PHP configuration file for application startup is mounted. Make sure that the PHP server uses this configuration file during the startup.
        self.php_config_location = php_config_location
        # The script that is run immediately after the container is started. Example: `{"exec":{"command":["sh","-c","echo hello"\\]}}`
        self.post_start = post_start
        # The script that is run before the container is stopped. Example: `{"exec":{"command":["sh","-c","echo hello"\\]}}`
        self.pre_stop = pre_stop
        # The configurations of Kubernetes Service-based service registration and discovery. Take note of the following rules:
        # 
        # *   **serviceName**: the name of the Alibaba Cloud service. Format: `<Custom content>-<Namespace ID>`. `-<Namespace ID>` is automatically specified based on the namespace in which an application resides and cannot be changed. For example, if you select the default namespace in the China (Beijing) region, `-cn-beijing-default` is automatically specified.
        # *   **namespaceId**: the namespace ID.
        # *   **portAndProtocol**: the port number and protocol. Valid values of the port number: 1 to 65535. Valid values of the protocol: **TCP** and **UDP**.
        # *   **enable**: enables the Kubernetes Service-based registration and discovery feature.
        self.pvtz_discovery_svc = pvtz_discovery_svc
        # The Python environment. Set the value to **PYTHON 3.9.15**.
        self.python = python
        # The configurations for installing custom module dependencies. By default, the dependencies defined by the requirements.txt file in the root directory are installed. If the package does not contain this file and you do not configure custom dependencies in the package, specify the dependencies that you want to install in the text box.
        self.python_modules = python_modules
        # The details of the health check that was performed on the container. If the container fails this health check multiple times, the system disables and restarts the container. Containers that fail health checks cannot receive traffic from Server Load Balancer (SLB) instances. You can use the **exec**, **httpGet**, or **tcpSocket** method to perform health checks. For more information, see the description of the **Liveness** parameter.
        # 
        # > You can use only one method to perform the health check.
        self.readiness = readiness
        # The number of instances.
        self.replicas = replicas
        # Secret Mount Description
        # Use the secret dictionaries created in the Namespace Secret Dictionary page to inject information into containers. Parameter descriptions are as follows:
        # 
        # - secretId: Secret instance ID. Obtain via the ListSecrets interface.
        # 
        # - key: Key-value pair. Note: Set the parameter sae-sys-secret-all to mount all keys.
        # 
        # - mountPath: Mount path.
        self.secret_mount_desc = secret_mount_desc
        # Security group ID.
        self.security_group_id = security_group_id
        # The gray-release tag of the application.
        self.service_tags = service_tags
        # The configuration of the container.
        self.sidecar_containers_config_shrink = sidecar_containers_config_shrink
        # The logging configurations of Log Service.
        # 
        # *   To use Log Service resources that are automatically created by SAE, set this parameter to `[{"logDir":"","logType":"stdout"},{"logDir":"/tmp/a.log"}]`.
        # *   To use custom Log Service resources, set this parameter to `[{"projectName":"test-sls","logType":"stdout","logDir":"","logstoreName":"sae","logtailName":""},{"projectName":"test","logDir":"/tmp/a.log","logstoreName":"sae","logtailName":""}]`.
        # 
        # The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **projectName**: the name of the Log Service project.
        # *   **logDir**: the path in which logs are stored.
        # *   **logType**: the log type. **stdout**: the standard output log of the container. You can specify only one stdout value for this parameter. If you leave this parameter empty, file logs are collected.
        # *   **logstoreName**: the name of the Logstore in Log Service.
        # *   **logtailName**: the name of the Logtail configuration in Log Service. If you do not configure this parameter, a new Logtail configuration is created.
        # 
        # If you do not need to modify the logging configurations when you deploy the application, configure the **SlsConfigs** parameter only in the first request. You do not need to include this parameter in subsequent requests. If you no longer need to use Log Service, leave the **SlsConfigs** parameter empty in the request.
        # 
        # > A Log Service project that is automatically created by SAE when you create an application is deleted when the application is deleted. Therefore, when you create an application, you cannot select a Log Service project that is automatically created by SAE for log collection.
        self.sls_configs = sls_configs
        # Check Failure: Indicates that the application failed to start. The system will report the exception and automatically restart it.
        # 
        # Note: 
        # 
        # Supports exec, httpGet, and tcpSocket methods. For specific examples, see Liveness Parameters.
        # Only one method can be selected for health checks.
        self.startup_probe = startup_probe
        # Configure K8s Service-based Service Registration/Discovery and Full-Chain Grayscale Capabilities
        # 
        # - enable: Whether to enable full-link grayscale based on K8s Service (set to "true" to enable; set to "false" to disable).
        # 
        # - namespaceId: Namespace ID
        # 
        # - portAndProtocol: Listener port and protocol. Format: {"Port:Protocol Type":"Container Port"}
        # - portProtocols: Define service ports and protocols
        # port: Port
        # protocol: Protocol
        # targetPort: Container port
        # 
        # - pvtzDiscoveryName: Service discovery name
        # 
        # - serviceId: Service ID
        # 
        # - serviceName: Service name
        self.swimlane_pvtz_discovery_svc = swimlane_pvtz_discovery_svc
        # The timeout period for a graceful shutdown. Default value: 30. Unit: seconds. Valid values: 1 to 300.
        self.termination_grace_period_seconds = termination_grace_period_seconds
        # The time zone. Default value: **Asia/Shanghai**.
        self.timezone = timezone
        # The Tomcat configuration. If you want to cancel this configuration, set this parameter to "" or "{}". The following variables are included in the configuration: Take note of the following rules:
        # 
        # *   **port**: the port number. The port number ranges from 1024 to 65535. Though the admin permissions are configured for the container, the root permissions are required to perform operations on ports whose number is smaller than 1024. Enter a value that ranges from 1025 to 65535 because the container has only the admin permissions. If you do not specify this parameter, the default port number 8080 is used.
        # *   **contextPath**: the path. Default value: /. This value indicates the root directory.
        # *   **maxThreads**: the maximum number of connections in the connection pool. Default value: 400.
        # *   **uriEncoding**: the URI encoding scheme in the Tomcat container. Valid values: UTF-8, ISO-8859-1, GBK, and GB2312.************ If you do not specify this parameter, the default value **ISO-8859-1** is used.
        # *   **useBodyEncoding**: specifies whether to use the encoding scheme specified in the request body for URI query parameters. Default value: true.
        self.tomcat_config = tomcat_config
        # The deployment policy. If the minimum number of available instances is 1, the value of the **UpdateStrategy** parameter is an empty string (""). If the minimum number of available instances is greater than 1, the following strategies can be configured:
        # 
        # *   The application is deployed on an instance. The remaining instances are automatically classified into two release batches whose interval is set to 1. In this case, the parameter is set to `{"type":"GrayBatchUpdate","batchUpdate":{"batch":2,"releaseType":"auto","batchWaitTime":1},"grayUpdate":{"gray":1}}`.
        # *   The application is deployed on an instance. The remaining instances are manually classified into two release batches. In this case, the parameter is set to `{"type":"GrayBatchUpdate","batchUpdate":{"batch":2,"releaseType":"manual"},"grayUpdate":{"gray":1}}`.
        # *   All instances are automatically classified into two release batches. The application is deployed on the instances of the two batches in parallel. In this case, the parameter is set to `{"type":"BatchUpdate","batchUpdate":{"batch":2,"releaseType":"auto","batchWaitTime":0}}`
        # 
        # The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **type**: the type of the release policy. Valid values: **GrayBatchUpdate** and **BatchUpdate**.
        # 
        # *   **batchUpdate**: the phased release policy.
        # 
        #     *   **batch**: the number of release batches.
        #     *   **releaseType**: the processing method for the batches. Valid values: **auto** and **manual**.
        #     *   **batchWaitTime**: the interval between release batches. Unit: seconds.
        # 
        # *   **grayUpdate**: the number of release batches in the phased release after a canary release. This parameter is returned only if the **type** parameter is set to **GrayBatchUpdate**.
        self.update_strategy = update_strategy
        # The ID of the vSwitch, where the EIP of the application instances resides. The vSwitch must reside in the VPC above.
        self.v_switch_id = v_switch_id
        # The startup command of the WAR package. For information about how to configure the startup command, see [Configure startup commands](https://help.aliyun.com/document_detail/96677.html).
        self.war_start_options = war_start_options
        # The version of the Tomcat container on which the deployment package depends. Valid values:
        # 
        # *   **apache-tomcat-7.0.91**\
        # *   **apache-tomcat-8.5.42**\
        # 
        # This parameter is not returned if the **PackageType** parameter is set to **Image**.
        self.web_container = web_container

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acr_assume_role_arn is not None:
            result['AcrAssumeRoleArn'] = self.acr_assume_role_arn
        if self.acr_instance_id is not None:
            result['AcrInstanceId'] = self.acr_instance_id
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.associate_eip is not None:
            result['AssociateEip'] = self.associate_eip
        if self.auto_enable_application_scaling_rule is not None:
            result['AutoEnableApplicationScalingRule'] = self.auto_enable_application_scaling_rule
        if self.batch_wait_time is not None:
            result['BatchWaitTime'] = self.batch_wait_time
        if self.change_order_desc is not None:
            result['ChangeOrderDesc'] = self.change_order_desc
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        if self.config_map_mount_desc is not None:
            result['ConfigMapMountDesc'] = self.config_map_mount_desc
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.custom_host_alias is not None:
            result['CustomHostAlias'] = self.custom_host_alias
        if self.custom_image_network_type is not None:
            result['CustomImageNetworkType'] = self.custom_image_network_type
        if self.deploy is not None:
            result['Deploy'] = self.deploy
        if self.dotnet is not None:
            result['Dotnet'] = self.dotnet
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        if self.enable_ahas is not None:
            result['EnableAhas'] = self.enable_ahas
        if self.enable_cpu_burst is not None:
            result['EnableCpuBurst'] = self.enable_cpu_burst
        if self.enable_grey_tag_route is not None:
            result['EnableGreyTagRoute'] = self.enable_grey_tag_route
        if self.enable_new_arms is not None:
            result['EnableNewArms'] = self.enable_new_arms
        if self.enable_prometheus is not None:
            result['EnablePrometheus'] = self.enable_prometheus
        if self.enable_sidecar_resource_isolated is not None:
            result['EnableSidecarResourceIsolated'] = self.enable_sidecar_resource_isolated
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.gpu_config is not None:
            result['GpuConfig'] = self.gpu_config
        if self.html is not None:
            result['Html'] = self.html
        if self.image_pull_secrets is not None:
            result['ImagePullSecrets'] = self.image_pull_secrets
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.init_containers_config_shrink is not None:
            result['InitContainersConfig'] = self.init_containers_config_shrink
        if self.jar_start_args is not None:
            result['JarStartArgs'] = self.jar_start_args
        if self.jar_start_options is not None:
            result['JarStartOptions'] = self.jar_start_options
        if self.jdk is not None:
            result['Jdk'] = self.jdk
        if self.kafka_configs is not None:
            result['KafkaConfigs'] = self.kafka_configs
        if self.liveness is not None:
            result['Liveness'] = self.liveness
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.micro_registration is not None:
            result['MicroRegistration'] = self.micro_registration
        if self.micro_registration_config is not None:
            result['MicroRegistrationConfig'] = self.micro_registration_config
        if self.microservice_engine_config is not None:
            result['MicroserviceEngineConfig'] = self.microservice_engine_config
        if self.min_ready_instance_ratio is not None:
            result['MinReadyInstanceRatio'] = self.min_ready_instance_ratio
        if self.min_ready_instances is not None:
            result['MinReadyInstances'] = self.min_ready_instances
        if self.mount_desc is not None:
            result['MountDesc'] = self.mount_desc
        if self.mount_host is not None:
            result['MountHost'] = self.mount_host
        if self.nas_configs is not None:
            result['NasConfigs'] = self.nas_configs
        if self.nas_id is not None:
            result['NasId'] = self.nas_id
        if self.new_sae_version is not None:
            result['NewSaeVersion'] = self.new_sae_version
        if self.oidc_role_name is not None:
            result['OidcRoleName'] = self.oidc_role_name
        if self.oss_ak_id is not None:
            result['OssAkId'] = self.oss_ak_id
        if self.oss_ak_secret is not None:
            result['OssAkSecret'] = self.oss_ak_secret
        if self.oss_mount_descs is not None:
            result['OssMountDescs'] = self.oss_mount_descs
        if self.package_type is not None:
            result['PackageType'] = self.package_type
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.php is not None:
            result['Php'] = self.php
        if self.php_arms_config_location is not None:
            result['PhpArmsConfigLocation'] = self.php_arms_config_location
        if self.php_config is not None:
            result['PhpConfig'] = self.php_config
        if self.php_config_location is not None:
            result['PhpConfigLocation'] = self.php_config_location
        if self.post_start is not None:
            result['PostStart'] = self.post_start
        if self.pre_stop is not None:
            result['PreStop'] = self.pre_stop
        if self.pvtz_discovery_svc is not None:
            result['PvtzDiscoverySvc'] = self.pvtz_discovery_svc
        if self.python is not None:
            result['Python'] = self.python
        if self.python_modules is not None:
            result['PythonModules'] = self.python_modules
        if self.readiness is not None:
            result['Readiness'] = self.readiness
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.secret_mount_desc is not None:
            result['SecretMountDesc'] = self.secret_mount_desc
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.service_tags is not None:
            result['ServiceTags'] = self.service_tags
        if self.sidecar_containers_config_shrink is not None:
            result['SidecarContainersConfig'] = self.sidecar_containers_config_shrink
        if self.sls_configs is not None:
            result['SlsConfigs'] = self.sls_configs
        if self.startup_probe is not None:
            result['StartupProbe'] = self.startup_probe
        if self.swimlane_pvtz_discovery_svc is not None:
            result['SwimlanePvtzDiscoverySvc'] = self.swimlane_pvtz_discovery_svc
        if self.termination_grace_period_seconds is not None:
            result['TerminationGracePeriodSeconds'] = self.termination_grace_period_seconds
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.tomcat_config is not None:
            result['TomcatConfig'] = self.tomcat_config
        if self.update_strategy is not None:
            result['UpdateStrategy'] = self.update_strategy
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.war_start_options is not None:
            result['WarStartOptions'] = self.war_start_options
        if self.web_container is not None:
            result['WebContainer'] = self.web_container
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcrAssumeRoleArn') is not None:
            self.acr_assume_role_arn = m.get('AcrAssumeRoleArn')
        if m.get('AcrInstanceId') is not None:
            self.acr_instance_id = m.get('AcrInstanceId')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AssociateEip') is not None:
            self.associate_eip = m.get('AssociateEip')
        if m.get('AutoEnableApplicationScalingRule') is not None:
            self.auto_enable_application_scaling_rule = m.get('AutoEnableApplicationScalingRule')
        if m.get('BatchWaitTime') is not None:
            self.batch_wait_time = m.get('BatchWaitTime')
        if m.get('ChangeOrderDesc') is not None:
            self.change_order_desc = m.get('ChangeOrderDesc')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        if m.get('ConfigMapMountDesc') is not None:
            self.config_map_mount_desc = m.get('ConfigMapMountDesc')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CustomHostAlias') is not None:
            self.custom_host_alias = m.get('CustomHostAlias')
        if m.get('CustomImageNetworkType') is not None:
            self.custom_image_network_type = m.get('CustomImageNetworkType')
        if m.get('Deploy') is not None:
            self.deploy = m.get('Deploy')
        if m.get('Dotnet') is not None:
            self.dotnet = m.get('Dotnet')
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        if m.get('EnableAhas') is not None:
            self.enable_ahas = m.get('EnableAhas')
        if m.get('EnableCpuBurst') is not None:
            self.enable_cpu_burst = m.get('EnableCpuBurst')
        if m.get('EnableGreyTagRoute') is not None:
            self.enable_grey_tag_route = m.get('EnableGreyTagRoute')
        if m.get('EnableNewArms') is not None:
            self.enable_new_arms = m.get('EnableNewArms')
        if m.get('EnablePrometheus') is not None:
            self.enable_prometheus = m.get('EnablePrometheus')
        if m.get('EnableSidecarResourceIsolated') is not None:
            self.enable_sidecar_resource_isolated = m.get('EnableSidecarResourceIsolated')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('GpuConfig') is not None:
            self.gpu_config = m.get('GpuConfig')
        if m.get('Html') is not None:
            self.html = m.get('Html')
        if m.get('ImagePullSecrets') is not None:
            self.image_pull_secrets = m.get('ImagePullSecrets')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('InitContainersConfig') is not None:
            self.init_containers_config_shrink = m.get('InitContainersConfig')
        if m.get('JarStartArgs') is not None:
            self.jar_start_args = m.get('JarStartArgs')
        if m.get('JarStartOptions') is not None:
            self.jar_start_options = m.get('JarStartOptions')
        if m.get('Jdk') is not None:
            self.jdk = m.get('Jdk')
        if m.get('KafkaConfigs') is not None:
            self.kafka_configs = m.get('KafkaConfigs')
        if m.get('Liveness') is not None:
            self.liveness = m.get('Liveness')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('MicroRegistration') is not None:
            self.micro_registration = m.get('MicroRegistration')
        if m.get('MicroRegistrationConfig') is not None:
            self.micro_registration_config = m.get('MicroRegistrationConfig')
        if m.get('MicroserviceEngineConfig') is not None:
            self.microservice_engine_config = m.get('MicroserviceEngineConfig')
        if m.get('MinReadyInstanceRatio') is not None:
            self.min_ready_instance_ratio = m.get('MinReadyInstanceRatio')
        if m.get('MinReadyInstances') is not None:
            self.min_ready_instances = m.get('MinReadyInstances')
        if m.get('MountDesc') is not None:
            self.mount_desc = m.get('MountDesc')
        if m.get('MountHost') is not None:
            self.mount_host = m.get('MountHost')
        if m.get('NasConfigs') is not None:
            self.nas_configs = m.get('NasConfigs')
        if m.get('NasId') is not None:
            self.nas_id = m.get('NasId')
        if m.get('NewSaeVersion') is not None:
            self.new_sae_version = m.get('NewSaeVersion')
        if m.get('OidcRoleName') is not None:
            self.oidc_role_name = m.get('OidcRoleName')
        if m.get('OssAkId') is not None:
            self.oss_ak_id = m.get('OssAkId')
        if m.get('OssAkSecret') is not None:
            self.oss_ak_secret = m.get('OssAkSecret')
        if m.get('OssMountDescs') is not None:
            self.oss_mount_descs = m.get('OssMountDescs')
        if m.get('PackageType') is not None:
            self.package_type = m.get('PackageType')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('Php') is not None:
            self.php = m.get('Php')
        if m.get('PhpArmsConfigLocation') is not None:
            self.php_arms_config_location = m.get('PhpArmsConfigLocation')
        if m.get('PhpConfig') is not None:
            self.php_config = m.get('PhpConfig')
        if m.get('PhpConfigLocation') is not None:
            self.php_config_location = m.get('PhpConfigLocation')
        if m.get('PostStart') is not None:
            self.post_start = m.get('PostStart')
        if m.get('PreStop') is not None:
            self.pre_stop = m.get('PreStop')
        if m.get('PvtzDiscoverySvc') is not None:
            self.pvtz_discovery_svc = m.get('PvtzDiscoverySvc')
        if m.get('Python') is not None:
            self.python = m.get('Python')
        if m.get('PythonModules') is not None:
            self.python_modules = m.get('PythonModules')
        if m.get('Readiness') is not None:
            self.readiness = m.get('Readiness')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('SecretMountDesc') is not None:
            self.secret_mount_desc = m.get('SecretMountDesc')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('ServiceTags') is not None:
            self.service_tags = m.get('ServiceTags')
        if m.get('SidecarContainersConfig') is not None:
            self.sidecar_containers_config_shrink = m.get('SidecarContainersConfig')
        if m.get('SlsConfigs') is not None:
            self.sls_configs = m.get('SlsConfigs')
        if m.get('StartupProbe') is not None:
            self.startup_probe = m.get('StartupProbe')
        if m.get('SwimlanePvtzDiscoverySvc') is not None:
            self.swimlane_pvtz_discovery_svc = m.get('SwimlanePvtzDiscoverySvc')
        if m.get('TerminationGracePeriodSeconds') is not None:
            self.termination_grace_period_seconds = m.get('TerminationGracePeriodSeconds')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('TomcatConfig') is not None:
            self.tomcat_config = m.get('TomcatConfig')
        if m.get('UpdateStrategy') is not None:
            self.update_strategy = m.get('UpdateStrategy')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('WarStartOptions') is not None:
            self.war_start_options = m.get('WarStartOptions')
        if m.get('WebContainer') is not None:
            self.web_container = m.get('WebContainer')
        return self


class DeployApplicationResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        change_order_id: str = None,
        is_need_approval: bool = None,
    ):
        # The application ID.
        self.app_id = app_id
        # The ID of the change order. It can be used to query the task status.
        self.change_order_id = change_order_id
        # Specifies whether approval is required when a RAM user performs release. Take note of the following rules:
        # 
        # *   **true**\
        # *   **false**\
        self.is_need_approval = is_need_approval

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.is_need_approval is not None:
            result['IsNeedApproval'] = self.is_need_approval
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('IsNeedApproval') is not None:
            self.is_need_approval = m.get('IsNeedApproval')
        return self


class DeployApplicationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DeployApplicationResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Take note of the following rules:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The response.
        self.data = data
        # The error code returned if the request failed. Take note of the following rules:
        # 
        # *   The **ErrorCode** parameter is not returned if the request succeeds.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The additional information that is returned. Take note of the following rules:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the application deployment is successful. Take note of the following rules:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DeployApplicationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeployApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeployApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeployApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAppServiceDetailRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        nacos_instance_id: str = None,
        nacos_namespace_id: str = None,
        service_group: str = None,
        service_name: str = None,
        service_type: str = None,
        service_version: str = None,
    ):
        # 6dcc8c9e-d3da-478a-a066-86dcf820\\*\\*\\*\\*\
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the MSE Nacos instance.
        self.nacos_instance_id = nacos_instance_id
        # The ID of the namespace for the MSE Nacos instance.
        self.nacos_namespace_id = nacos_namespace_id
        # springCloud
        self.service_group = service_group
        # edas.service.provider
        self.service_name = service_name
        # springCloud
        self.service_type = service_type
        # 1.0.0
        self.service_version = service_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.nacos_instance_id is not None:
            result['NacosInstanceId'] = self.nacos_instance_id
        if self.nacos_namespace_id is not None:
            result['NacosNamespaceId'] = self.nacos_namespace_id
        if self.service_group is not None:
            result['ServiceGroup'] = self.service_group
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        if self.service_type is not None:
            result['ServiceType'] = self.service_type
        if self.service_version is not None:
            result['ServiceVersion'] = self.service_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('NacosInstanceId') is not None:
            self.nacos_instance_id = m.get('NacosInstanceId')
        if m.get('NacosNamespaceId') is not None:
            self.nacos_namespace_id = m.get('NacosNamespaceId')
        if m.get('ServiceGroup') is not None:
            self.service_group = m.get('ServiceGroup')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        if m.get('ServiceType') is not None:
            self.service_type = m.get('ServiceType')
        if m.get('ServiceVersion') is not None:
            self.service_version = m.get('ServiceVersion')
        return self


class DescribeAppServiceDetailResponseBodyDataMethodsParameterDefinitions(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        type: str = None,
    ):
        # The description of the parameter.
        self.description = description
        # The name of the parameter.
        self.name = name
        # The type of the parameter.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeAppServiceDetailResponseBodyDataMethods(TeaModel):
    def __init__(
        self,
        method_controller: str = None,
        name: str = None,
        name_detail: str = None,
        parameter_definitions: List[DescribeAppServiceDetailResponseBodyDataMethodsParameterDefinitions] = None,
        parameter_details: List[str] = None,
        parameter_types: List[str] = None,
        paths: List[str] = None,
        request_methods: List[str] = None,
        return_details: str = None,
        return_type: str = None,
    ):
        # The class to which the method belongs.
        self.method_controller = method_controller
        # The name of the method.
        self.name = name
        # The details of the method.
        self.name_detail = name_detail
        # The definition of the parameter.
        self.parameter_definitions = parameter_definitions
        # The details of the parameters.
        self.parameter_details = parameter_details
        # The types of the parameters.
        self.parameter_types = parameter_types
        # The request paths. Format:
        # 
        # `/path`
        self.paths = paths
        # The request methods. Valid values:
        # 
        # *   **GET**\
        # *   **ALL**\
        self.request_methods = request_methods
        # The details of the response.
        self.return_details = return_details
        # The data format of the response.
        self.return_type = return_type

    def validate(self):
        if self.parameter_definitions:
            for k in self.parameter_definitions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.method_controller is not None:
            result['MethodController'] = self.method_controller
        if self.name is not None:
            result['Name'] = self.name
        if self.name_detail is not None:
            result['NameDetail'] = self.name_detail
        result['ParameterDefinitions'] = []
        if self.parameter_definitions is not None:
            for k in self.parameter_definitions:
                result['ParameterDefinitions'].append(k.to_map() if k else None)
        if self.parameter_details is not None:
            result['ParameterDetails'] = self.parameter_details
        if self.parameter_types is not None:
            result['ParameterTypes'] = self.parameter_types
        if self.paths is not None:
            result['Paths'] = self.paths
        if self.request_methods is not None:
            result['RequestMethods'] = self.request_methods
        if self.return_details is not None:
            result['ReturnDetails'] = self.return_details
        if self.return_type is not None:
            result['ReturnType'] = self.return_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MethodController') is not None:
            self.method_controller = m.get('MethodController')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NameDetail') is not None:
            self.name_detail = m.get('NameDetail')
        self.parameter_definitions = []
        if m.get('ParameterDefinitions') is not None:
            for k in m.get('ParameterDefinitions'):
                temp_model = DescribeAppServiceDetailResponseBodyDataMethodsParameterDefinitions()
                self.parameter_definitions.append(temp_model.from_map(k))
        if m.get('ParameterDetails') is not None:
            self.parameter_details = m.get('ParameterDetails')
        if m.get('ParameterTypes') is not None:
            self.parameter_types = m.get('ParameterTypes')
        if m.get('Paths') is not None:
            self.paths = m.get('Paths')
        if m.get('RequestMethods') is not None:
            self.request_methods = m.get('RequestMethods')
        if m.get('ReturnDetails') is not None:
            self.return_details = m.get('ReturnDetails')
        if m.get('ReturnType') is not None:
            self.return_type = m.get('ReturnType')
        return self


class DescribeAppServiceDetailResponseBodyData(TeaModel):
    def __init__(
        self,
        dubbo_application_name: str = None,
        edas_app_name: str = None,
        group: str = None,
        metadata: Dict[str, Any] = None,
        methods: List[DescribeAppServiceDetailResponseBodyDataMethods] = None,
        service_name: str = None,
        service_ports: List[int] = None,
        service_protocol: str = None,
        service_tags: List[str] = None,
        service_type: str = None,
        spring_application_name: str = None,
        version: str = None,
    ):
        # The name of the Dubbo application.
        self.dubbo_application_name = dubbo_application_name
        # The name of the application.
        self.edas_app_name = edas_app_name
        # The group to which the service belongs. You can create a custom group.
        self.group = group
        # The metadata. Example: `{side: "provider", port: "18081", preserved: {register: {source: "SPRING_CLOUD"}},…}`.
        self.metadata = metadata
        # The methods.
        self.methods = methods
        # The name of the service.
        self.service_name = service_name
        # The port used by the service.
        self.service_ports = service_ports
        # The protocol used by the service.
        self.service_protocol = service_protocol
        # The tag of the service.
        self.service_tags = service_tags
        # The type of the service. Valid values:
        # 
        # *   **dubbo**\
        # *   **springCloud**\
        self.service_type = service_type
        # The name of the Spring Cloud application.
        self.spring_application_name = spring_application_name
        # The version of the service. You can create a custom version.
        self.version = version

    def validate(self):
        if self.methods:
            for k in self.methods:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dubbo_application_name is not None:
            result['DubboApplicationName'] = self.dubbo_application_name
        if self.edas_app_name is not None:
            result['EdasAppName'] = self.edas_app_name
        if self.group is not None:
            result['Group'] = self.group
        if self.metadata is not None:
            result['Metadata'] = self.metadata
        result['Methods'] = []
        if self.methods is not None:
            for k in self.methods:
                result['Methods'].append(k.to_map() if k else None)
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        if self.service_ports is not None:
            result['ServicePorts'] = self.service_ports
        if self.service_protocol is not None:
            result['ServiceProtocol'] = self.service_protocol
        if self.service_tags is not None:
            result['ServiceTags'] = self.service_tags
        if self.service_type is not None:
            result['ServiceType'] = self.service_type
        if self.spring_application_name is not None:
            result['SpringApplicationName'] = self.spring_application_name
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DubboApplicationName') is not None:
            self.dubbo_application_name = m.get('DubboApplicationName')
        if m.get('EdasAppName') is not None:
            self.edas_app_name = m.get('EdasAppName')
        if m.get('Group') is not None:
            self.group = m.get('Group')
        if m.get('Metadata') is not None:
            self.metadata = m.get('Metadata')
        self.methods = []
        if m.get('Methods') is not None:
            for k in m.get('Methods'):
                temp_model = DescribeAppServiceDetailResponseBodyDataMethods()
                self.methods.append(temp_model.from_map(k))
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        if m.get('ServicePorts') is not None:
            self.service_ports = m.get('ServicePorts')
        if m.get('ServiceProtocol') is not None:
            self.service_protocol = m.get('ServiceProtocol')
        if m.get('ServiceTags') is not None:
            self.service_tags = m.get('ServiceTags')
        if m.get('ServiceType') is not None:
            self.service_type = m.get('ServiceType')
        if m.get('SpringApplicationName') is not None:
            self.spring_application_name = m.get('SpringApplicationName')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DescribeAppServiceDetailResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeAppServiceDetailResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # - **2xx**: indicates that the call was successful.
        # - **3xx**: indicates that the call was redirected.
        # - **4xx**: indicates that the call failed.
        # - **5xx**: indicates that a server error occurred.
        self.code = code
        # The data that is returned.
        self.data = data
        # The returned error code. Valid values:
        # 
        # - If the call is successful, the **ErrorCode** parameter is not returned.
        # - If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned information.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the meta data was obtained. Valid values:
        # 
        # *   **true**: The metadata was obtained.
        # *   **false**: The metadata failed to be obtained.
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeAppServiceDetailResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeAppServiceDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAppServiceDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAppServiceDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApplicationConfigRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        version_id: str = None,
    ):
        # The app id.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The version id.
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class DescribeApplicationConfigResponseBodyDataConfigMapMountDesc(TeaModel):
    def __init__(
        self,
        config_map_id: int = None,
        config_map_name: str = None,
        key: str = None,
        mount_path: str = None,
    ):
        # The ID of the ConfigMap.
        self.config_map_id = config_map_id
        # The name of the ConfigMap.
        self.config_map_name = config_map_name
        # The key-value pair that is stored in the ConfigMap.
        self.key = key
        # The path on which the ConfigMap is mounted.
        self.mount_path = mount_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        if self.config_map_name is not None:
            result['ConfigMapName'] = self.config_map_name
        if self.key is not None:
            result['Key'] = self.key
        if self.mount_path is not None:
            result['MountPath'] = self.mount_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        if m.get('ConfigMapName') is not None:
            self.config_map_name = m.get('ConfigMapName')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('MountPath') is not None:
            self.mount_path = m.get('MountPath')
        return self


class DescribeApplicationConfigResponseBodyDataInitContainersConfigConfigMapMountDesc(TeaModel):
    def __init__(
        self,
        config_map_id: int = None,
        config_map_name: str = None,
        key: str = None,
        mount_path: str = None,
    ):
        # ConfigMap ID。
        self.config_map_id = config_map_id
        # The name of the ConfigMap.
        self.config_map_name = config_map_name
        # The key.
        self.key = key
        # The mount path.
        self.mount_path = mount_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        if self.config_map_name is not None:
            result['ConfigMapName'] = self.config_map_name
        if self.key is not None:
            result['Key'] = self.key
        if self.mount_path is not None:
            result['MountPath'] = self.mount_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        if m.get('ConfigMapName') is not None:
            self.config_map_name = m.get('ConfigMapName')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('MountPath') is not None:
            self.mount_path = m.get('MountPath')
        return self


class DescribeApplicationConfigResponseBodyDataInitContainersConfig(TeaModel):
    def __init__(
        self,
        command: str = None,
        command_args: str = None,
        config_map_mount_desc: List[DescribeApplicationConfigResponseBodyDataInitContainersConfigConfigMapMountDesc] = None,
        envs: str = None,
        image_url: str = None,
        name: str = None,
    ):
        # The command that is used to start the image. The command must be an existing executable object in the container. Sample statements:
        # 
        #     command:
        #           - echo
        #           - abc
        #           - >
        #           - file0
        # 
        # In this example, the Command parameter is set to `Command="echo", CommandArgs=["abc", ">", "file0"]`.
        self.command = command
        # The parameters of the image startup command. The CommandArgs parameter specifies the parameters that are required for the **Command** parameter. You can specify the name in one of the following formats:
        # 
        # `["a","b"]`
        # 
        # In the preceding example, the CommandArgs parameter is set to `CommandArgs=["abc", ">", "file0"]`. The data type of `["abc", ">", "file0"]` must be an array of strings in the JSON format. This parameter is optional.
        self.command_args = command_args
        # The information of ConfigMap.
        self.config_map_mount_desc = config_map_mount_desc
        # The environment variables. You can configure custom environment variables or reference a ConfigMap. If you want to reference a ConfigMap, you must first create a ConfigMap. For more information, see [CreateConfigMap](https://help.aliyun.com/document_detail/176914.html). Take note of the following rules:
        # 
        # *   Customize
        # 
        #     *   **name**: the name of the environment variable.
        #     *   **value**: the value of the environment variable.
        # 
        # *   Reference ConfigMap
        # 
        #     *   **name**: the name of the environment variable. You can reference one or all keys. If you want to reference all keys, specify `sae-sys-configmap-all-<ConfigMap name>`. Example: `sae-sys-configmap-all-test1`.
        #     *   **valueFrom**: the reference of the environment variable. Set the value to `configMapRef`.
        #     *   **configMapId**: the ConfigMap ID.
        #     *   **key**: the key. If you want to reference all keys, do not configure this parameter.
        self.envs = envs
        # The image URL of the initialized container.
        self.image_url = image_url
        # The name of the initialized container.
        self.name = name

    def validate(self):
        if self.config_map_mount_desc:
            for k in self.config_map_mount_desc:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        result['ConfigMapMountDesc'] = []
        if self.config_map_mount_desc is not None:
            for k in self.config_map_mount_desc:
                result['ConfigMapMountDesc'].append(k.to_map() if k else None)
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        self.config_map_mount_desc = []
        if m.get('ConfigMapMountDesc') is not None:
            for k in m.get('ConfigMapMountDesc'):
                temp_model = DescribeApplicationConfigResponseBodyDataInitContainersConfigConfigMapMountDesc()
                self.config_map_mount_desc.append(temp_model.from_map(k))
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeApplicationConfigResponseBodyDataMountDesc(TeaModel):
    def __init__(
        self,
        mount_path: str = None,
        nas_path: str = None,
    ):
        # The path on which the NAS file system is mounted.
        self.mount_path = mount_path
        # The directory in the NAS file system.
        self.nas_path = nas_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mount_path is not None:
            result['MountPath'] = self.mount_path
        if self.nas_path is not None:
            result['NasPath'] = self.nas_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MountPath') is not None:
            self.mount_path = m.get('MountPath')
        if m.get('NasPath') is not None:
            self.nas_path = m.get('NasPath')
        return self


class DescribeApplicationConfigResponseBodyDataOssMountDescs(TeaModel):
    def __init__(
        self,
        bucket_name: str = None,
        bucket_path: str = None,
        mount_path: str = None,
        read_only: bool = None,
    ):
        # The name of the OSS bucket.
        self.bucket_name = bucket_name
        # The directory or object in OSS. If the specified directory or object does not exist, an error is returned.
        self.bucket_path = bucket_path
        # The path of the container in SAE. The parameter value that you specified overwrites the original value. If the specified path does not exist, SAE automatically creates the path.
        self.mount_path = mount_path
        # Indicates whether the application can use the container path to read data from or write data to resources in the directory of the OSS bucket. Valid values:
        # 
        # *   **true**: The application has the read-only permissions.
        # *   **false**: The application has the read and write permissions.
        self.read_only = read_only

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['bucketName'] = self.bucket_name
        if self.bucket_path is not None:
            result['bucketPath'] = self.bucket_path
        if self.mount_path is not None:
            result['mountPath'] = self.mount_path
        if self.read_only is not None:
            result['readOnly'] = self.read_only
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bucketName') is not None:
            self.bucket_name = m.get('bucketName')
        if m.get('bucketPath') is not None:
            self.bucket_path = m.get('bucketPath')
        if m.get('mountPath') is not None:
            self.mount_path = m.get('mountPath')
        if m.get('readOnly') is not None:
            self.read_only = m.get('readOnly')
        return self


class DescribeApplicationConfigResponseBodyDataSecretMountDesc(TeaModel):
    def __init__(
        self,
        key: str = None,
        mount_path: str = None,
        secret_id: int = None,
        secret_name: str = None,
    ):
        # The key to Base64 encode values.
        self.key = key
        # The mount path.
        self.mount_path = mount_path
        # The secret ID of the instance.
        self.secret_id = secret_id
        # The name of the secret.
        self.secret_name = secret_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.mount_path is not None:
            result['MountPath'] = self.mount_path
        if self.secret_id is not None:
            result['SecretId'] = self.secret_id
        if self.secret_name is not None:
            result['SecretName'] = self.secret_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('MountPath') is not None:
            self.mount_path = m.get('MountPath')
        if m.get('SecretId') is not None:
            self.secret_id = m.get('SecretId')
        if m.get('SecretName') is not None:
            self.secret_name = m.get('SecretName')
        return self


class DescribeApplicationConfigResponseBodyDataSidecarContainersConfigConfigMapMountDesc(TeaModel):
    def __init__(
        self,
        config_map_id: int = None,
        config_map_name: str = None,
        key: str = None,
        mount_path: str = None,
    ):
        # The ConfigMap ID.
        self.config_map_id = config_map_id
        # The ConfigMap name.
        self.config_map_name = config_map_name
        # The ConfigMap key
        self.key = key
        # The mount path.
        self.mount_path = mount_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        if self.config_map_name is not None:
            result['ConfigMapName'] = self.config_map_name
        if self.key is not None:
            result['Key'] = self.key
        if self.mount_path is not None:
            result['MountPath'] = self.mount_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        if m.get('ConfigMapName') is not None:
            self.config_map_name = m.get('ConfigMapName')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('MountPath') is not None:
            self.mount_path = m.get('MountPath')
        return self


class DescribeApplicationConfigResponseBodyDataSidecarContainersConfigEmptyDirDesc(TeaModel):
    def __init__(
        self,
        mount_path: str = None,
        name: str = None,
    ):
        # Mount path of the data volume within the container.
        self.mount_path = mount_path
        # The name of the shared temporary storage.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mount_path is not None:
            result['MountPath'] = self.mount_path
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MountPath') is not None:
            self.mount_path = m.get('MountPath')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeApplicationConfigResponseBodyDataSidecarContainersConfig(TeaModel):
    def __init__(
        self,
        acr_instance_id: str = None,
        command: str = None,
        command_args: str = None,
        config_map_mount_desc: List[DescribeApplicationConfigResponseBodyDataSidecarContainersConfigConfigMapMountDesc] = None,
        cpu: int = None,
        empty_dir_desc: List[DescribeApplicationConfigResponseBodyDataSidecarContainersConfigEmptyDirDesc] = None,
        envs: str = None,
        image_url: str = None,
        memory: int = None,
        name: str = None,
    ):
        # The ID of Container Registry Enterprise Edition instance. This parameter is required when the **ImageUrl** parameter is set to the URL of an image in an ACR Enterprise Edition instance.
        self.acr_instance_id = acr_instance_id
        # The command that is used to start the image. The command must be an existing executable object in the container. Sample statements:
        # 
        #     command:
        #           - echo
        #           - abc
        #           - >
        #           - file0
        # 
        # In this example, the Command parameter is set to `Command="echo", CommandArgs=["abc", ">", "file0"]`.
        self.command = command
        # The parameters of the image startup command. The CommandArgs parameter specifies the parameters that are required for the **Command** parameter. You can specify the name in one of the following formats:
        # 
        # `["a","b"]`
        # 
        # In the preceding example, the CommandArgs parameter is set to `CommandArgs=["abc", ">", "file0"]`. The data type of `["abc", ">", "file0"]` must be an array of strings in the JSON format. This parameter is optional.
        self.command_args = command_args
        # The description of the **ConfigMap** instance mounted to the application. Use configurations created on the Configuration Items page to configure containers. The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **congfigMapId**: the ID of the ConfigMap instance. You can call the [ListNamespacedConfigMaps](https://help.aliyun.com/document_detail/176917.html) operation to obtain the ID.
        # *   **key**: the key.
        # 
        # > You can use the `sae-sys-configmap-all` key to mount all keys.
        # 
        # *   **mountPath**: the mount path in the container.
        self.config_map_mount_desc = config_map_mount_desc
        # Set the CPU resource limit of the primary container that can be used by Sidecar container.
        self.cpu = cpu
        # Shared temporary storage mounted to the primary container and the Sidecar container.
        self.empty_dir_desc = empty_dir_desc
        # The environment variables. You can configure custom environment variables or reference a ConfigMap. If you want to reference a ConfigMap, you must first create a ConfigMap. For more information, see [CreateConfigMap](https://help.aliyun.com/document_detail/176914.html). Take note of the following rules:
        # 
        # *   Customize
        # 
        #     *   **name**: the name of the environment variable.
        #     *   **value**: the value of the environment variable.
        # 
        # *   Reference ConfigMap
        # 
        #     *   **name**: the name of the environment variable. You can reference one or all keys. If you want to reference all keys, specify `sae-sys-configmap-all-<ConfigMap name>`. Example: `sae-sys-configmap-all-test1`.
        #     *   **valueFrom**: the reference of the environment variable. Set the value to `configMapRef`.
        #     *   **configMapId**: the ConfigMap ID.
        #     *   **key**: the key. If you want to reference all keys, do not configure this parameter.
        self.envs = envs
        # The URL of the image.
        self.image_url = image_url
        # Set the memory limit of the primary container that can be used by Sidecar container.
        self.memory = memory
        # The container name.
        self.name = name

    def validate(self):
        if self.config_map_mount_desc:
            for k in self.config_map_mount_desc:
                if k:
                    k.validate()
        if self.empty_dir_desc:
            for k in self.empty_dir_desc:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acr_instance_id is not None:
            result['AcrInstanceId'] = self.acr_instance_id
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        result['ConfigMapMountDesc'] = []
        if self.config_map_mount_desc is not None:
            for k in self.config_map_mount_desc:
                result['ConfigMapMountDesc'].append(k.to_map() if k else None)
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        result['EmptyDirDesc'] = []
        if self.empty_dir_desc is not None:
            for k in self.empty_dir_desc:
                result['EmptyDirDesc'].append(k.to_map() if k else None)
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcrInstanceId') is not None:
            self.acr_instance_id = m.get('AcrInstanceId')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        self.config_map_mount_desc = []
        if m.get('ConfigMapMountDesc') is not None:
            for k in m.get('ConfigMapMountDesc'):
                temp_model = DescribeApplicationConfigResponseBodyDataSidecarContainersConfigConfigMapMountDesc()
                self.config_map_mount_desc.append(temp_model.from_map(k))
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        self.empty_dir_desc = []
        if m.get('EmptyDirDesc') is not None:
            for k in m.get('EmptyDirDesc'):
                temp_model = DescribeApplicationConfigResponseBodyDataSidecarContainersConfigEmptyDirDesc()
                self.empty_dir_desc.append(temp_model.from_map(k))
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeApplicationConfigResponseBodyDataTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeApplicationConfigResponseBodyData(TeaModel):
    def __init__(
        self,
        acr_assume_role_arn: str = None,
        acr_instance_id: str = None,
        app_description: str = None,
        app_id: str = None,
        app_name: str = None,
        app_source: str = None,
        associate_eip: bool = None,
        base_app_id: str = None,
        batch_wait_time: int = None,
        cluster_id: str = None,
        command: str = None,
        command_args: str = None,
        config_map_mount_desc: List[DescribeApplicationConfigResponseBodyDataConfigMapMountDesc] = None,
        cpu: int = None,
        custom_host_alias: str = None,
        custom_image_network_type: str = None,
        disk_size: int = None,
        dotnet: str = None,
        edas_container_version: str = None,
        enable_ahas: str = None,
        enable_cpu_burst: str = None,
        enable_grey_tag_route: bool = None,
        enable_idle: bool = None,
        enable_new_arms: bool = None,
        enable_prometheus: bool = None,
        envs: str = None,
        gpu_count: str = None,
        gpu_type: str = None,
        html: str = None,
        image_pull_secrets: str = None,
        image_url: str = None,
        init_containers_config: List[DescribeApplicationConfigResponseBodyDataInitContainersConfig] = None,
        is_stateful: bool = None,
        jar_start_args: str = None,
        jar_start_options: str = None,
        jdk: str = None,
        kafka_configs: str = None,
        liveness: str = None,
        memory: int = None,
        micro_registration: str = None,
        micro_registration_config: str = None,
        microservice_engine_config: str = None,
        min_ready_instance_ratio: int = None,
        min_ready_instances: int = None,
        mount_desc: List[DescribeApplicationConfigResponseBodyDataMountDesc] = None,
        mount_host: str = None,
        mse_application_id: str = None,
        mse_application_name: str = None,
        namespace_id: str = None,
        nas_configs: str = None,
        nas_id: str = None,
        new_sae_version: str = None,
        oidc_role_name: str = None,
        oss_ak_id: str = None,
        oss_ak_secret: str = None,
        oss_mount_descs: List[DescribeApplicationConfigResponseBodyDataOssMountDescs] = None,
        package_type: str = None,
        package_url: str = None,
        package_version: str = None,
        php: str = None,
        php_arms_config_location: str = None,
        php_config: str = None,
        php_config_location: str = None,
        post_start: str = None,
        pre_stop: str = None,
        programming_language: str = None,
        pvtz_discovery: str = None,
        python: str = None,
        python_modules: str = None,
        readiness: str = None,
        region_id: str = None,
        replicas: int = None,
        resource_type: str = None,
        secret_mount_desc: List[DescribeApplicationConfigResponseBodyDataSecretMountDesc] = None,
        security_group_id: str = None,
        service_tags: Dict[str, str] = None,
        sidecar_containers_config: List[DescribeApplicationConfigResponseBodyDataSidecarContainersConfig] = None,
        sls_configs: str = None,
        startup_probe: str = None,
        swimlane_pvtz_discovery: str = None,
        tags: List[DescribeApplicationConfigResponseBodyDataTags] = None,
        termination_grace_period_seconds: int = None,
        timezone: str = None,
        tomcat_config: str = None,
        update_strategy: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
        war_start_options: str = None,
        web_container: str = None,
    ):
        # The Alibaba Cloud Resource Name (ARN) of the RAM role that is used to pull images across accounts. For more information, see [Pull images across Alibaba Cloud accounts](https://help.aliyun.com/document_detail/190675.html) and [Grant permissions across Alibaba Cloud accounts by using a RAM role](https://help.aliyun.com/document_detail/223585.html).
        self.acr_assume_role_arn = acr_assume_role_arn
        # The ID of the Container Registry Enterprise Edition instance.
        self.acr_instance_id = acr_instance_id
        # The description of the application.
        self.app_description = app_description
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name
        # The SAE application type.
        # 
        # *   micro_service
        # *   web
        # *   job
        self.app_source = app_source
        # Indicates whether an elastic IP address (EIP) is associated with the application instance. Valid values:
        # 
        # *   **true**: The EIP is associated with the application instance.
        # *   **false**: The EIP is not associated with the application instance.
        self.associate_eip = associate_eip
        # The base app ID.
        self.base_app_id = base_app_id
        # The interval between batches in a phased release. Unit: seconds.
        self.batch_wait_time = batch_wait_time
        # The cluster ID.
        self.cluster_id = cluster_id
        # The command that is used to start the image. The command must be an existing executable object in the container. Example:
        # 
        # ```
        # 
        # command:
        #       - echo
        #       - abc
        #       - >
        #       - file0
        # ```
        # 
        # In this example, the Command parameter is set to `Command="echo", CommandArgs=["abc", ">", "file0"]`.
        self.command = command
        # The parameters of the image startup command. The CommandArgs parameter contains the parameters that are required for the **Command** parameter. Format:
        # 
        # `["a","b"]`
        # 
        # In the preceding **Command** example, the CommandArgs parameter is set to `CommandArgs=["abc", ">", "file0"]`. The data type of `["abc", ">", "file0"]` must be an array of strings in the JSON format. You do not need to configure this parameter if it does not exist in the Command parameter.
        self.command_args = command_args
        # The details of the ConfigMap.
        self.config_map_mount_desc = config_map_mount_desc
        # The CPU specifications that are required for each instance. Unit: millicores. You cannot set this parameter to 0. Valid values:
        # 
        # *   **500**\
        # *   **1000**\
        # *   **2000**\
        # *   **4000**\
        # *   **8000**\
        # *   **16000**\
        # *   **32000**\
        self.cpu = cpu
        # The custom mappings between hostnames and IP addresses in the container. Valid values:
        # 
        # *   **hostName**: the domain name or hostname.
        # *   **ip**: the IP address.
        self.custom_host_alias = custom_host_alias
        # The type of custom image. Set to empty string if using pre-built image.
        # 
        # - internet: public network image.
        # 
        # - intranet: private network image.
        self.custom_image_network_type = custom_image_network_type
        # The disk size. Unit: GB.
        self.disk_size = disk_size
        # The version of .NET.
        # 
        # - .NET 3.1
        # - .NET 5.0
        # - .NET 6.0
        # - .NET 7.0
        # - .NET 8.0
        self.dotnet = dotnet
        # The version of the container, such as Ali-Tomcat, in which an application developed based on High-speed Service Framework (HSF) is deployed.
        self.edas_container_version = edas_container_version
        # Indicates whether access to Application High Availability Service (AHAS) is enabled. Valid values:
        # 
        # *   **true**: Access to AHAS is enabled.
        # *   **false**: Access to AHAS is disabled.
        self.enable_ahas = enable_ahas
        # Enable CPU Burst.
        # 
        # - true: enable
        # 
        # - false: disable
        self.enable_cpu_burst = enable_cpu_burst
        # Indicates whether canary release rules are enabled. Canary release rules apply only to applications in Spring Cloud and Dubbo frameworks. Valid values:
        # 
        # *   **true**: The canary release rules are enabled.
        # *   **false**: The canary release rules are disabled.
        self.enable_grey_tag_route = enable_grey_tag_route
        # Enable idle mode.
        # 
        # - true: enable
        # 
        # - false: disable
        self.enable_idle = enable_idle
        # Enable new ARMS feature.
        # 
        # - true: enable
        # 
        # - false: disable
        self.enable_new_arms = enable_new_arms
        self.enable_prometheus = enable_prometheus
        # The environment variables. Variable description:
        # 
        # *   **name**: the name of the environment variable.
        # *   **value**: the value or reference of the environment variable.
        self.envs = envs
        self.gpu_count = gpu_count
        self.gpu_type = gpu_type
        self.html = html
        # The ID of the corresponding secret dictionary.
        self.image_pull_secrets = image_pull_secrets
        # The URL of the image. This parameter is returned only if the **PackageType** parameter is set to **Image**.
        self.image_url = image_url
        # Initialize container configuration.
        self.init_containers_config = init_containers_config
        self.is_stateful = is_stateful
        # The arguments in the JAR package. The arguments are used to start the application container. The default startup command is `$JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs`.
        self.jar_start_args = jar_start_args
        # The option settings in the JAR package. The settings are used to start the application container. The default startup command is `$JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs`.
        self.jar_start_options = jar_start_options
        # The version of the Java development kit (JDK) on which the deployment package of the application depends. The following versions are supported:
        # 
        # *   **Open JDK 8**\
        # *   **Open JDK 7**\
        # *   **Dragonwell 11**\
        # *   **Dragonwell 8**\
        # *   **openjdk-8u191-jdk-alpine3.9**\
        # *   **openjdk-7u201-jdk-alpine3.9**\
        # 
        # This parameter is not returned if the **PackageType** parameter is set to **Image**.
        self.jdk = jdk
        # The logging configurations of Message Queue for Apache Kafka. The following parameters are involved:
        # 
        # *   **KafkaConfigs**: the configurations of Message Queue for Apache Kafka.
        # 
        # *   **createTime**: the time when the Message Queue for Apache Kafka instance was created.
        # 
        # *   **kafkaTopic**: the message topic that is used to classify messages.
        # 
        # *   **logDir**: the path in which logs are stored.
        # 
        # *   **logType**: the type of collected logs. Valid values:
        # 
        #     *   **file_log**: the file log that is stored in the container. The path of the file logs in the container is returned.
        #     *   **stdout**: the standard output log of the container. You can specify only one stdout value.
        # 
        # *   **kafkaEndpoint**: the endpoint of the Message Queue for Apache Kafka service.
        # 
        # *   **kafkaInstanceId**: the ID of the Message Queue for Apache Kafka instance.
        # 
        # *   **region**: the region where the Message Queue for Apache Kafka instance resides.
        self.kafka_configs = kafka_configs
        # The details of the availability check that was performed on the container. If the container fails this health check multiple times, the system disables and restarts the container. You can use one of the following methods to perform the health check:
        # 
        # *   Sample code of the **exec** method: `{"exec":{"command":["sh","-c","cat/home/admin/start.sh"]},"initialDelaySeconds":30,"periodSeconds":30,"timeoutSeconds":2}`
        # *   Sample code of the **httpGet** method: `{"httpGet":{"path":"/","port":18091,"scheme":"HTTP","isContainKeyWord":true,"keyWord":"SAE"},"initialDelaySeconds":11,"periodSeconds":10,"timeoutSeconds":1}`
        # *   Sample code of the **tcpSocket** method: `{"tcpSocket":{"port":18091},"initialDelaySeconds":11,"periodSeconds":10,"timeoutSeconds":1}`
        # 
        # >  You can use only one method to perform the health check.
        # 
        # The following parameters are involved:
        # 
        # *   **exec.command**: the health check command.
        # *   **httpGet.path**: the request path.
        # *   **httpGet.scheme**: the protocol that is used to perform the health check. Valid values: **HTTP** and **HTTPS**.
        # *   **httpGet.isContainKeyWord**: indicates whether the response contains keywords. Valid values: **true** and **false**. If this field is not returned, the advanced settings are not used.
        # *   **httpGet.keyWord**: the custom keyword. This parameter is available only if the **isContainKeyWord** field is returned.
        # *   **tcpSocket.port**: the port that is used to check the status of TCP connections.
        # *   **initialDelaySeconds**: the delay of the health check. Default value: 10. Unit: seconds.
        # *   **periodSeconds**: the interval at which health checks are performed. Default value: 30. Unit: seconds.
        # *   **timeoutSeconds**: the timeout period of the health check. Default value: 1. Unit: seconds. If you set this parameter to 0 or leave this parameter empty, the timeout period is automatically set to 1 second.
        self.liveness = liveness
        # The size of memory required by each instance. Unit: MB. You cannot set this parameter to 0. The values of this parameter correspond to the values of the Cpu parameter:
        # 
        # *   This parameter is set to **1024** if the Cpu parameter is set to 500 or 1000.
        # *   This parameter is set to **2048** if the Cpu parameter is set to 500, 1000, or 1000.
        # *   This parameter is set to **4096** if the Cpu parameter is set to 1000, 2000, or 4000.
        # *   This parameter is set to **8192** if the Cpu parameter is set to 2000, 4000, or 8000.
        # *   This parameter is set to **12288** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **16384** if the Cpu parameter is set to 4000, 8000, or 16000.
        # *   This parameter is set to **24567** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **32768** if the Cpu parameter is set to 16000.
        # *   This parameter is set to **65536** if the Cpu parameter is set to 8000, 16000, or 32000.
        # *   This parameter is set to **131072** if the Cpu parameter is set to 32000.
        self.memory = memory
        # The Nacos registry. Valid values:
        # 
        # *   **0**: SAE built-in Nacos registry
        # *   **1**: self-managed Nacos registry
        # *   **2** : MSE Nacos registry
        self.micro_registration = micro_registration
        # The configuration of registration center. Takes effect only the type of registration center is MSE enterprise Nacos.
        self.micro_registration_config = micro_registration_config
        # Configure microservices governance
        # 
        # enable: Whether to enable microservices governance
        # 
        # - true: Enable
        # - false: Disable
        # 
        # mseLosslessRule: Configure lossless online/offline deployment
        # 
        # - delayTime: Delay duration (unit: seconds)
        # - enable: Whether to enable lossless deployment. Set to "true" to enable; set to "false" to disable.
        # - notice: Whether to enable notifications. Set to "true" to enable; set to "false" to disable.
        # - warmupTime: Small-traffic warm-up duration (unit: seconds)
        self.microservice_engine_config = microservice_engine_config
        # The percentage of the minimum number of available instances. Valid values:
        # 
        # *   **-1**: the default value. This value indicates that the minimum number of available instances is not measured by percentage. If you do not configure this parameter, the default value **-1** is used.
        # *   **0 to 100**: indicates that the minimum number of available instances is calculated by using the following formula: Current number of instances × (Value of MinReadyInstanceRatio × 100%). If the calculated result is not an integer, the result is rounded up to the nearest integer. For example, if the percentage is set to **50**% and five instances are available, the minimum number of available instances is 3.
        # 
        # >  If the **MinReadyInstance** and **MinReadyInstanceRatio** parameters are returned and the value of the **MinReadyInstanceRatio** parameter is not **-1**, the value of the **MinReadyInstanceRatio** parameter takes effect. If the **MinReadyInstances** parameter is set to **5** and the **MinReadyInstanceRatio** parameter is set to **50**, the value of the **MinReadyInstanceRatio** parameter determines the minimum number of available instances.
        self.min_ready_instance_ratio = min_ready_instance_ratio
        # The minimum number of available instances. Valid values:
        # 
        # *   If you set the value to **0**, business interruptions occur when the application is updated.
        # *   If you set the value to **-1**, the minimum number of available instances is automatically set to a system-recommended value. The value is the nearest integer to which the calculated result of the following formula is rounded up: Current number of instances × 25%. For example, if five instances are available, the minimum number of available instances is calculated by using the following formula: 5 × 25% = 1.25. In this case, the minimum number of available instances is 2.
        # 
        # >  Make sure that at least one instance is available during application deployment and rollback to prevent business interruptions.
        self.min_ready_instances = min_ready_instances
        # The details of the mounted NAS file system.
        self.mount_desc = mount_desc
        # The mount target of the NAS file system in the VPC where the application is deployed. If you do not need to modify this configuration during the deployment, configure the **MountHost** parameter only in the first request. You do not need to include this parameter in subsequent requests. If you need to remove this configuration, leave the **MountHost** parameter empty in the request.
        self.mount_host = mount_host
        # The ID of the microservice application.
        self.mse_application_id = mse_application_id
        # The application name of SAE service registered in MSE.
        self.mse_application_name = mse_application_name
        # The ID of the namespace.
        self.namespace_id = namespace_id
        # The configurations for mounting the NAS file system.
        self.nas_configs = nas_configs
        # The ID of the NAS file system.
        self.nas_id = nas_id
        # The SAE application edition.
        # 
        # - lite: The lightweight edition.
        # - std: The standard edition.
        # - pro: The professional edition.
        self.new_sae_version = new_sae_version
        # The name of the RAM role used to authenticate the user identity.
        # 
        # >  You need to create an OpenID Connect (OIDC) identity provider (IdP) and an identity provider (IdP) for role-based single sign-on (SSO) in advance. For more information, see [Creates an OpenID Connect (OIDC) identity provider (IdP)](https://help.aliyun.com/document_detail/2331022.html) and [Creates an identity provider (IdP) for role-based single sign-on (SSO)](https://help.aliyun.com/document_detail/2331016.html).
        self.oidc_role_name = oidc_role_name
        # The AccessKey ID that is used to read data from and write data to Object Storage Service (OSS) buckets.
        self.oss_ak_id = oss_ak_id
        # The AccessKey secret that is used to read data from and write data to OSS buckets.
        self.oss_ak_secret = oss_ak_secret
        # The description of the mounted OSS bucket.
        self.oss_mount_descs = oss_mount_descs
        # The type of the deployment package. Valid values:
        # 
        # *   If you deploy the application by using a Java Archive (JAR) package, you can set this parameter to **FatJar**, **War**, or **Image**.
        # 
        # *   If you deploy the application by using a PHP package, you can set this parameter to one of the following values:
        # 
        #     *   **PhpZip**\
        #     *   **IMAGE_PHP_5_4**\
        #     *   **IMAGE_PHP_5_4_ALPINE**\
        #     *   **IMAGE_PHP_5_5**\
        #     *   **IMAGE_PHP_5_5_ALPINE**\
        #     *   **IMAGE_PHP_5_6**\
        #     *   **IMAGE_PHP_5_6_ALPINE**\
        #     *   **IMAGE_PHP_7_0**\
        #     *   **IMAGE_PHP_7_0_ALPINE**\
        #     *   **IMAGE_PHP_7_1**\
        #     *   **IMAGE_PHP_7_1_ALPINE**\
        #     *   **IMAGE_PHP_7_2**\
        #     *   **IMAGE_PHP_7_2_ALPINE**\
        #     *   **IMAGE_PHP_7_3**\
        #     *   **IMAGE_PHP_7_3_ALPINE**\
        self.package_type = package_type
        # The URL of the deployment package. This parameter is returned only if the **PackageType** parameter is set to **FatJar** or **War**.
        self.package_url = package_url
        # The version of the deployment package. This parameter is returned only if the **PackageType** parameter is set to **FatJar** or **War**.
        self.package_version = package_version
        # The version of PHP supporting PHP deployment packages. Image is not supported.
        self.php = php
        # The path on which the PHP configuration file for application monitoring is mounted. Make sure that the PHP server loads the configuration file.
        # 
        # SAE automatically generates the corresponding configuration file. No manual operations are required.
        self.php_arms_config_location = php_arms_config_location
        # The details of the PHP configuration file.
        self.php_config = php_config
        # The path on which the PHP configuration file for application startup is mounted. Make sure that the PHP server uses this configuration file during the startup.
        self.php_config_location = php_config_location
        # The script that is run immediately after the container is started. Example: `{"exec":{"command":["cat","/etc/group"]}}`
        self.post_start = post_start
        # The script that is run before the container is stopped. Example: `{"exec":{"command":["cat","/etc/group"]}}`
        self.pre_stop = pre_stop
        # The programming language that is used to create the application. Valid values:
        # 
        # *   **java**: Java
        # *   **php**: PHP
        # *   **other**: Other programming languages, such as Python, C++, Go, .NET, and Node.js.
        self.programming_language = programming_language
        # Enable K8s Service discovery and registration.
        self.pvtz_discovery = pvtz_discovery
        # The Python environment. PYTHON 3.9.15 is supported.
        self.python = python
        # The configurations for installing custom module dependencies. By default, the dependencies defined by the requirements.txt file in the root directory are installed. If no software package is configured, you can specify dependencies based on your business requirements.
        self.python_modules = python_modules
        # The details of the health check that was performed on the container. If the container fails this health check multiple times, the system disables and restarts the container. Containers that fail health checks cannot receive traffic from Server Load Balancer (SLB) instances. You can use the **exec**, **httpGet**, or **tcpSocket** method to perform health checks. For more information, see the description of the **Liveness** parameter.
        # 
        # >  You can use only one method to perform the health check.
        self.readiness = readiness
        # The ID of the region.
        self.region_id = region_id
        # The number of application instances.
        self.replicas = replicas
        # The type of the resource. Set the value to `application`.
        self.resource_type = resource_type
        # Secret mount description.
        self.secret_mount_desc = secret_mount_desc
        # The ID of the security group.
        self.security_group_id = security_group_id
        # The canary tag configured for the application.
        self.service_tags = service_tags
        # The configuration of the Sidecar container.
        self.sidecar_containers_config = sidecar_containers_config
        # The logging configurations of Log Service.
        # 
        # *   To use Log Service resources that are automatically created by SAE, set this parameter to `[{"logDir":"","logType":"stdout"},{"logDir":"/tmp/a.log"}]`.
        # *   To use custom Log Service resources, set this parameter to `[{"projectName":"test-sls","logType":"stdout","logDir":"","logstoreName":"sae","logtailName":""},{"projectName":"test","logDir":"/tmp/a.log","logstoreName":"sae","logtailName":""}]`.
        # 
        # The following parameters are involved:
        # 
        # *   **projectName**: the name of the Log Service project.
        # *   **logDir**: the path in which logs are stored.
        # *   **logType**: the log type. **stdout**: the standard output log of the container. You can specify only one stdout value for this parameter. If you leave this parameter empty, file logs are collected.
        # *   **logstoreName**: the name of the Logstore in Log Service.
        # *   **logtailName**: the name of the Logtail configuration in Log Service. If you do not configure this parameter, a new Logtail configuration is created.
        # 
        # If you do not need to modify the logging configurations when you deploy the application, configure the **SlsConfigs** parameter only in the first request. You do not need to include this parameter in subsequent requests. If you no longer need to use Log Service, leave the **SlsConfigs** parameter empty in the request.
        self.sls_configs = sls_configs
        # Enable startup probe.
        self.startup_probe = startup_probe
        # Configuration of K8s Service discovery and registration, and full-chain gray-release feature.
        self.swimlane_pvtz_discovery = swimlane_pvtz_discovery
        # The details of the tags.
        self.tags = tags
        # The timeout period for a graceful shutdown. Default value: 30. Unit: seconds. Valid values: 1 to 300.
        self.termination_grace_period_seconds = termination_grace_period_seconds
        # The time zone. Default value: **Asia/Shanghai**.
        self.timezone = timezone
        # The Tomcat configuration. If you want to delete the configuration, set this parameter to {} or leave this parameter empty. The following parameters are involved:
        # 
        # *   **port**: the port number. Valid values: 1024 to 65535. The root permissions are required to perform operations on ports whose number is smaller than 1024. Enter a value that ranges from 1025 to 65535 because the container has only the admin permissions. If you do not configure this parameter, the default port number 8080 is used.
        # *   **contextPath**: the path. Default value: /. This value indicates the root directory.
        # *   **maxThreads**: the maximum number of connections in the connection pool. Default value: 400.
        # *   **uriEncoding**: the URI encoding scheme in the Tomcat container. Valid values: **UTF-8**, **ISO-8859-1**, **GBK**, and **GB2312**. If you do not configure this parameter, the default value **ISO-8859-1** is used.
        # *   **useBodyEncoding**: indicates whether to use the encoding scheme that is specified by **BodyEncoding for URL**. Default value: **true**.
        self.tomcat_config = tomcat_config
        # The deployment policy. If the minimum number of available instances is 1, the value of the **UpdateStrategy** parameter is an empty string (""). If the minimum number of available instances is greater than 1, the following strategies can be configured:
        # 
        # *   The application is deployed on an instance. The remaining instances are automatically classified into two release batches whose interval is set to 1. In this case, the parameter is set to `{"type":"GrayBatchUpdate","batchUpdate":{"batch":2,"releaseType":"auto","batchWaitTime":1},"grayUpdate":{"gray":1}}`.
        # *   The application is deployed on an instance. The remaining instances are manually classified into two release batches. In this case, the parameter is set to `{"type":"GrayBatchUpdate","batchUpdate":{"batch":2,"releaseType":"manual"},"grayUpdate":{"gray":1}}`.
        # *   All instances are automatically classified into two release batches. The application is deployed on the instances of the two batches in parallel. In this case, the parameter is set to `{"type":"BatchUpdate","batchUpdate":{"batch":2,"releaseType":"auto","batchWaitTime":0}}`
        # 
        # The following parameters are involved:
        # 
        # *   **type**: the type of the release policy. Valid values: **GrayBatchUpdate** and **BatchUpdate**.
        # 
        # *   **batchUpdate**: the phased release policy.
        # 
        #     *   **batch**: the number of release batches.
        #     *   **releaseType**: the processing method for the batches. Valid values: **auto** and **manual**.
        #     *   **batchWaitTime**: the interval between release batches. Unit: seconds.
        # 
        # *   **grayUpdate**: the number of release batches in the phased release after a canary release. This parameter is returned only if the **type** parameter is set to **GrayBatchUpdate**.
        self.update_strategy = update_strategy
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id
        # The option settings in the WAR package. The settings are used to start the application container. The default startup command is `java $JAVA_OPTS $CATALINA_OPTS -Options org.apache.catalina.startup.Bootstrap "$@" start`.
        self.war_start_options = war_start_options
        # The version of the Tomcat container on which the deployment package depends. Valid values:
        # 
        # *   **apache-tomcat-7.0.91**\
        # *   **apache-tomcat-8.5.42**\
        # 
        # This parameter is not returned if the **PackageType** parameter is set to **Image**.
        self.web_container = web_container

    def validate(self):
        if self.config_map_mount_desc:
            for k in self.config_map_mount_desc:
                if k:
                    k.validate()
        if self.init_containers_config:
            for k in self.init_containers_config:
                if k:
                    k.validate()
        if self.mount_desc:
            for k in self.mount_desc:
                if k:
                    k.validate()
        if self.oss_mount_descs:
            for k in self.oss_mount_descs:
                if k:
                    k.validate()
        if self.secret_mount_desc:
            for k in self.secret_mount_desc:
                if k:
                    k.validate()
        if self.sidecar_containers_config:
            for k in self.sidecar_containers_config:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acr_assume_role_arn is not None:
            result['AcrAssumeRoleArn'] = self.acr_assume_role_arn
        if self.acr_instance_id is not None:
            result['AcrInstanceId'] = self.acr_instance_id
        if self.app_description is not None:
            result['AppDescription'] = self.app_description
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.app_source is not None:
            result['AppSource'] = self.app_source
        if self.associate_eip is not None:
            result['AssociateEip'] = self.associate_eip
        if self.base_app_id is not None:
            result['BaseAppId'] = self.base_app_id
        if self.batch_wait_time is not None:
            result['BatchWaitTime'] = self.batch_wait_time
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        result['ConfigMapMountDesc'] = []
        if self.config_map_mount_desc is not None:
            for k in self.config_map_mount_desc:
                result['ConfigMapMountDesc'].append(k.to_map() if k else None)
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.custom_host_alias is not None:
            result['CustomHostAlias'] = self.custom_host_alias
        if self.custom_image_network_type is not None:
            result['CustomImageNetworkType'] = self.custom_image_network_type
        if self.disk_size is not None:
            result['DiskSize'] = self.disk_size
        if self.dotnet is not None:
            result['Dotnet'] = self.dotnet
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        if self.enable_ahas is not None:
            result['EnableAhas'] = self.enable_ahas
        if self.enable_cpu_burst is not None:
            result['EnableCpuBurst'] = self.enable_cpu_burst
        if self.enable_grey_tag_route is not None:
            result['EnableGreyTagRoute'] = self.enable_grey_tag_route
        if self.enable_idle is not None:
            result['EnableIdle'] = self.enable_idle
        if self.enable_new_arms is not None:
            result['EnableNewArms'] = self.enable_new_arms
        if self.enable_prometheus is not None:
            result['EnablePrometheus'] = self.enable_prometheus
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.gpu_count is not None:
            result['GpuCount'] = self.gpu_count
        if self.gpu_type is not None:
            result['GpuType'] = self.gpu_type
        if self.html is not None:
            result['Html'] = self.html
        if self.image_pull_secrets is not None:
            result['ImagePullSecrets'] = self.image_pull_secrets
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        result['InitContainersConfig'] = []
        if self.init_containers_config is not None:
            for k in self.init_containers_config:
                result['InitContainersConfig'].append(k.to_map() if k else None)
        if self.is_stateful is not None:
            result['IsStateful'] = self.is_stateful
        if self.jar_start_args is not None:
            result['JarStartArgs'] = self.jar_start_args
        if self.jar_start_options is not None:
            result['JarStartOptions'] = self.jar_start_options
        if self.jdk is not None:
            result['Jdk'] = self.jdk
        if self.kafka_configs is not None:
            result['KafkaConfigs'] = self.kafka_configs
        if self.liveness is not None:
            result['Liveness'] = self.liveness
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.micro_registration is not None:
            result['MicroRegistration'] = self.micro_registration
        if self.micro_registration_config is not None:
            result['MicroRegistrationConfig'] = self.micro_registration_config
        if self.microservice_engine_config is not None:
            result['MicroserviceEngineConfig'] = self.microservice_engine_config
        if self.min_ready_instance_ratio is not None:
            result['MinReadyInstanceRatio'] = self.min_ready_instance_ratio
        if self.min_ready_instances is not None:
            result['MinReadyInstances'] = self.min_ready_instances
        result['MountDesc'] = []
        if self.mount_desc is not None:
            for k in self.mount_desc:
                result['MountDesc'].append(k.to_map() if k else None)
        if self.mount_host is not None:
            result['MountHost'] = self.mount_host
        if self.mse_application_id is not None:
            result['MseApplicationId'] = self.mse_application_id
        if self.mse_application_name is not None:
            result['MseApplicationName'] = self.mse_application_name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.nas_configs is not None:
            result['NasConfigs'] = self.nas_configs
        if self.nas_id is not None:
            result['NasId'] = self.nas_id
        if self.new_sae_version is not None:
            result['NewSaeVersion'] = self.new_sae_version
        if self.oidc_role_name is not None:
            result['OidcRoleName'] = self.oidc_role_name
        if self.oss_ak_id is not None:
            result['OssAkId'] = self.oss_ak_id
        if self.oss_ak_secret is not None:
            result['OssAkSecret'] = self.oss_ak_secret
        result['OssMountDescs'] = []
        if self.oss_mount_descs is not None:
            for k in self.oss_mount_descs:
                result['OssMountDescs'].append(k.to_map() if k else None)
        if self.package_type is not None:
            result['PackageType'] = self.package_type
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.php is not None:
            result['Php'] = self.php
        if self.php_arms_config_location is not None:
            result['PhpArmsConfigLocation'] = self.php_arms_config_location
        if self.php_config is not None:
            result['PhpConfig'] = self.php_config
        if self.php_config_location is not None:
            result['PhpConfigLocation'] = self.php_config_location
        if self.post_start is not None:
            result['PostStart'] = self.post_start
        if self.pre_stop is not None:
            result['PreStop'] = self.pre_stop
        if self.programming_language is not None:
            result['ProgrammingLanguage'] = self.programming_language
        if self.pvtz_discovery is not None:
            result['PvtzDiscovery'] = self.pvtz_discovery
        if self.python is not None:
            result['Python'] = self.python
        if self.python_modules is not None:
            result['PythonModules'] = self.python_modules
        if self.readiness is not None:
            result['Readiness'] = self.readiness
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        result['SecretMountDesc'] = []
        if self.secret_mount_desc is not None:
            for k in self.secret_mount_desc:
                result['SecretMountDesc'].append(k.to_map() if k else None)
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.service_tags is not None:
            result['ServiceTags'] = self.service_tags
        result['SidecarContainersConfig'] = []
        if self.sidecar_containers_config is not None:
            for k in self.sidecar_containers_config:
                result['SidecarContainersConfig'].append(k.to_map() if k else None)
        if self.sls_configs is not None:
            result['SlsConfigs'] = self.sls_configs
        if self.startup_probe is not None:
            result['StartupProbe'] = self.startup_probe
        if self.swimlane_pvtz_discovery is not None:
            result['SwimlanePvtzDiscovery'] = self.swimlane_pvtz_discovery
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.termination_grace_period_seconds is not None:
            result['TerminationGracePeriodSeconds'] = self.termination_grace_period_seconds
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.tomcat_config is not None:
            result['TomcatConfig'] = self.tomcat_config
        if self.update_strategy is not None:
            result['UpdateStrategy'] = self.update_strategy
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.war_start_options is not None:
            result['WarStartOptions'] = self.war_start_options
        if self.web_container is not None:
            result['WebContainer'] = self.web_container
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcrAssumeRoleArn') is not None:
            self.acr_assume_role_arn = m.get('AcrAssumeRoleArn')
        if m.get('AcrInstanceId') is not None:
            self.acr_instance_id = m.get('AcrInstanceId')
        if m.get('AppDescription') is not None:
            self.app_description = m.get('AppDescription')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AppSource') is not None:
            self.app_source = m.get('AppSource')
        if m.get('AssociateEip') is not None:
            self.associate_eip = m.get('AssociateEip')
        if m.get('BaseAppId') is not None:
            self.base_app_id = m.get('BaseAppId')
        if m.get('BatchWaitTime') is not None:
            self.batch_wait_time = m.get('BatchWaitTime')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        self.config_map_mount_desc = []
        if m.get('ConfigMapMountDesc') is not None:
            for k in m.get('ConfigMapMountDesc'):
                temp_model = DescribeApplicationConfigResponseBodyDataConfigMapMountDesc()
                self.config_map_mount_desc.append(temp_model.from_map(k))
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CustomHostAlias') is not None:
            self.custom_host_alias = m.get('CustomHostAlias')
        if m.get('CustomImageNetworkType') is not None:
            self.custom_image_network_type = m.get('CustomImageNetworkType')
        if m.get('DiskSize') is not None:
            self.disk_size = m.get('DiskSize')
        if m.get('Dotnet') is not None:
            self.dotnet = m.get('Dotnet')
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        if m.get('EnableAhas') is not None:
            self.enable_ahas = m.get('EnableAhas')
        if m.get('EnableCpuBurst') is not None:
            self.enable_cpu_burst = m.get('EnableCpuBurst')
        if m.get('EnableGreyTagRoute') is not None:
            self.enable_grey_tag_route = m.get('EnableGreyTagRoute')
        if m.get('EnableIdle') is not None:
            self.enable_idle = m.get('EnableIdle')
        if m.get('EnableNewArms') is not None:
            self.enable_new_arms = m.get('EnableNewArms')
        if m.get('EnablePrometheus') is not None:
            self.enable_prometheus = m.get('EnablePrometheus')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('GpuCount') is not None:
            self.gpu_count = m.get('GpuCount')
        if m.get('GpuType') is not None:
            self.gpu_type = m.get('GpuType')
        if m.get('Html') is not None:
            self.html = m.get('Html')
        if m.get('ImagePullSecrets') is not None:
            self.image_pull_secrets = m.get('ImagePullSecrets')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        self.init_containers_config = []
        if m.get('InitContainersConfig') is not None:
            for k in m.get('InitContainersConfig'):
                temp_model = DescribeApplicationConfigResponseBodyDataInitContainersConfig()
                self.init_containers_config.append(temp_model.from_map(k))
        if m.get('IsStateful') is not None:
            self.is_stateful = m.get('IsStateful')
        if m.get('JarStartArgs') is not None:
            self.jar_start_args = m.get('JarStartArgs')
        if m.get('JarStartOptions') is not None:
            self.jar_start_options = m.get('JarStartOptions')
        if m.get('Jdk') is not None:
            self.jdk = m.get('Jdk')
        if m.get('KafkaConfigs') is not None:
            self.kafka_configs = m.get('KafkaConfigs')
        if m.get('Liveness') is not None:
            self.liveness = m.get('Liveness')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('MicroRegistration') is not None:
            self.micro_registration = m.get('MicroRegistration')
        if m.get('MicroRegistrationConfig') is not None:
            self.micro_registration_config = m.get('MicroRegistrationConfig')
        if m.get('MicroserviceEngineConfig') is not None:
            self.microservice_engine_config = m.get('MicroserviceEngineConfig')
        if m.get('MinReadyInstanceRatio') is not None:
            self.min_ready_instance_ratio = m.get('MinReadyInstanceRatio')
        if m.get('MinReadyInstances') is not None:
            self.min_ready_instances = m.get('MinReadyInstances')
        self.mount_desc = []
        if m.get('MountDesc') is not None:
            for k in m.get('MountDesc'):
                temp_model = DescribeApplicationConfigResponseBodyDataMountDesc()
                self.mount_desc.append(temp_model.from_map(k))
        if m.get('MountHost') is not None:
            self.mount_host = m.get('MountHost')
        if m.get('MseApplicationId') is not None:
            self.mse_application_id = m.get('MseApplicationId')
        if m.get('MseApplicationName') is not None:
            self.mse_application_name = m.get('MseApplicationName')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NasConfigs') is not None:
            self.nas_configs = m.get('NasConfigs')
        if m.get('NasId') is not None:
            self.nas_id = m.get('NasId')
        if m.get('NewSaeVersion') is not None:
            self.new_sae_version = m.get('NewSaeVersion')
        if m.get('OidcRoleName') is not None:
            self.oidc_role_name = m.get('OidcRoleName')
        if m.get('OssAkId') is not None:
            self.oss_ak_id = m.get('OssAkId')
        if m.get('OssAkSecret') is not None:
            self.oss_ak_secret = m.get('OssAkSecret')
        self.oss_mount_descs = []
        if m.get('OssMountDescs') is not None:
            for k in m.get('OssMountDescs'):
                temp_model = DescribeApplicationConfigResponseBodyDataOssMountDescs()
                self.oss_mount_descs.append(temp_model.from_map(k))
        if m.get('PackageType') is not None:
            self.package_type = m.get('PackageType')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('Php') is not None:
            self.php = m.get('Php')
        if m.get('PhpArmsConfigLocation') is not None:
            self.php_arms_config_location = m.get('PhpArmsConfigLocation')
        if m.get('PhpConfig') is not None:
            self.php_config = m.get('PhpConfig')
        if m.get('PhpConfigLocation') is not None:
            self.php_config_location = m.get('PhpConfigLocation')
        if m.get('PostStart') is not None:
            self.post_start = m.get('PostStart')
        if m.get('PreStop') is not None:
            self.pre_stop = m.get('PreStop')
        if m.get('ProgrammingLanguage') is not None:
            self.programming_language = m.get('ProgrammingLanguage')
        if m.get('PvtzDiscovery') is not None:
            self.pvtz_discovery = m.get('PvtzDiscovery')
        if m.get('Python') is not None:
            self.python = m.get('Python')
        if m.get('PythonModules') is not None:
            self.python_modules = m.get('PythonModules')
        if m.get('Readiness') is not None:
            self.readiness = m.get('Readiness')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        self.secret_mount_desc = []
        if m.get('SecretMountDesc') is not None:
            for k in m.get('SecretMountDesc'):
                temp_model = DescribeApplicationConfigResponseBodyDataSecretMountDesc()
                self.secret_mount_desc.append(temp_model.from_map(k))
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('ServiceTags') is not None:
            self.service_tags = m.get('ServiceTags')
        self.sidecar_containers_config = []
        if m.get('SidecarContainersConfig') is not None:
            for k in m.get('SidecarContainersConfig'):
                temp_model = DescribeApplicationConfigResponseBodyDataSidecarContainersConfig()
                self.sidecar_containers_config.append(temp_model.from_map(k))
        if m.get('SlsConfigs') is not None:
            self.sls_configs = m.get('SlsConfigs')
        if m.get('StartupProbe') is not None:
            self.startup_probe = m.get('StartupProbe')
        if m.get('SwimlanePvtzDiscovery') is not None:
            self.swimlane_pvtz_discovery = m.get('SwimlanePvtzDiscovery')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = DescribeApplicationConfigResponseBodyDataTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TerminationGracePeriodSeconds') is not None:
            self.termination_grace_period_seconds = m.get('TerminationGracePeriodSeconds')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('TomcatConfig') is not None:
            self.tomcat_config = m.get('TomcatConfig')
        if m.get('UpdateStrategy') is not None:
            self.update_strategy = m.get('UpdateStrategy')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('WarStartOptions') is not None:
            self.war_start_options = m.get('WarStartOptions')
        if m.get('WebContainer') is not None:
            self.web_container = m.get('WebContainer')
        return self


class DescribeApplicationConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeApplicationConfigResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The information about the application.
        self.data = data
        # The returned error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned information.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the configurations of an application were obtained. Valid values:
        # 
        # *   **true**: The configurations were obtained.
        # *   **false**: The configurations failed to be obtained.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeApplicationConfigResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeApplicationConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApplicationConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApplicationConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApplicationGroupsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        current_page: int = None,
        page_size: int = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The page number.
        self.current_page = current_page
        # The number of entries per page.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeApplicationGroupsResponseBodyData(TeaModel):
    def __init__(
        self,
        edas_container_version: str = None,
        group_id: str = None,
        group_name: str = None,
        group_type: int = None,
        image_url: str = None,
        jdk: str = None,
        package_type: str = None,
        package_url: str = None,
        package_version: str = None,
        package_version_id: str = None,
        replicas: int = None,
        running_instances: int = None,
        web_container: str = None,
    ):
        # The version of the container, such as Ali-Tomcat, in which an application that is developed based on High-speed Service Framework (HSF) is deployed.
        self.edas_container_version = edas_container_version
        # The ID of the instance group.
        self.group_id = group_id
        # The name of the instance group.
        self.group_name = group_name
        # The type of the instance group.
        self.group_type = group_type
        # The URL of the image. This parameter is returned only if the **PackageType** parameter is set to **Image**.
        self.image_url = image_url
        # The version of the JDK on which the deployment package of the application depends. This parameter is not returned if the **PackageType** parameter is set to **Image**.
        self.jdk = jdk
        # The type of the deployment package. Valid values:
        # 
        # *   If you deploy a Java application, the value of this parameter can be **FatJar**, **War**, or **Image**.
        # 
        # *   If you deploy a PHP application, the value of this parameter can be one of the following values:
        # 
        #     *   **PhpZip**\
        #     *   **IMAGE_PHP_5_4**\
        #     *   **IMAGE_PHP_5_4_ALPINE**\
        #     *   **IMAGE_PHP_5_5**\
        #     *   **IMAGE_PHP_5_5_ALPINE**\
        #     *   **IMAGE_PHP_5_6**\
        #     *   **IMAGE_PHP_5_6_ALPINE**\
        #     *   **IMAGE_PHP_7_0**\
        #     *   **IMAGE_PHP_7_0_ALPINE**\
        #     *   **IMAGE_PHP_7_1**\
        #     *   **IMAGE_PHP_7_1_ALPINE**\
        #     *   **IMAGE_PHP_7_2**\
        #     *   **IMAGE_PHP_7_2_ALPINE**\
        #     *   **IMAGE_PHP_7_3**\
        #     *   **IMAGE_PHP_7_3_ALPINE**\
        self.package_type = package_type
        # The URL of the deployment package. This parameter is returned only if the **PackageType** parameter is set to **FatJar**, **War**, or **PhpZip**.
        self.package_url = package_url
        # The version of the deployment package. This parameter is returned only if the **PackageType** parameter is set to **FatJar**, **War**, or **PhpZip**. The value of this parameter is automatically generated only if the **ImageUrl** is returned.
        self.package_version = package_version
        self.package_version_id = package_version_id
        # The total number of instances.
        self.replicas = replicas
        # The number of running instances.
        self.running_instances = running_instances
        # The version of the Tomcat container on which the deployment package depends. This parameter is not returned if the **PackageType** parameter is set to **Image**.
        self.web_container = web_container

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.jdk is not None:
            result['Jdk'] = self.jdk
        if self.package_type is not None:
            result['PackageType'] = self.package_type
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.package_version_id is not None:
            result['PackageVersionId'] = self.package_version_id
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.running_instances is not None:
            result['RunningInstances'] = self.running_instances
        if self.web_container is not None:
            result['WebContainer'] = self.web_container
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('Jdk') is not None:
            self.jdk = m.get('Jdk')
        if m.get('PackageType') is not None:
            self.package_type = m.get('PackageType')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('PackageVersionId') is not None:
            self.package_version_id = m.get('PackageVersionId')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('RunningInstances') is not None:
            self.running_instances = m.get('RunningInstances')
        if m.get('WebContainer') is not None:
            self.web_container = m.get('WebContainer')
        return self


class DescribeApplicationGroupsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[DescribeApplicationGroupsResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The information about the instance groups of the application.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the instance groups of an application were obtained. Valid values:
        # 
        # *   **true**: The instance groups were obtained.
        # *   **false**: The instance groups failed to be obtained.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeApplicationGroupsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeApplicationGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApplicationGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApplicationGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApplicationImageRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        image_url: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The URL of the image.
        # 
        # This parameter is required.
        self.image_url = image_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        return self


class DescribeApplicationImageResponseBodyData(TeaModel):
    def __init__(
        self,
        cr_url: str = None,
        logo: str = None,
        region_id: str = None,
        repo_name: str = None,
        repo_namespace: str = None,
        repo_origin_type: str = None,
        repo_tag: str = None,
        repo_type: str = None,
    ):
        # This parameter is reserved.
        self.cr_url = cr_url
        # This parameter is reserved.
        self.logo = logo
        # The region ID.
        self.region_id = region_id
        # The name of the repository.
        self.repo_name = repo_name
        # The name of the namespace to which the image repository belongs.
        self.repo_namespace = repo_namespace
        # The type of the repository. Only Container Registry is supported.
        self.repo_origin_type = repo_origin_type
        # The tag of the image.
        self.repo_tag = repo_tag
        # This parameter is reserved.
        self.repo_type = repo_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cr_url is not None:
            result['CrUrl'] = self.cr_url
        if self.logo is not None:
            result['Logo'] = self.logo
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repo_name is not None:
            result['RepoName'] = self.repo_name
        if self.repo_namespace is not None:
            result['RepoNamespace'] = self.repo_namespace
        if self.repo_origin_type is not None:
            result['RepoOriginType'] = self.repo_origin_type
        if self.repo_tag is not None:
            result['RepoTag'] = self.repo_tag
        if self.repo_type is not None:
            result['RepoType'] = self.repo_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CrUrl') is not None:
            self.cr_url = m.get('CrUrl')
        if m.get('Logo') is not None:
            self.logo = m.get('Logo')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepoName') is not None:
            self.repo_name = m.get('RepoName')
        if m.get('RepoNamespace') is not None:
            self.repo_namespace = m.get('RepoNamespace')
        if m.get('RepoOriginType') is not None:
            self.repo_origin_type = m.get('RepoOriginType')
        if m.get('RepoTag') is not None:
            self.repo_tag = m.get('RepoTag')
        if m.get('RepoType') is not None:
            self.repo_type = m.get('RepoType')
        return self


class DescribeApplicationImageResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeApplicationImageResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The information about the image of the application.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the information about the image was obtained. Valid values:
        # 
        # *   **true**: The information was obtained.
        # *   **false**: The information failed to be obtained.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeApplicationImageResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeApplicationImageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApplicationImageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApplicationImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApplicationInstancesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        current_page: int = None,
        group_id: str = None,
        instance_id: str = None,
        page_size: int = None,
        pipeline_id: str = None,
        reverse: bool = None,
    ):
        # d700e680-aa4d-4ec1-afc2-6566b5ff\\*\\*\\*\\*\
        # 
        # This parameter is required.
        self.app_id = app_id
        # 1
        self.current_page = current_page
        # b2a8a925-477a-4ed7-b825-d5e22500\\*\\*\\*\\*\
        # 
        # This parameter is required.
        self.group_id = group_id
        # The ID of the application instance.
        self.instance_id = instance_id
        # 10
        self.page_size = page_size
        self.pipeline_id = pipeline_id
        # true
        self.reverse = reverse

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.reverse is not None:
            result['Reverse'] = self.reverse
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Reverse') is not None:
            self.reverse = m.get('Reverse')
        return self


class DescribeApplicationInstancesResponseBodyDataInstancesSidecarContainersStatus(TeaModel):
    def __init__(
        self,
        container_id: str = None,
        container_status: str = None,
        image_url: str = None,
    ):
        # The ID of the sidecar container.
        self.container_id = container_id
        # The status of the container.
        self.container_status = container_status
        # The URL of the image.
        self.image_url = image_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.container_status is not None:
            result['ContainerStatus'] = self.container_status
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('ContainerStatus') is not None:
            self.container_status = m.get('ContainerStatus')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        return self


class DescribeApplicationInstancesResponseBodyDataInstances(TeaModel):
    def __init__(
        self,
        create_time_stamp: int = None,
        debug_status: bool = None,
        eip: str = None,
        finish_time_stamp: int = None,
        group_id: str = None,
        image_url: str = None,
        instance_container_ip: str = None,
        instance_container_restarts: int = None,
        instance_container_status: str = None,
        instance_health_status: str = None,
        instance_id: str = None,
        main_container_status: str = None,
        package_version: str = None,
        sidecar_containers_status: List[DescribeApplicationInstancesResponseBodyDataInstancesSidecarContainersStatus] = None,
        timestamp: int = None,
        unhealthy_message: str = None,
        v_switch_id: str = None,
    ):
        # The start time of the instance creation process. Unit: milliseconds.
        self.create_time_stamp = create_time_stamp
        self.debug_status = debug_status
        # The elastic IP address (EIP).
        self.eip = eip
        # The end time of the instance creation process. Unit: milliseconds.
        self.finish_time_stamp = finish_time_stamp
        # The ID of the group to which the instance belongs.
        self.group_id = group_id
        # The address of the repository.
        # 
        # >  If you deploy the application by using a JAR or WAR package, the image generated by SAE is not available for download.
        self.image_url = image_url
        # The internal IP address of the instance.
        self.instance_container_ip = instance_container_ip
        # The number of times that the instance restarted.
        self.instance_container_restarts = instance_container_restarts
        # The state of the instance. Valid values:
        # 
        # *   **Error**: An error occurred during the instance startup.
        # *   **CrashLoopBackOff**: The container failed to start. An error occurred during the startup process and persisted after the restart.
        # *   **ErrImagePull**: An error occurred while the container image was being pulled from the instance.
        # *   **ImagePullBackOff**: The container image could not be obtained.
        # *   **Pending**: The instance is waiting to be scheduled.
        # *   **Unknown**: An unknown exception occurred.
        # *   **Terminating**: The instance creation process is being terminated.
        # *   **NotFound**: The instance cannot be found.
        # *   **PodInitializing**: The instance is being initialized.
        # *   **Init:0/1**: The instance is initialized.
        # *   **Running**: The instance is running.
        self.instance_container_status = instance_container_status
        # The configurations of health checks. Valid values:
        # 
        # *   **WithoutHealthCheckConfig**: Liveness and readiness checks are not configured.
        # *   **WithoutLivenessConfig**: The liveness check is not configured.
        # *   **WithoutReadinessConfig**: The readiness check is not configured.
        # *   **NotCheckedYet**: The health checks are not performed or are in progress.
        # *   **LivenessUnhealthy**: The instance failed the liveness check.
        # *   **ReadinessUnhealthy**: The instance failed the readiness check.
        # *   **Unhealthy**: The instance failed both liveness and readiness checks.
        # *   **Healthy**: The instance passed both liveness and readiness checks.
        self.instance_health_status = instance_health_status
        # The ID of the instance.
        self.instance_id = instance_id
        # The status of the main container.
        self.main_container_status = main_container_status
        # The version of the package.
        self.package_version = package_version
        # The status of the sidecar container.
        self.sidecar_containers_status = sidecar_containers_status
        self.timestamp = timestamp
        # If the health check of an application instance fails, the detailed failure cause or error message is returned. If the health check of an application instance passes, no response is returned.
        self.unhealthy_message = unhealthy_message
        # The ID of the zone where the instance is deployed.
        self.v_switch_id = v_switch_id

    def validate(self):
        if self.sidecar_containers_status:
            for k in self.sidecar_containers_status:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time_stamp is not None:
            result['CreateTimeStamp'] = self.create_time_stamp
        if self.debug_status is not None:
            result['DebugStatus'] = self.debug_status
        if self.eip is not None:
            result['Eip'] = self.eip
        if self.finish_time_stamp is not None:
            result['FinishTimeStamp'] = self.finish_time_stamp
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.instance_container_ip is not None:
            result['InstanceContainerIp'] = self.instance_container_ip
        if self.instance_container_restarts is not None:
            result['InstanceContainerRestarts'] = self.instance_container_restarts
        if self.instance_container_status is not None:
            result['InstanceContainerStatus'] = self.instance_container_status
        if self.instance_health_status is not None:
            result['InstanceHealthStatus'] = self.instance_health_status
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.main_container_status is not None:
            result['MainContainerStatus'] = self.main_container_status
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        result['SidecarContainersStatus'] = []
        if self.sidecar_containers_status is not None:
            for k in self.sidecar_containers_status:
                result['SidecarContainersStatus'].append(k.to_map() if k else None)
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.unhealthy_message is not None:
            result['UnhealthyMessage'] = self.unhealthy_message
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTimeStamp') is not None:
            self.create_time_stamp = m.get('CreateTimeStamp')
        if m.get('DebugStatus') is not None:
            self.debug_status = m.get('DebugStatus')
        if m.get('Eip') is not None:
            self.eip = m.get('Eip')
        if m.get('FinishTimeStamp') is not None:
            self.finish_time_stamp = m.get('FinishTimeStamp')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('InstanceContainerIp') is not None:
            self.instance_container_ip = m.get('InstanceContainerIp')
        if m.get('InstanceContainerRestarts') is not None:
            self.instance_container_restarts = m.get('InstanceContainerRestarts')
        if m.get('InstanceContainerStatus') is not None:
            self.instance_container_status = m.get('InstanceContainerStatus')
        if m.get('InstanceHealthStatus') is not None:
            self.instance_health_status = m.get('InstanceHealthStatus')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MainContainerStatus') is not None:
            self.main_container_status = m.get('MainContainerStatus')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        self.sidecar_containers_status = []
        if m.get('SidecarContainersStatus') is not None:
            for k in m.get('SidecarContainersStatus'):
                temp_model = DescribeApplicationInstancesResponseBodyDataInstancesSidecarContainersStatus()
                self.sidecar_containers_status.append(temp_model.from_map(k))
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UnhealthyMessage') is not None:
            self.unhealthy_message = m.get('UnhealthyMessage')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeApplicationInstancesResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        instances: List[DescribeApplicationInstancesResponseBodyDataInstances] = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # The number of the returned page.
        self.current_page = current_page
        # The application instances.
        self.instances = instances
        # The number of entries returned on each page.
        self.page_size = page_size
        # The total number of returned instances.
        self.total_size = total_size

    def validate(self):
        if self.instances:
            for k in self.instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['Instances'] = []
        if self.instances is not None:
            for k in self.instances:
                result['Instances'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.instances = []
        if m.get('Instances') is not None:
            for k in m.get('Instances'):
                temp_model = DescribeApplicationInstancesResponseBodyDataInstances()
                self.instances.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class DescribeApplicationInstancesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeApplicationInstancesResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The details of the application instance.
        self.data = data
        # The error code. 
        # 
        # - The **ErrorCode** parameter is not returned when the request succeeds.
        # - The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the list of application instances was obtained. Valid values:
        # 
        # *   **true**: indicates that the list was obtained.
        # *   **false**: indicates that the list could not be obtained.
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeApplicationInstancesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeApplicationInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApplicationInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApplicationInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApplicationNlbsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DescribeApplicationNlbsResponseBodyData(TeaModel):
    def __init__(
        self,
        instances: Dict[str, DataInstancesValue] = None,
    ):
        # The details of the instance.
        self.instances = instances

    def validate(self):
        if self.instances:
            for v in self.instances.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instances'] = {}
        if self.instances is not None:
            for k, v in self.instances.items():
                result['Instances'][k] = v.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instances = {}
        if m.get('Instances') is not None:
            for k, v in m.get('Instances').items():
                temp_model = DataInstancesValue()
                self.instances[k] = temp_model.from_map(v)
        return self


class DescribeApplicationNlbsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeApplicationNlbsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: str = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The request was successful.
        # *   **3xx**: The request was redirected.
        # *   **4xx**: The request failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The status code. Value values:
        # 
        # *   If the request was successful, **ErrorCode** is not returned.
        # *   If the request failed, **ErrorCode** is returned. For more information, see **Error codes** section in this topic.
        self.error_code = error_code
        # The message returned. Valid values:If the request was successful, success is returned. If the request failed, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the NLB instance was successfully associated with the application. Valid values:
        # 
        # *   **true**: The application was associated.
        # *   **false**: The application failed to be associated.
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeApplicationNlbsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeApplicationNlbsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApplicationNlbsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApplicationNlbsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApplicationScalingRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        scaling_rule_name: str = None,
    ):
        # a0d2e04c-159d-40a8-b240-d2f2c263\\*\\*\\*\\*\
        # 
        # This parameter is required.
        self.app_id = app_id
        # test
        # 
        # This parameter is required.
        self.scaling_rule_name = scaling_rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.scaling_rule_name is not None:
            result['ScalingRuleName'] = self.scaling_rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ScalingRuleName') is not None:
            self.scaling_rule_name = m.get('ScalingRuleName')
        return self


class DescribeApplicationScalingRuleResponseBodyDataMetricMetrics(TeaModel):
    def __init__(
        self,
        metric_target_average_utilization: int = None,
        metric_type: str = None,
        slb_id: str = None,
        slb_logstore: str = None,
        slb_project: str = None,
        vport: str = None,
    ):
        # The limit on the metric.
        # 
        # *   The limit on the CPU utilization. Unit: percentage.
        # *   The limit on the memory usage. Unit: percentage.
        # *   The limit on the average number of active TCP connections per second.
        # *   The limit on the QPS of the Internet-facing SLB instance.
        # *   The limit on the response time of the Internet-facing SLB instance. Unit: milliseconds.
        self.metric_target_average_utilization = metric_target_average_utilization
        # The metric that is used to trigger the auto scaling policy. Valid values:
        # 
        # *   **CPU**: the CPU utilization.
        # *   **MEMORY**: the memory usage.
        # *   **tcpActiveConn**: the average number of active TCP connections for an instance in 30 seconds.
        # *   **SLB_QPS**: the average QPS of the Internet-facing SLB instance associated with an application instance in 15 seconds.
        # *   **SLB_RT**: the average response time of the Internet-facing SLB instance in 15 seconds.
        self.metric_type = metric_type
        self.slb_id = slb_id
        self.slb_logstore = slb_logstore
        self.slb_project = slb_project
        self.vport = vport

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_target_average_utilization is not None:
            result['MetricTargetAverageUtilization'] = self.metric_target_average_utilization
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.slb_id is not None:
            result['SlbId'] = self.slb_id
        if self.slb_logstore is not None:
            result['SlbLogstore'] = self.slb_logstore
        if self.slb_project is not None:
            result['SlbProject'] = self.slb_project
        if self.vport is not None:
            result['Vport'] = self.vport
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetricTargetAverageUtilization') is not None:
            self.metric_target_average_utilization = m.get('MetricTargetAverageUtilization')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('SlbId') is not None:
            self.slb_id = m.get('SlbId')
        if m.get('SlbLogstore') is not None:
            self.slb_logstore = m.get('SlbLogstore')
        if m.get('SlbProject') is not None:
            self.slb_project = m.get('SlbProject')
        if m.get('Vport') is not None:
            self.vport = m.get('Vport')
        return self


class DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusCurrentMetrics(TeaModel):
    def __init__(
        self,
        current_value: int = None,
        name: str = None,
        type: str = None,
    ):
        # The current value of the metric.
        self.current_value = current_value
        # The name of the metric.
        # 
        # *   **cpu**: the CPU utilization.
        # *   **memory**: the memory usage.
        # *   **tcpActiveConn**: the number of active TCP connections.
        # *   **slb_incall_qps**: the QPS of the Internet-facing SLB instance.
        # *   **slb_incall_rt**: the response time of the Internet-facing SLB instance.
        self.name = name
        # The type of the data. This parameter corresponds to the metric.
        # 
        # *   **Resource**: used when the metric is the **CPU utilization** or **memory usage**.
        # *   **Pods**: used when the metric is the **number of active TCP connections**.
        # *   **External**: used when the metric is about the **SLB** instance or from **Application Real-Time Monitoring Service (ARMS)**.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_value is not None:
            result['CurrentValue'] = self.current_value
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentValue') is not None:
            self.current_value = m.get('CurrentValue')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusNextScaleMetrics(TeaModel):
    def __init__(
        self,
        name: str = None,
        next_scale_in_average_utilization: int = None,
        next_scale_out_average_utilization: int = None,
    ):
        # The name of the metric.
        # 
        # *   **cpu**: the CPU utilization.
        # *   **memory**: the memory usage.
        # *   **tcpActiveConn**: the number of active TCP connections.
        # *   **slb_incall_qps**: the QPS of the Internet-facing SLB instance.
        # *   **slb_incall_rt**: the response time of the Internet-facing SLB instance.
        self.name = name
        # The metric value as a percentage that triggers the application scale-in next time.
        self.next_scale_in_average_utilization = next_scale_in_average_utilization
        # The metric value as a percentage that triggers the application scale-out next time.
        self.next_scale_out_average_utilization = next_scale_out_average_utilization

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.next_scale_in_average_utilization is not None:
            result['NextScaleInAverageUtilization'] = self.next_scale_in_average_utilization
        if self.next_scale_out_average_utilization is not None:
            result['NextScaleOutAverageUtilization'] = self.next_scale_out_average_utilization
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NextScaleInAverageUtilization') is not None:
            self.next_scale_in_average_utilization = m.get('NextScaleInAverageUtilization')
        if m.get('NextScaleOutAverageUtilization') is not None:
            self.next_scale_out_average_utilization = m.get('NextScaleOutAverageUtilization')
        return self


class DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatus(TeaModel):
    def __init__(
        self,
        current_metrics: List[DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusCurrentMetrics] = None,
        current_replicas: int = None,
        desired_replicas: int = None,
        last_scale_time: str = None,
        next_scale_metrics: List[DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusNextScaleMetrics] = None,
        next_scale_time_period: int = None,
    ):
        # The metrics that is used to trigger the current auto scaling policy.
        self.current_metrics = current_metrics
        # The current number of instances.
        self.current_replicas = current_replicas
        # The expected number of instances.
        self.desired_replicas = desired_replicas
        # The time when the auto scaling policy was last triggered.
        self.last_scale_time = last_scale_time
        # The metrics that are used to trigger the auto scaling policy next time.
        self.next_scale_metrics = next_scale_metrics
        # The duration for which the metric-based auto scaling policy takes effect next time.
        self.next_scale_time_period = next_scale_time_period

    def validate(self):
        if self.current_metrics:
            for k in self.current_metrics:
                if k:
                    k.validate()
        if self.next_scale_metrics:
            for k in self.next_scale_metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CurrentMetrics'] = []
        if self.current_metrics is not None:
            for k in self.current_metrics:
                result['CurrentMetrics'].append(k.to_map() if k else None)
        if self.current_replicas is not None:
            result['CurrentReplicas'] = self.current_replicas
        if self.desired_replicas is not None:
            result['DesiredReplicas'] = self.desired_replicas
        if self.last_scale_time is not None:
            result['LastScaleTime'] = self.last_scale_time
        result['NextScaleMetrics'] = []
        if self.next_scale_metrics is not None:
            for k in self.next_scale_metrics:
                result['NextScaleMetrics'].append(k.to_map() if k else None)
        if self.next_scale_time_period is not None:
            result['NextScaleTimePeriod'] = self.next_scale_time_period
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.current_metrics = []
        if m.get('CurrentMetrics') is not None:
            for k in m.get('CurrentMetrics'):
                temp_model = DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusCurrentMetrics()
                self.current_metrics.append(temp_model.from_map(k))
        if m.get('CurrentReplicas') is not None:
            self.current_replicas = m.get('CurrentReplicas')
        if m.get('DesiredReplicas') is not None:
            self.desired_replicas = m.get('DesiredReplicas')
        if m.get('LastScaleTime') is not None:
            self.last_scale_time = m.get('LastScaleTime')
        self.next_scale_metrics = []
        if m.get('NextScaleMetrics') is not None:
            for k in m.get('NextScaleMetrics'):
                temp_model = DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusNextScaleMetrics()
                self.next_scale_metrics.append(temp_model.from_map(k))
        if m.get('NextScaleTimePeriod') is not None:
            self.next_scale_time_period = m.get('NextScaleTimePeriod')
        return self


class DescribeApplicationScalingRuleResponseBodyDataMetricScaleDownRules(TeaModel):
    def __init__(
        self,
        disabled: bool = None,
        stabilization_window_seconds: int = None,
        step: int = None,
    ):
        # Indicates whether the application scale-in is disabled. Valid values:
        # 
        # *   **true**: disabled.
        # *   **false**: enabled.
        # 
        # >  When this parameter is set to true, the application instances are never reduced. This prevents risks to your business in peak hours. By default, this parameter is set to false.
        self.disabled = disabled
        # The cooldown time of the scale-in. Valid values: 0 to 3600. Unit: seconds. Default value: 0.
        self.stabilization_window_seconds = stabilization_window_seconds
        # The step size for the scale-in. The maximum number of instances that can be reduced within a specific period of time.
        self.step = step

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.stabilization_window_seconds is not None:
            result['StabilizationWindowSeconds'] = self.stabilization_window_seconds
        if self.step is not None:
            result['Step'] = self.step
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('StabilizationWindowSeconds') is not None:
            self.stabilization_window_seconds = m.get('StabilizationWindowSeconds')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        return self


class DescribeApplicationScalingRuleResponseBodyDataMetricScaleUpRules(TeaModel):
    def __init__(
        self,
        disabled: bool = None,
        stabilization_window_seconds: int = None,
        step: int = None,
    ):
        # Indicates whether the application scale-in is disabled. Valid values:
        # 
        # *   **true**: The application scale-in is disabled.
        # *   **false**: The application scale-in is enabled.
        # 
        # >  When this parameter is set to true, the application instances are never reduced. This prevents risks to your business in peak hours. By default, this parameter is set to false.
        self.disabled = disabled
        # The cooldown time of the scale-out. Valid values: 0 to 3600. Unit: seconds. Default value: 0.
        self.stabilization_window_seconds = stabilization_window_seconds
        # The step size for the scale-out. The maximum number of instances that can be added within a specific period of time.
        self.step = step

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.stabilization_window_seconds is not None:
            result['StabilizationWindowSeconds'] = self.stabilization_window_seconds
        if self.step is not None:
            result['Step'] = self.step
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('StabilizationWindowSeconds') is not None:
            self.stabilization_window_seconds = m.get('StabilizationWindowSeconds')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        return self


class DescribeApplicationScalingRuleResponseBodyDataMetric(TeaModel):
    def __init__(
        self,
        max_replicas: int = None,
        metrics: List[DescribeApplicationScalingRuleResponseBodyDataMetricMetrics] = None,
        metrics_status: DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatus = None,
        min_replicas: int = None,
        scale_down_rules: DescribeApplicationScalingRuleResponseBodyDataMetricScaleDownRules = None,
        scale_up_rules: DescribeApplicationScalingRuleResponseBodyDataMetricScaleUpRules = None,
    ):
        # The maximum number of instances.
        self.max_replicas = max_replicas
        # The list of metrics that are used to trigger the auto scaling policy.
        self.metrics = metrics
        # The execution status of the metric-based auto scaling policy.
        self.metrics_status = metrics_status
        # The minimum number of instances.
        self.min_replicas = min_replicas
        # Rules that determine the application scale-in.
        self.scale_down_rules = scale_down_rules
        # Rules that determine the application scale-out.
        self.scale_up_rules = scale_up_rules

    def validate(self):
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()
        if self.metrics_status:
            self.metrics_status.validate()
        if self.scale_down_rules:
            self.scale_down_rules.validate()
        if self.scale_up_rules:
            self.scale_up_rules.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        result['Metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['Metrics'].append(k.to_map() if k else None)
        if self.metrics_status is not None:
            result['MetricsStatus'] = self.metrics_status.to_map()
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        if self.scale_down_rules is not None:
            result['ScaleDownRules'] = self.scale_down_rules.to_map()
        if self.scale_up_rules is not None:
            result['ScaleUpRules'] = self.scale_up_rules.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        self.metrics = []
        if m.get('Metrics') is not None:
            for k in m.get('Metrics'):
                temp_model = DescribeApplicationScalingRuleResponseBodyDataMetricMetrics()
                self.metrics.append(temp_model.from_map(k))
        if m.get('MetricsStatus') is not None:
            temp_model = DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatus()
            self.metrics_status = temp_model.from_map(m['MetricsStatus'])
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        if m.get('ScaleDownRules') is not None:
            temp_model = DescribeApplicationScalingRuleResponseBodyDataMetricScaleDownRules()
            self.scale_down_rules = temp_model.from_map(m['ScaleDownRules'])
        if m.get('ScaleUpRules') is not None:
            temp_model = DescribeApplicationScalingRuleResponseBodyDataMetricScaleUpRules()
            self.scale_up_rules = temp_model.from_map(m['ScaleUpRules'])
        return self


class DescribeApplicationScalingRuleResponseBodyDataTimerSchedules(TeaModel):
    def __init__(
        self,
        at_time: str = None,
        max_replicas: int = None,
        min_replicas: int = None,
        target_replicas: int = None,
    ):
        # The point in time. Format: **Hour:Minute**.
        self.at_time = at_time
        self.max_replicas = max_replicas
        self.min_replicas = min_replicas
        # The expected number of instances.
        self.target_replicas = target_replicas

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.at_time is not None:
            result['AtTime'] = self.at_time
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        if self.target_replicas is not None:
            result['TargetReplicas'] = self.target_replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AtTime') is not None:
            self.at_time = m.get('AtTime')
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        if m.get('TargetReplicas') is not None:
            self.target_replicas = m.get('TargetReplicas')
        return self


class DescribeApplicationScalingRuleResponseBodyDataTimer(TeaModel):
    def __init__(
        self,
        begin_date: str = None,
        end_date: str = None,
        period: str = None,
        schedules: List[DescribeApplicationScalingRuleResponseBodyDataTimerSchedules] = None,
    ):
        # The start date of the validity period of the scheduled auto scaling policy. Valid values:
        # 
        # *   If both the **BeginDate** and **EndDate** parameters are set to **null**, the auto scaling policy can always be triggered. The default value for these parameters is null.
        # *   If the two parameters are set to specific dates, the scheduled auto scaling policy can be triggered during the period between the two dates. For example, if **BeginDate** is **2021-03-25** and **EndDate** is **2021-04-25**, the auto scaling policy is valid for one month.
        self.begin_date = begin_date
        # The end date of the validity period of the scheduled auto scaling policy. Valid values:
        # 
        # *   If both the **BeginDate** and **EndDate** parameters are set to **null**, the auto scaling policy can always be triggered. The default value for these parameters is null.
        # *   If the two parameters are set to specific dates, the scheduled auto scaling policy can be triggered during the period between the two dates. For example, if **BeginDate** is **2021-03-25** and **EndDate** is **2021-04-25**, the auto scaling policy is valid for one month.
        self.end_date = end_date
        # The days on which the scheduled auto scaling policy takes effect. Valid values:
        # 
        # *   **\\* \\* \\***: The scheduled auto scaling policy takes effect at a specified time every day.
        # 
        # *   **\\* \\* Fri,Mon**: The scheduled auto scaling policy takes effect at a specified time on one or multiple days of a week. The specified time is in the GMT+8 time zone. Valid values:
        # 
        #     *   **Sun**: Sunday
        #     *   **Mon**: Monday
        #     *   **Tue**: Tuesday
        #     *   **Wed**: Wednesday
        #     *   **Thu**: Thursday
        #     *   **Fri**: Friday
        #     *   **Sat**: Saturday
        # 
        # *   **1,2,3,28,31 \\* \\***: The scheduled auto scaling policy takes effect at a specified time on one or multiple days of a month. Valid values: 1 to 31. If the month does not have a 31st day, the auto scaling policy takes effect on the specified days other than the 31st day.
        self.period = period
        # The points in time when the auto scaling policy is triggered within one day.
        self.schedules = schedules

    def validate(self):
        if self.schedules:
            for k in self.schedules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_date is not None:
            result['BeginDate'] = self.begin_date
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.period is not None:
            result['Period'] = self.period
        result['Schedules'] = []
        if self.schedules is not None:
            for k in self.schedules:
                result['Schedules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BeginDate') is not None:
            self.begin_date = m.get('BeginDate')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        self.schedules = []
        if m.get('Schedules') is not None:
            for k in m.get('Schedules'):
                temp_model = DescribeApplicationScalingRuleResponseBodyDataTimerSchedules()
                self.schedules.append(temp_model.from_map(k))
        return self


class DescribeApplicationScalingRuleResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        create_time: int = None,
        last_disable_time: int = None,
        metric: DescribeApplicationScalingRuleResponseBodyDataMetric = None,
        min_ready_instance_ratio: int = None,
        min_ready_instances: int = None,
        scale_rule_enabled: bool = None,
        scale_rule_name: str = None,
        scale_rule_type: str = None,
        timer: DescribeApplicationScalingRuleResponseBodyDataTimer = None,
        update_time: int = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The time when the auto scaling policy was created. Unit: milliseconds.
        self.create_time = create_time
        # The time when the auto scaling policy was last disabled.
        self.last_disable_time = last_disable_time
        # The details of the metric-based auto scaling policy.
        self.metric = metric
        # The ratio of the minimum number of available instances to the current number of instances. Valid values:
        # 
        # *   **-1** (default value): The minimum number of available instances is not determined based on this parameter.
        # *   **0 to 100**: The minimum number of available instances is calculated by using the following formula: Number of existing instances × Value of MinReadyInstanceRatio × 100%. The calculation result is rounded up to the nearest integer. For example, if the number of existing instances is 5 and MinReadyInstanceRatio is set to 50, the minimum number of available instances is 3.
        # 
        # >  If the **MinReadyInstanceRatio** and **MinReadyInstanceRatio** parameters are configured and the **MinReadyInstanceRatio** parameter is set to a number from 0 to 100, the value of the MinReadyInstanceRatio parameter takes precedence. For example, if the **MinReadyInstances** parameter is set to **5**, and the **MinReadyInstanceRatio** parameter is set to **50**, the minimum number of available instances is set to the nearest integer rounded up from the calculated result of the following formula: Nmber of existing instances × **50**.
        self.min_ready_instance_ratio = min_ready_instance_ratio
        # The minimum number of available instances. Valid values:
        # 
        # *   If you set the value to **0**, business is interrupted when the application is updated.
        # *   If you set this property to -1, the system calculates a recommended value as the minimum number of available instances by using the following formula: Recommended value = Number of existing instances × 25%. The calculation result is rounded up to the nearest integer. For example, if the number of existing instances is 5, the recommended value is calculated by using the following formula: 5 × 25% = 1.25. In this case, the minimum number of available instances is 2.
        # 
        # >  To ensure business continuity, make sure that at least one instance is available during application deployment and rollback.
        self.min_ready_instances = min_ready_instances
        # Indicates whether the auto scaling policy is enabled. Valid values:
        # 
        # *   **true**: enabled
        # *   **false**: disabled
        self.scale_rule_enabled = scale_rule_enabled
        # The name of the auto scaling policy.
        self.scale_rule_name = scale_rule_name
        # The type of the auto scaling policy. Valid values:
        # 
        # *   **timing**: the scheduled auto scaling policy.
        # *   **metric**: the metric-based auto scaling policy.
        # *   **mix**: the hybrid auto scaling policy.
        self.scale_rule_type = scale_rule_type
        # The details of the scheduled auto scaling policy.
        self.timer = timer
        # The time when the auto scaling policy was updated. Unit: milliseconds.
        self.update_time = update_time

    def validate(self):
        if self.metric:
            self.metric.validate()
        if self.timer:
            self.timer.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_disable_time is not None:
            result['LastDisableTime'] = self.last_disable_time
        if self.metric is not None:
            result['Metric'] = self.metric.to_map()
        if self.min_ready_instance_ratio is not None:
            result['MinReadyInstanceRatio'] = self.min_ready_instance_ratio
        if self.min_ready_instances is not None:
            result['MinReadyInstances'] = self.min_ready_instances
        if self.scale_rule_enabled is not None:
            result['ScaleRuleEnabled'] = self.scale_rule_enabled
        if self.scale_rule_name is not None:
            result['ScaleRuleName'] = self.scale_rule_name
        if self.scale_rule_type is not None:
            result['ScaleRuleType'] = self.scale_rule_type
        if self.timer is not None:
            result['Timer'] = self.timer.to_map()
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastDisableTime') is not None:
            self.last_disable_time = m.get('LastDisableTime')
        if m.get('Metric') is not None:
            temp_model = DescribeApplicationScalingRuleResponseBodyDataMetric()
            self.metric = temp_model.from_map(m['Metric'])
        if m.get('MinReadyInstanceRatio') is not None:
            self.min_ready_instance_ratio = m.get('MinReadyInstanceRatio')
        if m.get('MinReadyInstances') is not None:
            self.min_ready_instances = m.get('MinReadyInstances')
        if m.get('ScaleRuleEnabled') is not None:
            self.scale_rule_enabled = m.get('ScaleRuleEnabled')
        if m.get('ScaleRuleName') is not None:
            self.scale_rule_name = m.get('ScaleRuleName')
        if m.get('ScaleRuleType') is not None:
            self.scale_rule_type = m.get('ScaleRuleType')
        if m.get('Timer') is not None:
            temp_model = DescribeApplicationScalingRuleResponseBodyDataTimer()
            self.timer = temp_model.from_map(m['Timer'])
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeApplicationScalingRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeApplicationScalingRuleResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        # The data returned.
        self.data = data
        self.error_code = error_code
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeApplicationScalingRuleResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeApplicationScalingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApplicationScalingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApplicationScalingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApplicationScalingRulesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # 7171a6ca-d1cd-4928-8642-7d5cfe69\\*\\*\\*\\*\
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetrics(TeaModel):
    def __init__(
        self,
        metric_target_average_utilization: int = None,
        metric_type: str = None,
        slb_id: str = None,
        slb_logstore: str = None,
        slb_project: str = None,
        vport: str = None,
    ):
        # The limit on the metric.
        # 
        # *   The limit on the CPU utilization. Unit: percentage.
        # *   The limit on the memory usage. Unit: percentage.
        # *   The limit on the average number of active TCP connections per second.
        # *   The limit on the queries per second (QPS) of the Internet-facing Server Load Balancer (SLB) instance.
        # *   The limit on the response time of the Internet-facing SLB instance. Unit: milliseconds.
        self.metric_target_average_utilization = metric_target_average_utilization
        # The metric that is used to trigger the auto scaling policy. Valid values:
        # 
        # *   **CPU**: the CPU utilization.
        # *   **MEMORY**: the memory usage.
        # *   **tcpActiveConn**: the average number of active TCP connections per second of an application instance in 30 seconds.
        # *   **SLB_QPS**: the average QPS of the Internet-facing SLB instance associated with an application instance in 15 seconds.
        # *   **SLB_RT**: the average response time of the Internet-facing SLB instance in 15 seconds.
        self.metric_type = metric_type
        self.slb_id = slb_id
        self.slb_logstore = slb_logstore
        self.slb_project = slb_project
        self.vport = vport

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_target_average_utilization is not None:
            result['MetricTargetAverageUtilization'] = self.metric_target_average_utilization
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.slb_id is not None:
            result['SlbId'] = self.slb_id
        if self.slb_logstore is not None:
            result['SlbLogstore'] = self.slb_logstore
        if self.slb_project is not None:
            result['SlbProject'] = self.slb_project
        if self.vport is not None:
            result['Vport'] = self.vport
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetricTargetAverageUtilization') is not None:
            self.metric_target_average_utilization = m.get('MetricTargetAverageUtilization')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('SlbId') is not None:
            self.slb_id = m.get('SlbId')
        if m.get('SlbLogstore') is not None:
            self.slb_logstore = m.get('SlbLogstore')
        if m.get('SlbProject') is not None:
            self.slb_project = m.get('SlbProject')
        if m.get('Vport') is not None:
            self.vport = m.get('Vport')
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusCurrentMetrics(TeaModel):
    def __init__(
        self,
        current_value: int = None,
        name: str = None,
        type: str = None,
    ):
        # The current value of the metric.
        self.current_value = current_value
        # The name of the metric.
        # 
        # *   **cpu**: the CPU utilization.
        # *   **memory**: the memory usage.
        # *   **tcpActiveConn**: the number of active TCP connections.
        # *   **slb_incall_qps**: the QPS of the Internet-facing SLB instance.
        # *   **slb_incall_rt**: the response time of the Internet-facing SLB instance.
        self.name = name
        # The type of the data. This parameter corresponds to the metric.
        # 
        # *   **Resource**: used when the metric is the **CPU utilization** or **memory usage**.
        # *   **Pods**: used when the metric is the **number of active TCP connections**.
        # *   **External**: used when the metric is about the **SLB** instance or from **Application Real-Time Monitoring Service (ARMS)**.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_value is not None:
            result['CurrentValue'] = self.current_value
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentValue') is not None:
            self.current_value = m.get('CurrentValue')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusNextScaleMetrics(TeaModel):
    def __init__(
        self,
        name: str = None,
        next_scale_in_average_utilization: int = None,
        next_scale_out_average_utilization: int = None,
    ):
        # The name of the metric.
        # 
        # *   **cpu**: the CPU utilization.
        # *   **memory**: the memory usage.
        # *   **tcpActiveConn**: the number of active TCP connections.
        # *   **slb_incall_qps**: the QPS of the Internet-facing SLB instance.
        # *   **slb_incall_rt**: the response time of the Internet-facing SLB instance.
        self.name = name
        # The metric value as a percentage that triggers the application scale-in next time.
        self.next_scale_in_average_utilization = next_scale_in_average_utilization
        # The metric value as a percentage that triggers the application scale-out next time.
        self.next_scale_out_average_utilization = next_scale_out_average_utilization

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.next_scale_in_average_utilization is not None:
            result['NextScaleInAverageUtilization'] = self.next_scale_in_average_utilization
        if self.next_scale_out_average_utilization is not None:
            result['NextScaleOutAverageUtilization'] = self.next_scale_out_average_utilization
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NextScaleInAverageUtilization') is not None:
            self.next_scale_in_average_utilization = m.get('NextScaleInAverageUtilization')
        if m.get('NextScaleOutAverageUtilization') is not None:
            self.next_scale_out_average_utilization = m.get('NextScaleOutAverageUtilization')
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatus(TeaModel):
    def __init__(
        self,
        current_metrics: List[DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusCurrentMetrics] = None,
        current_replicas: int = None,
        desired_replicas: int = None,
        last_scale_time: str = None,
        max_replicas: int = None,
        min_replicas: int = None,
        next_scale_metrics: List[DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusNextScaleMetrics] = None,
        next_scale_time_period: int = None,
    ):
        # The metrics that are used to trigger the auto scaling policy this time.
        self.current_metrics = current_metrics
        # The current number of instances.
        self.current_replicas = current_replicas
        # The expected number of instances.
        self.desired_replicas = desired_replicas
        # The time when the auto scaling policy was last triggered.
        self.last_scale_time = last_scale_time
        # The maximum number of instances.
        self.max_replicas = max_replicas
        # The minimum number of instances.
        self.min_replicas = min_replicas
        # The metrics that are used to trigger the auto scaling policy next time.
        self.next_scale_metrics = next_scale_metrics
        # The duration for which the metric-based auto scaling policy takes effect next time.
        self.next_scale_time_period = next_scale_time_period

    def validate(self):
        if self.current_metrics:
            for k in self.current_metrics:
                if k:
                    k.validate()
        if self.next_scale_metrics:
            for k in self.next_scale_metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CurrentMetrics'] = []
        if self.current_metrics is not None:
            for k in self.current_metrics:
                result['CurrentMetrics'].append(k.to_map() if k else None)
        if self.current_replicas is not None:
            result['CurrentReplicas'] = self.current_replicas
        if self.desired_replicas is not None:
            result['DesiredReplicas'] = self.desired_replicas
        if self.last_scale_time is not None:
            result['LastScaleTime'] = self.last_scale_time
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        result['NextScaleMetrics'] = []
        if self.next_scale_metrics is not None:
            for k in self.next_scale_metrics:
                result['NextScaleMetrics'].append(k.to_map() if k else None)
        if self.next_scale_time_period is not None:
            result['NextScaleTimePeriod'] = self.next_scale_time_period
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.current_metrics = []
        if m.get('CurrentMetrics') is not None:
            for k in m.get('CurrentMetrics'):
                temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusCurrentMetrics()
                self.current_metrics.append(temp_model.from_map(k))
        if m.get('CurrentReplicas') is not None:
            self.current_replicas = m.get('CurrentReplicas')
        if m.get('DesiredReplicas') is not None:
            self.desired_replicas = m.get('DesiredReplicas')
        if m.get('LastScaleTime') is not None:
            self.last_scale_time = m.get('LastScaleTime')
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        self.next_scale_metrics = []
        if m.get('NextScaleMetrics') is not None:
            for k in m.get('NextScaleMetrics'):
                temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusNextScaleMetrics()
                self.next_scale_metrics.append(temp_model.from_map(k))
        if m.get('NextScaleTimePeriod') is not None:
            self.next_scale_time_period = m.get('NextScaleTimePeriod')
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricPrometheusMetrics(TeaModel):
    def __init__(
        self,
        prometheus_query: str = None,
        target_metric_value: str = None,
    ):
        self.prometheus_query = prometheus_query
        self.target_metric_value = target_metric_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prometheus_query is not None:
            result['PrometheusQuery'] = self.prometheus_query
        if self.target_metric_value is not None:
            result['TargetMetricValue'] = self.target_metric_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PrometheusQuery') is not None:
            self.prometheus_query = m.get('PrometheusQuery')
        if m.get('TargetMetricValue') is not None:
            self.target_metric_value = m.get('TargetMetricValue')
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleDownRules(TeaModel):
    def __init__(
        self,
        disabled: bool = None,
        stabilization_window_seconds: int = None,
        step: int = None,
    ):
        # Indicates whether the application scale-in was disabled. Valid values:
        # 
        # *   **true**: The application scale-in was disabled.
        # *   **false**: The application scale-in was enabled.
        # 
        # >  When this parameter is set to true, the application instances will never be reduced. This prevents risks to your business in peak hours. By default, this parameter is set to false.
        self.disabled = disabled
        # The cooldown time of the scale-in. Valid values: 0 to 3600. Unit: seconds. The default value is 0.
        self.stabilization_window_seconds = stabilization_window_seconds
        # The step size for the scale-in. The maximum number of instances that can be reduced in a unit of time.
        self.step = step

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.stabilization_window_seconds is not None:
            result['StabilizationWindowSeconds'] = self.stabilization_window_seconds
        if self.step is not None:
            result['Step'] = self.step
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('StabilizationWindowSeconds') is not None:
            self.stabilization_window_seconds = m.get('StabilizationWindowSeconds')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleUpRules(TeaModel):
    def __init__(
        self,
        disabled: bool = None,
        stabilization_window_seconds: int = None,
        step: int = None,
    ):
        # Indicates whether the application scale-in was disabled. Valid values:
        # 
        # *   **true**: The application scale-in was disabled.
        # *   **false**: The application scale-in was enabled.
        # 
        # >  When this parameter is set to true, the application instances will never be reduced. This prevents risks to your business in peak hours. By default, this parameter is set to false.
        self.disabled = disabled
        # The cooldown time of the scale-out. Valid values: 0 to 3600. Unit: seconds. The default value is 0.
        self.stabilization_window_seconds = stabilization_window_seconds
        # The step size for the scale-out. The maximum number of instances that can be added in a unit of time.
        self.step = step

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.stabilization_window_seconds is not None:
            result['StabilizationWindowSeconds'] = self.stabilization_window_seconds
        if self.step is not None:
            result['Step'] = self.step
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('StabilizationWindowSeconds') is not None:
            self.stabilization_window_seconds = m.get('StabilizationWindowSeconds')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetric(TeaModel):
    def __init__(
        self,
        max_replicas: int = None,
        metric_source: str = None,
        metrics: List[DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetrics] = None,
        metrics_status: DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatus = None,
        min_replicas: int = None,
        prometheus_metrics: List[DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricPrometheusMetrics] = None,
        prometheus_token: str = None,
        prometheus_url: str = None,
        scale_down_rules: DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleDownRules = None,
        scale_up_rules: DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleUpRules = None,
    ):
        # The maximum number of instances.
        self.max_replicas = max_replicas
        self.metric_source = metric_source
        # The list of metrics that are used to trigger the auto scaling policy.
        self.metrics = metrics
        # The execution status of the metric-based auto scaling policy.
        self.metrics_status = metrics_status
        # The minimum number of instances.
        self.min_replicas = min_replicas
        self.prometheus_metrics = prometheus_metrics
        self.prometheus_token = prometheus_token
        self.prometheus_url = prometheus_url
        # Rules that determine the application scale-in.
        self.scale_down_rules = scale_down_rules
        # Rules that determine the application scale-out.
        self.scale_up_rules = scale_up_rules

    def validate(self):
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()
        if self.metrics_status:
            self.metrics_status.validate()
        if self.prometheus_metrics:
            for k in self.prometheus_metrics:
                if k:
                    k.validate()
        if self.scale_down_rules:
            self.scale_down_rules.validate()
        if self.scale_up_rules:
            self.scale_up_rules.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        if self.metric_source is not None:
            result['MetricSource'] = self.metric_source
        result['Metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['Metrics'].append(k.to_map() if k else None)
        if self.metrics_status is not None:
            result['MetricsStatus'] = self.metrics_status.to_map()
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        result['PrometheusMetrics'] = []
        if self.prometheus_metrics is not None:
            for k in self.prometheus_metrics:
                result['PrometheusMetrics'].append(k.to_map() if k else None)
        if self.prometheus_token is not None:
            result['PrometheusToken'] = self.prometheus_token
        if self.prometheus_url is not None:
            result['PrometheusUrl'] = self.prometheus_url
        if self.scale_down_rules is not None:
            result['ScaleDownRules'] = self.scale_down_rules.to_map()
        if self.scale_up_rules is not None:
            result['ScaleUpRules'] = self.scale_up_rules.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        if m.get('MetricSource') is not None:
            self.metric_source = m.get('MetricSource')
        self.metrics = []
        if m.get('Metrics') is not None:
            for k in m.get('Metrics'):
                temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetrics()
                self.metrics.append(temp_model.from_map(k))
        if m.get('MetricsStatus') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatus()
            self.metrics_status = temp_model.from_map(m['MetricsStatus'])
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        self.prometheus_metrics = []
        if m.get('PrometheusMetrics') is not None:
            for k in m.get('PrometheusMetrics'):
                temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricPrometheusMetrics()
                self.prometheus_metrics.append(temp_model.from_map(k))
        if m.get('PrometheusToken') is not None:
            self.prometheus_token = m.get('PrometheusToken')
        if m.get('PrometheusUrl') is not None:
            self.prometheus_url = m.get('PrometheusUrl')
        if m.get('ScaleDownRules') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleDownRules()
            self.scale_down_rules = temp_model.from_map(m['ScaleDownRules'])
        if m.get('ScaleUpRules') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleUpRules()
            self.scale_up_rules = temp_model.from_map(m['ScaleUpRules'])
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimerSchedules(TeaModel):
    def __init__(
        self,
        at_time: str = None,
        max_replicas: int = None,
        min_replicas: int = None,
        target_replicas: int = None,
    ):
        # The point in time. Format: **Hour:Minute**.
        self.at_time = at_time
        # The maximum number of instances.
        self.max_replicas = max_replicas
        # The minimum number of instances.
        self.min_replicas = min_replicas
        # The expected number of instances.
        self.target_replicas = target_replicas

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.at_time is not None:
            result['AtTime'] = self.at_time
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        if self.target_replicas is not None:
            result['TargetReplicas'] = self.target_replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AtTime') is not None:
            self.at_time = m.get('AtTime')
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        if m.get('TargetReplicas') is not None:
            self.target_replicas = m.get('TargetReplicas')
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimer(TeaModel):
    def __init__(
        self,
        begin_date: str = None,
        end_date: str = None,
        period: str = None,
        schedules: List[DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimerSchedules] = None,
        time_zone: str = None,
    ):
        # The start date of the validity period of the scheduled auto scaling policy. Valid values:
        # 
        # *   If both the **BeginDate** and **EndDate** parameters are set to **null**, the auto scaling policy can always be triggered. The default value for these parameters is null.
        # *   If the two parameters are set to specific dates, the scheduled auto scaling policy can be triggered during the period between the two dates. For example, if **BeginDate** is 2021-03-25 and **EndDate** is 2021-04-25, the auto scaling policy is valid for one month.
        self.begin_date = begin_date
        # The end date of the validity period of the scheduled auto scaling policy. Valid values:
        # 
        # *   If both the **BeginDate** and **EndDate** parameters are set to **null**, the auto scaling policy can always be triggered. The default value for these parameters is null.
        # *   If the two parameters are set to specific dates, the scheduled auto scaling policy can be triggered during the period between the two dates. For example, if **BeginDate** is 2021-03-25 and **EndDate** is 2021-04-25, the auto scaling policy is valid for one month.
        self.end_date = end_date
        # The days on which the scheduled auto scaling policy takes effect. Valid values:
        # 
        # *   **\\* \\* \\***: The scheduled auto scaling policy takes effect at a specified time every day.
        # 
        # *   **\\* \\* Fri,Mon**: The scheduled auto scaling policy takes effect at a specified time on one or multiple days of a week. The specified time is in the GMT+8 time zone. Valid values:
        # 
        #     *   **Sun**: Sunday
        #     *   **Mon**: Monday
        #     *   **Tue**: Tuesday
        #     *   **Wed**: Wednesday
        #     *   **Thu**: Thursday
        #     *   **Fri**: Friday
        #     *   **Sat**: Saturday
        # 
        # *   **1,2,3,28,31 \\* \\***: The scheduled auto scaling policy takes effect at a specified time on one or multiple days of a month. Valid values: 1 to 31. If the month does not have a 31st day, the auto scaling policy takes effect on the specified days other than the 31st day.
        self.period = period
        # The points in time when the auto scaling policy is triggered within one day.
        self.schedules = schedules
        self.time_zone = time_zone

    def validate(self):
        if self.schedules:
            for k in self.schedules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_date is not None:
            result['BeginDate'] = self.begin_date
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.period is not None:
            result['Period'] = self.period
        result['Schedules'] = []
        if self.schedules is not None:
            for k in self.schedules:
                result['Schedules'].append(k.to_map() if k else None)
        if self.time_zone is not None:
            result['TimeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BeginDate') is not None:
            self.begin_date = m.get('BeginDate')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        self.schedules = []
        if m.get('Schedules') is not None:
            for k in m.get('Schedules'):
                temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimerSchedules()
                self.schedules.append(temp_model.from_map(k))
        if m.get('TimeZone') is not None:
            self.time_zone = m.get('TimeZone')
        return self


class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRules(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        create_time: int = None,
        last_disable_time: int = None,
        metric: DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetric = None,
        min_ready_instance_ratio: int = None,
        min_ready_instances: int = None,
        scale_rule_enabled: bool = None,
        scale_rule_name: str = None,
        scale_rule_type: str = None,
        timer: DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimer = None,
        update_time: int = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The time when the auto scaling policy was created. Unit: milliseconds.
        self.create_time = create_time
        # The time when the auto scaling policy was last disabled.
        self.last_disable_time = last_disable_time
        # The details of the metric-based auto scaling policy.
        self.metric = metric
        self.min_ready_instance_ratio = min_ready_instance_ratio
        self.min_ready_instances = min_ready_instances
        # Indicates whether the auto scaling policy is enabled. Valid values:
        # 
        # *   **true**: enabled
        # *   **false**: disabled
        self.scale_rule_enabled = scale_rule_enabled
        # The name of the auto scaling policy.
        self.scale_rule_name = scale_rule_name
        # The type of the auto scaling policy. Valid values:
        # 
        # *   **timing**: the scheduled auto scaling policy.
        # *   **metric**: the metric-based auto scaling policy.
        # *   **mix**: the hybrid auto scaling policy.
        self.scale_rule_type = scale_rule_type
        # The details of the scheduled auto scaling policy.
        self.timer = timer
        # The time when the auto scaling policy was updated. Unit: milliseconds.
        self.update_time = update_time

    def validate(self):
        if self.metric:
            self.metric.validate()
        if self.timer:
            self.timer.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_disable_time is not None:
            result['LastDisableTime'] = self.last_disable_time
        if self.metric is not None:
            result['Metric'] = self.metric.to_map()
        if self.min_ready_instance_ratio is not None:
            result['MinReadyInstanceRatio'] = self.min_ready_instance_ratio
        if self.min_ready_instances is not None:
            result['MinReadyInstances'] = self.min_ready_instances
        if self.scale_rule_enabled is not None:
            result['ScaleRuleEnabled'] = self.scale_rule_enabled
        if self.scale_rule_name is not None:
            result['ScaleRuleName'] = self.scale_rule_name
        if self.scale_rule_type is not None:
            result['ScaleRuleType'] = self.scale_rule_type
        if self.timer is not None:
            result['Timer'] = self.timer.to_map()
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastDisableTime') is not None:
            self.last_disable_time = m.get('LastDisableTime')
        if m.get('Metric') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetric()
            self.metric = temp_model.from_map(m['Metric'])
        if m.get('MinReadyInstanceRatio') is not None:
            self.min_ready_instance_ratio = m.get('MinReadyInstanceRatio')
        if m.get('MinReadyInstances') is not None:
            self.min_ready_instances = m.get('MinReadyInstances')
        if m.get('ScaleRuleEnabled') is not None:
            self.scale_rule_enabled = m.get('ScaleRuleEnabled')
        if m.get('ScaleRuleName') is not None:
            self.scale_rule_name = m.get('ScaleRuleName')
        if m.get('ScaleRuleType') is not None:
            self.scale_rule_type = m.get('ScaleRuleType')
        if m.get('Timer') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimer()
            self.timer = temp_model.from_map(m['Timer'])
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeApplicationScalingRulesResponseBodyData(TeaModel):
    def __init__(
        self,
        application_scaling_rules: List[DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRules] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # The auto scaling policies of the application.
        self.application_scaling_rules = application_scaling_rules
        # The number of the returned page.
        self.current_page = current_page
        # The number of entries returned on each page.
        self.page_size = page_size
        # The total number of auto scaling policies.
        self.total_size = total_size

    def validate(self):
        if self.application_scaling_rules:
            for k in self.application_scaling_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ApplicationScalingRules'] = []
        if self.application_scaling_rules is not None:
            for k in self.application_scaling_rules:
                result['ApplicationScalingRules'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.application_scaling_rules = []
        if m.get('ApplicationScalingRules') is not None:
            for k in m.get('ApplicationScalingRules'):
                temp_model = DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRules()
                self.application_scaling_rules.append(temp_model.from_map(k))
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class DescribeApplicationScalingRulesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeApplicationScalingRulesResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        # The data returned.
        self.data = data
        self.error_code = error_code
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeApplicationScalingRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApplicationScalingRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApplicationScalingRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApplicationSlbsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the request.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DescribeApplicationSlbsResponseBodyDataInternet(TeaModel):
    def __init__(
        self,
        cookie: str = None,
        cookie_timeout: int = None,
        create_time: int = None,
        https_ca_cert_id: str = None,
        https_cert_id: str = None,
        port: int = None,
        protocol: str = None,
        sticky_session: bool = None,
        sticky_session_type: str = None,
        target_port: int = None,
    ):
        self.cookie = cookie
        self.cookie_timeout = cookie_timeout
        # The timestamp when the canary release rule was created.
        self.create_time = create_time
        self.https_ca_cert_id = https_ca_cert_id
        # The supported protocol.
        self.https_cert_id = https_cert_id
        # The ID of the internal-facing SLB instance.
        self.port = port
        # The container port.
        self.protocol = protocol
        self.sticky_session = sticky_session
        self.sticky_session_type = sticky_session_type
        # The port specified for the SLB listener.
        self.target_port = target_port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cookie is not None:
            result['Cookie'] = self.cookie
        if self.cookie_timeout is not None:
            result['CookieTimeout'] = self.cookie_timeout
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.https_ca_cert_id is not None:
            result['HttpsCaCertId'] = self.https_ca_cert_id
        if self.https_cert_id is not None:
            result['HttpsCertId'] = self.https_cert_id
        if self.port is not None:
            result['Port'] = self.port
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.sticky_session is not None:
            result['StickySession'] = self.sticky_session
        if self.sticky_session_type is not None:
            result['StickySessionType'] = self.sticky_session_type
        if self.target_port is not None:
            result['TargetPort'] = self.target_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cookie') is not None:
            self.cookie = m.get('Cookie')
        if m.get('CookieTimeout') is not None:
            self.cookie_timeout = m.get('CookieTimeout')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('HttpsCaCertId') is not None:
            self.https_ca_cert_id = m.get('HttpsCaCertId')
        if m.get('HttpsCertId') is not None:
            self.https_cert_id = m.get('HttpsCertId')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('StickySession') is not None:
            self.sticky_session = m.get('StickySession')
        if m.get('StickySessionType') is not None:
            self.sticky_session_type = m.get('StickySessionType')
        if m.get('TargetPort') is not None:
            self.target_port = m.get('TargetPort')
        return self


class DescribeApplicationSlbsResponseBodyDataIntranet(TeaModel):
    def __init__(
        self,
        cookie: str = None,
        cookie_timeout: int = None,
        create_time: int = None,
        https_ca_cert_id: str = None,
        https_cert_id: str = None,
        port: int = None,
        protocol: str = None,
        sticky_session: bool = None,
        sticky_session_type: str = None,
        target_port: int = None,
    ):
        self.cookie = cookie
        self.cookie_timeout = cookie_timeout
        # The timestamp when the canary release rule was created.
        self.create_time = create_time
        self.https_ca_cert_id = https_ca_cert_id
        # The supported protocol.
        self.https_cert_id = https_cert_id
        # The IP address of the Internet-facing SLB instance.
        self.port = port
        # The container port.
        self.protocol = protocol
        self.sticky_session = sticky_session
        self.sticky_session_type = sticky_session_type
        # The port specified for the SLB listener.
        self.target_port = target_port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cookie is not None:
            result['Cookie'] = self.cookie
        if self.cookie_timeout is not None:
            result['CookieTimeout'] = self.cookie_timeout
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.https_ca_cert_id is not None:
            result['HttpsCaCertId'] = self.https_ca_cert_id
        if self.https_cert_id is not None:
            result['HttpsCertId'] = self.https_cert_id
        if self.port is not None:
            result['Port'] = self.port
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.sticky_session is not None:
            result['StickySession'] = self.sticky_session
        if self.sticky_session_type is not None:
            result['StickySessionType'] = self.sticky_session_type
        if self.target_port is not None:
            result['TargetPort'] = self.target_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cookie') is not None:
            self.cookie = m.get('Cookie')
        if m.get('CookieTimeout') is not None:
            self.cookie_timeout = m.get('CookieTimeout')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('HttpsCaCertId') is not None:
            self.https_ca_cert_id = m.get('HttpsCaCertId')
        if m.get('HttpsCertId') is not None:
            self.https_cert_id = m.get('HttpsCertId')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('StickySession') is not None:
            self.sticky_session = m.get('StickySession')
        if m.get('StickySessionType') is not None:
            self.sticky_session_type = m.get('StickySessionType')
        if m.get('TargetPort') is not None:
            self.target_port = m.get('TargetPort')
        return self


class DescribeApplicationSlbsResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        cluster_id: str = None,
        internet: List[DescribeApplicationSlbsResponseBodyDataInternet] = None,
        internet_ip: str = None,
        internet_slb_charge_type: str = None,
        internet_slb_expired: bool = None,
        internet_slb_id: str = None,
        intranet: List[DescribeApplicationSlbsResponseBodyDataIntranet] = None,
        intranet_ip: str = None,
        intranet_slb_charge_type: str = None,
        intranet_slb_expired: bool = None,
        intranet_slb_id: str = None,
    ):
        self.app_id = app_id
        self.app_name = app_name
        self.cluster_id = cluster_id
        # The configurations of the Internet-facing SLB instance.
        self.internet = internet
        # The ID of the Internet-facing SLB instance.
        self.internet_ip = internet_ip
        self.internet_slb_charge_type = internet_slb_charge_type
        self.internet_slb_expired = internet_slb_expired
        # Configurations of Internet-facing SLB instances.
        self.internet_slb_id = internet_slb_id
        # The configurations of the internal-facing SLB instance.
        self.intranet = intranet
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.intranet_ip = intranet_ip
        self.intranet_slb_charge_type = intranet_slb_charge_type
        self.intranet_slb_expired = intranet_slb_expired
        # The IP address of the internal-facing SLB instance.
        self.intranet_slb_id = intranet_slb_id

    def validate(self):
        if self.internet:
            for k in self.internet:
                if k:
                    k.validate()
        if self.intranet:
            for k in self.intranet:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        result['Internet'] = []
        if self.internet is not None:
            for k in self.internet:
                result['Internet'].append(k.to_map() if k else None)
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.internet_slb_charge_type is not None:
            result['InternetSlbChargeType'] = self.internet_slb_charge_type
        if self.internet_slb_expired is not None:
            result['InternetSlbExpired'] = self.internet_slb_expired
        if self.internet_slb_id is not None:
            result['InternetSlbId'] = self.internet_slb_id
        result['Intranet'] = []
        if self.intranet is not None:
            for k in self.intranet:
                result['Intranet'].append(k.to_map() if k else None)
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.intranet_slb_charge_type is not None:
            result['IntranetSlbChargeType'] = self.intranet_slb_charge_type
        if self.intranet_slb_expired is not None:
            result['IntranetSlbExpired'] = self.intranet_slb_expired
        if self.intranet_slb_id is not None:
            result['IntranetSlbId'] = self.intranet_slb_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        self.internet = []
        if m.get('Internet') is not None:
            for k in m.get('Internet'):
                temp_model = DescribeApplicationSlbsResponseBodyDataInternet()
                self.internet.append(temp_model.from_map(k))
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('InternetSlbChargeType') is not None:
            self.internet_slb_charge_type = m.get('InternetSlbChargeType')
        if m.get('InternetSlbExpired') is not None:
            self.internet_slb_expired = m.get('InternetSlbExpired')
        if m.get('InternetSlbId') is not None:
            self.internet_slb_id = m.get('InternetSlbId')
        self.intranet = []
        if m.get('Intranet') is not None:
            for k in m.get('Intranet'):
                temp_model = DescribeApplicationSlbsResponseBodyDataIntranet()
                self.intranet.append(temp_model.from_map(k))
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('IntranetSlbChargeType') is not None:
            self.intranet_slb_charge_type = m.get('IntranetSlbChargeType')
        if m.get('IntranetSlbExpired') is not None:
            self.intranet_slb_expired = m.get('IntranetSlbExpired')
        if m.get('IntranetSlbId') is not None:
            self.intranet_slb_id = m.get('IntranetSlbId')
        return self


class DescribeApplicationSlbsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeApplicationSlbsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # Indicates whether the information about the SLB instances that are associated with an application was obtained successfully. Valid values:
        # 
        # *   **true**: indicates that the information was obtained successfully.
        # *   **false**: indicates that the information failed to be obtained.
        self.code = code
        # The returned data.
        self.data = data
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.error_code = error_code
        # The ID of the trace. It can be used to query the details of a request.
        self.message = message
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.request_id = request_id
        self.success = success
        # The returned data.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeApplicationSlbsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeApplicationSlbsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApplicationSlbsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApplicationSlbsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeApplicationStatusRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DescribeApplicationStatusResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        arms_advanced_enabled: str = None,
        arms_apm_info: str = None,
        create_time: str = None,
        current_status: str = None,
        enable_agent: bool = None,
        file_size_limit: int = None,
        last_change_order_id: str = None,
        last_change_order_running: bool = None,
        last_change_order_status: str = None,
        running_instances: int = None,
        sub_status: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # Indicates whether Application Real-Time Monitoring Service (ARMS) advanced monitoring is enabled. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.arms_advanced_enabled = arms_advanced_enabled
        # The metadata of the application in ARMS.
        self.arms_apm_info = arms_apm_info
        # The time when the application was created.
        self.create_time = create_time
        # The current status of the application. Valid values:
        # 
        # *   **RUNNING**\
        # *   **STOPPED**\
        # *   **UNKNOWN**\
        self.current_status = current_status
        # Indicates whether SAE agent is enabled.
        # 
        # *   **true**\
        # *   **false**\
        self.enable_agent = enable_agent
        # The file size limit. Unit: KB. Valid values: 0 to 10240.
        self.file_size_limit = file_size_limit
        # The ID of the latest change order that is executed. If no change orders are executed or if change orders expire, this parameter is left empty.
        self.last_change_order_id = last_change_order_id
        # Indicates whether the latest change order is being executed. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.last_change_order_running = last_change_order_running
        # The status of the latest change order. Valid values:
        # 
        # *   **READY**: The change order is ready.
        # *   **RUNNING**: The change order is being executed.
        # *   **SUCCESS**: The change order was executed.
        # *   **FAIL**: The change order failed to be executed.
        # *   **ABORT**: The change order is stopped.
        # *   **WAIT_BATCH_CONFIRM**: The change order is pending execution. You must manually confirm the release batch.
        # *   **AUTO_BATCH_WAIT**: The change order is pending execution. SAE will automatically confirm the release batch.
        # *   **SYSTEM_FAIL**: A system exception occurred.
        # *   **WAIT_APPROVAL**: The change order is pending approval.
        # *   **APPROVED**: The change order is approved and is pending execution.
        self.last_change_order_status = last_change_order_status
        # The number of running instances of the application.
        self.running_instances = running_instances
        # The substatus of the change order. This parameter indicates whether an exception occurred while the change order was being executed. Valid values:
        # 
        # *   **NORMAL**\
        # *   **RUNNING_BUT_HAS_ERROR**: For example, if an error occurs during a phased release, you must manually roll back the application. In this case, the change order cannot be completed because the change order is still being executed.
        self.sub_status = sub_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.arms_advanced_enabled is not None:
            result['ArmsAdvancedEnabled'] = self.arms_advanced_enabled
        if self.arms_apm_info is not None:
            result['ArmsApmInfo'] = self.arms_apm_info
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.current_status is not None:
            result['CurrentStatus'] = self.current_status
        if self.enable_agent is not None:
            result['EnableAgent'] = self.enable_agent
        if self.file_size_limit is not None:
            result['FileSizeLimit'] = self.file_size_limit
        if self.last_change_order_id is not None:
            result['LastChangeOrderId'] = self.last_change_order_id
        if self.last_change_order_running is not None:
            result['LastChangeOrderRunning'] = self.last_change_order_running
        if self.last_change_order_status is not None:
            result['LastChangeOrderStatus'] = self.last_change_order_status
        if self.running_instances is not None:
            result['RunningInstances'] = self.running_instances
        if self.sub_status is not None:
            result['SubStatus'] = self.sub_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ArmsAdvancedEnabled') is not None:
            self.arms_advanced_enabled = m.get('ArmsAdvancedEnabled')
        if m.get('ArmsApmInfo') is not None:
            self.arms_apm_info = m.get('ArmsApmInfo')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CurrentStatus') is not None:
            self.current_status = m.get('CurrentStatus')
        if m.get('EnableAgent') is not None:
            self.enable_agent = m.get('EnableAgent')
        if m.get('FileSizeLimit') is not None:
            self.file_size_limit = m.get('FileSizeLimit')
        if m.get('LastChangeOrderId') is not None:
            self.last_change_order_id = m.get('LastChangeOrderId')
        if m.get('LastChangeOrderRunning') is not None:
            self.last_change_order_running = m.get('LastChangeOrderRunning')
        if m.get('LastChangeOrderStatus') is not None:
            self.last_change_order_status = m.get('LastChangeOrderStatus')
        if m.get('RunningInstances') is not None:
            self.running_instances = m.get('RunningInstances')
        if m.get('SubStatus') is not None:
            self.sub_status = m.get('SubStatus')
        return self


class DescribeApplicationStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeApplicationStatusResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The returned result.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the status of the application was queried. Valid values:
        # 
        # *   **true**: The status was queried.
        # *   **false**: The status failed to be queried.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeApplicationStatusResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeApplicationStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeApplicationStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeApplicationStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeChangeOrderRequest(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order. You can call the [ListChangeOrders](https://help.aliyun.com/document_detail/126615.html) operation to obtain the ID.
        # 
        # This parameter is required.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class DescribeChangeOrderResponseBodyDataPipelines(TeaModel):
    def __init__(
        self,
        batch_type: int = None,
        parallel_count: int = None,
        pipeline_id: str = None,
        pipeline_name: str = None,
        start_time: int = None,
        status: int = None,
        update_time: int = None,
    ):
        # The batch type.
        self.batch_type = batch_type
        # The number of parallel tasks in a batch.
        self.parallel_count = parallel_count
        # The ID of the batch.
        self.pipeline_id = pipeline_id
        # The name of the batch.
        self.pipeline_name = pipeline_name
        # The time when the batch processing started.
        self.start_time = start_time
        # The status of the batch. Valid values:
        # 
        # *   **0**: The batch is being prepared.
        # *   **1**: The batch is being processed.
        # *   **2**: The batch was processed.
        # *   **3**: The batch failed to be processed.
        # *   **6**: The batch processing was terminated.
        # *   **8**: The execution process is pending. You must manually release the batch.
        # *   **9**: The execution process is pending. SAE will automatically release the batch.
        # *   **10**: The batch failed to be processed due to a system exception.
        # *   **11**: The batch is pending approval.
        # *   **12**: The batch is approved and is pending execution.
        self.status = status
        # The time when the batch information was last modified.
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_type is not None:
            result['BatchType'] = self.batch_type
        if self.parallel_count is not None:
            result['ParallelCount'] = self.parallel_count
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.pipeline_name is not None:
            result['PipelineName'] = self.pipeline_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BatchType') is not None:
            self.batch_type = m.get('BatchType')
        if m.get('ParallelCount') is not None:
            self.parallel_count = m.get('ParallelCount')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('PipelineName') is not None:
            self.pipeline_name = m.get('PipelineName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeChangeOrderResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        application_enable_grey_tag_route: bool = None,
        application_update_strategy: str = None,
        approval_id: str = None,
        auto: bool = None,
        batch_count: int = None,
        batch_type: str = None,
        batch_wait_time: int = None,
        change_order_id: str = None,
        co_type: str = None,
        co_type_code: str = None,
        create_time: str = None,
        current_pipeline_id: str = None,
        description: str = None,
        error_message: str = None,
        pipelines: List[DescribeChangeOrderResponseBodyDataPipelines] = None,
        status: int = None,
        sub_status: int = None,
        support_rollback: bool = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name
        self.application_enable_grey_tag_route = application_enable_grey_tag_route
        self.application_update_strategy = application_update_strategy
        # The approval ID of the change order.
        self.approval_id = approval_id
        # Indicates whether SAE automatically releases the batches. Valid values:
        # 
        # *   **true**: SAE automatically releases the batches.
        # *   **false**: SAE does not automatically release the batches.
        self.auto = auto
        # The number of release batches.
        self.batch_count = batch_count
        # The processing method for the batches. Valid values:
        # 
        # *   **auto**: SAE automatically releases the batches.
        # *   **Manual**: You must manually release the batches.
        self.batch_type = batch_type
        # The interval between batches in a phased release. SAE automatically releases batches at the specified interval. Unit: minutes.
        self.batch_wait_time = batch_wait_time
        # The ID of the change order.
        self.change_order_id = change_order_id
        # The change type, which corresponds to the **CoTypeCode** parameter.
        self.co_type = co_type
        # The code of the change type. Valid values:
        # 
        # *   **CoBindSlb**: associates a Sever Load Balancer (SLB) instance with the application.
        # *   **CoUnbindSlb**: disassociates the SLB instance from the application.
        # *   **CoCreateApp**: creates the application.
        # *   **CoDeleteApp**: deletes the application.
        # *   **CoDeploy**: deploys the application.
        # *   **CoRestartApplication**: restarts the application.
        # *   **CoRollback**: rolls back the application.
        # *   **CoScaleIn**: scales in the application.
        # *   **CoScaleOut**: scales out the application.
        # *   **CoStart**: starts the application.
        # *   **CoStop**: stops the application.
        # *   **CoRescaleApplicationVertically**: modifies the instance type.
        # *   **CoDeployHistroy**: rolls back the application to a historical version.
        # *   **CoBindNas**: associates a NAS file system with the application.
        # *   **CoUnbindNas**: disassociates the NAS file system from the application.
        # *   **CoBatchStartApplication**: starts multiple applications concurrently.
        # *   **CoBatchStopApplication**: stops multiple applications concurrently.
        # *   **CoRestartInstances**: restarts the instances.
        # *   **CoDeleteInstances**: deletes the instances.
        # *   **CoScaleInAppWithInstances**: reduces the specified number of application instances.
        self.co_type_code = co_type_code
        # The time when the change order was created.
        self.create_time = create_time
        # The ID of the current batch.
        self.current_pipeline_id = current_pipeline_id
        # The description of the change order.
        self.description = description
        # The error message.
        self.error_message = error_message
        # The batch information.
        self.pipelines = pipelines
        # The status of the change order. Valid values:
        # 
        # *   **0**: The change order is being prepared.
        # *   **1**: The change order is being executed.
        # *   **2**: The change order was executed.
        # *   **3**: The change order failed to be executed.
        # *   **6**: The change order was terminated.
        # *   **8**: The execution process is pending. You must manually release the batches.
        # *   **9**: The execution process is pending. SAE will automatically release the batches.
        # *   **10**: The execution failed due to a system exception.
        # *   **11**: The change order is pending approval.
        # *   **12**: The change order is approved and is pending execution.
        self.status = status
        # The substatus of the change order. This parameter indicates whether an exception occurred while the change order was being executed. Valid values:
        # 
        # *   **0**: No exception occurred.
        # *   **1**: An exception occurred. For example, if an error occurs during a phased release, you must manually roll back the application. In this case, the change order cannot be completed, so the Status parameter is still displayed as "1", which indicates that the change order is being executed. You can check the value of this parameter to determine whether an exception occurs.
        self.sub_status = sub_status
        # Indicates whether the application can be rolled back. Valid values:
        # 
        # *   **true**: The application can be rolled back.
        # *   **false**: The application cannot be rolled back.
        self.support_rollback = support_rollback

    def validate(self):
        if self.pipelines:
            for k in self.pipelines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.application_enable_grey_tag_route is not None:
            result['ApplicationEnableGreyTagRoute'] = self.application_enable_grey_tag_route
        if self.application_update_strategy is not None:
            result['ApplicationUpdateStrategy'] = self.application_update_strategy
        if self.approval_id is not None:
            result['ApprovalId'] = self.approval_id
        if self.auto is not None:
            result['Auto'] = self.auto
        if self.batch_count is not None:
            result['BatchCount'] = self.batch_count
        if self.batch_type is not None:
            result['BatchType'] = self.batch_type
        if self.batch_wait_time is not None:
            result['BatchWaitTime'] = self.batch_wait_time
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.co_type is not None:
            result['CoType'] = self.co_type
        if self.co_type_code is not None:
            result['CoTypeCode'] = self.co_type_code
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.current_pipeline_id is not None:
            result['CurrentPipelineId'] = self.current_pipeline_id
        if self.description is not None:
            result['Description'] = self.description
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['Pipelines'] = []
        if self.pipelines is not None:
            for k in self.pipelines:
                result['Pipelines'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        if self.sub_status is not None:
            result['SubStatus'] = self.sub_status
        if self.support_rollback is not None:
            result['SupportRollback'] = self.support_rollback
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ApplicationEnableGreyTagRoute') is not None:
            self.application_enable_grey_tag_route = m.get('ApplicationEnableGreyTagRoute')
        if m.get('ApplicationUpdateStrategy') is not None:
            self.application_update_strategy = m.get('ApplicationUpdateStrategy')
        if m.get('ApprovalId') is not None:
            self.approval_id = m.get('ApprovalId')
        if m.get('Auto') is not None:
            self.auto = m.get('Auto')
        if m.get('BatchCount') is not None:
            self.batch_count = m.get('BatchCount')
        if m.get('BatchType') is not None:
            self.batch_type = m.get('BatchType')
        if m.get('BatchWaitTime') is not None:
            self.batch_wait_time = m.get('BatchWaitTime')
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('CoType') is not None:
            self.co_type = m.get('CoType')
        if m.get('CoTypeCode') is not None:
            self.co_type_code = m.get('CoTypeCode')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CurrentPipelineId') is not None:
            self.current_pipeline_id = m.get('CurrentPipelineId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.pipelines = []
        if m.get('Pipelines') is not None:
            for k in m.get('Pipelines'):
                temp_model = DescribeChangeOrderResponseBodyDataPipelines()
                self.pipelines.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubStatus') is not None:
            self.sub_status = m.get('SubStatus')
        if m.get('SupportRollback') is not None:
            self.support_rollback = m.get('SupportRollback')
        return self


class DescribeChangeOrderResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeChangeOrderResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The details of the change order.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the information of the change order was queried. Valid values:
        # 
        # *   **true**: The information was queried.
        # *   **false**: The information failed to be queried.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeChangeOrderResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeChangeOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeChangeOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeChangeOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeComponentsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        type: str = None,
    ):
        # The application ID.
        self.app_id = app_id
        # The type of the supported components. Valid values:
        # 
        # *   **TOMCAT**\
        # *   **JDK**\
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeComponentsResponseBodyData(TeaModel):
    def __init__(
        self,
        component_description: str = None,
        component_key: str = None,
        expired: bool = None,
        type: str = None,
    ):
        # The description of the component.
        self.component_description = component_description
        # The component ID.
        self.component_key = component_key
        # Indicates whether the component is expired. Valid values:
        # 
        # *   **true**: The component is expired.
        # *   **false**: The component is not expired.
        self.expired = expired
        # The type of the component.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.component_description is not None:
            result['ComponentDescription'] = self.component_description
        if self.component_key is not None:
            result['ComponentKey'] = self.component_key
        if self.expired is not None:
            result['Expired'] = self.expired
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComponentDescription') is not None:
            self.component_description = m.get('ComponentDescription')
        if m.get('ComponentKey') is not None:
            self.component_key = m.get('ComponentKey')
        if m.get('Expired') is not None:
            self.expired = m.get('Expired')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeComponentsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[DescribeComponentsResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The request was successful.
        # *   **3xx**: The request was redirected.
        # *   **4xx**: The request failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The details of the supported components.
        self.data = data
        # The status code. Valid values:
        # 
        # *   If the request was successful, **ErrorCode** is not returned.
        # *   If the request failed, **ErrorCode** is returned. For more information, see **Error codes** section of this topic.
        self.error_code = error_code
        # The message returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the component version was obtained. Valid values:
        # 
        # *   **true**: The applications were obtained.
        # *   **false**: The applications failed to be queried.
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeComponentsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeComponentsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeComponentsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeComponentsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeConfigMapRequest(TeaModel):
    def __init__(
        self,
        config_map_id: int = None,
    ):
        # The ID of the ConfigMap whose details you want to query. You can call the [ListNamespacedConfigMaps](https://help.aliyun.com/document_detail/176917.html) operation to obtain the ID of a ConfigMap.
        # 
        # This parameter is required.
        self.config_map_id = config_map_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        return self


class DescribeConfigMapResponseBodyDataRelateApps(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        return self


class DescribeConfigMapResponseBodyData(TeaModel):
    def __init__(
        self,
        config_map_id: int = None,
        create_time: int = None,
        data: Dict[str, Any] = None,
        description: str = None,
        name: str = None,
        namespace_id: str = None,
        relate_apps: List[DescribeConfigMapResponseBodyDataRelateApps] = None,
        update_time: int = None,
    ):
        # The ID of the ConfigMap.
        self.config_map_id = config_map_id
        # The time when the ConfigMap was created.
        self.create_time = create_time
        # The key-value pairs of the ConfigMap. Format:
        # 
        # {"k1":"v1", "k2":"v2"}
        # 
        # k specifies a key and v specifies a value. For more information, see [Manage a Kubernetes ConfigMap](https://help.aliyun.com/document_detail/171326.html).
        self.data = data
        # The description of the ConfigMap.
        self.description = description
        # The name of the ConfigMap.
        self.name = name
        # The ID of the namespace.
        self.namespace_id = namespace_id
        # The application that is associated with the ConfigMap.
        self.relate_apps = relate_apps
        # The time when the ConfigMap was updated.
        self.update_time = update_time

    def validate(self):
        if self.relate_apps:
            for k in self.relate_apps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.data is not None:
            result['Data'] = self.data
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        result['RelateApps'] = []
        if self.relate_apps is not None:
            for k in self.relate_apps:
                result['RelateApps'].append(k.to_map() if k else None)
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        self.relate_apps = []
        if m.get('RelateApps') is not None:
            for k in m.get('RelateApps'):
                temp_model = DescribeConfigMapResponseBodyDataRelateApps()
                self.relate_apps.append(temp_model.from_map(k))
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeConfigMapResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeConfigMapResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The returned result.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the details of the ConfigMap were queried. Valid values:
        # 
        # *   **true**: The details were queried.
        # *   **false**: The details failed to be queried.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeConfigMapResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeConfigMapResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeConfigMapResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeConfigMapResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeConfigurationPriceRequest(TeaModel):
    def __init__(
        self,
        cpu: int = None,
        memory: int = None,
        new_sae_version: str = None,
        resource_type: str = None,
        workload: str = None,
    ):
        # The CPU specifications that are required for each instance. Unit: millicores. This parameter cannot be set to 0. Valid values:
        # 
        # *   **500**\
        # *   **1000**\
        # *   **2000**\
        # *   **4000**\
        # *   **8000**\
        # *   **12000**\
        # *   **16000**\
        # *   **32000**\
        # 
        # This parameter is required.
        self.cpu = cpu
        # The memory size that is required by each instance. Unit: MB. This parameter cannot be set to 0. The values of this parameter correspond to the values of the Cpu parameter:
        # 
        # *   This parameter is set to **1024** if the Cpu parameter is set to 500 or 1000.
        # *   This parameter is set to **2048** if the Cpu parameter is set to 500, 1000, or 2000.
        # *   This parameter is set to **4096** if the Cpu parameter is set to 1000, 2000, or 4000.
        # *   This parameter is set to **8192** if the Cpu parameter is set to 2000, 4000, or 8,000.
        # *   This parameter is set to **12288** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **16384** if the Cpu parameter is set to 4000, 8000, or 16000.
        # *   This parameter is set to **24576** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **32768** if the Cpu parameter is set to 16000.
        # *   This parameter is set to **65536** if the Cpu parameter is set to 8000, 16000, or 32000.
        # *   This parameter is set to **131072** if the Cpu parameter is set to 32000.
        # 
        # This parameter is required.
        self.memory = memory
        self.new_sae_version = new_sae_version
        self.resource_type = resource_type
        # Scenarios:
        # 
        # *   Web
        # *   micro_service
        self.workload = workload

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.new_sae_version is not None:
            result['NewSaeVersion'] = self.new_sae_version
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.workload is not None:
            result['Workload'] = self.workload
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('NewSaeVersion') is not None:
            self.new_sae_version = m.get('NewSaeVersion')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('Workload') is not None:
            self.workload = m.get('Workload')
        return self


class DescribeConfigurationPriceResponseBodyDataBagUsage(TeaModel):
    def __init__(
        self,
        cpu: float = None,
        cu: float = None,
        mem: float = None,
    ):
        # The available CPU capacity. Unit: cores \\*.
        self.cpu = cpu
        self.cu = cu
        # The available memory size. Unit: GiB ×.
        self.mem = mem

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.mem is not None:
            result['Mem'] = self.mem
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        return self


class DescribeConfigurationPriceResponseBodyDataCpuMemPriceOrder(TeaModel):
    def __init__(
        self,
        discount_amount: float = None,
        original_amount: float = None,
        rule_ids: List[str] = None,
        trade_amount: float = None,
    ):
        # The discount amount.
        self.discount_amount = discount_amount
        # The original price.
        self.original_amount = original_amount
        # The ID of the discount rule.
        self.rule_ids = rule_ids
        # The final price of the order.
        self.trade_amount = trade_amount

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.discount_amount is not None:
            result['DiscountAmount'] = self.discount_amount
        if self.original_amount is not None:
            result['OriginalAmount'] = self.original_amount
        if self.rule_ids is not None:
            result['RuleIds'] = self.rule_ids
        if self.trade_amount is not None:
            result['TradeAmount'] = self.trade_amount
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DiscountAmount') is not None:
            self.discount_amount = m.get('DiscountAmount')
        if m.get('OriginalAmount') is not None:
            self.original_amount = m.get('OriginalAmount')
        if m.get('RuleIds') is not None:
            self.rule_ids = m.get('RuleIds')
        if m.get('TradeAmount') is not None:
            self.trade_amount = m.get('TradeAmount')
        return self


class DescribeConfigurationPriceResponseBodyDataCpuMemPriceRules(TeaModel):
    def __init__(
        self,
        name: str = None,
        rule_desc_id: float = None,
    ):
        # The name of discount rule.
        self.name = name
        # The ID of the discount rule.
        self.rule_desc_id = rule_desc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.rule_desc_id is not None:
            result['RuleDescId'] = self.rule_desc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RuleDescId') is not None:
            self.rule_desc_id = m.get('RuleDescId')
        return self


class DescribeConfigurationPriceResponseBodyDataCpuMemPrice(TeaModel):
    def __init__(
        self,
        order: DescribeConfigurationPriceResponseBodyDataCpuMemPriceOrder = None,
        rules: List[DescribeConfigurationPriceResponseBodyDataCpuMemPriceRules] = None,
    ):
        # The information about pricing.
        self.order = order
        # The discount rules.
        self.rules = rules

    def validate(self):
        if self.order:
            self.order.validate()
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order is not None:
            result['Order'] = self.order.to_map()
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Order') is not None:
            temp_model = DescribeConfigurationPriceResponseBodyDataCpuMemPriceOrder()
            self.order = temp_model.from_map(m['Order'])
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = DescribeConfigurationPriceResponseBodyDataCpuMemPriceRules()
                self.rules.append(temp_model.from_map(k))
        return self


class DescribeConfigurationPriceResponseBodyDataOrder(TeaModel):
    def __init__(
        self,
        discount_amount: float = None,
        original_amount: float = None,
        rule_ids: List[str] = None,
        trade_amount: float = None,
    ):
        # The discount amount.
        self.discount_amount = discount_amount
        # The original price of the order.
        self.original_amount = original_amount
        # The ID of the promotion rule.
        self.rule_ids = rule_ids
        # The transaction price.
        self.trade_amount = trade_amount

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.discount_amount is not None:
            result['DiscountAmount'] = self.discount_amount
        if self.original_amount is not None:
            result['OriginalAmount'] = self.original_amount
        if self.rule_ids is not None:
            result['RuleIds'] = self.rule_ids
        if self.trade_amount is not None:
            result['TradeAmount'] = self.trade_amount
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DiscountAmount') is not None:
            self.discount_amount = m.get('DiscountAmount')
        if m.get('OriginalAmount') is not None:
            self.original_amount = m.get('OriginalAmount')
        if m.get('RuleIds') is not None:
            self.rule_ids = m.get('RuleIds')
        if m.get('TradeAmount') is not None:
            self.trade_amount = m.get('TradeAmount')
        return self


class DescribeConfigurationPriceResponseBodyDataRequestPriceOrder(TeaModel):
    def __init__(
        self,
        discount_amount: float = None,
        original_amount: float = None,
        rule_ids: List[str] = None,
        trade_amount: float = None,
    ):
        # The discount amount.
        self.discount_amount = discount_amount
        # The original price of the order.
        self.original_amount = original_amount
        # The ID of the discount rule.
        self.rule_ids = rule_ids
        # The actual price of the order.
        self.trade_amount = trade_amount

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.discount_amount is not None:
            result['DiscountAmount'] = self.discount_amount
        if self.original_amount is not None:
            result['OriginalAmount'] = self.original_amount
        if self.rule_ids is not None:
            result['RuleIds'] = self.rule_ids
        if self.trade_amount is not None:
            result['TradeAmount'] = self.trade_amount
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DiscountAmount') is not None:
            self.discount_amount = m.get('DiscountAmount')
        if m.get('OriginalAmount') is not None:
            self.original_amount = m.get('OriginalAmount')
        if m.get('RuleIds') is not None:
            self.rule_ids = m.get('RuleIds')
        if m.get('TradeAmount') is not None:
            self.trade_amount = m.get('TradeAmount')
        return self


class DescribeConfigurationPriceResponseBodyDataRequestPriceRules(TeaModel):
    def __init__(
        self,
        name: str = None,
        rule_desc_id: int = None,
    ):
        # The name of the discount rule.
        self.name = name
        # The ID of the discount policy.
        self.rule_desc_id = rule_desc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.rule_desc_id is not None:
            result['RuleDescId'] = self.rule_desc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RuleDescId') is not None:
            self.rule_desc_id = m.get('RuleDescId')
        return self


class DescribeConfigurationPriceResponseBodyDataRequestPrice(TeaModel):
    def __init__(
        self,
        order: DescribeConfigurationPriceResponseBodyDataRequestPriceOrder = None,
        rules: List[DescribeConfigurationPriceResponseBodyDataRequestPriceRules] = None,
    ):
        # The information about pricing.
        self.order = order
        # The discount rule.
        self.rules = rules

    def validate(self):
        if self.order:
            self.order.validate()
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order is not None:
            result['Order'] = self.order.to_map()
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Order') is not None:
            temp_model = DescribeConfigurationPriceResponseBodyDataRequestPriceOrder()
            self.order = temp_model.from_map(m['Order'])
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = DescribeConfigurationPriceResponseBodyDataRequestPriceRules()
                self.rules.append(temp_model.from_map(k))
        return self


class DescribeConfigurationPriceResponseBodyDataRules(TeaModel):
    def __init__(
        self,
        name: str = None,
        rule_desc_id: int = None,
    ):
        # The name of the promotion rule.
        self.name = name
        # The ID of the promotion rule.
        self.rule_desc_id = rule_desc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.rule_desc_id is not None:
            result['RuleDescId'] = self.rule_desc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RuleDescId') is not None:
            self.rule_desc_id = m.get('RuleDescId')
        return self


class DescribeConfigurationPriceResponseBodyDataTrafficPriceOrder(TeaModel):
    def __init__(
        self,
        discount_amount: float = None,
        original_amount: float = None,
        rule_ids: List[str] = None,
        trade_amount: float = None,
    ):
        # The discount amount.
        self.discount_amount = discount_amount
        # The original price of the order.
        self.original_amount = original_amount
        # The ID of the discount rule.
        self.rule_ids = rule_ids
        # The final price of the order.
        self.trade_amount = trade_amount

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.discount_amount is not None:
            result['DiscountAmount'] = self.discount_amount
        if self.original_amount is not None:
            result['OriginalAmount'] = self.original_amount
        if self.rule_ids is not None:
            result['RuleIds'] = self.rule_ids
        if self.trade_amount is not None:
            result['TradeAmount'] = self.trade_amount
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DiscountAmount') is not None:
            self.discount_amount = m.get('DiscountAmount')
        if m.get('OriginalAmount') is not None:
            self.original_amount = m.get('OriginalAmount')
        if m.get('RuleIds') is not None:
            self.rule_ids = m.get('RuleIds')
        if m.get('TradeAmount') is not None:
            self.trade_amount = m.get('TradeAmount')
        return self


class DescribeConfigurationPriceResponseBodyDataTrafficPriceRules(TeaModel):
    def __init__(
        self,
        name: str = None,
        rule_desc_id: float = None,
    ):
        # The name of the discount rule.
        self.name = name
        # The ID of the discount rule.
        self.rule_desc_id = rule_desc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.rule_desc_id is not None:
            result['RuleDescId'] = self.rule_desc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RuleDescId') is not None:
            self.rule_desc_id = m.get('RuleDescId')
        return self


class DescribeConfigurationPriceResponseBodyDataTrafficPrice(TeaModel):
    def __init__(
        self,
        order: DescribeConfigurationPriceResponseBodyDataTrafficPriceOrder = None,
        rules: List[DescribeConfigurationPriceResponseBodyDataTrafficPriceRules] = None,
    ):
        # The information about pricing.
        self.order = order
        # The discount rule.
        self.rules = rules

    def validate(self):
        if self.order:
            self.order.validate()
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order is not None:
            result['Order'] = self.order.to_map()
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Order') is not None:
            temp_model = DescribeConfigurationPriceResponseBodyDataTrafficPriceOrder()
            self.order = temp_model.from_map(m['Order'])
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = DescribeConfigurationPriceResponseBodyDataTrafficPriceRules()
                self.rules.append(temp_model.from_map(k))
        return self


class DescribeConfigurationPriceResponseBodyData(TeaModel):
    def __init__(
        self,
        bag_usage: DescribeConfigurationPriceResponseBodyDataBagUsage = None,
        cpu_mem_price: DescribeConfigurationPriceResponseBodyDataCpuMemPrice = None,
        order: DescribeConfigurationPriceResponseBodyDataOrder = None,
        request_price: DescribeConfigurationPriceResponseBodyDataRequestPrice = None,
        rules: List[DescribeConfigurationPriceResponseBodyDataRules] = None,
        traffic_price: DescribeConfigurationPriceResponseBodyDataTrafficPrice = None,
    ):
        # The remaining capacity of the resource plan.
        self.bag_usage = bag_usage
        # The price of CPU and memory.
        self.cpu_mem_price = cpu_mem_price
        # The information about pricing.
        self.order = order
        # The price based on the number of requests.
        self.request_price = request_price
        # The promotion rules.
        self.rules = rules
        # The traffic price.
        self.traffic_price = traffic_price

    def validate(self):
        if self.bag_usage:
            self.bag_usage.validate()
        if self.cpu_mem_price:
            self.cpu_mem_price.validate()
        if self.order:
            self.order.validate()
        if self.request_price:
            self.request_price.validate()
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()
        if self.traffic_price:
            self.traffic_price.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bag_usage is not None:
            result['BagUsage'] = self.bag_usage.to_map()
        if self.cpu_mem_price is not None:
            result['CpuMemPrice'] = self.cpu_mem_price.to_map()
        if self.order is not None:
            result['Order'] = self.order.to_map()
        if self.request_price is not None:
            result['RequestPrice'] = self.request_price.to_map()
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        if self.traffic_price is not None:
            result['TrafficPrice'] = self.traffic_price.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BagUsage') is not None:
            temp_model = DescribeConfigurationPriceResponseBodyDataBagUsage()
            self.bag_usage = temp_model.from_map(m['BagUsage'])
        if m.get('CpuMemPrice') is not None:
            temp_model = DescribeConfigurationPriceResponseBodyDataCpuMemPrice()
            self.cpu_mem_price = temp_model.from_map(m['CpuMemPrice'])
        if m.get('Order') is not None:
            temp_model = DescribeConfigurationPriceResponseBodyDataOrder()
            self.order = temp_model.from_map(m['Order'])
        if m.get('RequestPrice') is not None:
            temp_model = DescribeConfigurationPriceResponseBodyDataRequestPrice()
            self.request_price = temp_model.from_map(m['RequestPrice'])
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = DescribeConfigurationPriceResponseBodyDataRules()
                self.rules.append(temp_model.from_map(k))
        if m.get('TrafficPrice') is not None:
            temp_model = DescribeConfigurationPriceResponseBodyDataTrafficPrice()
            self.traffic_price = temp_model.from_map(m['TrafficPrice'])
        return self


class DescribeConfigurationPriceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeConfigurationPriceResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The request was successful.
        # *   **3xx**: The request was redirected.
        # *   **4xx**: The request failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The price.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the request was successful, **ErrorCode** is not returned.
        # *   If the request failed, **ErrorCode** is returned. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The message returned. Valid values:
        # 
        # *   If the request was successful, **success** is returned.
        # *   If the request failed, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the configuration price was obtained.
        # 
        # *   **true**: The price was obtained.
        # *   **false**: The price failed to be queried.
        self.success = success
        # The ID of the trace.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeConfigurationPriceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeConfigurationPriceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeConfigurationPriceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeConfigurationPriceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEdasContainersResponseBodyData(TeaModel):
    def __init__(
        self,
        disabled: bool = None,
        edas_container_version: str = None,
    ):
        # Indicates whether the component is disabled. Valid values:
        # 
        # *   **true**: The component is disabled.
        # *   **false**: The component is not disabled.
        self.disabled = disabled
        # The version of the container, such as Ali-Tomcat, in which an application that is developed based on High-speed Service Framework (HSF) is deployed.
        self.edas_container_version = edas_container_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        return self


class DescribeEdasContainersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[DescribeEdasContainersResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The components.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the list of container components of a microservices application was obtained. Valid values:
        # 
        # *   **true**: The list was obtained.
        # *   **false**: The list failed to be obtained.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeEdasContainersResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeEdasContainersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEdasContainersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEdasContainersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGreyTagRouteRequest(TeaModel):
    def __init__(
        self,
        grey_tag_route_id: int = None,
    ):
        # The ID of the canary release rule.
        # 
        # This parameter is required.
        self.grey_tag_route_id = grey_tag_route_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grey_tag_route_id is not None:
            result['GreyTagRouteId'] = self.grey_tag_route_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GreyTagRouteId') is not None:
            self.grey_tag_route_id = m.get('GreyTagRouteId')
        return self


class DescribeGreyTagRouteResponseBodyDataAlbRulesItems(TeaModel):
    def __init__(
        self,
        cond: str = None,
        expr: str = None,
        index: int = None,
        name: str = None,
        operator: str = None,
        type: str = None,
        value: str = None,
    ):
        # Valid value: ==.
        self.cond = cond
        # This parameter is not returned for applications that are associated with ALB instances.
        self.expr = expr
        # This parameter is not returned for applications that are associated with Application Load Balancer (ALB) instances.
        self.index = index
        # The name of the parameter.
        self.name = name
        # The operator. Valid value: **rawvalue**. This value indicates direct comparison.
        self.operator = operator
        # The type of the comparison. Valid values:
        # 
        # *   **sourceIp**: SourceIp
        # *   **cookie**: cookie
        # *   **header**: header
        self.type = type
        # The value of the parameter. This value is compared with the value that is obtained based on the type and name parameters.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cond is not None:
            result['cond'] = self.cond
        if self.expr is not None:
            result['expr'] = self.expr
        if self.index is not None:
            result['index'] = self.index
        if self.name is not None:
            result['name'] = self.name
        if self.operator is not None:
            result['operator'] = self.operator
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cond') is not None:
            self.cond = m.get('cond')
        if m.get('expr') is not None:
            self.expr = m.get('expr')
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeGreyTagRouteResponseBodyDataAlbRules(TeaModel):
    def __init__(
        self,
        condition: str = None,
        ingress_id: str = None,
        items: List[DescribeGreyTagRouteResponseBodyDataAlbRulesItems] = None,
        service_id: str = None,
    ):
        # The condition mode of the canary release rule. Valid value: AND. This value indicates that that all conditions must be met.
        self.condition = condition
        # The ID of the gateway routing rule.
        self.ingress_id = ingress_id
        self.items = items
        # The service ID.
        self.service_id = service_id

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['condition'] = self.condition
        if self.ingress_id is not None:
            result['ingressId'] = self.ingress_id
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.service_id is not None:
            result['serviceId'] = self.service_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        if m.get('ingressId') is not None:
            self.ingress_id = m.get('ingressId')
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = DescribeGreyTagRouteResponseBodyDataAlbRulesItems()
                self.items.append(temp_model.from_map(k))
        if m.get('serviceId') is not None:
            self.service_id = m.get('serviceId')
        return self


class DescribeGreyTagRouteResponseBodyDataDubboRulesItems(TeaModel):
    def __init__(
        self,
        cond: str = None,
        expr: str = None,
        index: int = None,
        name: str = None,
        operator: str = None,
        type: str = None,
        value: str = None,
    ):
        # The comparison operator. Valid values: **>**, **<**, **>=**, **<=**, **==**, and **! =**.
        self.cond = cond
        # The expression that is used to obtain the value of the parameter. Valid values:
        # 
        # *   **Empty**: obtains the value of the parameter.
        # *   **.name**: obtains the name property of the parameter. This expression works the same way as args0.getName().
        # *   **.isEnabled()**: obtains the enabled property of the parameter. This expression works the same way as args0.isEnabled().
        # *   **[0]**: indicates that the value of the parameter is an array and obtains the first value of the array. This expression works the same way as args0[0]. This expression does not start with a period (.).
        # *   **.get(0)**: indicates that the value of the parameter is a list and obtains the first value of the list. This expression works the same way as args0.get(0).
        # *   **.get("key")**: indicates that the value of the parameter is a map and obtains the value of the key in the map. This expression works the same way as args0.get("key").
        self.expr = expr
        # The index of the parameter. The value 0 indicates the first parameter.
        self.index = index
        # This parameter is not returned for Dubbo services.
        self.name = name
        # The operator. Valid values:
        # 
        # *   **rawvalue**: direct comparison.
        # *   **list**: whitelist.
        # *   **mod**: mods 100.
        # *   **deterministic_proportional_steaming_division**: percentage.
        self.operator = operator
        # This parameter is not returned for Dubbo services.
        self.type = type
        # The value of the parameter. This value is compared with the value that is obtained based on the **expr** and **index** parameters.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cond is not None:
            result['cond'] = self.cond
        if self.expr is not None:
            result['expr'] = self.expr
        if self.index is not None:
            result['index'] = self.index
        if self.name is not None:
            result['name'] = self.name
        if self.operator is not None:
            result['operator'] = self.operator
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cond') is not None:
            self.cond = m.get('cond')
        if m.get('expr') is not None:
            self.expr = m.get('expr')
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeGreyTagRouteResponseBodyDataDubboRules(TeaModel):
    def __init__(
        self,
        condition: str = None,
        group: str = None,
        items: List[DescribeGreyTagRouteResponseBodyDataDubboRulesItems] = None,
        method_name: str = None,
        service_name: str = None,
        version: str = None,
    ):
        # The relationship between the conditions in the canary release rule. Valid values:
        # 
        # *   **AND**: The conditions are in the logical AND relation. All conditions must be met at the same time.
        # *   **OR**: The conditions are in the logical OR relation. At least one of the conditions must be met.
        self.condition = condition
        # The group of the Dubbo service that corresponds to the canary release rule.
        self.group = group
        # The conditions.
        self.items = items
        # The method name of the Dubbo service.
        self.method_name = method_name
        # The name of the Dubbo service.
        self.service_name = service_name
        # The version of the Dubbo service.
        self.version = version

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['condition'] = self.condition
        if self.group is not None:
            result['group'] = self.group
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.method_name is not None:
            result['methodName'] = self.method_name
        if self.service_name is not None:
            result['serviceName'] = self.service_name
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        if m.get('group') is not None:
            self.group = m.get('group')
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = DescribeGreyTagRouteResponseBodyDataDubboRulesItems()
                self.items.append(temp_model.from_map(k))
        if m.get('methodName') is not None:
            self.method_name = m.get('methodName')
        if m.get('serviceName') is not None:
            self.service_name = m.get('serviceName')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class DescribeGreyTagRouteResponseBodyDataScRulesItems(TeaModel):
    def __init__(
        self,
        cond: str = None,
        expr: str = None,
        index: int = None,
        name: str = None,
        operator: str = None,
        type: str = None,
        value: str = None,
    ):
        # The comparison operator. Valid values: **>**, **<**, **>=**, **<=**, **==**, and **! =**.
        self.cond = cond
        # This parameter is not returned for Spring Cloud applications.
        self.expr = expr
        # This parameter is not returned for Spring Cloud applications.
        self.index = index
        # The name of the parameter.
        self.name = name
        # The operator. Valid values:
        # 
        # *   **rawvalue**: direct comparison.
        # *   **list**: whitelist.
        # *   **mod**: mods 100.
        # *   **deterministic_proportional_steaming_division**: percentage.
        self.operator = operator
        # The type of the comparison. Valid values:
        # 
        # *   **param**: parameter
        # *   **cookie**: cookie
        # *   **header**: header
        self.type = type
        # The value of the parameter. This value is compared with the value that is obtained based on the **type** and **name** parameters.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cond is not None:
            result['cond'] = self.cond
        if self.expr is not None:
            result['expr'] = self.expr
        if self.index is not None:
            result['index'] = self.index
        if self.name is not None:
            result['name'] = self.name
        if self.operator is not None:
            result['operator'] = self.operator
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cond') is not None:
            self.cond = m.get('cond')
        if m.get('expr') is not None:
            self.expr = m.get('expr')
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeGreyTagRouteResponseBodyDataScRules(TeaModel):
    def __init__(
        self,
        condition: str = None,
        items: List[DescribeGreyTagRouteResponseBodyDataScRulesItems] = None,
        path: str = None,
    ):
        # The relationship between the conditions in the canary release rule. Valid values:
        # 
        # *   **AND**: The conditions are in the logical AND relation. All conditions must be met at the same time.
        # *   **OR**: The conditions are in the logical OR relation. At least one of the conditions must be met.
        self.condition = condition
        # The conditions.
        self.items = items
        # The path of the canary release rule of the Spring Cloud application.
        self.path = path

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['condition'] = self.condition
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.path is not None:
            result['path'] = self.path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = DescribeGreyTagRouteResponseBodyDataScRulesItems()
                self.items.append(temp_model.from_map(k))
        if m.get('path') is not None:
            self.path = m.get('path')
        return self


class DescribeGreyTagRouteResponseBodyData(TeaModel):
    def __init__(
        self,
        alb_rules: List[DescribeGreyTagRouteResponseBodyDataAlbRules] = None,
        app_id: str = None,
        create_time: int = None,
        description: str = None,
        dubbo_rules: List[DescribeGreyTagRouteResponseBodyDataDubboRules] = None,
        grey_tag_route_id: int = None,
        name: str = None,
        sc_rules: List[DescribeGreyTagRouteResponseBodyDataScRules] = None,
        update_time: int = None,
    ):
        self.alb_rules = alb_rules
        # The ID of the application.
        self.app_id = app_id
        # The timestamp when the canary release rule was created. Unit: milliseconds.
        self.create_time = create_time
        # The description of the canary release rule.
        self.description = description
        # The canary release rule of the Dubbo service.
        self.dubbo_rules = dubbo_rules
        # The ID of the canary release rule. The ID is globally unique.
        self.grey_tag_route_id = grey_tag_route_id
        # The name of the canary release rule.
        self.name = name
        # The canary release rule of the Spring Cloud application.
        self.sc_rules = sc_rules
        # The timestamp when the canary release rule was updated. Unit: milliseconds.
        self.update_time = update_time

    def validate(self):
        if self.alb_rules:
            for k in self.alb_rules:
                if k:
                    k.validate()
        if self.dubbo_rules:
            for k in self.dubbo_rules:
                if k:
                    k.validate()
        if self.sc_rules:
            for k in self.sc_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlbRules'] = []
        if self.alb_rules is not None:
            for k in self.alb_rules:
                result['AlbRules'].append(k.to_map() if k else None)
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        result['DubboRules'] = []
        if self.dubbo_rules is not None:
            for k in self.dubbo_rules:
                result['DubboRules'].append(k.to_map() if k else None)
        if self.grey_tag_route_id is not None:
            result['GreyTagRouteId'] = self.grey_tag_route_id
        if self.name is not None:
            result['Name'] = self.name
        result['ScRules'] = []
        if self.sc_rules is not None:
            for k in self.sc_rules:
                result['ScRules'].append(k.to_map() if k else None)
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alb_rules = []
        if m.get('AlbRules') is not None:
            for k in m.get('AlbRules'):
                temp_model = DescribeGreyTagRouteResponseBodyDataAlbRules()
                self.alb_rules.append(temp_model.from_map(k))
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.dubbo_rules = []
        if m.get('DubboRules') is not None:
            for k in m.get('DubboRules'):
                temp_model = DescribeGreyTagRouteResponseBodyDataDubboRules()
                self.dubbo_rules.append(temp_model.from_map(k))
        if m.get('GreyTagRouteId') is not None:
            self.grey_tag_route_id = m.get('GreyTagRouteId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.sc_rules = []
        if m.get('ScRules') is not None:
            for k in m.get('ScRules'):
                temp_model = DescribeGreyTagRouteResponseBodyDataScRules()
                self.sc_rules.append(temp_model.from_map(k))
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeGreyTagRouteResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeGreyTagRouteResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The information about the canary release rule.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the information of the change order was queried. Valid values:
        # 
        # *   **true**: The information was queried.
        # *   **false**: The information failed to be queried.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeGreyTagRouteResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeGreyTagRouteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeGreyTagRouteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGreyTagRouteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeIngressRequest(TeaModel):
    def __init__(
        self,
        ingress_id: int = None,
    ):
        # The ID of the routing rule to be queried.
        # 
        # This parameter is required.
        self.ingress_id = ingress_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ingress_id is not None:
            result['IngressId'] = self.ingress_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IngressId') is not None:
            self.ingress_id = m.get('IngressId')
        return self


class DescribeIngressResponseBodyDataCorsConfig(TeaModel):
    def __init__(
        self,
        allow_credentials: str = None,
        allow_headers: str = None,
        allow_methods: str = None,
        allow_origin: str = None,
        enable: str = None,
        expose_headers: str = None,
        max_age: str = None,
    ):
        self.allow_credentials = allow_credentials
        self.allow_headers = allow_headers
        self.allow_methods = allow_methods
        self.allow_origin = allow_origin
        self.enable = enable
        self.expose_headers = expose_headers
        self.max_age = max_age

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_credentials is not None:
            result['AllowCredentials'] = self.allow_credentials
        if self.allow_headers is not None:
            result['AllowHeaders'] = self.allow_headers
        if self.allow_methods is not None:
            result['AllowMethods'] = self.allow_methods
        if self.allow_origin is not None:
            result['AllowOrigin'] = self.allow_origin
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.expose_headers is not None:
            result['ExposeHeaders'] = self.expose_headers
        if self.max_age is not None:
            result['MaxAge'] = self.max_age
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllowCredentials') is not None:
            self.allow_credentials = m.get('AllowCredentials')
        if m.get('AllowHeaders') is not None:
            self.allow_headers = m.get('AllowHeaders')
        if m.get('AllowMethods') is not None:
            self.allow_methods = m.get('AllowMethods')
        if m.get('AllowOrigin') is not None:
            self.allow_origin = m.get('AllowOrigin')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('ExposeHeaders') is not None:
            self.expose_headers = m.get('ExposeHeaders')
        if m.get('MaxAge') is not None:
            self.max_age = m.get('MaxAge')
        return self


class DescribeIngressResponseBodyDataDefaultRule(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        backend_protocol: str = None,
        container_port: int = None,
    ):
        # The ID of the application that is specified in the default rule.
        self.app_id = app_id
        # The name of the application that is specified in the default rule.
        self.app_name = app_name
        # The backend protocol. Valid values:
        # 
        # *   **http**: HTTP is suitable for applications that need to identify the transmitted data.
        # *   **https**: HTTP is suitable for applications that require encrypted data transmission.
        # *   **grpc**: GRPC is suitable for load balancing scenarios in which you want to deploy services in multi-language frameworks, such as the .NET framework.
        # 
        # This parameter is returned only if the**LoadBalanceType** parameter is set to **ALB** and the **ListenerProtocol** parameter **is set to HTTPS**.
        self.backend_protocol = backend_protocol
        # The container port of the application that is specified in the default rule.
        self.container_port = container_port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.backend_protocol is not None:
            result['BackendProtocol'] = self.backend_protocol
        if self.container_port is not None:
            result['ContainerPort'] = self.container_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BackendProtocol') is not None:
            self.backend_protocol = m.get('BackendProtocol')
        if m.get('ContainerPort') is not None:
            self.container_port = m.get('ContainerPort')
        return self


class DescribeIngressResponseBodyDataRulesRuleActions(TeaModel):
    def __init__(
        self,
        action_config: str = None,
        action_type: str = None,
    ):
        self.action_config = action_config
        self.action_type = action_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_config is not None:
            result['ActionConfig'] = self.action_config
        if self.action_type is not None:
            result['ActionType'] = self.action_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionConfig') is not None:
            self.action_config = m.get('ActionConfig')
        if m.get('ActionType') is not None:
            self.action_type = m.get('ActionType')
        return self


class DescribeIngressResponseBodyDataRules(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        backend_protocol: str = None,
        container_port: int = None,
        domain: str = None,
        path: str = None,
        rewrite_path: str = None,
        rule_actions: List[DescribeIngressResponseBodyDataRulesRuleActions] = None,
    ):
        # The ID of the application specified in the forwarding rule.
        self.app_id = app_id
        # The name of the application specified in the forwarding rules.
        self.app_name = app_name
        # The backend protocol. Valid values:
        # 
        # *   **http**: HTTP is suitable for applications that need to identify the transmitted data.
        # *   **https**: HTTPS is suitable for applications that require encrypted data transmission.
        # *   **grpc**: GRPC is suitable for load balancing scenarios in which you want to deploy services in multi-language frameworks, such as the .NET framework.
        # 
        # This parameter is returned only if the **LoadBalanceType** parameter is set to **ALB** and the **ListenerProtocol** parameter is set to **HTTPS**.
        self.backend_protocol = backend_protocol
        # Tthe container port of the application specified in the forwarding rules.
        self.container_port = container_port
        # The domain name of the application specified in the forwarding rules.
        self.domain = domain
        # The path of a URL.
        self.path = path
        # The path that is used to rewrite the original path.
        self.rewrite_path = rewrite_path
        self.rule_actions = rule_actions

    def validate(self):
        if self.rule_actions:
            for k in self.rule_actions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.backend_protocol is not None:
            result['BackendProtocol'] = self.backend_protocol
        if self.container_port is not None:
            result['ContainerPort'] = self.container_port
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.path is not None:
            result['Path'] = self.path
        if self.rewrite_path is not None:
            result['RewritePath'] = self.rewrite_path
        result['RuleActions'] = []
        if self.rule_actions is not None:
            for k in self.rule_actions:
                result['RuleActions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BackendProtocol') is not None:
            self.backend_protocol = m.get('BackendProtocol')
        if m.get('ContainerPort') is not None:
            self.container_port = m.get('ContainerPort')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('RewritePath') is not None:
            self.rewrite_path = m.get('RewritePath')
        self.rule_actions = []
        if m.get('RuleActions') is not None:
            for k in m.get('RuleActions'):
                temp_model = DescribeIngressResponseBodyDataRulesRuleActions()
                self.rule_actions.append(temp_model.from_map(k))
        return self


class DescribeIngressResponseBodyData(TeaModel):
    def __init__(
        self,
        cert_id: str = None,
        cert_ids: str = None,
        cors_config: DescribeIngressResponseBodyDataCorsConfig = None,
        created_by_sae: bool = None,
        default_rule: DescribeIngressResponseBodyDataDefaultRule = None,
        description: str = None,
        enable_xforwarded_for: bool = None,
        enable_xforwarded_for_client_src_port: bool = None,
        enable_xforwarded_for_proto: bool = None,
        enable_xforwarded_for_slb_id: bool = None,
        enable_xforwarded_for_slb_port: bool = None,
        id: int = None,
        idle_timeout: int = None,
        listener_port: int = None,
        listener_protocol: str = None,
        load_balance_type: str = None,
        name: str = None,
        namespace_id: str = None,
        request_timeout: int = None,
        rules: List[DescribeIngressResponseBodyDataRules] = None,
        security_policy_id: str = None,
        slb_id: str = None,
        slb_type: str = None,
    ):
        # The ID of the certificate that is associated with a Classic Load Balancer (**CLB**) instance.
        self.cert_id = cert_id
        # The ID of the certificate that is associated with an Application Load Balancer **ALB** instance.
        self.cert_ids = cert_ids
        self.cors_config = cors_config
        self.created_by_sae = created_by_sae
        # The default rule.
        self.default_rule = default_rule
        # The name of a routing rule.
        self.description = description
        self.enable_xforwarded_for = enable_xforwarded_for
        self.enable_xforwarded_for_client_src_port = enable_xforwarded_for_client_src_port
        self.enable_xforwarded_for_proto = enable_xforwarded_for_proto
        self.enable_xforwarded_for_slb_id = enable_xforwarded_for_slb_id
        self.enable_xforwarded_for_slb_port = enable_xforwarded_for_slb_port
        # The ID of a routing rule.
        self.id = id
        self.idle_timeout = idle_timeout
        # The listener ports for an SLB instance.
        self.listener_port = listener_port
        # The protocol used to forward requests. Valid values:
        # 
        # *   **HTTP**: HTTP is suitable for applications that need to identify the transmitted data.
        # *   **HTTPS**: HTTPS is suitable for applications that require encrypted data transmission.
        # 
        # This parameter is optional in the **CreateIngress** and **UpadateIngress** operations. If you do not configure this parameter when you call the CreateIngress or UpdateIngress operation to create or update a gateway routing rule, this parameter is not returned for the corresponding response.
        self.listener_protocol = listener_protocol
        # The type of SLB instances. Valid values:
        # 
        # *   **clb**: Classic Load Balancer (formerly known as SLB).
        # *   **alb**: Application Load Balancer.
        self.load_balance_type = load_balance_type
        # The name of a routing rule.
        self.name = name
        # The ID of a namespace.
        self.namespace_id = namespace_id
        self.request_timeout = request_timeout
        # The forwarding rules.
        self.rules = rules
        self.security_policy_id = security_policy_id
        # The ID of a Server Load Balancer (SLB) instance.
        self.slb_id = slb_id
        # The type of an SLB instance. Valid values:
        # 
        # *   **internet**: an Internet-facing SLB instance
        # *   **intranet**: an Intranet-facing SLB instance
        self.slb_type = slb_type

    def validate(self):
        if self.cors_config:
            self.cors_config.validate()
        if self.default_rule:
            self.default_rule.validate()
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_id is not None:
            result['CertId'] = self.cert_id
        if self.cert_ids is not None:
            result['CertIds'] = self.cert_ids
        if self.cors_config is not None:
            result['CorsConfig'] = self.cors_config.to_map()
        if self.created_by_sae is not None:
            result['CreatedBySae'] = self.created_by_sae
        if self.default_rule is not None:
            result['DefaultRule'] = self.default_rule.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.enable_xforwarded_for is not None:
            result['EnableXForwardedFor'] = self.enable_xforwarded_for
        if self.enable_xforwarded_for_client_src_port is not None:
            result['EnableXForwardedForClientSrcPort'] = self.enable_xforwarded_for_client_src_port
        if self.enable_xforwarded_for_proto is not None:
            result['EnableXForwardedForProto'] = self.enable_xforwarded_for_proto
        if self.enable_xforwarded_for_slb_id is not None:
            result['EnableXForwardedForSlbId'] = self.enable_xforwarded_for_slb_id
        if self.enable_xforwarded_for_slb_port is not None:
            result['EnableXForwardedForSlbPort'] = self.enable_xforwarded_for_slb_port
        if self.id is not None:
            result['Id'] = self.id
        if self.idle_timeout is not None:
            result['IdleTimeout'] = self.idle_timeout
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.listener_protocol is not None:
            result['ListenerProtocol'] = self.listener_protocol
        if self.load_balance_type is not None:
            result['LoadBalanceType'] = self.load_balance_type
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.request_timeout is not None:
            result['RequestTimeout'] = self.request_timeout
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        if self.security_policy_id is not None:
            result['SecurityPolicyId'] = self.security_policy_id
        if self.slb_id is not None:
            result['SlbId'] = self.slb_id
        if self.slb_type is not None:
            result['SlbType'] = self.slb_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertId') is not None:
            self.cert_id = m.get('CertId')
        if m.get('CertIds') is not None:
            self.cert_ids = m.get('CertIds')
        if m.get('CorsConfig') is not None:
            temp_model = DescribeIngressResponseBodyDataCorsConfig()
            self.cors_config = temp_model.from_map(m['CorsConfig'])
        if m.get('CreatedBySae') is not None:
            self.created_by_sae = m.get('CreatedBySae')
        if m.get('DefaultRule') is not None:
            temp_model = DescribeIngressResponseBodyDataDefaultRule()
            self.default_rule = temp_model.from_map(m['DefaultRule'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnableXForwardedFor') is not None:
            self.enable_xforwarded_for = m.get('EnableXForwardedFor')
        if m.get('EnableXForwardedForClientSrcPort') is not None:
            self.enable_xforwarded_for_client_src_port = m.get('EnableXForwardedForClientSrcPort')
        if m.get('EnableXForwardedForProto') is not None:
            self.enable_xforwarded_for_proto = m.get('EnableXForwardedForProto')
        if m.get('EnableXForwardedForSlbId') is not None:
            self.enable_xforwarded_for_slb_id = m.get('EnableXForwardedForSlbId')
        if m.get('EnableXForwardedForSlbPort') is not None:
            self.enable_xforwarded_for_slb_port = m.get('EnableXForwardedForSlbPort')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IdleTimeout') is not None:
            self.idle_timeout = m.get('IdleTimeout')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('ListenerProtocol') is not None:
            self.listener_protocol = m.get('ListenerProtocol')
        if m.get('LoadBalanceType') is not None:
            self.load_balance_type = m.get('LoadBalanceType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('RequestTimeout') is not None:
            self.request_timeout = m.get('RequestTimeout')
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = DescribeIngressResponseBodyDataRules()
                self.rules.append(temp_model.from_map(k))
        if m.get('SecurityPolicyId') is not None:
            self.security_policy_id = m.get('SecurityPolicyId')
        if m.get('SlbId') is not None:
            self.slb_id = m.get('SlbId')
        if m.get('SlbType') is not None:
            self.slb_type = m.get('SlbType')
        return self


class DescribeIngressResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeIngressResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The request was successful.
        # *   **3xx**: The request was redirected.
        # *   **4xx**: The request failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The result returned.
        self.data = data
        # The error codes. Valid values:
        # 
        # *   **ErrorCode** is not returned if a request is successful.
        # *   **ErrorCode** is returned if a request failed. For more information, see **Error code** section of this topic.
        self.error_code = error_code
        # The message returned. Valid values:
        # 
        # *   **success** is returned when a request is successful.
        # *   An error code is returned when the request failed.
        self.message = message
        # The ID of a request.
        self.request_id = request_id
        # Indicates whether the configurations of Ingresses were queried successfully. Valid values:
        # 
        # *   **true**: The information was queried.
        # *   **false**: The information failed to be queried.
        self.success = success
        # The ID of a trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeIngressResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeIngressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeIngressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeIngressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceLogRequest(TeaModel):
    def __init__(
        self,
        container_id: str = None,
        instance_id: str = None,
    ):
        # The ID of the sidecar container. You can call the [DescribeApplicationInstances](https://help.aliyun.com/document_detail/2834847.html) to obtain the ID.
        self.container_id = container_id
        # The instance ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeInstanceLogResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The interface state or POP error code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The information of instance logs.
        self.data = data
        # Error code.
        # 
        # - No error code returned if the request succeeded.
        # 
        # - Error code returned if the request failed. Refer to error code list below for details.
        self.error_code = error_code
        # The returned message.
        # 
        # success is returned when the request succeeds.
        # An error code is returned when the request fails.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Indicates whether the logs of the instance is obtained.
        # 
        # - true: logs obtained.
        # 
        # - false: failed to obtain logs.
        self.success = success
        # Trace ID.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeInstanceLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInstanceLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceSpecificationsResponseBodyData(TeaModel):
    def __init__(
        self,
        cpu: int = None,
        enable: bool = None,
        id: int = None,
        memory: int = None,
        spec_info: str = None,
        version: int = None,
    ):
        # The CPU specification of the instance type. Unit: millicore.
        self.cpu = cpu
        # Indicates whether the instance type is available. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.enable = enable
        # The ID of the instance type.
        self.id = id
        # The memory size of the instance type. Unit: MB.
        self.memory = memory
        # The name of the instance type.
        self.spec_info = spec_info
        # The version number of the instance type.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.id is not None:
            result['Id'] = self.id
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.spec_info is not None:
            result['SpecInfo'] = self.spec_info
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('SpecInfo') is not None:
            self.spec_info = m.get('SpecInfo')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DescribeInstanceSpecificationsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[DescribeInstanceSpecificationsResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The information about the instance types.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   If the request failed, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the instance types were queried. Valid values:
        # 
        # *   **true**: The instance types were queried.
        # *   **false**: The instance types failed to be queried.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeInstanceSpecificationsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeInstanceSpecificationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeInstanceSpecificationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceSpecificationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeJobRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        job_id: str = None,
    ):
        # The ID of the job template.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The job ID.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class DescribeJobResponseBodyDataConfigMapMountDesc(TeaModel):
    def __init__(
        self,
        config_map_id: int = None,
        config_map_name: str = None,
        key: str = None,
        mount_path: str = None,
    ):
        # The ConfigMap ID.
        self.config_map_id = config_map_id
        # The ConfigMap name.
        self.config_map_name = config_map_name
        # The key-value pair that is stored in the ConfigMap.
        self.key = key
        # The path on which the ConfigMap is mounted.
        self.mount_path = mount_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        if self.config_map_name is not None:
            result['ConfigMapName'] = self.config_map_name
        if self.key is not None:
            result['Key'] = self.key
        if self.mount_path is not None:
            result['MountPath'] = self.mount_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        if m.get('ConfigMapName') is not None:
            self.config_map_name = m.get('ConfigMapName')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('MountPath') is not None:
            self.mount_path = m.get('MountPath')
        return self


class DescribeJobResponseBodyDataMountDesc(TeaModel):
    def __init__(
        self,
        mount_path: str = None,
        nas_path: str = None,
    ):
        # The path on which the NAS file system is mounted.
        self.mount_path = mount_path
        # The directory in the NAS file system.
        self.nas_path = nas_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mount_path is not None:
            result['MountPath'] = self.mount_path
        if self.nas_path is not None:
            result['NasPath'] = self.nas_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MountPath') is not None:
            self.mount_path = m.get('MountPath')
        if m.get('NasPath') is not None:
            self.nas_path = m.get('NasPath')
        return self


class DescribeJobResponseBodyDataOssMountDescs(TeaModel):
    def __init__(
        self,
        bucket_name: str = None,
        bucket_path: str = None,
        mount_path: str = None,
        read_only: bool = None,
    ):
        # The name of the bucket.
        self.bucket_name = bucket_name
        # The directory or object in OSS. If the specified directory or object does not exist, an error is returned.
        self.bucket_path = bucket_path
        # The path of the container in SAE. The parameter value that you specified overwrites the original value. If the specified path does not exist, SAE automatically creates the path.
        self.mount_path = mount_path
        # Indicates whether the job template can use the container directory to read data from or write data to resources in the directory of the OSS bucket. Valid values:
        # 
        # *   **true**: The job template has the read-only permissions.
        # *   **false**: The job template has the read and write permissions.
        self.read_only = read_only

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['bucketName'] = self.bucket_name
        if self.bucket_path is not None:
            result['bucketPath'] = self.bucket_path
        if self.mount_path is not None:
            result['mountPath'] = self.mount_path
        if self.read_only is not None:
            result['readOnly'] = self.read_only
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bucketName') is not None:
            self.bucket_name = m.get('bucketName')
        if m.get('bucketPath') is not None:
            self.bucket_path = m.get('bucketPath')
        if m.get('mountPath') is not None:
            self.mount_path = m.get('mountPath')
        if m.get('readOnly') is not None:
            self.read_only = m.get('readOnly')
        return self


class DescribeJobResponseBodyDataTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeJobResponseBodyData(TeaModel):
    def __init__(
        self,
        acr_assume_role_arn: str = None,
        acr_instance_id: str = None,
        app_description: str = None,
        app_id: str = None,
        app_name: str = None,
        backoff_limit: int = None,
        command: str = None,
        command_args: str = None,
        concurrency_policy: str = None,
        config_map_mount_desc: List[DescribeJobResponseBodyDataConfigMapMountDesc] = None,
        cpu: int = None,
        custom_host_alias: str = None,
        edas_container_version: str = None,
        envs: str = None,
        image_pull_secrets: str = None,
        image_url: str = None,
        jar_start_args: str = None,
        jar_start_options: str = None,
        jdk: str = None,
        memory: int = None,
        mount_desc: List[DescribeJobResponseBodyDataMountDesc] = None,
        mount_host: str = None,
        namespace_id: str = None,
        nas_configs: str = None,
        nas_id: str = None,
        oss_ak_id: str = None,
        oss_ak_secret: str = None,
        oss_mount_descs: List[DescribeJobResponseBodyDataOssMountDescs] = None,
        package_type: str = None,
        package_url: str = None,
        package_version: str = None,
        php_config: str = None,
        php_config_location: str = None,
        post_start: str = None,
        pre_stop: str = None,
        programming_language: str = None,
        public_web_hook_urls: List[str] = None,
        python: str = None,
        python_modules: str = None,
        ref_app_id: str = None,
        refed_app_ids: List[str] = None,
        region_id: str = None,
        replicas: int = None,
        security_group_id: str = None,
        slice: bool = None,
        slice_envs: str = None,
        sls_configs: str = None,
        suspend: bool = None,
        tags: List[DescribeJobResponseBodyDataTags] = None,
        termination_grace_period_seconds: int = None,
        timeout: int = None,
        timezone: str = None,
        tomcat_config: str = None,
        trigger_config: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
        vpc_web_hook_urls: List[str] = None,
        war_start_options: str = None,
        web_container: str = None,
    ):
        # The Alibaba Cloud Resource Name (ARN) of the RAM role that is used to pull images across accounts. For more information, see [Pull images across Alibaba Cloud accounts](https://help.aliyun.com/document_detail/190675.html) and [Grant permissions across Alibaba Cloud accounts by using a RAM role](https://help.aliyun.com/document_detail/223585.html).
        self.acr_assume_role_arn = acr_assume_role_arn
        # The ID of the Container Registry Enterprise Edition instance.
        self.acr_instance_id = acr_instance_id
        # The description of the job template.
        self.app_description = app_description
        # The ID of the job template.
        self.app_id = app_id
        # The name of the job template.
        self.app_name = app_name
        # The number of times that the job was retried.
        self.backoff_limit = backoff_limit
        # The command that is used to start the image. The command must be an existing executable object in the container. Example:
        # 
        #     command:
        #           - echo
        #           - abc
        #           - >
        #           - file0
        # 
        # In this example, the Command parameter is set to `Command="echo", CommandArgs=["abc", ">", "file0"]`.
        self.command = command
        # The arguments of the image startup command. This parameter contains the arguments that are required for **Command**. Format:
        # 
        # `["a","b"]`
        # 
        # In the preceding **Command** example, the CommandArgs parameter is set to `CommandArgs=["abc", ">", "file0"]`. The data type of `["abc", ">", "file0"]` must be an array of strings in the JSON format. If this parameter does not exist in the Command parameter, you do not need to configure it.
        self.command_args = command_args
        # The concurrency policy of the job. Valid values:
        # 
        # *   **Forbid**: Concurrent running is prohibited. If the previous job is not completed, no new job is created.
        # *   **Allow**: Concurrent running is allowed.
        # *   **Replace**: If the previous job is not completed when the time to create a new job is reached, the new job replaces the previous job.
        self.concurrency_policy = concurrency_policy
        # The details of the ConfigMap.
        self.config_map_mount_desc = config_map_mount_desc
        # The CPU specifications required for each instance. Unit: millicore. This parameter cannot be set to 0. Valid values:
        # 
        # *   **500**\
        # *   **1000**\
        # *   **2000**\
        # *   **4000**\
        # *   **8000**\
        # *   **16000**\
        # *   **32000**\
        self.cpu = cpu
        # The custom mapping between the hostname and IP address in the container. Valid values:
        # 
        # *   **hostName**: the domain name or hostname.
        # *   **ip**: the IP address.
        self.custom_host_alias = custom_host_alias
        # The version of the container, such as Ali-Tomcat, in which a job that is developed based on High-speed Service Framework (HSF) is deployed.
        self.edas_container_version = edas_container_version
        # The environment variables. You can configure custom environment variables or reference a ConfigMap. If you want to reference a ConfigMap, you must first create a ConfigMap. For more information, see [CreateConfigMap](https://help.aliyun.com/document_detail/176914.html). Valid values:
        # 
        # *   Custom configuration
        # 
        #     *   **name**: the name of the environment variable.
        #     *   **value**: the value of the environment variable.
        # 
        # *   Reference a ConfigMap
        # 
        #     *   **name**: the name of the environment variable. You can reference one or all keys. To reference all keys, specify `sae-sys-configmap-all-<ConfigMap name>`. Example: `sae-sys-configmap-all-test1`.
        #     *   **valueFrom**: the reference of the environment variable. Set the value to `configMapRef`.
        #     *   **configMapId**: the ID of the ConfigMap.
        #     *   **key**: the key. If you want to reference all keys, you do not need to configure this parameter.
        self.envs = envs
        # The ID of the corresponding secret.
        self.image_pull_secrets = image_pull_secrets
        # The URL of the image. This parameter is returned only if **PackageType** is set to **Image**.
        self.image_url = image_url
        # The arguments in the JAR package. The arguments are used to start the job. The default startup command is `$JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs`.
        self.jar_start_args = jar_start_args
        # The option settings in the JAR package. The settings are used to start the job. The default startup command is `$JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs`.
        self.jar_start_options = jar_start_options
        # The version of the Java Development Kit (JDK) on which the deployment package of the application depends. The following versions are supported:
        # 
        # *   **Open JDK 8**\
        # *   **Open JDK 7**\
        # *   **Dragonwell 11**\
        # *   **Dragonwell 8**\
        # *   **openjdk-8u191-jdk-alpine3.9**\
        # *   **openjdk-7u201-jdk-alpine3.9**\
        # 
        # This parameter is not returned if **PackageType** is set to **Image**.
        self.jdk = jdk
        # The size of memory that is required by each instance. Unit: MB. This parameter cannot be set to 0. The values of this parameter correspond to the values of the Cpu parameter:
        # 
        # *   This parameter is set to **1024** if the Cpu parameter is set to 500 or 1000.
        # *   This parameter is set to **2048** if the Cpu parameter is set to 500, 1000, or 2000.
        # *   This parameter is set to **4096** if the Cpu parameter is set to 1000, 2000, or 4000.
        # *   This parameter is set to **8192** if the Cpu parameter is set to 2000, 4000, or 8000.
        # *   This parameter is set to **12288** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **16384** if the Cpu parameter is set to 4000, 8000, or 16000.
        # *   This parameter is set to **24567** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **32768** if the Cpu parameter is set to 16000.
        # *   This parameter is set to **65536** if the Cpu parameter is set to 8000, 16000, or 32000.
        # *   This parameter is set to **131072** if the Cpu parameter is set to 32000.
        self.memory = memory
        # The details of the mounted NAS file system.
        self.mount_desc = mount_desc
        # The mount target of the Apsara File Storage NAS (NAS) file system in the virtual private cloud (VPC) where the job template is deployed. If you do not need to modify the NAS configurations when you deploy the job template, configure the **MountHost** parameter only in the first request. You do not need to include this parameter in subsequent requests. If you no longer need to use NAS, leave the **MountHost** parameter empty in the request.
        self.mount_host = mount_host
        # The namespace ID.
        self.namespace_id = namespace_id
        # The configurations for mounting the NAS file system.
        self.nas_configs = nas_configs
        # The ID of the NAS file system.
        self.nas_id = nas_id
        # The AccessKey ID that is used to read data from and write data to Object Storage Service (OSS).
        self.oss_ak_id = oss_ak_id
        # The AccessKey secret that is used to read data from and write data to OSS.
        self.oss_ak_secret = oss_ak_secret
        # The description of mounted OSS buckets.
        self.oss_mount_descs = oss_mount_descs
        # The type of the deployment package. Valid values:
        # 
        # *   If you deploy a Java job template, you can set this parameter to **FatJar**, **War**, or **Image**.
        # 
        # *   If you deploy a PHP job template, the following types are available:
        # 
        #     *   **PhpZip**\
        #     *   **IMAGE_PHP_5_4**\
        #     *   **IMAGE_PHP_5_4_ALPINE**\
        #     *   **IMAGE_PHP_5_5**\
        #     *   **IMAGE_PHP_5_5_ALPINE**\
        #     *   **IMAGE_PHP_5_6**\
        #     *   **IMAGE_PHP_5_6_ALPINE**\
        #     *   **IMAGE_PHP_7_0**\
        #     *   **IMAGE_PHP_7_0_ALPINE**\
        #     *   **IMAGE_PHP_7_1**\
        #     *   **IMAGE_PHP_7_1_ALPINE**\
        #     *   **IMAGE_PHP_7_2**\
        #     *   **IMAGE_PHP_7_2_ALPINE**\
        #     *   **IMAGE_PHP_7_3**\
        #     *   **IMAGE_PHP_7_3_ALPINE**\
        # 
        # *   If you deploy a Python job template, you can set this parameter to **PythonZip** or **Image**.
        self.package_type = package_type
        # The URL of the deployment package. This parameter is returned only if **PackageType** is set to **FatJar** or **War**.
        self.package_url = package_url
        # The version of the deployment package. This parameter is required only if **PackageType** is set to **FatJar** or **War**.
        self.package_version = package_version
        # The details of the PHP configuration file.
        self.php_config = php_config
        # The path on which the PHP configuration file for job startup is mounted. Make sure that the PHP server uses this configuration file during the startup.
        self.php_config_location = php_config_location
        # The script that is run immediately after the container is started. Example: `{"exec":{"command":["cat","/etc/group"\\]}}`
        self.post_start = post_start
        # The script that is run before the container is stopped. Example: `{"exec":{"command":["cat","/etc/group"\\]}}`
        self.pre_stop = pre_stop
        # The programming language in which the job template is created. Valid values:
        # 
        # *   **java**: Java
        # *   **php**: PHP
        # *   **python**: Python
        # *   **other**: other programming languages, such as C++, Go, .NET, and Node.js
        self.programming_language = programming_language
        # The Internet request URLs of one-time jobs.
        self.public_web_hook_urls = public_web_hook_urls
        # The Python environment. PYTHON 3.9.15 is supported.
        self.python = python
        # The configurations for installing custom module dependencies. By default, the dependencies defined by the requirements.txt file in the root directory are installed. If no software package is configured, you can specify dependencies based on your business requirements.
        self.python_modules = python_modules
        # The ID of the job template that you reference.
        self.ref_app_id = ref_app_id
        # The IDs of the referenced job templates.
        self.refed_app_ids = refed_app_ids
        # The region ID.
        self.region_id = region_id
        # The number of job instances.
        self.replicas = replicas
        # The ID of the security group.
        self.security_group_id = security_group_id
        # Indicates whether job sharding is enabled.
        self.slice = slice
        # The parameters of job sharding.
        self.slice_envs = slice_envs
        # The logging configurations of Log Service.
        # 
        # *   To use Log Service resources that are automatically created by SAE, set this parameter to `[{"logDir":"","logType":"stdout"},{"logDir":"/tmp/a.log"}]`.
        # *   To use custom Log Service resources, set this parameter to `[{"projectName":"test-sls","logType":"stdout","logDir":"","logstoreName":"sae","logtailName":""},{"projectName":"test","logDir":"/tmp/a.log","logstoreName":"sae","logtailName":""}]`.
        # 
        # Parameter description:
        # 
        # *   **projectName**: the name of the Log Service project.
        # *   **logDir**: the path in which logs are stored.
        # *   **logType**: the log type. **stdout**: the standard output (stdout) log of the container. Only one stdout value for this parameter can be specified. If this parameter is not configured, file logs are collected.
        # *   **logstoreName**: the name of the Logstore in Log Service.
        # *   **logtailName**: the name of the Logtail in Log Service. If this parameter is not configured, a new Logtail is created.
        # 
        # If you do not need to modify the logging configurations when you deploy the application, configure **SlsConfigs** only in the first request. If you no longer need to use Log Service, leave **SlsConfigs** empty in the request.
        self.sls_configs = sls_configs
        # Indicates whether the job template is suspended.
        self.suspend = suspend
        # The tags.
        self.tags = tags
        # The timeout period for a graceful shutdown. Default value: 30. Unit: seconds. Valid values: 1 to 300.
        self.termination_grace_period_seconds = termination_grace_period_seconds
        # The timeout period of the job. Unit: seconds.
        self.timeout = timeout
        # The time zone. Default value: **Asia/Shanghai**.
        self.timezone = timezone
        # The Tomcat configuration. If you want to delete the configuration, set this parameter to {} or leave this parameter empty. Parameter description:
        # 
        # *   **port**: the port number. Valid values: 1024 to 65535. The root permissions are required to perform operations on ports whose number is smaller than 1024. Enter a value that ranges from 1025 to 65535 because the container has only the admin permissions. If this parameter is not configured, the default value 8080 is used.
        # *   **contextPath**: the path. Default value: /. The value indicates the root directory.
        # *   **maxThreads**: the maximum number of connections in the connection pool. Default value: 400.
        # *   **uriEncoding**: the URI encoding scheme in the Tomcat container. Valid values: **UTF-8**, **ISO-8859-1**, **GBK**, and **GB2312**. If this parameter is not configured, the default value **ISO-8859-1** is used.
        # *   **useBodyEncoding**: indicates whether to use the encoding scheme that is specified by **BodyEncoding for URL**. Default value: **true**.
        self.tomcat_config = tomcat_config
        self.trigger_config = trigger_config
        # The vSwitch ID.
        self.v_switch_id = v_switch_id
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id
        # The internal request URLs for one-time jobs.
        self.vpc_web_hook_urls = vpc_web_hook_urls
        # The option settings in the WAR package. The settings are used to start the job. The default startup command is `java $JAVA_OPTS $CATALINA_OPTS -Options org.apache.catalina.startup.Bootstrap "$@" start`.
        self.war_start_options = war_start_options
        # The version of the Tomcat container on which the deployment package depends. The following versions are supported:
        # 
        # *   **apache-tomcat-7.0.91**\
        # *   **apache-tomcat-8.5.42**\
        # 
        # This parameter is not returned if **PackageType** is set to **Image**.
        self.web_container = web_container

    def validate(self):
        if self.config_map_mount_desc:
            for k in self.config_map_mount_desc:
                if k:
                    k.validate()
        if self.mount_desc:
            for k in self.mount_desc:
                if k:
                    k.validate()
        if self.oss_mount_descs:
            for k in self.oss_mount_descs:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acr_assume_role_arn is not None:
            result['AcrAssumeRoleArn'] = self.acr_assume_role_arn
        if self.acr_instance_id is not None:
            result['AcrInstanceId'] = self.acr_instance_id
        if self.app_description is not None:
            result['AppDescription'] = self.app_description
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.backoff_limit is not None:
            result['BackoffLimit'] = self.backoff_limit
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        if self.concurrency_policy is not None:
            result['ConcurrencyPolicy'] = self.concurrency_policy
        result['ConfigMapMountDesc'] = []
        if self.config_map_mount_desc is not None:
            for k in self.config_map_mount_desc:
                result['ConfigMapMountDesc'].append(k.to_map() if k else None)
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.custom_host_alias is not None:
            result['CustomHostAlias'] = self.custom_host_alias
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.image_pull_secrets is not None:
            result['ImagePullSecrets'] = self.image_pull_secrets
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.jar_start_args is not None:
            result['JarStartArgs'] = self.jar_start_args
        if self.jar_start_options is not None:
            result['JarStartOptions'] = self.jar_start_options
        if self.jdk is not None:
            result['Jdk'] = self.jdk
        if self.memory is not None:
            result['Memory'] = self.memory
        result['MountDesc'] = []
        if self.mount_desc is not None:
            for k in self.mount_desc:
                result['MountDesc'].append(k.to_map() if k else None)
        if self.mount_host is not None:
            result['MountHost'] = self.mount_host
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.nas_configs is not None:
            result['NasConfigs'] = self.nas_configs
        if self.nas_id is not None:
            result['NasId'] = self.nas_id
        if self.oss_ak_id is not None:
            result['OssAkId'] = self.oss_ak_id
        if self.oss_ak_secret is not None:
            result['OssAkSecret'] = self.oss_ak_secret
        result['OssMountDescs'] = []
        if self.oss_mount_descs is not None:
            for k in self.oss_mount_descs:
                result['OssMountDescs'].append(k.to_map() if k else None)
        if self.package_type is not None:
            result['PackageType'] = self.package_type
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.php_config is not None:
            result['PhpConfig'] = self.php_config
        if self.php_config_location is not None:
            result['PhpConfigLocation'] = self.php_config_location
        if self.post_start is not None:
            result['PostStart'] = self.post_start
        if self.pre_stop is not None:
            result['PreStop'] = self.pre_stop
        if self.programming_language is not None:
            result['ProgrammingLanguage'] = self.programming_language
        if self.public_web_hook_urls is not None:
            result['PublicWebHookUrls'] = self.public_web_hook_urls
        if self.python is not None:
            result['Python'] = self.python
        if self.python_modules is not None:
            result['PythonModules'] = self.python_modules
        if self.ref_app_id is not None:
            result['RefAppId'] = self.ref_app_id
        if self.refed_app_ids is not None:
            result['RefedAppIds'] = self.refed_app_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.slice is not None:
            result['Slice'] = self.slice
        if self.slice_envs is not None:
            result['SliceEnvs'] = self.slice_envs
        if self.sls_configs is not None:
            result['SlsConfigs'] = self.sls_configs
        if self.suspend is not None:
            result['Suspend'] = self.suspend
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.termination_grace_period_seconds is not None:
            result['TerminationGracePeriodSeconds'] = self.termination_grace_period_seconds
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.tomcat_config is not None:
            result['TomcatConfig'] = self.tomcat_config
        if self.trigger_config is not None:
            result['TriggerConfig'] = self.trigger_config
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vpc_web_hook_urls is not None:
            result['VpcWebHookUrls'] = self.vpc_web_hook_urls
        if self.war_start_options is not None:
            result['WarStartOptions'] = self.war_start_options
        if self.web_container is not None:
            result['WebContainer'] = self.web_container
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcrAssumeRoleArn') is not None:
            self.acr_assume_role_arn = m.get('AcrAssumeRoleArn')
        if m.get('AcrInstanceId') is not None:
            self.acr_instance_id = m.get('AcrInstanceId')
        if m.get('AppDescription') is not None:
            self.app_description = m.get('AppDescription')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BackoffLimit') is not None:
            self.backoff_limit = m.get('BackoffLimit')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        if m.get('ConcurrencyPolicy') is not None:
            self.concurrency_policy = m.get('ConcurrencyPolicy')
        self.config_map_mount_desc = []
        if m.get('ConfigMapMountDesc') is not None:
            for k in m.get('ConfigMapMountDesc'):
                temp_model = DescribeJobResponseBodyDataConfigMapMountDesc()
                self.config_map_mount_desc.append(temp_model.from_map(k))
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CustomHostAlias') is not None:
            self.custom_host_alias = m.get('CustomHostAlias')
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('ImagePullSecrets') is not None:
            self.image_pull_secrets = m.get('ImagePullSecrets')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('JarStartArgs') is not None:
            self.jar_start_args = m.get('JarStartArgs')
        if m.get('JarStartOptions') is not None:
            self.jar_start_options = m.get('JarStartOptions')
        if m.get('Jdk') is not None:
            self.jdk = m.get('Jdk')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        self.mount_desc = []
        if m.get('MountDesc') is not None:
            for k in m.get('MountDesc'):
                temp_model = DescribeJobResponseBodyDataMountDesc()
                self.mount_desc.append(temp_model.from_map(k))
        if m.get('MountHost') is not None:
            self.mount_host = m.get('MountHost')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NasConfigs') is not None:
            self.nas_configs = m.get('NasConfigs')
        if m.get('NasId') is not None:
            self.nas_id = m.get('NasId')
        if m.get('OssAkId') is not None:
            self.oss_ak_id = m.get('OssAkId')
        if m.get('OssAkSecret') is not None:
            self.oss_ak_secret = m.get('OssAkSecret')
        self.oss_mount_descs = []
        if m.get('OssMountDescs') is not None:
            for k in m.get('OssMountDescs'):
                temp_model = DescribeJobResponseBodyDataOssMountDescs()
                self.oss_mount_descs.append(temp_model.from_map(k))
        if m.get('PackageType') is not None:
            self.package_type = m.get('PackageType')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('PhpConfig') is not None:
            self.php_config = m.get('PhpConfig')
        if m.get('PhpConfigLocation') is not None:
            self.php_config_location = m.get('PhpConfigLocation')
        if m.get('PostStart') is not None:
            self.post_start = m.get('PostStart')
        if m.get('PreStop') is not None:
            self.pre_stop = m.get('PreStop')
        if m.get('ProgrammingLanguage') is not None:
            self.programming_language = m.get('ProgrammingLanguage')
        if m.get('PublicWebHookUrls') is not None:
            self.public_web_hook_urls = m.get('PublicWebHookUrls')
        if m.get('Python') is not None:
            self.python = m.get('Python')
        if m.get('PythonModules') is not None:
            self.python_modules = m.get('PythonModules')
        if m.get('RefAppId') is not None:
            self.ref_app_id = m.get('RefAppId')
        if m.get('RefedAppIds') is not None:
            self.refed_app_ids = m.get('RefedAppIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('Slice') is not None:
            self.slice = m.get('Slice')
        if m.get('SliceEnvs') is not None:
            self.slice_envs = m.get('SliceEnvs')
        if m.get('SlsConfigs') is not None:
            self.sls_configs = m.get('SlsConfigs')
        if m.get('Suspend') is not None:
            self.suspend = m.get('Suspend')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = DescribeJobResponseBodyDataTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TerminationGracePeriodSeconds') is not None:
            self.termination_grace_period_seconds = m.get('TerminationGracePeriodSeconds')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('TomcatConfig') is not None:
            self.tomcat_config = m.get('TomcatConfig')
        if m.get('TriggerConfig') is not None:
            self.trigger_config = m.get('TriggerConfig')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VpcWebHookUrls') is not None:
            self.vpc_web_hook_urls = m.get('VpcWebHookUrls')
        if m.get('WarStartOptions') is not None:
            self.war_start_options = m.get('WarStartOptions')
        if m.get('WebContainer') is not None:
            self.web_container = m.get('WebContainer')
        return self


class DescribeJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeJobResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The information of the job template.
        self.data = data
        # The error code returned. Take note of the following rules:
        # 
        # *   If the call is successful, **ErrorCode** is not returned.
        # *   If the call fails, **ErrorCode** is returned. For more information, see the "**Error codes**" section in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the configurations of the job template were obtained. Valid values:
        # 
        # *   **true**: The configurations were obtained.
        # *   **false**: The configurations failed to be obtained.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeJobHistoryRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        current_page: int = None,
        page_size: int = None,
        state: str = None,
    ):
        # The ID of the job template.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The number of the page to return.
        self.current_page = current_page
        # The number of entries to return on each page. Valid values: 0 to 10000.
        self.page_size = page_size
        # The status of the job. Valid values:
        # 
        # *   **0**: The job is not executed.
        # *   **1**: The job is executed.
        # *   **2**: The job fails to be executed.
        # *   **3**: The job is being executed.
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class DescribeJobHistoryResponseBodyDataJobs(TeaModel):
    def __init__(
        self,
        active: int = None,
        completion_time: int = None,
        failed: int = None,
        job_id: str = None,
        message: str = None,
        start_time: int = None,
        state: str = None,
        succeeded: int = None,
    ):
        # The number of running instances.
        self.active = active
        # The time when the job was executed.
        self.completion_time = completion_time
        # The number of instances that failed to run.
        self.failed = failed
        # The job ID.
        self.job_id = job_id
        # The message returned if exceptions occur during job running.
        self.message = message
        # The time when the job was created.
        self.start_time = start_time
        # The status of the job. Valid values:
        # 
        # *   **0**: The job was not executed.
        # *   **1**: The job was executed.
        # *   **2**: The job failed to be executed.
        # *   **3**: The job is being executed.
        self.state = state
        # The number of instances that are successfully run.
        self.succeeded = succeeded

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active is not None:
            result['Active'] = self.active
        if self.completion_time is not None:
            result['CompletionTime'] = self.completion_time
        if self.failed is not None:
            result['Failed'] = self.failed
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.state is not None:
            result['State'] = self.state
        if self.succeeded is not None:
            result['Succeeded'] = self.succeeded
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Active') is not None:
            self.active = m.get('Active')
        if m.get('CompletionTime') is not None:
            self.completion_time = m.get('CompletionTime')
        if m.get('Failed') is not None:
            self.failed = m.get('Failed')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Succeeded') is not None:
            self.succeeded = m.get('Succeeded')
        return self


class DescribeJobHistoryResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        jobs: List[DescribeJobHistoryResponseBodyDataJobs] = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # The jobs.
        self.jobs = jobs
        # The number of entries to return on each page. Valid values: 0 to 10000.
        self.page_size = page_size
        # The total number of jobs.
        self.total_size = total_size

    def validate(self):
        if self.jobs:
            for k in self.jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['Jobs'] = []
        if self.jobs is not None:
            for k in self.jobs:
                result['Jobs'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.jobs = []
        if m.get('Jobs') is not None:
            for k in m.get('Jobs'):
                temp_model = DescribeJobHistoryResponseBodyDataJobs()
                self.jobs.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class DescribeJobHistoryResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeJobHistoryResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code returned. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code returned. Take note of the following rules:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section in this topic.
        self.error_code = error_code
        # The message returned. Take note of the following rules:
        # 
        # *   If the call is successful, **success** is returned.
        # *   If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeJobHistoryResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeJobHistoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeJobHistoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeJobHistoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeJobStatusRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        job_id: str = None,
    ):
        # The ID of the job template.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The job ID.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class DescribeJobStatusResponseBodyData(TeaModel):
    def __init__(
        self,
        active: int = None,
        completion_time: int = None,
        failed: int = None,
        job_id: str = None,
        message: str = None,
        start_time: int = None,
        state: str = None,
        succeeded: int = None,
    ):
        # The number of running instances.
        self.active = active
        # The time when the job was executed.
        self.completion_time = completion_time
        # The number of instances that failed to run.
        self.failed = failed
        # The job ID.
        self.job_id = job_id
        # The returned message. Take note of the following rules:
        # 
        # *   If the call is successful, **success** is returned.
        # *   If the call fails, an error code is returned.
        self.message = message
        # The time when the job was created.
        self.start_time = start_time
        # The status of the job. Valid values:
        # 
        # *   **0**: The job is not executed.
        # *   **1**: The job was executed.
        # *   **2**: The job failed to be executed.
        # *   **3**: The job is being executed.
        self.state = state
        # The number of instances that are successfully run.
        self.succeeded = succeeded

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active is not None:
            result['Active'] = self.active
        if self.completion_time is not None:
            result['CompletionTime'] = self.completion_time
        if self.failed is not None:
            result['Failed'] = self.failed
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.state is not None:
            result['State'] = self.state
        if self.succeeded is not None:
            result['Succeeded'] = self.succeeded
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Active') is not None:
            self.active = m.get('Active')
        if m.get('CompletionTime') is not None:
            self.completion_time = m.get('CompletionTime')
        if m.get('Failed') is not None:
            self.failed = m.get('Failed')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Succeeded') is not None:
            self.succeeded = m.get('Succeeded')
        return self


class DescribeJobStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeJobStatusResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code returned. Take note of the following rules:
        # 
        # *   **ErrorCode** is not returned if the request succeeds.
        # *   **ErrorCode** is returned if the request fails. For more information, see the "**Error codes**" section in this topic.
        self.error_code = error_code
        # The returned message. Take note of the following rules:
        # 
        # *   If the call is successful, **success** is returned.
        # *   If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeJobStatusResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeJobStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeJobStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeJobStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNamespaceRequest(TeaModel):
    def __init__(
        self,
        name_space_short_id: str = None,
        namespace_id: str = None,
    ):
        # The short ID of the namespace. You do not need to specify a region ID. The value of this parameter can be up to 20 characters in length and can contain only lowercase letters and digits.
        self.name_space_short_id = name_space_short_id
        # The ID of the namespace. The information about the default namespace cannot be queried or modified. The default namespace cannot be deleted.
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class DescribeNamespaceResponseBodyData(TeaModel):
    def __init__(
        self,
        enable_micro_registration: bool = None,
        name_space_short_id: str = None,
        namespace_description: str = None,
        namespace_id: str = None,
        namespace_name: str = None,
        region_id: str = None,
    ):
        # Indicates whether the SAE built-in registry is enabled. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.enable_micro_registration = enable_micro_registration
        # The short ID of the namespace.
        self.name_space_short_id = name_space_short_id
        # The description of the namespace.
        self.namespace_description = namespace_description
        # The ID of the namespace. The information about the default namespace cannot be queried or modified. The default namespace cannot be deleted.
        self.namespace_id = namespace_id
        # The name of the namespace.
        self.namespace_name = namespace_name
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_micro_registration is not None:
            result['EnableMicroRegistration'] = self.enable_micro_registration
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_description is not None:
            result['NamespaceDescription'] = self.namespace_description
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.namespace_name is not None:
            result['NamespaceName'] = self.namespace_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableMicroRegistration') is not None:
            self.enable_micro_registration = m.get('EnableMicroRegistration')
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceDescription') is not None:
            self.namespace_description = m.get('NamespaceDescription')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NamespaceName') is not None:
            self.namespace_name = m.get('NamespaceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeNamespaceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeNamespaceResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The information about the namespace.
        self.data = data
        # The error code returned. Take note of the following rules:
        # 
        # *   The **ErrorCode** parameter is not returned if the request succeeds.
        # *   The **ErrorCode** parameter is returned if the request fails. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The additional information that is returned. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the information about the namespace was queried successfully. Valid values:
        # 
        # *   **true**: The information was queried.
        # *   **false**: The image failed to be found.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeNamespaceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeNamespaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNamespaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNamespaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNamespaceListRequest(TeaModel):
    def __init__(
        self,
        contain_custom: bool = None,
        hybrid_cloud_exclude: bool = None,
    ):
        # Specifies whether to return custom namespaces. Valid values:
        # 
        # *   **true**: The system returns custom namespaces.
        # *   **false**: The system does not return custom namespaces.
        self.contain_custom = contain_custom
        # Indicates whether hybrid cloud namespaces are excluded. Valid values:
        # 
        # *   **true**: Hybrid cloud namespaces are excluded.
        # *   **false**: Hybrid cloud namespaces are included.
        self.hybrid_cloud_exclude = hybrid_cloud_exclude

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contain_custom is not None:
            result['ContainCustom'] = self.contain_custom
        if self.hybrid_cloud_exclude is not None:
            result['HybridCloudExclude'] = self.hybrid_cloud_exclude
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContainCustom') is not None:
            self.contain_custom = m.get('ContainCustom')
        if m.get('HybridCloudExclude') is not None:
            self.hybrid_cloud_exclude = m.get('HybridCloudExclude')
        return self


class DescribeNamespaceListResponseBodyData(TeaModel):
    def __init__(
        self,
        agent_install: str = None,
        current: bool = None,
        custom: bool = None,
        hybrid_cloud_enable: bool = None,
        name_space_short_id: str = None,
        namespace_id: str = None,
        namespace_name: str = None,
        region_id: str = None,
        security_group_id: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
    ):
        # The command that was run to install the agent.
        self.agent_install = agent_install
        # This parameter is no longer valid.
        self.current = current
        # Indicates whether custom namespaces are returned. Valid values:
        # 
        # *   **true**: Custom namespaces are returned.
        # *   **false**: Custom namespaces are not returned.
        self.custom = custom
        # Indicates whether hybrid cloud namespaces are excluded. Valid values:
        # 
        # *   **true**: Hybrid cloud namespaces are excluded.
        # *   **false**: Hybrid cloud namespaces are included.
        self.hybrid_cloud_enable = hybrid_cloud_enable
        # The short ID of the namespace.
        self.name_space_short_id = name_space_short_id
        # The ID of the namespace.
        self.namespace_id = namespace_id
        # The name of the namespace.
        self.namespace_name = namespace_name
        # The region to which the namespace belongs.
        self.region_id = region_id
        # The ID of the security group.
        self.security_group_id = security_group_id
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_install is not None:
            result['AgentInstall'] = self.agent_install
        if self.current is not None:
            result['Current'] = self.current
        if self.custom is not None:
            result['Custom'] = self.custom
        if self.hybrid_cloud_enable is not None:
            result['HybridCloudEnable'] = self.hybrid_cloud_enable
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.namespace_name is not None:
            result['NamespaceName'] = self.namespace_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentInstall') is not None:
            self.agent_install = m.get('AgentInstall')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        if m.get('Custom') is not None:
            self.custom = m.get('Custom')
        if m.get('HybridCloudEnable') is not None:
            self.hybrid_cloud_enable = m.get('HybridCloudEnable')
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NamespaceName') is not None:
            self.namespace_name = m.get('NamespaceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeNamespaceListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[DescribeNamespaceListResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The list of namespaces.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the list of namespaces was queried. Valid values:
        # 
        # *   **true**: The list was queried.
        # *   **false**: The list failed to be queried.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeNamespaceListResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeNamespaceListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNamespaceListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNamespaceListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNamespaceResourcesRequest(TeaModel):
    def __init__(
        self,
        name_space_short_id: str = None,
        namespace_id: str = None,
    ):
        self.name_space_short_id = name_space_short_id
        # cn-shanghai:test
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class DescribeNamespaceResourcesResponseBodyData(TeaModel):
    def __init__(
        self,
        app_count: int = None,
        belong_region: str = None,
        description: str = None,
        jump_server_app_id: str = None,
        jump_server_ip: str = None,
        last_change_order_id: str = None,
        last_change_order_running: bool = None,
        last_change_order_status: str = None,
        name_space_short_id: str = None,
        namespace_id: str = None,
        namespace_name: str = None,
        notification_expired: bool = None,
        security_group_id: str = None,
        tenant_id: str = None,
        user_id: str = None,
        v_switch_id: str = None,
        v_switch_name: str = None,
        vpc_id: str = None,
        vpc_name: str = None,
    ):
        # The number of applications.
        self.app_count = app_count
        # The region to which the namespace belongs.
        self.belong_region = belong_region
        # The description of the namespace.
        self.description = description
        # The ID of the jump server application.
        self.jump_server_app_id = jump_server_app_id
        # The IP address of the jump server.
        self.jump_server_ip = jump_server_ip
        # The ID of the change order.
        self.last_change_order_id = last_change_order_id
        # Indicates whether a change order is being executed in the namespace. Valid values:
        # 
        # *   **true**: indicates that a change order is being executed in the namespace.
        # *   **false**: indicates that no change orders are being executed in the namespace.
        self.last_change_order_running = last_change_order_running
        # The status of the latest change order. Valid values:
        # 
        # *   **READY**: The change order is ready.
        # *   **RUNNING**: The change order is being executed.
        # *   **SUCCESS**: The change order was executed.
        # *   **FAIL**: The change order could not be executed.
        # *   **ABORT**: The change order was terminated.
        # *   **WAIT_BATCH_CONFIRM**: The change order is pending execution. You must manually confirm the release batch.
        # *   **AUTO_BATCH_WAIT**: The change order is pending execution. SAE will automatically confirm the release batch.
        # *   **SYSTEM_FAIL**: A system exception occurred.
        # *   **WAIT_APPROVAL**: The change order is pending approval.
        # *   **APPROVED**: The change order is approved and is pending execution.
        self.last_change_order_status = last_change_order_status
        self.name_space_short_id = name_space_short_id
        # The ID of the namespace.
        self.namespace_id = namespace_id
        # The name of the namespace.
        self.namespace_name = namespace_name
        # Indicates whether the notification of a change order is expired. Valid values:
        # 
        # *   **true**: indicates that the notification is expired.
        # *   **false**: indicates that the notification is not expired.
        self.notification_expired = notification_expired
        # The ID of the security group.
        self.security_group_id = security_group_id
        # The ID of the tenant in the SAE namespace.
        self.tenant_id = tenant_id
        # The ID of the user.
        self.user_id = user_id
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id
        # The name of the vSwitch.
        self.v_switch_name = v_switch_name
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id
        # The name of the VPC.
        self.vpc_name = vpc_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_count is not None:
            result['AppCount'] = self.app_count
        if self.belong_region is not None:
            result['BelongRegion'] = self.belong_region
        if self.description is not None:
            result['Description'] = self.description
        if self.jump_server_app_id is not None:
            result['JumpServerAppId'] = self.jump_server_app_id
        if self.jump_server_ip is not None:
            result['JumpServerIp'] = self.jump_server_ip
        if self.last_change_order_id is not None:
            result['LastChangeOrderId'] = self.last_change_order_id
        if self.last_change_order_running is not None:
            result['LastChangeOrderRunning'] = self.last_change_order_running
        if self.last_change_order_status is not None:
            result['LastChangeOrderStatus'] = self.last_change_order_status
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.namespace_name is not None:
            result['NamespaceName'] = self.namespace_name
        if self.notification_expired is not None:
            result['NotificationExpired'] = self.notification_expired
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.v_switch_name is not None:
            result['VSwitchName'] = self.v_switch_name
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vpc_name is not None:
            result['VpcName'] = self.vpc_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppCount') is not None:
            self.app_count = m.get('AppCount')
        if m.get('BelongRegion') is not None:
            self.belong_region = m.get('BelongRegion')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('JumpServerAppId') is not None:
            self.jump_server_app_id = m.get('JumpServerAppId')
        if m.get('JumpServerIp') is not None:
            self.jump_server_ip = m.get('JumpServerIp')
        if m.get('LastChangeOrderId') is not None:
            self.last_change_order_id = m.get('LastChangeOrderId')
        if m.get('LastChangeOrderRunning') is not None:
            self.last_change_order_running = m.get('LastChangeOrderRunning')
        if m.get('LastChangeOrderStatus') is not None:
            self.last_change_order_status = m.get('LastChangeOrderStatus')
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NamespaceName') is not None:
            self.namespace_name = m.get('NamespaceName')
        if m.get('NotificationExpired') is not None:
            self.notification_expired = m.get('NotificationExpired')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VSwitchName') is not None:
            self.v_switch_name = m.get('VSwitchName')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VpcName') is not None:
            self.vpc_name = m.get('VpcName')
        return self


class DescribeNamespaceResourcesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeNamespaceResourcesResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request failed.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the information about resources in the namespace was queried successfully. Valid values:
        # 
        # *   **true**: indicates that the query was successful.
        # *   **false**: indicates that the query failed.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeNamespaceResourcesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeNamespaceResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNamespaceResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNamespaceResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNamespacesRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
    ):
        # The page number.
        # 
        # This parameter is required.
        self.current_page = current_page
        # The number of entries per page. Valid values: 0 to 10000.
        # 
        # This parameter is required.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeNamespacesResponseBodyDataNamespaces(TeaModel):
    def __init__(
        self,
        access_key: str = None,
        address_server_host: str = None,
        name_space_short_id: str = None,
        namespace_description: str = None,
        namespace_id: str = None,
        namespace_name: str = None,
        region_id: str = None,
        secret_key: str = None,
        tenant_id: str = None,
    ):
        # The ACM-specific AccessKey ID. It can be used to manage data in an Application Configuration Management (ACM) namespace. For more information, see [Differences between Alibaba Cloud AccessKey and ACM-specific AccessKey](https://help.aliyun.com/document_detail/68941.html).
        self.access_key = access_key
        # The endpoint of the host.
        self.address_server_host = address_server_host
        # The short ID of the namespace.
        self.name_space_short_id = name_space_short_id
        # The description of the namespace.
        self.namespace_description = namespace_description
        # The ID of the namespace. You cannot query, modify, or delete the default namespace.
        self.namespace_id = namespace_id
        # The name of the namespace.
        self.namespace_name = namespace_name
        # The region ID.
        self.region_id = region_id
        # The ACM-specific AccessKey secret. It can be used to manage data in an ACM namespace. For more information, see [Differences between Alibaba Cloud AccessKey and ACM-specific AccessKey](https://help.aliyun.com/document_detail/68941.html).
        self.secret_key = secret_key
        # The tenant ID.
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_key is not None:
            result['AccessKey'] = self.access_key
        if self.address_server_host is not None:
            result['AddressServerHost'] = self.address_server_host
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_description is not None:
            result['NamespaceDescription'] = self.namespace_description
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.namespace_name is not None:
            result['NamespaceName'] = self.namespace_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.secret_key is not None:
            result['SecretKey'] = self.secret_key
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessKey') is not None:
            self.access_key = m.get('AccessKey')
        if m.get('AddressServerHost') is not None:
            self.address_server_host = m.get('AddressServerHost')
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceDescription') is not None:
            self.namespace_description = m.get('NamespaceDescription')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NamespaceName') is not None:
            self.namespace_name = m.get('NamespaceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SecretKey') is not None:
            self.secret_key = m.get('SecretKey')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DescribeNamespacesResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        namespaces: List[DescribeNamespacesResponseBodyDataNamespaces] = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # The page number.
        self.current_page = current_page
        # The namespaces.
        self.namespaces = namespaces
        # The number of entries per page.
        self.page_size = page_size
        # The total number of namespaces.
        self.total_size = total_size

    def validate(self):
        if self.namespaces:
            for k in self.namespaces:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['Namespaces'] = []
        if self.namespaces is not None:
            for k in self.namespaces:
                result['Namespaces'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.namespaces = []
        if m.get('Namespaces') is not None:
            for k in m.get('Namespaces'):
                temp_model = DescribeNamespacesResponseBodyDataNamespaces()
                self.namespaces.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class DescribeNamespacesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeNamespacesResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The information of namespaces.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the list of namespaces was queried. Valid values:
        # 
        # *   **true**: The list was queried.
        # *   **false**: The list failed to be queried.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeNamespacesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeNamespacesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeNamespacesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNamespacesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePipelineRequest(TeaModel):
    def __init__(
        self,
        pipeline_id: str = None,
    ):
        # The ID of the batch. You can call the [DescribeChangeOrder](https://help.aliyun.com/document_detail/126617.html) operation to obtain the ID.
        # 
        # This parameter is required.
        self.pipeline_id = pipeline_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        return self


class DescribePipelineResponseBodyDataStageListTaskList(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_ignore: int = None,
        error_message: str = None,
        message: str = None,
        show_manual_ignore: bool = None,
        stage_id: str = None,
        status: int = None,
        task_id: str = None,
        task_name: str = None,
    ):
        # The error code returned when the task could not be executed. If the task is successfully executed, this parameter is not returned.
        self.error_code = error_code
        # Indicates whether to execute the subsequent tasks when the task failed. Valid values:
        # 
        # *   **0**: The subsequent tasks cannot be executed.
        # *   **1**: The subsequent tasks can be executed.
        self.error_ignore = error_ignore
        # The error message returned when the task could not be executed. If the task is successfully executed, this parameter is not returned.
        self.error_message = error_message
        # The returned message indicating the task execution result.
        self.message = message
        # Indicates whether a running task can be manually skipped. Valid values:
        # 
        # *   **true**: The running task can be skipped.
        # *   **false**: The zone does not allow you to change the network type of an ApsaraDB for Redis instance from classic network to VPC.
        self.show_manual_ignore = show_manual_ignore
        # The ID of the stage.
        self.stage_id = stage_id
        # The task status. Valid values:
        # 
        # *   **0**: The task is prepared for execution.
        # *   **1**: The task is being executed.
        # *   **2**: successful
        # *   **3**: The task could not be executed.
        # *   **5**: The task is pending retry.
        # *   **6**: The task was terminated.
        self.status = status
        # The ID of the task.
        self.task_id = task_id
        # The name of the task.
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_ignore is not None:
            result['ErrorIgnore'] = self.error_ignore
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message is not None:
            result['Message'] = self.message
        if self.show_manual_ignore is not None:
            result['ShowManualIgnore'] = self.show_manual_ignore
        if self.stage_id is not None:
            result['StageId'] = self.stage_id
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorIgnore') is not None:
            self.error_ignore = m.get('ErrorIgnore')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ShowManualIgnore') is not None:
            self.show_manual_ignore = m.get('ShowManualIgnore')
        if m.get('StageId') is not None:
            self.stage_id = m.get('StageId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        return self


class DescribePipelineResponseBodyDataStageList(TeaModel):
    def __init__(
        self,
        executor_type: int = None,
        stage_id: str = None,
        stage_name: str = None,
        status: int = None,
        task_list: List[DescribePipelineResponseBodyDataStageListTaskList] = None,
    ):
        # The execution type of the stage. Valid values:
        # 
        # *   **0**: in sequence.
        # *   **1**: in parallel.
        self.executor_type = executor_type
        # The ID of the stage.
        self.stage_id = stage_id
        # The name of the stage.
        self.stage_name = stage_name
        # The status of the batch processing stage. Valid values:
        # 
        # *   **0**: The batch is prepared for this processing stage.
        # *   **1**: The task is being executed.
        # *   **2**: successful
        # *   **3**: The processing failed in this stage.
        # *   **6**: The processing stage was terminated.
        self.status = status
        # The list of task statuses.
        self.task_list = task_list

    def validate(self):
        if self.task_list:
            for k in self.task_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.executor_type is not None:
            result['ExecutorType'] = self.executor_type
        if self.stage_id is not None:
            result['StageId'] = self.stage_id
        if self.stage_name is not None:
            result['StageName'] = self.stage_name
        if self.status is not None:
            result['Status'] = self.status
        result['TaskList'] = []
        if self.task_list is not None:
            for k in self.task_list:
                result['TaskList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExecutorType') is not None:
            self.executor_type = m.get('ExecutorType')
        if m.get('StageId') is not None:
            self.stage_id = m.get('StageId')
        if m.get('StageName') is not None:
            self.stage_name = m.get('StageName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.task_list = []
        if m.get('TaskList') is not None:
            for k in m.get('TaskList'):
                temp_model = DescribePipelineResponseBodyDataStageListTaskList()
                self.task_list.append(temp_model.from_map(k))
        return self


class DescribePipelineResponseBodyData(TeaModel):
    def __init__(
        self,
        co_status: str = None,
        current_stage_id: str = None,
        next_pipeline_id: str = None,
        pipeline_id: str = None,
        pipeline_name: str = None,
        pipeline_status: int = None,
        show_batch: bool = None,
        stage_list: List[DescribePipelineResponseBodyDataStageList] = None,
    ):
        # The status of the change order for the batch.
        self.co_status = co_status
        # The ID of the batch processing stage.
        self.current_stage_id = current_stage_id
        # The ID of the next batch.
        self.next_pipeline_id = next_pipeline_id
        # The ID of the batch.
        self.pipeline_id = pipeline_id
        # The name of the batch.
        self.pipeline_name = pipeline_name
        # The batch status. Valid values:
        # 
        # *   **0**: The batch is prepared for processing.
        # *   **1**: The task is being executed.
        # *   **2**: successful
        # *   **3**: The processing failed in this stage.
        # *   **6**: The batch processing was terminated.
        # *   **10**: The batch could not be processed due to a system exception.
        self.pipeline_status = pipeline_status
        # Indicates whether to start processing the next batch. Valid values:
        # 
        # *   **false**: indicates that the next batch cannot be processed yet.
        # *   **true**: indicates that the next batch can be processed now.
        self.show_batch = show_batch
        # The list of batch processing stages.
        self.stage_list = stage_list

    def validate(self):
        if self.stage_list:
            for k in self.stage_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.co_status is not None:
            result['CoStatus'] = self.co_status
        if self.current_stage_id is not None:
            result['CurrentStageId'] = self.current_stage_id
        if self.next_pipeline_id is not None:
            result['NextPipelineId'] = self.next_pipeline_id
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.pipeline_name is not None:
            result['PipelineName'] = self.pipeline_name
        if self.pipeline_status is not None:
            result['PipelineStatus'] = self.pipeline_status
        if self.show_batch is not None:
            result['ShowBatch'] = self.show_batch
        result['StageList'] = []
        if self.stage_list is not None:
            for k in self.stage_list:
                result['StageList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CoStatus') is not None:
            self.co_status = m.get('CoStatus')
        if m.get('CurrentStageId') is not None:
            self.current_stage_id = m.get('CurrentStageId')
        if m.get('NextPipelineId') is not None:
            self.next_pipeline_id = m.get('NextPipelineId')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('PipelineName') is not None:
            self.pipeline_name = m.get('PipelineName')
        if m.get('PipelineStatus') is not None:
            self.pipeline_status = m.get('PipelineStatus')
        if m.get('ShowBatch') is not None:
            self.show_batch = m.get('ShowBatch')
        self.stage_list = []
        if m.get('StageList') is not None:
            for k in m.get('StageList'):
                temp_model = DescribePipelineResponseBodyDataStageList()
                self.stage_list.append(temp_model.from_map(k))
        return self


class DescribePipelineResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribePipelineResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The batch information.
        self.data = data
        # The error code returned if the request failed. Take note of the following rules:
        # 
        # *   The **ErrorCode** parameter is not returned if the request succeeds.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The message returned for the operation.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the batch information was obtained. Valid values:
        # 
        # *   **true**: The information was queried.
        # *   **false**: The image failed to be found.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribePipelineResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribePipelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePipelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRegionsResponseBodyRegionsRegionRecommendZones(TeaModel):
    def __init__(
        self,
        recommend_zone: List[str] = None,
    ):
        self.recommend_zone = recommend_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.recommend_zone is not None:
            result['RecommendZone'] = self.recommend_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RecommendZone') is not None:
            self.recommend_zone = m.get('RecommendZone')
        return self


class DescribeRegionsResponseBodyRegionsRegion(TeaModel):
    def __init__(
        self,
        local_name: str = None,
        recommend_zones: DescribeRegionsResponseBodyRegionsRegionRecommendZones = None,
        region_endpoint: str = None,
        region_id: str = None,
    ):
        # The region name. Valid values:
        # 
        # *   **China (Hangzhou)**\
        # *   **China (Shanghai)**\
        # *   **China (Beijing)**\
        # *   **China (Zhangjiakou)**\
        # *   **China (Shenzhen)**\
        # *   **China (Guangzhou)**\
        # *   **China (Hong Kong)**\
        # *   **Singapore**\
        # *   **US (Silicon Valley)**\
        self.local_name = local_name
        # The recommended zones.
        self.recommend_zones = recommend_zones
        # The endpoint for the region. Valid values:
        # 
        # *   **sae.cn-hangzhou.aliyuncs.com**\
        # *   **sae.cn-shanghai.aliyuncs.com**\
        # *   **sae.cn-beijing.aliyuncs.com**\
        # *   **sae.cn-zhangjiakou.aliyuncs.com**\
        # *   **sae.cn-shenzhen.aliyuncs.com**\
        # *   **sae.cn-guangzhou.aliyuncs.com**\
        # *   **sae.cn-hongkong.aliyuncs.com**\
        # *   **sae.ap-southeast-1.aliyuncs.com**\
        # *   **sae.us-west-1.aliyuncs.com**\
        self.region_endpoint = region_endpoint
        # The region ID. Valid values:
        # 
        # *   **cn-hangzhou**: the ID of the China (Hangzhou) region
        # *   **cn-shanghai**: the ID of the China (Shanghai) region
        # *   **cn-beijing**: the ID of the China (Beijing) region
        # *   **cn-zhangjiakou**: the ID of the China (Zhangjiakou) region
        # *   **cn-shenzhen**: the ID of the China (Shenzhen) region
        # *   **cn-guangzhou**: the ID of the China (Guangzhou) region
        # *   **cn-hongkong**: the ID of the China (Hong Kong) region
        # *   **ap-southeast-1**: the ID of the Singapore region
        # *   **us-west-1**: the ID of the US (Silicon Valley) region
        self.region_id = region_id

    def validate(self):
        if self.recommend_zones:
            self.recommend_zones.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.local_name is not None:
            result['LocalName'] = self.local_name
        if self.recommend_zones is not None:
            result['RecommendZones'] = self.recommend_zones.to_map()
        if self.region_endpoint is not None:
            result['RegionEndpoint'] = self.region_endpoint
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LocalName') is not None:
            self.local_name = m.get('LocalName')
        if m.get('RecommendZones') is not None:
            temp_model = DescribeRegionsResponseBodyRegionsRegionRecommendZones()
            self.recommend_zones = temp_model.from_map(m['RecommendZones'])
        if m.get('RegionEndpoint') is not None:
            self.region_endpoint = m.get('RegionEndpoint')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeRegionsResponseBodyRegions(TeaModel):
    def __init__(
        self,
        region: List[DescribeRegionsResponseBodyRegionsRegion] = None,
    ):
        self.region = region

    def validate(self):
        if self.region:
            for k in self.region:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Region'] = []
        if self.region is not None:
            for k in self.region:
                result['Region'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.region = []
        if m.get('Region') is not None:
            for k in m.get('Region'):
                temp_model = DescribeRegionsResponseBodyRegionsRegion()
                self.region.append(temp_model.from_map(k))
        return self


class DescribeRegionsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        regions: DescribeRegionsResponseBodyRegions = None,
        request_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The returned message.
        self.message = message
        # The regions.
        self.regions = regions
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.regions:
            self.regions.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.regions is not None:
            result['Regions'] = self.regions.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Regions') is not None:
            temp_model = DescribeRegionsResponseBodyRegions()
            self.regions = temp_model.from_map(m['Regions'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeRegionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRegionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRegionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecretRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
        secret_id: int = None,
    ):
        # The ID of the namespace where the Secret resides. If the namespace is the default namespace, you need to only enter the region ID, such as `cn-beijing`.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # The ID of the Secret instance to be queried. You can call the [ListSecrets](https://help.aliyun.com/document_detail/466929.html) operation to view the IDs of Secrete instances.
        # 
        # This parameter is required.
        self.secret_id = secret_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.secret_id is not None:
            result['SecretId'] = self.secret_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('SecretId') is not None:
            self.secret_id = m.get('SecretId')
        return self


class DescribeSecretResponseBodyDataRelateApps(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
    ):
        # The application ID.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        return self


class DescribeSecretResponseBodyData(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        namespace_id: str = None,
        relate_apps: List[DescribeSecretResponseBodyDataRelateApps] = None,
        secret_data: Dict[str, str] = None,
        secret_id: int = None,
        secret_name: str = None,
        secret_type: str = None,
        update_time: int = None,
    ):
        # The time when the task was created.
        self.create_time = create_time
        # The ID of the namespace.
        self.namespace_id = namespace_id
        # The associated application.
        self.relate_apps = relate_apps
        # Secret key-value pair data.
        self.secret_data = secret_data
        # The ID of the Secret instance.
        self.secret_id = secret_id
        # The name of the Secret instance.
        self.secret_name = secret_name
        # The type of the Secret instance.
        self.secret_type = secret_type
        # The time when the task was updated.
        self.update_time = update_time

    def validate(self):
        if self.relate_apps:
            for k in self.relate_apps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        result['RelateApps'] = []
        if self.relate_apps is not None:
            for k in self.relate_apps:
                result['RelateApps'].append(k.to_map() if k else None)
        if self.secret_data is not None:
            result['SecretData'] = self.secret_data
        if self.secret_id is not None:
            result['SecretId'] = self.secret_id
        if self.secret_name is not None:
            result['SecretName'] = self.secret_name
        if self.secret_type is not None:
            result['SecretType'] = self.secret_type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        self.relate_apps = []
        if m.get('RelateApps') is not None:
            for k in m.get('RelateApps'):
                temp_model = DescribeSecretResponseBodyDataRelateApps()
                self.relate_apps.append(temp_model.from_map(k))
        if m.get('SecretData') is not None:
            self.secret_data = m.get('SecretData')
        if m.get('SecretId') is not None:
            self.secret_id = m.get('SecretId')
        if m.get('SecretName') is not None:
            self.secret_name = m.get('SecretName')
        if m.get('SecretType') is not None:
            self.secret_type = m.get('SecretType')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeSecretResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeSecretResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The response.
        self.data = data
        # The error code returned. Valid values:
        # 
        # *   The **ErrorCode** parameter is not returned if the request succeeds.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The additional information that is returned. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the details of the Secret instance are successfully queried. Valid values:
        # 
        # *   **true**: The information was queried.
        # *   **false**: The image failed to be found.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeSecretResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeSecretResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSecretResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecretResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSwimmingLaneRequest(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        lane_id: int = None,
        namespace_id: str = None,
    ):
        self.group_id = group_id
        self.lane_id = lane_id
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lane_id is not None:
            result['LaneId'] = self.lane_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('LaneId') is not None:
            self.lane_id = m.get('LaneId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class DescribeSwimmingLaneResponseBodyDataAppEntryRuleConditions(TeaModel):
    def __init__(
        self,
        condition: str = None,
        name: str = None,
        type: str = None,
        value: str = None,
        values: List[str] = None,
    ):
        self.condition = condition
        self.name = name
        self.type = type
        self.value = value
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class DescribeSwimmingLaneResponseBodyDataAppEntryRule(TeaModel):
    def __init__(
        self,
        condition_joiner: str = None,
        conditions: List[DescribeSwimmingLaneResponseBodyDataAppEntryRuleConditions] = None,
        independent_percentage_enable: bool = None,
        paths: List[str] = None,
        percentage: int = None,
        percentage_by_path: Dict[str, int] = None,
    ):
        self.condition_joiner = condition_joiner
        self.conditions = conditions
        self.independent_percentage_enable = independent_percentage_enable
        self.paths = paths
        self.percentage = percentage
        self.percentage_by_path = percentage_by_path

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition_joiner is not None:
            result['ConditionJoiner'] = self.condition_joiner
        result['Conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['Conditions'].append(k.to_map() if k else None)
        if self.independent_percentage_enable is not None:
            result['IndependentPercentageEnable'] = self.independent_percentage_enable
        if self.paths is not None:
            result['Paths'] = self.paths
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        if self.percentage_by_path is not None:
            result['PercentageByPath'] = self.percentage_by_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConditionJoiner') is not None:
            self.condition_joiner = m.get('ConditionJoiner')
        self.conditions = []
        if m.get('Conditions') is not None:
            for k in m.get('Conditions'):
                temp_model = DescribeSwimmingLaneResponseBodyDataAppEntryRuleConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('IndependentPercentageEnable') is not None:
            self.independent_percentage_enable = m.get('IndependentPercentageEnable')
        if m.get('Paths') is not None:
            self.paths = m.get('Paths')
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        if m.get('PercentageByPath') is not None:
            self.percentage_by_path = m.get('PercentageByPath')
        return self


class DescribeSwimmingLaneResponseBodyDataApps(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        mse_app_id: str = None,
        mse_app_name: str = None,
        mse_namespace_id: str = None,
    ):
        self.app_id = app_id
        self.app_name = app_name
        self.mse_app_id = mse_app_id
        self.mse_app_name = mse_app_name
        self.mse_namespace_id = mse_namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.mse_app_id is not None:
            result['MseAppId'] = self.mse_app_id
        if self.mse_app_name is not None:
            result['MseAppName'] = self.mse_app_name
        if self.mse_namespace_id is not None:
            result['mseNamespaceId'] = self.mse_namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('MseAppId') is not None:
            self.mse_app_id = m.get('MseAppId')
        if m.get('MseAppName') is not None:
            self.mse_app_name = m.get('MseAppName')
        if m.get('mseNamespaceId') is not None:
            self.mse_namespace_id = m.get('mseNamespaceId')
        return self


class DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleConditions(TeaModel):
    def __init__(
        self,
        condition: str = None,
        name: str = None,
        type: str = None,
        value: str = None,
    ):
        self.condition = condition
        self.name = name
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicatePathPredicate(TeaModel):
    def __init__(
        self,
        path: str = None,
        type: str = None,
    ):
        self.path = path
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.path is not None:
            result['Path'] = self.path
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicate(TeaModel):
    def __init__(
        self,
        path_predicate: DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicatePathPredicate = None,
    ):
        self.path_predicate = path_predicate

    def validate(self):
        if self.path_predicate:
            self.path_predicate.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.path_predicate is not None:
            result['PathPredicate'] = self.path_predicate.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PathPredicate') is not None:
            temp_model = DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicatePathPredicate()
            self.path_predicate = temp_model.from_map(m['PathPredicate'])
        return self


class DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutes(TeaModel):
    def __init__(
        self,
        route_id: int = None,
        route_name: str = None,
        route_predicate: DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicate = None,
    ):
        self.route_id = route_id
        self.route_name = route_name
        self.route_predicate = route_predicate

    def validate(self):
        if self.route_predicate:
            self.route_predicate.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.route_id is not None:
            result['RouteId'] = self.route_id
        if self.route_name is not None:
            result['RouteName'] = self.route_name
        if self.route_predicate is not None:
            result['RoutePredicate'] = self.route_predicate.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RouteId') is not None:
            self.route_id = m.get('RouteId')
        if m.get('RouteName') is not None:
            self.route_name = m.get('RouteName')
        if m.get('RoutePredicate') is not None:
            temp_model = DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicate()
            self.route_predicate = temp_model.from_map(m['RoutePredicate'])
        return self


class DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRule(TeaModel):
    def __init__(
        self,
        condition_joiner: str = None,
        conditions: List[DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleConditions] = None,
        independent_percentage_enable: bool = None,
        percentage: int = None,
        percentage_by_route: Dict[str, int] = None,
        route_ids: List[int] = None,
        routes: List[DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutes] = None,
    ):
        self.condition_joiner = condition_joiner
        self.conditions = conditions
        self.independent_percentage_enable = independent_percentage_enable
        self.percentage = percentage
        self.percentage_by_route = percentage_by_route
        self.route_ids = route_ids
        self.routes = routes

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()
        if self.routes:
            for k in self.routes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition_joiner is not None:
            result['ConditionJoiner'] = self.condition_joiner
        result['Conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['Conditions'].append(k.to_map() if k else None)
        if self.independent_percentage_enable is not None:
            result['IndependentPercentageEnable'] = self.independent_percentage_enable
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        if self.percentage_by_route is not None:
            result['PercentageByRoute'] = self.percentage_by_route
        if self.route_ids is not None:
            result['RouteIds'] = self.route_ids
        result['Routes'] = []
        if self.routes is not None:
            for k in self.routes:
                result['Routes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConditionJoiner') is not None:
            self.condition_joiner = m.get('ConditionJoiner')
        self.conditions = []
        if m.get('Conditions') is not None:
            for k in m.get('Conditions'):
                temp_model = DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('IndependentPercentageEnable') is not None:
            self.independent_percentage_enable = m.get('IndependentPercentageEnable')
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        if m.get('PercentageByRoute') is not None:
            self.percentage_by_route = m.get('PercentageByRoute')
        if m.get('RouteIds') is not None:
            self.route_ids = m.get('RouteIds')
        self.routes = []
        if m.get('Routes') is not None:
            for k in m.get('Routes'):
                temp_model = DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutes()
                self.routes.append(temp_model.from_map(k))
        return self


class DescribeSwimmingLaneResponseBodyData(TeaModel):
    def __init__(
        self,
        app_entry_rule: DescribeSwimmingLaneResponseBodyDataAppEntryRule = None,
        apps: List[DescribeSwimmingLaneResponseBodyDataApps] = None,
        canary_model: int = None,
        enable: bool = None,
        enable_rules: bool = None,
        lane_id: int = None,
        lane_name: str = None,
        lane_tag: str = None,
        mse_gateway_entry_rule: DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRule = None,
    ):
        self.app_entry_rule = app_entry_rule
        self.apps = apps
        self.canary_model = canary_model
        self.enable = enable
        self.enable_rules = enable_rules
        self.lane_id = lane_id
        self.lane_name = lane_name
        self.lane_tag = lane_tag
        self.mse_gateway_entry_rule = mse_gateway_entry_rule

    def validate(self):
        if self.app_entry_rule:
            self.app_entry_rule.validate()
        if self.apps:
            for k in self.apps:
                if k:
                    k.validate()
        if self.mse_gateway_entry_rule:
            self.mse_gateway_entry_rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_entry_rule is not None:
            result['AppEntryRule'] = self.app_entry_rule.to_map()
        result['Apps'] = []
        if self.apps is not None:
            for k in self.apps:
                result['Apps'].append(k.to_map() if k else None)
        if self.canary_model is not None:
            result['CanaryModel'] = self.canary_model
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.enable_rules is not None:
            result['EnableRules'] = self.enable_rules
        if self.lane_id is not None:
            result['LaneId'] = self.lane_id
        if self.lane_name is not None:
            result['LaneName'] = self.lane_name
        if self.lane_tag is not None:
            result['LaneTag'] = self.lane_tag
        if self.mse_gateway_entry_rule is not None:
            result['MseGatewayEntryRule'] = self.mse_gateway_entry_rule.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppEntryRule') is not None:
            temp_model = DescribeSwimmingLaneResponseBodyDataAppEntryRule()
            self.app_entry_rule = temp_model.from_map(m['AppEntryRule'])
        self.apps = []
        if m.get('Apps') is not None:
            for k in m.get('Apps'):
                temp_model = DescribeSwimmingLaneResponseBodyDataApps()
                self.apps.append(temp_model.from_map(k))
        if m.get('CanaryModel') is not None:
            self.canary_model = m.get('CanaryModel')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('EnableRules') is not None:
            self.enable_rules = m.get('EnableRules')
        if m.get('LaneId') is not None:
            self.lane_id = m.get('LaneId')
        if m.get('LaneName') is not None:
            self.lane_name = m.get('LaneName')
        if m.get('LaneTag') is not None:
            self.lane_tag = m.get('LaneTag')
        if m.get('MseGatewayEntryRule') is not None:
            temp_model = DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRule()
            self.mse_gateway_entry_rule = temp_model.from_map(m['MseGatewayEntryRule'])
        return self


class DescribeSwimmingLaneResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeSwimmingLaneResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeSwimmingLaneResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribeSwimmingLaneResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSwimmingLaneResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSwimmingLaneResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebApplicationRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
    ):
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class DescribeWebApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WebApplicationBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WebApplicationBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebApplicationResourceStaticsRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        namespace_id: str = None,
        region_id: str = None,
        start_time: int = None,
    ):
        # The end of the time range during which data was queried.
        self.end_time = end_time
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # The region ID.
        self.region_id = region_id
        # The time when the task was created.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeWebApplicationResourceStaticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WebApplicationResourceStaticsBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WebApplicationResourceStaticsBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebApplicationRevisionRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
    ):
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class DescribeWebApplicationRevisionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WebApplicationRevisionBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WebApplicationRevisionBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebApplicationScalingConfigRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
    ):
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class DescribeWebApplicationScalingConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WebApplicationScalingConfigBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WebApplicationScalingConfigBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebApplicationTrafficConfigRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
    ):
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class DescribeWebApplicationTrafficConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WebApplicationTrafficConfigBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WebApplicationTrafficConfigBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebCustomDomainRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
    ):
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class DescribeWebCustomDomainResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WebCustomDomain = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WebCustomDomain()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebInstanceLogsRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
    ):
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class DescribeWebInstanceLogsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WebApplicationInstanceLogsBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WebApplicationInstanceLogsBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableApplicationScalingRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        scaling_rule_name: str = None,
    ):
        # timer-0800-2100
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the request.
        # 
        # This parameter is required.
        self.scaling_rule_name = scaling_rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.scaling_rule_name is not None:
            result['ScalingRuleName'] = self.scaling_rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ScalingRuleName') is not None:
            self.scaling_rule_name = m.get('ScalingRuleName')
        return self


class DisableApplicationScalingRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The request was successful.
        # *   **3xx**: The request was redirected.
        # *   **4xx**: The request failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The error codes. Valid values:
        # 
        # *   If the request was successful, **ErrorCode** is not returned.
        # *   If the request failed, **ErrorCode** is returned. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message. Valid values:
        # 
        # *   If the request was successful, **success** is returned.
        # *   If the request failed, an error code is returned.
        self.message = message
        # The ID of the trace. The ID is used to query the details of a request.
        self.request_id = request_id
        # Indicates whether the auto scaling policy was disabled. Valid values:
        # 
        # *   **true**: The auto scaling policy was disabled.
        # *   **false**: The auto scaling policy failed to be disabled.
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DisableApplicationScalingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableApplicationScalingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableApplicationScalingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DowngradeApplicationApmServiceRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DowngradeApplicationApmServiceResponseBodyData(TeaModel):
    def __init__(
        self,
        status: bool = None,
    ):
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DowngradeApplicationApmServiceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DowngradeApplicationApmServiceResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DowngradeApplicationApmServiceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DowngradeApplicationApmServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DowngradeApplicationApmServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DowngradeApplicationApmServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableApplicationScalingRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        scaling_rule_name: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The name of the auto scaling policy.
        # 
        # This parameter is required.
        self.scaling_rule_name = scaling_rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.scaling_rule_name is not None:
            result['ScalingRuleName'] = self.scaling_rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ScalingRuleName') is not None:
            self.scaling_rule_name = m.get('ScalingRuleName')
        return self


class EnableApplicationScalingRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Take note of the following rules:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The error code returned if the request failed. Take note of the following rules:
        # 
        # *   The **ErrorCode** parameter is not returned if the request succeeds.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The additional information that is returned. Take note of the following rules:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Specifies whether the instances are successfully restarted. Take note of the following rules:
        # 
        # *   **true**\
        # *   **false**: The restart failed.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class EnableApplicationScalingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableApplicationScalingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableApplicationScalingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecJobRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        command: str = None,
        command_args: str = None,
        envs: str = None,
        event_id: str = None,
        jar_start_args: str = None,
        jar_start_options: str = None,
        replicas: str = None,
        time: str = None,
        war_start_options: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.command = command
        self.command_args = command_args
        self.envs = envs
        self.event_id = event_id
        # The arguments in the JAR package. The arguments are used to start the job. The default startup command is `$JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs`.
        self.jar_start_args = jar_start_args
        # The option settings in the JAR package. The settings are used to start the job. The default startup command is `$JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArg`.
        self.jar_start_options = jar_start_options
        # The number of concurrent instances.
        self.replicas = replicas
        # The time at which the job is triggered. Format: `yyyy-MM-dd\\"T\\"HH:mm:ss\\"Z\\"`.
        self.time = time
        # The startup command of the WAR package. For information about how to configure the startup command, see [Configure a startup command](https://help.aliyun.com/document_detail/96677.html).
        self.war_start_options = war_start_options

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.jar_start_args is not None:
            result['JarStartArgs'] = self.jar_start_args
        if self.jar_start_options is not None:
            result['JarStartOptions'] = self.jar_start_options
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.time is not None:
            result['Time'] = self.time
        if self.war_start_options is not None:
            result['WarStartOptions'] = self.war_start_options
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('JarStartArgs') is not None:
            self.jar_start_args = m.get('JarStartArgs')
        if m.get('JarStartOptions') is not None:
            self.jar_start_options = m.get('JarStartOptions')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('WarStartOptions') is not None:
            self.war_start_options = m.get('WarStartOptions')
        return self


class ExecJobResponseBodyData(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        msg: str = None,
        success: str = None,
    ):
        self.code = code
        self.data = data
        self.msg = msg
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExecJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ExecJobResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ExecJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ExecJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExecJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        namespace_id: str = None,
    ):
        # The application ID.
        self.app_id = app_id
        # The application name.
        self.app_name = app_name
        # The ID of the namespace.
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class GetApplicationResponseBodyApplication(TeaModel):
    def __init__(
        self,
        app_description: str = None,
        app_id: str = None,
        app_name: str = None,
        base_app_id: str = None,
        cpu: int = None,
        instances: int = None,
        is_stateful: bool = None,
        mem: int = None,
        mse_enabled: bool = None,
        mse_namespace_id: str = None,
        namespace_id: str = None,
        programming_language: str = None,
        running_instances: int = None,
        scale_rule_enabled: str = None,
        scale_rule_type: str = None,
    ):
        # The description of the application.
        self.app_description = app_description
        # The application ID.
        self.app_id = app_id
        # The application name.
        self.app_name = app_name
        # The ID of the basic application.
        self.base_app_id = base_app_id
        # The CPU specifications that are required for each instance. Unit: millicores. This parameter cannot be set to 0. Valid values:
        # 
        # *   **500**\
        # *   **1000**\
        # *   **2000**\
        # *   **4000**\
        # *   **8000**\
        # *   **12000**\
        # *   **16000**\
        # *   **32000**\
        self.cpu = cpu
        # The number of application instances.
        self.instances = instances
        self.is_stateful = is_stateful
        # The memory size that is required by each instance. Unit: MB. This parameter cannot be set to 0. The values of this parameter correspond to the values of the Cpu parameter:
        # 
        # *   This parameter is set to **1024** if the Cpu parameter is set to 500 or 1000.
        # *   This parameter is set to **2048** if the Cpu parameter is set to 500, 1000, or 2000.
        # *   This parameter is set to **4096** if the Cpu parameter is set to 1000, 2000, or 4000.
        # *   This parameter is set to **8192** if the Cpu parameter is set to 2000, 4000, or 8000.
        # *   This parameter is set to **12288** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **16384** if the Cpu parameter is set to 4000, 8000, or 16000.
        # *   This parameter is set to **24576** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **32768** if the Cpu parameter is set to 16000.
        # *   This parameter is set to **65536** if the Cpu parameter is set to 8000, 16000, or 32000.
        # *   This parameter is set to **131072** if the Cpu parameter is set to 32000.
        self.mem = mem
        # Specifies whether to enable WebAssembly Filter. Valid values:
        # 
        # *   true: enables this parameter.
        # *   false: disables this parameter.
        self.mse_enabled = mse_enabled
        # The ID of the namespace to which the MSE instance belongs.
        self.mse_namespace_id = mse_namespace_id
        # The namespace ID.
        self.namespace_id = namespace_id
        # The programming language that is used to create the application. Valid values:
        # 
        # *   **java** :Java.
        # *   **php**: PHP.
        # *   **other**: other programming languages, such as Python, C++, Go, .NET, and Node.js
        self.programming_language = programming_language
        # The number of application instances that are running.
        self.running_instances = running_instances
        # Indicates whether the auto scaling policy is enabled. Valid values:
        # 
        # *   **true**: The auto scaling policy is enabled.
        # *   **false**: The auto scaling policy is disabled.
        self.scale_rule_enabled = scale_rule_enabled
        # The type of the auto scaling policy. Valid values:
        # 
        # *   **timing**: a scheduled auto scaling policy.
        # *   **metric**: a metric-based auto scaling policy.
        # *   **mix**: a hybrid auto scaling policy.
        self.scale_rule_type = scale_rule_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_description is not None:
            result['AppDescription'] = self.app_description
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.base_app_id is not None:
            result['BaseAppId'] = self.base_app_id
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.instances is not None:
            result['Instances'] = self.instances
        if self.is_stateful is not None:
            result['IsStateful'] = self.is_stateful
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.mse_enabled is not None:
            result['MseEnabled'] = self.mse_enabled
        if self.mse_namespace_id is not None:
            result['MseNamespaceId'] = self.mse_namespace_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.programming_language is not None:
            result['ProgrammingLanguage'] = self.programming_language
        if self.running_instances is not None:
            result['RunningInstances'] = self.running_instances
        if self.scale_rule_enabled is not None:
            result['ScaleRuleEnabled'] = self.scale_rule_enabled
        if self.scale_rule_type is not None:
            result['ScaleRuleType'] = self.scale_rule_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppDescription') is not None:
            self.app_description = m.get('AppDescription')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BaseAppId') is not None:
            self.base_app_id = m.get('BaseAppId')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('Instances') is not None:
            self.instances = m.get('Instances')
        if m.get('IsStateful') is not None:
            self.is_stateful = m.get('IsStateful')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('MseEnabled') is not None:
            self.mse_enabled = m.get('MseEnabled')
        if m.get('MseNamespaceId') is not None:
            self.mse_namespace_id = m.get('MseNamespaceId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('ProgrammingLanguage') is not None:
            self.programming_language = m.get('ProgrammingLanguage')
        if m.get('RunningInstances') is not None:
            self.running_instances = m.get('RunningInstances')
        if m.get('ScaleRuleEnabled') is not None:
            self.scale_rule_enabled = m.get('ScaleRuleEnabled')
        if m.get('ScaleRuleType') is not None:
            self.scale_rule_type = m.get('ScaleRuleType')
        return self


class GetApplicationResponseBody(TeaModel):
    def __init__(
        self,
        application: GetApplicationResponseBodyApplication = None,
        message: str = None,
        request_id: str = None,
        trace_id: str = None,
    ):
        # The details of the application.
        self.application = application
        # The additional information returned. Valid values:
        # 
        # *   When a request is successful, **success**is returned.
        # *   An error code is returned when a request failed.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.application:
            self.application.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application is not None:
            result['Application'] = self.application.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Application') is not None:
            temp_model = GetApplicationResponseBodyApplication()
            self.application = temp_model.from_map(m['Application'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class GetApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetArmsTopNMetricRequest(TeaModel):
    def __init__(
        self,
        app_source: str = None,
        cpu_strategy: str = None,
        end_time: int = None,
        limit: int = None,
        order_by: str = None,
        region_id: str = None,
        start_time: int = None,
    ):
        # The CPU allocation policy. Valid values:
        # 
        # *   **request**: CPU cores are allocated only when a request is initiated.
        # *   **always**: Fixed CPU cores are always allocated.
        self.app_source = app_source
        # The additional information that is returned. The following limits are imposed on the ID:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.cpu_strategy = cpu_strategy
        # The SAE application type. Valid values:
        # 
        # *   **micro_service**\
        # *   **web**\
        # *   **job**\
        # 
        # This parameter is required.
        self.end_time = end_time
        # The beginning of the time range to query.
        # 
        # This parameter is required.
        self.limit = limit
        # The number of entries to return. Valid values: 0 to 100.
        # 
        # This parameter is required.
        self.order_by = order_by
        # The field based on which you want to sort the returned entries.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The end of the time range to query.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_source is not None:
            result['AppSource'] = self.app_source
        if self.cpu_strategy is not None:
            result['CpuStrategy'] = self.cpu_strategy
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppSource') is not None:
            self.app_source = m.get('AppSource')
        if m.get('CpuStrategy') is not None:
            self.cpu_strategy = m.get('CpuStrategy')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetArmsTopNMetricResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        count: int = None,
        error: int = None,
        name: str = None,
        region_id: str = None,
        rt: int = None,
    ):
        # The application ID.
        self.app_id = app_id
        # The total number of requests.
        self.count = count
        # The number of errors.
        self.error = error
        # The application name.
        self.name = name
        # The namespace ID.
        self.region_id = region_id
        # The average response time. Unit: milliseconds.
        self.rt = rt

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.count is not None:
            result['Count'] = self.count
        if self.error is not None:
            result['Error'] = self.error
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rt is not None:
            result['Rt'] = self.rt
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Error') is not None:
            self.error = m.get('Error')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Rt') is not None:
            self.rt = m.get('Rt')
        return self


class GetArmsTopNMetricResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[GetArmsTopNMetricResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The following limits are imposed on the ID:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The details of applications.
        self.data = data
        # The request ID.
        self.message = message
        # 3B763F98-0BA2-5C23-B6B8-558568D2C1C2
        self.request_id = request_id
        # Indicates whether the list of applications was obtained. The following limits are imposed on the ID:
        # 
        # *   **true**: The namespaces were obtained.
        # *   **false**: no
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GetArmsTopNMetricResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetArmsTopNMetricResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetArmsTopNMetricResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetArmsTopNMetricResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAvailabilityMetricRequest(TeaModel):
    def __init__(
        self,
        app_source: str = None,
        cpu_strategy: str = None,
        limit: int = None,
        region_id: str = None,
    ):
        # The SAE application type. Valid values:
        # 
        # *   **micro_service**\
        # *   **web**\
        # *   **job**\
        self.app_source = app_source
        # The CPU allocation policy. Valid values:
        # 
        # *   **request**: CPU cores are allocated only when a request is initiated.
        # *   **always**: Fixed CPU cores are always allocated.
        self.cpu_strategy = cpu_strategy
        # The number of entries to return. Valid values: 0 to 100.
        # 
        # This parameter is required.
        self.limit = limit
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_source is not None:
            result['AppSource'] = self.app_source
        if self.cpu_strategy is not None:
            result['CpuStrategy'] = self.cpu_strategy
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppSource') is not None:
            self.app_source = m.get('AppSource')
        if m.get('CpuStrategy') is not None:
            self.cpu_strategy = m.get('CpuStrategy')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetAvailabilityMetricResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        enable_autoscale: int = None,
        error_instances: int = None,
        instances: int = None,
        name: str = None,
        region_id: str = None,
        runnings: int = None,
    ):
        # The application ID.
        self.app_id = app_id
        # Indicates whether an auto scaling policy is enabled. Valid values:
        # 
        # *   **1**: An auto scaling policy is enabled.
        # *   **0**: No auto scaling policy is enabled.
        self.enable_autoscale = enable_autoscale
        # The number of abnormal instances.
        self.error_instances = error_instances
        # The expected number of instances.
        self.instances = instances
        # The application name.
        self.name = name
        # The namespace ID.
        self.region_id = region_id
        # The current number of instances.
        self.runnings = runnings

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.enable_autoscale is not None:
            result['EnableAutoscale'] = self.enable_autoscale
        if self.error_instances is not None:
            result['ErrorInstances'] = self.error_instances
        if self.instances is not None:
            result['Instances'] = self.instances
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.runnings is not None:
            result['Runnings'] = self.runnings
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EnableAutoscale') is not None:
            self.enable_autoscale = m.get('EnableAutoscale')
        if m.get('ErrorInstances') is not None:
            self.error_instances = m.get('ErrorInstances')
        if m.get('Instances') is not None:
            self.instances = m.get('Instances')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Runnings') is not None:
            self.runnings = m.get('Runnings')
        return self


class GetAvailabilityMetricResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[GetAvailabilityMetricResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The following limits are imposed on the ID:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The data entries returned.
        self.data = data
        # The additional information that is returned. The following limits are imposed on the ID:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the list of applications was obtained. The following limits are imposed on the ID:
        # 
        # *   **true**: The namespaces were obtained.
        # *   **false**: no
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GetAvailabilityMetricResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetAvailabilityMetricResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAvailabilityMetricResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAvailabilityMetricResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetChangeOrderMetricRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_source: str = None,
        co_type: str = None,
        cpu_strategy: str = None,
        create_time: str = None,
        limit: int = None,
        order_by: str = None,
        region_id: str = None,
    ):
        self.app_id = app_id
        # The SAE application type. Valid values:
        # 
        # *   **micro_service**\
        # *   **web**\
        # *   **job**\
        self.app_source = app_source
        self.co_type = co_type
        # The CPU allocation policy. Valid values:
        # 
        # *   **request**: CPU cores are allocated only when a request is initiated.
        # *   **always**: Fixed CPU cores are always allocated.
        self.cpu_strategy = cpu_strategy
        # The start time when the change order was created.
        # 
        # This parameter is required.
        self.create_time = create_time
        # The number of entries to return. Valid values: 0 to 100.
        # 
        # This parameter is required.
        self.limit = limit
        # The field based on which you want to sort the returned entries.
        # 
        # This parameter is required.
        self.order_by = order_by
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_source is not None:
            result['AppSource'] = self.app_source
        if self.co_type is not None:
            result['CoType'] = self.co_type
        if self.cpu_strategy is not None:
            result['CpuStrategy'] = self.cpu_strategy
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppSource') is not None:
            self.app_source = m.get('AppSource')
        if m.get('CoType') is not None:
            self.co_type = m.get('CoType')
        if m.get('CpuStrategy') is not None:
            self.cpu_strategy = m.get('CpuStrategy')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetChangeOrderMetricResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        avg_time_cost_ms: float = None,
        error: int = None,
        error_percent: float = None,
        max_time_cost_ms: float = None,
        name: str = None,
        optimize_suggestions: str = None,
        region_id: str = None,
        task_time_cost_ms_avg: str = None,
        total: int = None,
    ):
        # The application ID.
        self.app_id = app_id
        self.avg_time_cost_ms = avg_time_cost_ms
        # The number of abnormal change orders.
        self.error = error
        # The percentage of change failures.
        self.error_percent = error_percent
        self.max_time_cost_ms = max_time_cost_ms
        # The application name.
        self.name = name
        self.optimize_suggestions = optimize_suggestions
        # The namespace ID.
        self.region_id = region_id
        self.task_time_cost_ms_avg = task_time_cost_ms_avg
        # The total number of change orders.
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.avg_time_cost_ms is not None:
            result['AvgTimeCostMs'] = self.avg_time_cost_ms
        if self.error is not None:
            result['Error'] = self.error
        if self.error_percent is not None:
            result['ErrorPercent'] = self.error_percent
        if self.max_time_cost_ms is not None:
            result['MaxTimeCostMs'] = self.max_time_cost_ms
        if self.name is not None:
            result['Name'] = self.name
        if self.optimize_suggestions is not None:
            result['OptimizeSuggestions'] = self.optimize_suggestions
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_time_cost_ms_avg is not None:
            result['TaskTimeCostMsAvg'] = self.task_time_cost_ms_avg
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AvgTimeCostMs') is not None:
            self.avg_time_cost_ms = m.get('AvgTimeCostMs')
        if m.get('Error') is not None:
            self.error = m.get('Error')
        if m.get('ErrorPercent') is not None:
            self.error_percent = m.get('ErrorPercent')
        if m.get('MaxTimeCostMs') is not None:
            self.max_time_cost_ms = m.get('MaxTimeCostMs')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OptimizeSuggestions') is not None:
            self.optimize_suggestions = m.get('OptimizeSuggestions')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskTimeCostMsAvg') is not None:
            self.task_time_cost_ms_avg = m.get('TaskTimeCostMsAvg')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class GetChangeOrderMetricResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[GetChangeOrderMetricResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The following limits are imposed on the ID:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The details of applications.
        self.data = data
        # The additional information that is returned. The following limits are imposed on the ID:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the microservice list was obtained. The following limits are imposed on the ID:
        # 
        # *   **true**: The namespaces were obtained.
        # *   **false**: no
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GetChangeOrderMetricResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetChangeOrderMetricResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetChangeOrderMetricResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetChangeOrderMetricResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetScaleAppMetricRequest(TeaModel):
    def __init__(
        self,
        app_source: str = None,
        cpu_strategy: str = None,
        limit: int = None,
        region_id: str = None,
    ):
        # The SAE application type. Valid values:
        # 
        # *   **micro_service**\
        # *   **web**\
        # *   **job**\
        self.app_source = app_source
        # The CPU allocation policy. Valid values:
        # 
        # *   **request**: CPU cores are allocated only when a request is initiated.
        # *   **always**: Fixed CPU cores are always allocated.
        self.cpu_strategy = cpu_strategy
        # The number of entries to return. Valid values: 0 to 100.
        # 
        # This parameter is required.
        self.limit = limit
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_source is not None:
            result['AppSource'] = self.app_source
        if self.cpu_strategy is not None:
            result['CpuStrategy'] = self.cpu_strategy
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppSource') is not None:
            self.app_source = m.get('AppSource')
        if m.get('CpuStrategy') is not None:
            self.cpu_strategy = m.get('CpuStrategy')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetScaleAppMetricResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        max_replicas: int = None,
        name: str = None,
        region_id: str = None,
        runnings: int = None,
    ):
        # The application ID.
        self.app_id = app_id
        # The maximum number of instances.
        self.max_replicas = max_replicas
        # The application name.
        self.name = name
        # The namespace ID.
        self.region_id = region_id
        # The current number of instances.
        self.runnings = runnings

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.runnings is not None:
            result['Runnings'] = self.runnings
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Runnings') is not None:
            self.runnings = m.get('Runnings')
        return self


class GetScaleAppMetricResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[GetScaleAppMetricResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The following limits are imposed on the ID:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The details of applications.
        self.data = data
        # The additional information that is returned. The following limits are imposed on the ID:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the microservice list was obtained. The following limits are imposed on the ID:
        # 
        # *   **true**: The namespaces were obtained.
        # *   **false**: no
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GetScaleAppMetricResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetScaleAppMetricResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetScaleAppMetricResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetScaleAppMetricResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetWarningEventMetricRequest(TeaModel):
    def __init__(
        self,
        app_source: str = None,
        cpu_strategy: str = None,
        end_time: int = None,
        limit: int = None,
        region_id: str = None,
        start_time: int = None,
    ):
        # The SAE application type. Valid values:
        # 
        # *   **micro_service**\
        # *   **web**\
        # *   **job**\
        self.app_source = app_source
        # The CPU allocation policy. Valid values:
        # 
        # *   **request**: CPU cores are allocated only when a request is initiated.
        # *   **always**: Fixed CPU cores are always allocated.
        self.cpu_strategy = cpu_strategy
        # The end of the time range to query.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The number of entries to return. Valid values: 0 to 100.
        # 
        # This parameter is required.
        self.limit = limit
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The beginning of the time range to query.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_source is not None:
            result['AppSource'] = self.app_source
        if self.cpu_strategy is not None:
            result['CpuStrategy'] = self.cpu_strategy
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppSource') is not None:
            self.app_source = m.get('AppSource')
        if m.get('CpuStrategy') is not None:
            self.cpu_strategy = m.get('CpuStrategy')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetWarningEventMetricResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        name: str = None,
        region_id: str = None,
        warning_count: int = None,
    ):
        # The details of the application.
        self.app_id = app_id
        # The application ID.
        self.name = name
        # The application name.
        self.region_id = region_id
        # The namespace ID.
        self.warning_count = warning_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.warning_count is not None:
            result['WarningCount'] = self.warning_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('WarningCount') is not None:
            self.warning_count = m.get('WarningCount')
        return self


class GetWarningEventMetricResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[GetWarningEventMetricResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The number of Warning events.
        self.code = code
        # 3B763F98-0BA2-5C23-B6B8-558568D2C1C2
        self.data = data
        # The additional information that is returned. The following limits are imposed on the ID:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # The HTTP status code. The following limits are imposed on the ID:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GetWarningEventMetricResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetWarningEventMetricResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetWarningEventMetricResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetWarningEventMetricResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetWebshellTokenRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        container_name: str = None,
        pod_name: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # The name of the container.
        # 
        # Note:
        # 
        # *   If this parameter is specified, Cloud Assistant runs the command in the specified container of the instance.
        # 
        # *   If this parameter is specified, the command can run only on Linux instances on which Cloud Assistant Agent 2.2.3.344 or later is installed.
        # 
        #     *   For information about how to query the version of Cloud Assistant Agent, see [Install Cloud Assistant Agent](https://help.aliyun.com/document_detail/64921.html).
        #     *   For information about how to upgrade Cloud Assistant Agent, see [Upgrade or disable upgrades for Cloud Assistant Agent](https://help.aliyun.com/document_detail/134383.html).
        # 
        # *   If this parameter is specified, the `Username` parameter that is specified in a request to call this operation and the `WorkingDir` parameter that is specified in a request to call the [CreateCommand](https://help.aliyun.com/document_detail/64844.html) operation do not take effect. You can run the command only in the default working directory of the container by using the default user of the container. For more information, see [Use Cloud Assistant to run commands in containers](https://help.aliyun.com/document_detail/456641.html).
        # 
        # *   If this parameter is specified, only shell scripts can be run in Linux containers. You cannot add a command in the format similar to `#!/usr/bin/python` at the beginning of a script to specify a script interpreter. For more information, see [Use Cloud Assistant to run commands in containers](https://help.aliyun.com/document_detail/456641.html).
        self.container_name = container_name
        # This parameter is required.
        self.pod_name = pod_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.container_name is not None:
            result['ContainerName'] = self.container_name
        if self.pod_name is not None:
            result['PodName'] = self.pod_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ContainerName') is not None:
            self.container_name = m.get('ContainerName')
        if m.get('PodName') is not None:
            self.pod_name = m.get('PodName')
        return self


class GetWebshellTokenResponseBodyData(TeaModel):
    def __init__(
        self,
        http_url: str = None,
        token: str = None,
        web_socket_url: str = None,
    ):
        self.http_url = http_url
        self.token = token
        self.web_socket_url = web_socket_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.http_url is not None:
            result['HttpUrl'] = self.http_url
        if self.token is not None:
            result['Token'] = self.token
        if self.web_socket_url is not None:
            result['WebSocketUrl'] = self.web_socket_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HttpUrl') is not None:
            self.http_url = m.get('HttpUrl')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        if m.get('WebSocketUrl') is not None:
            self.web_socket_url = m.get('WebSocketUrl')
        return self


class GetWebshellTokenResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetWebshellTokenResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetWebshellTokenResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class GetWebshellTokenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetWebshellTokenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetWebshellTokenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAllSwimmingLaneGroupsRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
    ):
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class ListAllSwimmingLaneGroupsResponseBodyDataApps(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        mse_app_id: str = None,
        mse_app_name: str = None,
        mse_namespace_id: str = None,
    ):
        self.app_id = app_id
        self.app_name = app_name
        self.mse_app_id = mse_app_id
        self.mse_app_name = mse_app_name
        self.mse_namespace_id = mse_namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.mse_app_id is not None:
            result['MseAppId'] = self.mse_app_id
        if self.mse_app_name is not None:
            result['MseAppName'] = self.mse_app_name
        if self.mse_namespace_id is not None:
            result['MseNamespaceId'] = self.mse_namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('MseAppId') is not None:
            self.mse_app_id = m.get('MseAppId')
        if m.get('MseAppName') is not None:
            self.mse_app_name = m.get('MseAppName')
        if m.get('MseNamespaceId') is not None:
            self.mse_namespace_id = m.get('MseNamespaceId')
        return self


class ListAllSwimmingLaneGroupsResponseBodyDataEntryApp(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        app_type: str = None,
        mse_app_id: str = None,
        mse_app_name: str = None,
        mse_namespace_id: str = None,
    ):
        self.app_id = app_id
        self.app_name = app_name
        self.app_type = app_type
        self.mse_app_id = mse_app_id
        self.mse_app_name = mse_app_name
        self.mse_namespace_id = mse_namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.mse_app_id is not None:
            result['MseAppId'] = self.mse_app_id
        if self.mse_app_name is not None:
            result['MseAppName'] = self.mse_app_name
        if self.mse_namespace_id is not None:
            result['MseNamespaceId'] = self.mse_namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('MseAppId') is not None:
            self.mse_app_id = m.get('MseAppId')
        if m.get('MseAppName') is not None:
            self.mse_app_name = m.get('MseAppName')
        if m.get('MseNamespaceId') is not None:
            self.mse_namespace_id = m.get('MseNamespaceId')
        return self


class ListAllSwimmingLaneGroupsResponseBodyData(TeaModel):
    def __init__(
        self,
        app_ids: List[str] = None,
        apps: List[ListAllSwimmingLaneGroupsResponseBodyDataApps] = None,
        canary_model: int = None,
        entry_app: ListAllSwimmingLaneGroupsResponseBodyDataEntryApp = None,
        entry_app_id: str = None,
        entry_app_type: str = None,
        group_id: int = None,
        group_name: str = None,
        mse_namespace_id: str = None,
        namespace_id: str = None,
        swim_version: str = None,
    ):
        self.app_ids = app_ids
        self.apps = apps
        self.canary_model = canary_model
        self.entry_app = entry_app
        self.entry_app_id = entry_app_id
        self.entry_app_type = entry_app_type
        self.group_id = group_id
        self.group_name = group_name
        self.mse_namespace_id = mse_namespace_id
        self.namespace_id = namespace_id
        self.swim_version = swim_version

    def validate(self):
        if self.apps:
            for k in self.apps:
                if k:
                    k.validate()
        if self.entry_app:
            self.entry_app.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_ids is not None:
            result['AppIds'] = self.app_ids
        result['Apps'] = []
        if self.apps is not None:
            for k in self.apps:
                result['Apps'].append(k.to_map() if k else None)
        if self.canary_model is not None:
            result['CanaryModel'] = self.canary_model
        if self.entry_app is not None:
            result['EntryApp'] = self.entry_app.to_map()
        if self.entry_app_id is not None:
            result['EntryAppId'] = self.entry_app_id
        if self.entry_app_type is not None:
            result['EntryAppType'] = self.entry_app_type
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.mse_namespace_id is not None:
            result['MseNamespaceId'] = self.mse_namespace_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.swim_version is not None:
            result['SwimVersion'] = self.swim_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppIds') is not None:
            self.app_ids = m.get('AppIds')
        self.apps = []
        if m.get('Apps') is not None:
            for k in m.get('Apps'):
                temp_model = ListAllSwimmingLaneGroupsResponseBodyDataApps()
                self.apps.append(temp_model.from_map(k))
        if m.get('CanaryModel') is not None:
            self.canary_model = m.get('CanaryModel')
        if m.get('EntryApp') is not None:
            temp_model = ListAllSwimmingLaneGroupsResponseBodyDataEntryApp()
            self.entry_app = temp_model.from_map(m['EntryApp'])
        if m.get('EntryAppId') is not None:
            self.entry_app_id = m.get('EntryAppId')
        if m.get('EntryAppType') is not None:
            self.entry_app_type = m.get('EntryAppType')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('MseNamespaceId') is not None:
            self.mse_namespace_id = m.get('MseNamespaceId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('SwimVersion') is not None:
            self.swim_version = m.get('SwimVersion')
        return self


class ListAllSwimmingLaneGroupsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListAllSwimmingLaneGroupsResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListAllSwimmingLaneGroupsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListAllSwimmingLaneGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAllSwimmingLaneGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAllSwimmingLaneGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAllSwimmingLanesRequest(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        namespace_id: str = None,
    ):
        self.group_id = group_id
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class ListAllSwimmingLanesResponseBodyDataAppEntryRuleConditions(TeaModel):
    def __init__(
        self,
        condition: str = None,
        name: str = None,
        type: str = None,
        value: str = None,
        values: List[str] = None,
    ):
        self.condition = condition
        self.name = name
        self.type = type
        self.value = value
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class ListAllSwimmingLanesResponseBodyDataAppEntryRule(TeaModel):
    def __init__(
        self,
        condition_joiner: str = None,
        conditions: List[ListAllSwimmingLanesResponseBodyDataAppEntryRuleConditions] = None,
        independent_percentage_enable: bool = None,
        paths: List[str] = None,
        percentage: int = None,
        percentage_by_path: Dict[str, int] = None,
    ):
        self.condition_joiner = condition_joiner
        self.conditions = conditions
        self.independent_percentage_enable = independent_percentage_enable
        self.paths = paths
        self.percentage = percentage
        self.percentage_by_path = percentage_by_path

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition_joiner is not None:
            result['ConditionJoiner'] = self.condition_joiner
        result['Conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['Conditions'].append(k.to_map() if k else None)
        if self.independent_percentage_enable is not None:
            result['IndependentPercentageEnable'] = self.independent_percentage_enable
        if self.paths is not None:
            result['Paths'] = self.paths
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        if self.percentage_by_path is not None:
            result['PercentageByPath'] = self.percentage_by_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConditionJoiner') is not None:
            self.condition_joiner = m.get('ConditionJoiner')
        self.conditions = []
        if m.get('Conditions') is not None:
            for k in m.get('Conditions'):
                temp_model = ListAllSwimmingLanesResponseBodyDataAppEntryRuleConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('IndependentPercentageEnable') is not None:
            self.independent_percentage_enable = m.get('IndependentPercentageEnable')
        if m.get('Paths') is not None:
            self.paths = m.get('Paths')
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        if m.get('PercentageByPath') is not None:
            self.percentage_by_path = m.get('PercentageByPath')
        return self


class ListAllSwimmingLanesResponseBodyDataApps(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        mse_app_id: str = None,
        mse_app_name: str = None,
        mse_namespace_id: str = None,
    ):
        self.app_id = app_id
        self.app_name = app_name
        self.mse_app_id = mse_app_id
        self.mse_app_name = mse_app_name
        self.mse_namespace_id = mse_namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.mse_app_id is not None:
            result['MseAppId'] = self.mse_app_id
        if self.mse_app_name is not None:
            result['MseAppName'] = self.mse_app_name
        if self.mse_namespace_id is not None:
            result['MseNamespaceId'] = self.mse_namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('MseAppId') is not None:
            self.mse_app_id = m.get('MseAppId')
        if m.get('MseAppName') is not None:
            self.mse_app_name = m.get('MseAppName')
        if m.get('MseNamespaceId') is not None:
            self.mse_namespace_id = m.get('MseNamespaceId')
        return self


class ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleConditions(TeaModel):
    def __init__(
        self,
        condition: str = None,
        name: str = None,
        type: str = None,
        value: str = None,
    ):
        self.condition = condition
        self.name = name
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicatePathPredicate(TeaModel):
    def __init__(
        self,
        path: str = None,
        type: str = None,
    ):
        self.path = path
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.path is not None:
            result['path'] = self.path
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicate(TeaModel):
    def __init__(
        self,
        path_predicate: ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicatePathPredicate = None,
    ):
        self.path_predicate = path_predicate

    def validate(self):
        if self.path_predicate:
            self.path_predicate.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.path_predicate is not None:
            result['PathPredicate'] = self.path_predicate.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PathPredicate') is not None:
            temp_model = ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicatePathPredicate()
            self.path_predicate = temp_model.from_map(m['PathPredicate'])
        return self


class ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutes(TeaModel):
    def __init__(
        self,
        route_id: int = None,
        route_name: str = None,
        route_predicate: ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicate = None,
    ):
        self.route_id = route_id
        self.route_name = route_name
        self.route_predicate = route_predicate

    def validate(self):
        if self.route_predicate:
            self.route_predicate.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.route_id is not None:
            result['RouteId'] = self.route_id
        if self.route_name is not None:
            result['RouteName'] = self.route_name
        if self.route_predicate is not None:
            result['RoutePredicate'] = self.route_predicate.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RouteId') is not None:
            self.route_id = m.get('RouteId')
        if m.get('RouteName') is not None:
            self.route_name = m.get('RouteName')
        if m.get('RoutePredicate') is not None:
            temp_model = ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicate()
            self.route_predicate = temp_model.from_map(m['RoutePredicate'])
        return self


class ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRule(TeaModel):
    def __init__(
        self,
        condition_joiner: str = None,
        conditions: List[ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleConditions] = None,
        independent_percentage_enable: bool = None,
        percentage: int = None,
        percentage_by_route: Dict[str, int] = None,
        route_ids: List[int] = None,
        routes: List[ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutes] = None,
    ):
        self.condition_joiner = condition_joiner
        self.conditions = conditions
        self.independent_percentage_enable = independent_percentage_enable
        self.percentage = percentage
        self.percentage_by_route = percentage_by_route
        self.route_ids = route_ids
        self.routes = routes

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()
        if self.routes:
            for k in self.routes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition_joiner is not None:
            result['ConditionJoiner'] = self.condition_joiner
        result['Conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['Conditions'].append(k.to_map() if k else None)
        if self.independent_percentage_enable is not None:
            result['IndependentPercentageEnable'] = self.independent_percentage_enable
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        if self.percentage_by_route is not None:
            result['PercentageByRoute'] = self.percentage_by_route
        if self.route_ids is not None:
            result['RouteIds'] = self.route_ids
        result['Routes'] = []
        if self.routes is not None:
            for k in self.routes:
                result['Routes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConditionJoiner') is not None:
            self.condition_joiner = m.get('ConditionJoiner')
        self.conditions = []
        if m.get('Conditions') is not None:
            for k in m.get('Conditions'):
                temp_model = ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('IndependentPercentageEnable') is not None:
            self.independent_percentage_enable = m.get('IndependentPercentageEnable')
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        if m.get('PercentageByRoute') is not None:
            self.percentage_by_route = m.get('PercentageByRoute')
        if m.get('RouteIds') is not None:
            self.route_ids = m.get('RouteIds')
        self.routes = []
        if m.get('Routes') is not None:
            for k in m.get('Routes'):
                temp_model = ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutes()
                self.routes.append(temp_model.from_map(k))
        return self


class ListAllSwimmingLanesResponseBodyData(TeaModel):
    def __init__(
        self,
        app_entry_rule: ListAllSwimmingLanesResponseBodyDataAppEntryRule = None,
        apps: List[ListAllSwimmingLanesResponseBodyDataApps] = None,
        canary_model: int = None,
        enable: bool = None,
        enable_rules: bool = None,
        lane_id: int = None,
        lane_name: str = None,
        lane_tag: str = None,
        mse_gateway_entry_rule: ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRule = None,
    ):
        self.app_entry_rule = app_entry_rule
        self.apps = apps
        self.canary_model = canary_model
        self.enable = enable
        self.enable_rules = enable_rules
        self.lane_id = lane_id
        self.lane_name = lane_name
        self.lane_tag = lane_tag
        self.mse_gateway_entry_rule = mse_gateway_entry_rule

    def validate(self):
        if self.app_entry_rule:
            self.app_entry_rule.validate()
        if self.apps:
            for k in self.apps:
                if k:
                    k.validate()
        if self.mse_gateway_entry_rule:
            self.mse_gateway_entry_rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_entry_rule is not None:
            result['AppEntryRule'] = self.app_entry_rule.to_map()
        result['Apps'] = []
        if self.apps is not None:
            for k in self.apps:
                result['Apps'].append(k.to_map() if k else None)
        if self.canary_model is not None:
            result['CanaryModel'] = self.canary_model
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.enable_rules is not None:
            result['EnableRules'] = self.enable_rules
        if self.lane_id is not None:
            result['LaneId'] = self.lane_id
        if self.lane_name is not None:
            result['LaneName'] = self.lane_name
        if self.lane_tag is not None:
            result['LaneTag'] = self.lane_tag
        if self.mse_gateway_entry_rule is not None:
            result['MseGatewayEntryRule'] = self.mse_gateway_entry_rule.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppEntryRule') is not None:
            temp_model = ListAllSwimmingLanesResponseBodyDataAppEntryRule()
            self.app_entry_rule = temp_model.from_map(m['AppEntryRule'])
        self.apps = []
        if m.get('Apps') is not None:
            for k in m.get('Apps'):
                temp_model = ListAllSwimmingLanesResponseBodyDataApps()
                self.apps.append(temp_model.from_map(k))
        if m.get('CanaryModel') is not None:
            self.canary_model = m.get('CanaryModel')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('EnableRules') is not None:
            self.enable_rules = m.get('EnableRules')
        if m.get('LaneId') is not None:
            self.lane_id = m.get('LaneId')
        if m.get('LaneName') is not None:
            self.lane_name = m.get('LaneName')
        if m.get('LaneTag') is not None:
            self.lane_tag = m.get('LaneTag')
        if m.get('MseGatewayEntryRule') is not None:
            temp_model = ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRule()
            self.mse_gateway_entry_rule = temp_model.from_map(m['MseGatewayEntryRule'])
        return self


class ListAllSwimmingLanesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListAllSwimmingLanesResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListAllSwimmingLanesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListAllSwimmingLanesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAllSwimmingLanesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAllSwimmingLanesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAppEventsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        current_page: int = None,
        event_type: str = None,
        namespace: str = None,
        object_kind: str = None,
        object_name: str = None,
        page_size: int = None,
        reason: str = None,
    ):
        # The application ID.
        self.app_id = app_id
        # The page number of the page to return.
        self.current_page = current_page
        # The type of the event. Valid values:
        # 
        # *   **Warning**: an alert.
        # *   **Normal**: a normal event.
        self.event_type = event_type
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace = namespace
        # The type of the object. Valid values:
        # 
        # *   **Deployment**: an application.
        # *   **Pod**: an application instance.
        # *   **Service**: a Server Load Balancer (SLB) instance.
        # *   **HorizontalPodAutoscaler**: an auto scaling policy.
        # *   **CloneSet**: an application.
        self.object_kind = object_kind
        # The name of the object. Fuzzy search by prefix is supported.
        self.object_name = object_name
        # The number of entries to return on each page. Valid values: 0 to 10000.
        self.page_size = page_size
        # The cause of the event. Fuzzy search by prefix is supported.
        self.reason = reason

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.object_kind is not None:
            result['ObjectKind'] = self.object_kind
        if self.object_name is not None:
            result['ObjectName'] = self.object_name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.reason is not None:
            result['Reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('ObjectKind') is not None:
            self.object_kind = m.get('ObjectKind')
        if m.get('ObjectName') is not None:
            self.object_name = m.get('ObjectName')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        return self


class ListAppEventsResponseBodyDataAppEventEntity(TeaModel):
    def __init__(
        self,
        cause_analysis: str = None,
        event_type: str = None,
        first_timestamp: str = None,
        last_timestamp: str = None,
        message: str = None,
        object_kind: str = None,
        object_name: str = None,
        reason: str = None,
    ):
        self.cause_analysis = cause_analysis
        # The type of the event. Valid values:
        self.event_type = event_type
        # The timestamp of the first occurrence of the event.
        self.first_timestamp = first_timestamp
        # The timestamp of the last occurrence of the event.
        self.last_timestamp = last_timestamp
        # The information about the event.
        self.message = message
        # The type of the object.
        self.object_kind = object_kind
        # The name of the object.
        self.object_name = object_name
        # The cause of the event.
        self.reason = reason

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cause_analysis is not None:
            result['CauseAnalysis'] = self.cause_analysis
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.first_timestamp is not None:
            result['FirstTimestamp'] = self.first_timestamp
        if self.last_timestamp is not None:
            result['LastTimestamp'] = self.last_timestamp
        if self.message is not None:
            result['Message'] = self.message
        if self.object_kind is not None:
            result['ObjectKind'] = self.object_kind
        if self.object_name is not None:
            result['ObjectName'] = self.object_name
        if self.reason is not None:
            result['Reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CauseAnalysis') is not None:
            self.cause_analysis = m.get('CauseAnalysis')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('FirstTimestamp') is not None:
            self.first_timestamp = m.get('FirstTimestamp')
        if m.get('LastTimestamp') is not None:
            self.last_timestamp = m.get('LastTimestamp')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ObjectKind') is not None:
            self.object_kind = m.get('ObjectKind')
        if m.get('ObjectName') is not None:
            self.object_name = m.get('ObjectName')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        return self


class ListAppEventsResponseBodyData(TeaModel):
    def __init__(
        self,
        app_event_entity: List[ListAppEventsResponseBodyDataAppEventEntity] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # The events.
        self.app_event_entity = app_event_entity
        # The number of the returned page.
        self.current_page = current_page
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of events that occurred in an application.
        self.total_size = total_size

    def validate(self):
        if self.app_event_entity:
            for k in self.app_event_entity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AppEventEntity'] = []
        if self.app_event_entity is not None:
            for k in self.app_event_entity:
                result['AppEventEntity'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.app_event_entity = []
        if m.get('AppEventEntity') is not None:
            for k in m.get('AppEventEntity'):
                temp_model = ListAppEventsResponseBodyDataAppEventEntity()
                self.app_event_entity.append(temp_model.from_map(k))
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListAppEventsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListAppEventsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The events.
        self.data = data
        # The error code returned if the call failed. Take note of the following rules:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the events that occurred in the application were queried. Valid values:
        # 
        # *   **true**: The events were queried.
        # *   **false**: The events failed to be queried.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListAppEventsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListAppEventsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAppEventsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAppEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAppServicesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        nacos_instance_id: str = None,
        nacos_namespace_id: str = None,
        namespace_id: str = None,
        page_number: int = None,
        page_size: int = None,
        registry_type: str = None,
        service_type: str = None,
        vpc_id: str = None,
    ):
        # The ID of the application. You must specify only one of the following parameters: vpcId, namespace ID, and application ID.
        self.app_id = app_id
        # The ID of the MSE Nacos instance. This parameter is required when the registry type is set to MSE Nacos.
        self.nacos_instance_id = nacos_instance_id
        # The ID of the MSE Nacos namespace. This parameter is required when the registry type is set to MSE Nacos.
        self.nacos_namespace_id = nacos_namespace_id
        # The ID of the namespace. You must specify only one of the following parameters: VPC ID, namespace ID, and application ID.
        self.namespace_id = namespace_id
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The registry type. Valid values:
        # 
        # *   **0**: SAE Nacos
        # *   **1**: SAE built-in Nacos
        # *   **2** :MSE Nacos
        # *   **9**: SAE Kubernetes service
        self.registry_type = registry_type
        # The service type. Valid values:
        # 
        # *   **dubbo**\
        # *   **springCloud**\
        # *   **hsf**\
        # *   **k8sService**\
        self.service_type = service_type
        # The unique identifier of the VPC. You must specify only one of the following parameters: VPC ID, namespace ID, and application ID.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.nacos_instance_id is not None:
            result['NacosInstanceId'] = self.nacos_instance_id
        if self.nacos_namespace_id is not None:
            result['NacosNamespaceId'] = self.nacos_namespace_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.service_type is not None:
            result['ServiceType'] = self.service_type
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('NacosInstanceId') is not None:
            self.nacos_instance_id = m.get('NacosInstanceId')
        if m.get('NacosNamespaceId') is not None:
            self.nacos_namespace_id = m.get('NacosNamespaceId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('ServiceType') is not None:
            self.service_type = m.get('ServiceType')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class ListAppServicesResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        instance_count: str = None,
        namespace_id: str = None,
        namespace_name: str = None,
        registry_type: str = None,
        security_group_id: str = None,
        service_group: str = None,
        service_name: str = None,
        service_port_and_protocol: Dict[str, str] = None,
        service_ports: List[int] = None,
        service_protocol: str = None,
        service_type: str = None,
        service_version: str = None,
    ):
        # The application ID.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name
        # The number of instances of the microservice.
        self.instance_count = instance_count
        # The ID of the namespace to which the application belongs.
        self.namespace_id = namespace_id
        # The name of the namespace.
        self.namespace_name = namespace_name
        # The registry type. Valid values:
        # 
        # *   **0**：SAE Nacos
        # *   **1**: SAE built-in Nacos
        # *   **2**: MSE Nacos
        # *   **9**: SAE Kubernets service
        self.registry_type = registry_type
        # The IDs of the security groups.
        self.security_group_id = security_group_id
        # The group to which the microservice belongs.
        self.service_group = service_group
        # The name of the microservice.
        self.service_name = service_name
        # The ports and protocols.
        self.service_port_and_protocol = service_port_and_protocol
        # The list of ports.
        self.service_ports = service_ports
        # The protocol used by the microservice.
        self.service_protocol = service_protocol
        # The type of the microservice. Valid values:
        # 
        # *   **dubbo**\
        # *   **springCloud**\
        # *   **hsf**\
        # *   **k8sService**\
        self.service_type = service_type
        # The version of the microservice.
        self.service_version = service_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.namespace_name is not None:
            result['NamespaceName'] = self.namespace_name
        if self.registry_type is not None:
            result['RegistryType'] = self.registry_type
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.service_group is not None:
            result['ServiceGroup'] = self.service_group
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        if self.service_port_and_protocol is not None:
            result['ServicePortAndProtocol'] = self.service_port_and_protocol
        if self.service_ports is not None:
            result['ServicePorts'] = self.service_ports
        if self.service_protocol is not None:
            result['ServiceProtocol'] = self.service_protocol
        if self.service_type is not None:
            result['ServiceType'] = self.service_type
        if self.service_version is not None:
            result['ServiceVersion'] = self.service_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NamespaceName') is not None:
            self.namespace_name = m.get('NamespaceName')
        if m.get('RegistryType') is not None:
            self.registry_type = m.get('RegistryType')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('ServiceGroup') is not None:
            self.service_group = m.get('ServiceGroup')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        if m.get('ServicePortAndProtocol') is not None:
            self.service_port_and_protocol = m.get('ServicePortAndProtocol')
        if m.get('ServicePorts') is not None:
            self.service_ports = m.get('ServicePorts')
        if m.get('ServiceProtocol') is not None:
            self.service_protocol = m.get('ServiceProtocol')
        if m.get('ServiceType') is not None:
            self.service_type = m.get('ServiceType')
        if m.get('ServiceVersion') is not None:
            self.service_version = m.get('ServiceVersion')
        return self


class ListAppServicesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListAppServicesResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code that is returned. Valid values:
        # 
        # *   **2xx**: The request was successful.
        # *   **3xx**: The request was redirected.
        # *   **4xx**: The request failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The details of the microservice.
        self.data = data
        # The status code. Valid values:
        # 
        # *   If the request was successful, the **ErrorCode** parameter is not returned.
        # *   If the request failed, **ErrorCode** is returned. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The message returned. Valid values:
        # 
        # *   If the request was successful, **success** is returned.
        # *   If the request failed, an error message is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListAppServicesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListAppServicesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAppServicesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAppServicesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAppServicesPageRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        page_number: int = None,
        page_size: int = None,
        service_type: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned on each page. Valid values: 0 to 9999.
        self.page_size = page_size
        # The service type. Valid values:
        # 
        # *   **dubbo**\
        # *   **springCloud**\
        # 
        # This parameter is required.
        self.service_type = service_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.service_type is not None:
            result['ServiceType'] = self.service_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ServiceType') is not None:
            self.service_type = m.get('ServiceType')
        return self


class ListAppServicesPageResponseBodyDataResult(TeaModel):
    def __init__(
        self,
        edas_app_id: str = None,
        edas_app_name: str = None,
        group: str = None,
        instance_num: int = None,
        service_name: str = None,
        version: str = None,
    ):
        # The ID of the application.
        self.edas_app_id = edas_app_id
        # The name of the application.
        self.edas_app_name = edas_app_name
        # The group to which the service belongs. You can create a custom group.
        self.group = group
        # The number of instances.
        self.instance_num = instance_num
        # The service name.
        self.service_name = service_name
        # The version of a service. You can create a custom version.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.edas_app_id is not None:
            result['EdasAppId'] = self.edas_app_id
        if self.edas_app_name is not None:
            result['EdasAppName'] = self.edas_app_name
        if self.group is not None:
            result['Group'] = self.group
        if self.instance_num is not None:
            result['InstanceNum'] = self.instance_num
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EdasAppId') is not None:
            self.edas_app_id = m.get('EdasAppId')
        if m.get('EdasAppName') is not None:
            self.edas_app_name = m.get('EdasAppName')
        if m.get('Group') is not None:
            self.group = m.get('Group')
        if m.get('InstanceNum') is not None:
            self.instance_num = m.get('InstanceNum')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListAppServicesPageResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: str = None,
        page_number: str = None,
        page_size: str = None,
        result: List[ListAppServicesPageResponseBodyDataResult] = None,
        total_size: str = None,
    ):
        # The page number of the current page.
        self.current_page = current_page
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned on each page. Valid values: 0 to 9999.
        self.page_size = page_size
        # The result returned.
        self.result = result
        # The total number of returned pages.
        self.total_size = total_size

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Result'] = []
        if self.result is not None:
            for k in self.result:
                result['Result'].append(k.to_map() if k else None)
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.result = []
        if m.get('Result') is not None:
            for k in m.get('Result'):
                temp_model = ListAppServicesPageResponseBodyDataResult()
                self.result.append(temp_model.from_map(k))
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListAppServicesPageResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListAppServicesPageResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The request was successful.
        # *   **3xx**: The request was redirected.
        # *   **4xx**: The request failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The details of services.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the request was successful, **ErrorCode** is not returned.
        # *   If the request failed, **ErrorCode** is returned. For more information, see **Error codes** section of this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the microservice list was obtained. Valid values:
        # 
        # *   **true**: The list was obtained.
        # *   **false**: The list failed to be obtained.
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListAppServicesPageResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListAppServicesPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAppServicesPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAppServicesPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAppVersionsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The returned message.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class ListAppVersionsResponseBodyData(TeaModel):
    def __init__(
        self,
        build_package_url: str = None,
        create_time: str = None,
        id: str = None,
        type: str = None,
        war_url: str = None,
    ):
        # The URL of the code package. If you use the SAE console to upload the code package, take note of the following items:
        # 
        # *   You cannot download the URL. You must call the GetPackageVersionAccessableUrl operation to obtain the URL. The obtained URL is valid for 10 minutes.
        # *   SAE can retain the package up to 90 days. After 90 days, the URL cannot be returned or downloaded.
        self.build_package_url = build_package_url
        # The download link of the WAR or JAR package. This parameter is returned when the **Type** parameter is set to **url**.
        self.create_time = create_time
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.id = id
        # The deployment method of the application. Valid values:
        # 
        # *   **image**: indicates that the application is deployed by using an image.
        # *   **url**: indicates that the application is deployed by using a code package.
        self.type = type
        # The URL of the image.
        self.war_url = war_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.build_package_url is not None:
            result['BuildPackageUrl'] = self.build_package_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.id is not None:
            result['Id'] = self.id
        if self.type is not None:
            result['Type'] = self.type
        if self.war_url is not None:
            result['WarUrl'] = self.war_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BuildPackageUrl') is not None:
            self.build_package_url = m.get('BuildPackageUrl')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WarUrl') is not None:
            self.war_url = m.get('WarUrl')
        return self


class ListAppVersionsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListAppVersionsResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # Indicates whether the historical versions of the application were obtained. Valid values:
        # 
        # *   **true**: indicates that the historical versions of the application were obtained.
        # *   **false**: indicates that the historical versions of the application could not be obtained.
        self.code = code
        # The information about the versions.
        self.data = data
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.error_code = error_code
        # The ID of the request.
        self.message = message
        # The information about the versions.
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListAppVersionsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListAppVersionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAppVersionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAppVersionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListApplicationsRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        app_source: str = None,
        current_page: int = None,
        field_type: str = None,
        field_value: str = None,
        is_stateful: str = None,
        namespace_id: str = None,
        order_by: str = None,
        page_size: int = None,
        reverse: bool = None,
        tags: str = None,
    ):
        # The application name.
        self.app_name = app_name
        # The SAE application type. Valid values:
        # 
        # - **micro_service**\
        # - **web**\
        # - **job**\
        self.app_source = app_source
        # The current page number.
        self.current_page = current_page
        # Set the filtering criteria for applications. The value options are as follows:
        # 
        # - appName: Application name.
        # - appIds: Application IDs.
        # - slbIps: SLB IP addresses.
        # - instanceIps: Instance IP addresses.
        self.field_type = field_type
        # The name, ID, SLB IP, or instance IP of the target application.
        self.field_value = field_value
        self.is_stateful = is_stateful
        # The namespace ID.
        self.namespace_id = namespace_id
        # Specifies how applications are sorted. Valid values:
        # 
        # *   **running**: The applications are sorted based on the number of running instances.
        # *   **instances**: The applications are sorted based on the number of destination instances.
        self.order_by = order_by
        # The number of records in each page. Value range: [0,10000]
        self.page_size = page_size
        # Sort by the running status of application instances. If the statuses are the same, sort by instance ID. The value options are as follows:
        # 
        # - true: Sort in ascending order. Instances are arranged according to the startup process, for example: to ultimately reach the running state, an instance must first go through steps such as starting containers, pulling images, and initializing the instance.
        # - false: Sort in descending order.
        self.reverse = reverse
        # The tag in the format of a key-value pair.
        # *   **key**: the tag key. It cannot exceed 128 characters in length.
        # *   **value**: the tag value. It cannot exceed 128 characters in length.
        # 
        # Tag keys and tag values are case-sensitive. If you specify multiple tags, the system adds all the tags to the specified resources. Each tag key on a resource can have only one tag value. If you create a tag that has the same key as an existing tag, the value of the existing tag is overwritten.
        # 
        # Tag keys and tag values cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.
        self.tags = tags

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.app_source is not None:
            result['AppSource'] = self.app_source
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.field_type is not None:
            result['FieldType'] = self.field_type
        if self.field_value is not None:
            result['FieldValue'] = self.field_value
        if self.is_stateful is not None:
            result['IsStateful'] = self.is_stateful
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.reverse is not None:
            result['Reverse'] = self.reverse
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AppSource') is not None:
            self.app_source = m.get('AppSource')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('FieldType') is not None:
            self.field_type = m.get('FieldType')
        if m.get('FieldValue') is not None:
            self.field_value = m.get('FieldValue')
        if m.get('IsStateful') is not None:
            self.is_stateful = m.get('IsStateful')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Reverse') is not None:
            self.reverse = m.get('Reverse')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class ListApplicationsResponseBodyDataApplicationsChildrenTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListApplicationsResponseBodyDataApplicationsChildren(TeaModel):
    def __init__(
        self,
        app_deleting_status: bool = None,
        app_description: str = None,
        app_id: str = None,
        app_name: str = None,
        app_type: str = None,
        base_app_id: str = None,
        cpu: int = None,
        instances: int = None,
        is_stateful: bool = None,
        mem: int = None,
        mse_enabled: bool = None,
        namespace_id: str = None,
        namespace_name: str = None,
        new_sae_version: str = None,
        programming_language: str = None,
        region_id: str = None,
        running_instances: int = None,
        scale_rule_enabled: bool = None,
        scale_rule_type: str = None,
        tags: List[ListApplicationsResponseBodyDataApplicationsChildrenTags] = None,
    ):
        # If is deleting this application.
        self.app_deleting_status = app_deleting_status
        # The application description.
        self.app_description = app_description
        # The application ID.
        self.app_id = app_id
        # The application name.
        self.app_name = app_name
        # The way to deploy applications.
        self.app_type = app_type
        # The base application ID.
        self.base_app_id = base_app_id
        # The CPU sepcification.
        self.cpu = cpu
        # The number of instances.
        self.instances = instances
        self.is_stateful = is_stateful
        # The memory specification.
        self.mem = mem
        # If this application has enabled MSE.
        self.mse_enabled = mse_enabled
        # The namespace ID.
        self.namespace_id = namespace_id
        # The name of the namespace.
        self.namespace_name = namespace_name
        # The application edition.
        # 
        # - lite: the lightweight edition.
        # - std: the standard edition.
        # - pro: the professional edition.
        self.new_sae_version = new_sae_version
        # The programming language of this application.
        self.programming_language = programming_language
        # The region ID.
        self.region_id = region_id
        # The number of instances in running state.
        self.running_instances = running_instances
        # If the scale rule is enabled.
        self.scale_rule_enabled = scale_rule_enabled
        # The type of the scale rule.
        self.scale_rule_type = scale_rule_type
        # The application tag.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_deleting_status is not None:
            result['AppDeletingStatus'] = self.app_deleting_status
        if self.app_description is not None:
            result['AppDescription'] = self.app_description
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.base_app_id is not None:
            result['BaseAppId'] = self.base_app_id
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.instances is not None:
            result['Instances'] = self.instances
        if self.is_stateful is not None:
            result['IsStateful'] = self.is_stateful
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.mse_enabled is not None:
            result['MseEnabled'] = self.mse_enabled
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.namespace_name is not None:
            result['NamespaceName'] = self.namespace_name
        if self.new_sae_version is not None:
            result['NewSaeVersion'] = self.new_sae_version
        if self.programming_language is not None:
            result['ProgrammingLanguage'] = self.programming_language
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.running_instances is not None:
            result['RunningInstances'] = self.running_instances
        if self.scale_rule_enabled is not None:
            result['ScaleRuleEnabled'] = self.scale_rule_enabled
        if self.scale_rule_type is not None:
            result['ScaleRuleType'] = self.scale_rule_type
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppDeletingStatus') is not None:
            self.app_deleting_status = m.get('AppDeletingStatus')
        if m.get('AppDescription') is not None:
            self.app_description = m.get('AppDescription')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('BaseAppId') is not None:
            self.base_app_id = m.get('BaseAppId')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('Instances') is not None:
            self.instances = m.get('Instances')
        if m.get('IsStateful') is not None:
            self.is_stateful = m.get('IsStateful')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('MseEnabled') is not None:
            self.mse_enabled = m.get('MseEnabled')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NamespaceName') is not None:
            self.namespace_name = m.get('NamespaceName')
        if m.get('NewSaeVersion') is not None:
            self.new_sae_version = m.get('NewSaeVersion')
        if m.get('ProgrammingLanguage') is not None:
            self.programming_language = m.get('ProgrammingLanguage')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RunningInstances') is not None:
            self.running_instances = m.get('RunningInstances')
        if m.get('ScaleRuleEnabled') is not None:
            self.scale_rule_enabled = m.get('ScaleRuleEnabled')
        if m.get('ScaleRuleType') is not None:
            self.scale_rule_type = m.get('ScaleRuleType')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListApplicationsResponseBodyDataApplicationsChildrenTags()
                self.tags.append(temp_model.from_map(k))
        return self


class ListApplicationsResponseBodyDataApplicationsTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListApplicationsResponseBodyDataApplications(TeaModel):
    def __init__(
        self,
        app_deleting_status: bool = None,
        app_description: str = None,
        app_id: str = None,
        app_name: str = None,
        app_type: str = None,
        base_app_id: str = None,
        children: List[ListApplicationsResponseBodyDataApplicationsChildren] = None,
        cpu: int = None,
        disk_size: int = None,
        enable_idle: str = None,
        image_url: str = None,
        instances: int = None,
        is_stateful: bool = None,
        mem: int = None,
        mse_enabled: bool = None,
        mse_namespace_id: str = None,
        namespace_id: str = None,
        namespace_name: str = None,
        new_sae_version: str = None,
        package_url: str = None,
        programming_language: str = None,
        region_id: str = None,
        running_instances: int = None,
        tags: List[ListApplicationsResponseBodyDataApplicationsTags] = None,
        vpc_id: str = None,
    ):
        # Indicates whether the application is being deleted. Valid values:
        # 
        # *   **true**: The application is being deleted.
        # *   **false**: The application is not being deleted.
        self.app_deleting_status = app_deleting_status
        # The description of the application.
        self.app_description = app_description
        # The application ID.
        self.app_id = app_id
        # The application name.
        self.app_name = app_name
        # The application type.
        self.app_type = app_type
        # The base app ID. Only gray-release applications have this property.
        self.base_app_id = base_app_id
        # The gray-release application list of this application.
        self.children = children
        # The CPU specifications that are required for each instance. Unit: millicores. This parameter cannot be set to 0. Valid values:
        # 
        # *   **500**\
        # *   **1000**\
        # *   **2000**\
        # *   **4000**\
        # *   **8000**\
        # *   **16000**\
        # *   **32000**\
        self.cpu = cpu
        # The disk size. Unit: GB.
        self.disk_size = disk_size
        # If the idle mode is enabled.
        self.enable_idle = enable_idle
        # The image URL.
        self.image_url = image_url
        # The number of application instances.
        self.instances = instances
        self.is_stateful = is_stateful
        # The memory size that is required by each instance. Unit: MB. This parameter cannot be set to 0. The values of this parameter correspond to the values of the Cpu parameter:
        # 
        # *   This parameter is set to **1024** if the Cpu parameter is set to 500 or 1000.
        # *   This parameter is set to **2048** if the Cpu parameter is set to 500, 1000, or 2000.
        # *   This parameter is set to **4096** if the Cpu parameter is set to 1000, 2000, or 4000.
        # *   This parameter is set to **8192** if the Cpu parameter is set to 2000, 4000, or 8000.
        # *   This parameter is set to **12288** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **16384** if the Cpu parameter is set to 4000, 8000, or 16000.
        # *   This parameter is set to **24576** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **32768** if the Cpu parameter is set to 16000.
        # *   This parameter is set to **65536** if the Cpu parameter is set to 8000, 16000, or 32000.
        # *   This parameter is set to **131072** if the Cpu parameter is set to 32000.
        self.mem = mem
        # The application has enabled MSE or not.
        self.mse_enabled = mse_enabled
        # The name space of MSE:
        # 
        # - default: the free edition.
        # - sae-pro: the professional edition.
        # - sae-ent: the enterprise eiditon.
        self.mse_namespace_id = mse_namespace_id
        # The namespace ID.
        self.namespace_id = namespace_id
        # The name of the namespace.
        self.namespace_name = namespace_name
        # The application edition.
        # 
        # - lite: the lightweight edition.
        # - std: the standard edition.
        # - pro: the professional edition.
        self.new_sae_version = new_sae_version
        # The package URL.
        self.package_url = package_url
        # The programming language of the application.
        self.programming_language = programming_language
        # The region ID.
        self.region_id = region_id
        # The number of running instances.
        self.running_instances = running_instances
        # The tags of the application.
        self.tags = tags
        # VPC ID.
        self.vpc_id = vpc_id

    def validate(self):
        if self.children:
            for k in self.children:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_deleting_status is not None:
            result['AppDeletingStatus'] = self.app_deleting_status
        if self.app_description is not None:
            result['AppDescription'] = self.app_description
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.base_app_id is not None:
            result['BaseAppId'] = self.base_app_id
        result['Children'] = []
        if self.children is not None:
            for k in self.children:
                result['Children'].append(k.to_map() if k else None)
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.disk_size is not None:
            result['DiskSize'] = self.disk_size
        if self.enable_idle is not None:
            result['EnableIdle'] = self.enable_idle
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.instances is not None:
            result['Instances'] = self.instances
        if self.is_stateful is not None:
            result['IsStateful'] = self.is_stateful
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.mse_enabled is not None:
            result['MseEnabled'] = self.mse_enabled
        if self.mse_namespace_id is not None:
            result['MseNamespaceId'] = self.mse_namespace_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.namespace_name is not None:
            result['NamespaceName'] = self.namespace_name
        if self.new_sae_version is not None:
            result['NewSaeVersion'] = self.new_sae_version
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.programming_language is not None:
            result['ProgrammingLanguage'] = self.programming_language
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.running_instances is not None:
            result['RunningInstances'] = self.running_instances
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppDeletingStatus') is not None:
            self.app_deleting_status = m.get('AppDeletingStatus')
        if m.get('AppDescription') is not None:
            self.app_description = m.get('AppDescription')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('BaseAppId') is not None:
            self.base_app_id = m.get('BaseAppId')
        self.children = []
        if m.get('Children') is not None:
            for k in m.get('Children'):
                temp_model = ListApplicationsResponseBodyDataApplicationsChildren()
                self.children.append(temp_model.from_map(k))
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('DiskSize') is not None:
            self.disk_size = m.get('DiskSize')
        if m.get('EnableIdle') is not None:
            self.enable_idle = m.get('EnableIdle')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('Instances') is not None:
            self.instances = m.get('Instances')
        if m.get('IsStateful') is not None:
            self.is_stateful = m.get('IsStateful')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('MseEnabled') is not None:
            self.mse_enabled = m.get('MseEnabled')
        if m.get('MseNamespaceId') is not None:
            self.mse_namespace_id = m.get('MseNamespaceId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NamespaceName') is not None:
            self.namespace_name = m.get('NamespaceName')
        if m.get('NewSaeVersion') is not None:
            self.new_sae_version = m.get('NewSaeVersion')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('ProgrammingLanguage') is not None:
            self.programming_language = m.get('ProgrammingLanguage')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RunningInstances') is not None:
            self.running_instances = m.get('RunningInstances')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListApplicationsResponseBodyDataApplicationsTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class ListApplicationsResponseBodyData(TeaModel):
    def __init__(
        self,
        applications: List[ListApplicationsResponseBodyDataApplications] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # The queried applications.
        self.applications = applications
        # The current page number.
        self.current_page = current_page
        # The number of records in each page.
        self.page_size = page_size
        # The number of applications.
        self.total_size = total_size

    def validate(self):
        if self.applications:
            for k in self.applications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Applications'] = []
        if self.applications is not None:
            for k in self.applications:
                result['Applications'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.applications = []
        if m.get('Applications') is not None:
            for k in m.get('Applications'):
                temp_model = ListApplicationsResponseBodyDataApplications()
                self.applications.append(temp_model.from_map(k))
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListApplicationsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        current_page: int = None,
        data: ListApplicationsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total_size: int = None,
    ):
        # The HTTP status code. Take note of the following rules:
        # 
        # - **2xx**: The call was successful.
        # - **3xx**: The call was redirected.
        # - **4xx**: The call failed.
        # - **5xx**: A server error occurred.
        self.code = code
        # The current page number.
        self.current_page = current_page
        # The queried applications.
        self.data = data
        # The returned error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # Additional message.
        self.message = message
        # The page size.
        self.page_size = page_size
        # Request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The number of applications.
        self.total_size = total_size

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Data') is not None:
            temp_model = ListApplicationsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListApplicationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListApplicationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListApplicationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListApplicationsForSwimmingLaneRequest(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        namespace_id: str = None,
        tag: str = None,
    ):
        self.group_id = group_id
        # This parameter is required.
        self.namespace_id = namespace_id
        self.tag = tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class ListApplicationsForSwimmingLaneResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        base_app_id: str = None,
        base_app_name: str = None,
        mse_app_id: str = None,
        mse_app_name: str = None,
        mse_namespace_id: str = None,
        service_tags: Dict[str, str] = None,
    ):
        self.app_id = app_id
        self.app_name = app_name
        self.base_app_id = base_app_id
        self.base_app_name = base_app_name
        self.mse_app_id = mse_app_id
        self.mse_app_name = mse_app_name
        self.mse_namespace_id = mse_namespace_id
        self.service_tags = service_tags

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.base_app_id is not None:
            result['BaseAppId'] = self.base_app_id
        if self.base_app_name is not None:
            result['BaseAppName'] = self.base_app_name
        if self.mse_app_id is not None:
            result['MseAppId'] = self.mse_app_id
        if self.mse_app_name is not None:
            result['MseAppName'] = self.mse_app_name
        if self.mse_namespace_id is not None:
            result['MseNamespaceId'] = self.mse_namespace_id
        if self.service_tags is not None:
            result['ServiceTags'] = self.service_tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BaseAppId') is not None:
            self.base_app_id = m.get('BaseAppId')
        if m.get('BaseAppName') is not None:
            self.base_app_name = m.get('BaseAppName')
        if m.get('MseAppId') is not None:
            self.mse_app_id = m.get('MseAppId')
        if m.get('MseAppName') is not None:
            self.mse_app_name = m.get('MseAppName')
        if m.get('MseNamespaceId') is not None:
            self.mse_namespace_id = m.get('MseNamespaceId')
        if m.get('ServiceTags') is not None:
            self.service_tags = m.get('ServiceTags')
        return self


class ListApplicationsForSwimmingLaneResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListApplicationsForSwimmingLaneResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListApplicationsForSwimmingLaneResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListApplicationsForSwimmingLaneResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListApplicationsForSwimmingLaneResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListApplicationsForSwimmingLaneResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListChangeOrdersRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        co_status: str = None,
        co_type: str = None,
        current_page: int = None,
        key: str = None,
        order_by: str = None,
        page_size: int = None,
        reverse: bool = None,
    ):
        # 1
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the request.
        self.co_status = co_status
        # The type of the change order. Valid values:
        # 
        # *   **CoBindSlb**: associates the Server Load Balancer (SLB) instance with the application.
        # *   **CoUnbindSlb**: disassociates an SLB instance from the application.
        # *   **CoCreateApp**: creates the application.
        # *   **CoDeleteApp**: deletes the application.
        # *   **CoDeploy**: deploys the application.
        # *   **CoRestartApplication**: restarts the application.
        # *   **CoRollback**: rolls back the application.
        # *   **CoScaleIn**: scales in the application.
        # *   **CoScaleOut**: scales out the application.
        # *   **CoStartApplication**: starts the application.
        # *   **CoStopApplication**: stops the application.
        # *   **CoRescaleApplicationVertically**: modifies the instance type.
        # *   **CoDeployHistroy**: rolls back the application to an earlier version.
        # *   **CoBindNas**: associates a network-attached storage (NAS) file system with the application.
        # *   **CoUnbindNas**: disassociates a NAS file system from the application.
        # *   **CoBatchStartApplication**: starts multiple applications concurrently.
        # *   **CoBatchStopApplication**: stops multiple applications concurrently.
        # *   **CoRestartInstances**: restarts the instance.
        # *   **CoDeleteInstances**: deletes the instance.
        # *   **CoScaleInAppWithInstances**: reduces the specified number of application instances.
        self.co_type = co_type
        # 20
        self.current_page = current_page
        # CoCreateApp
        self.key = key
        self.order_by = order_by
        # test
        self.page_size = page_size
        self.reverse = reverse

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.co_status is not None:
            result['CoStatus'] = self.co_status
        if self.co_type is not None:
            result['CoType'] = self.co_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.key is not None:
            result['Key'] = self.key
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.reverse is not None:
            result['Reverse'] = self.reverse
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CoStatus') is not None:
            self.co_status = m.get('CoStatus')
        if m.get('CoType') is not None:
            self.co_type = m.get('CoType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Reverse') is not None:
            self.reverse = m.get('Reverse')
        return self


class ListChangeOrdersResponseBodyDataChangeOrderList(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        batch_count: int = None,
        batch_type: str = None,
        change_order_id: str = None,
        co_type: str = None,
        co_type_code: str = None,
        create_time: str = None,
        create_user_id: str = None,
        description: str = None,
        finish_time: str = None,
        group_id: str = None,
        source: str = None,
        status: int = None,
        user_id: str = None,
    ):
        # The number of entries returned on each page.
        self.app_id = app_id
        # The ID of the user who created the change order.
        self.batch_count = batch_count
        # The ID of the group.
        self.batch_type = batch_type
        # The mode in which the release batches are determined. Valid values:
        # 
        # *   **auto**: SAE automatically determines the release batches.
        # *   **manual**: You must manually determine the release batches.
        self.change_order_id = change_order_id
        # The ID of the application.
        self.co_type = co_type
        # The code of the change order. Valid values:
        # 
        # *   **CoBindSlb**: associates the Server Load Balancer (SLB) instance with the application.
        # *   **CoUnbindSlb**: disassociates an SLB instance from the application.
        # *   **CoCreateApp**: creates the application.
        # *   **CoDeleteApp**: deletes the application.
        # *   **CoDeploy**: deploys the application.
        # *   **CoRestartApplication**: restarts the application.
        # *   **CoRollback**: rolls back the application.
        # *   **CoScaleIn**: scales in the application.
        # *   **CoScaleOut**: scales out the application.
        # *   **CoStartApplication**: starts the application.
        # *   **CoStopApplication**: stops the application.
        # *   **CoRescaleApplicationVertically**: modifies the instance type.
        # *   **CoDeployHistroy**: rolls back the application to an earlier version.
        # *   **CoBindNas**: associates a network-attached storage (NAS) file system with the application.
        # *   **CoUnbindNas**: disassociates a NAS file system from the application.
        # *   **CoBatchStartApplication**: starts multiple applications concurrently.
        # *   **CoBatchStopApplication**: stops multiple applications concurrently.
        # *   **CoRestartInstances**: restarts the instance.
        # *   **CoDeleteInstances**: deletes the instance.
        # *   **CoScaleInAppWithInstances**: reduces the specified number of application instances.
        self.co_type_code = co_type_code
        # The ID of the user.
        self.create_time = create_time
        # The code of the change type. Valid values:
        # 
        # *   **CoBindSlb**: associates an SLB instance with the application.
        # *   **CoUnbindSlb**: disassociates the SLB instance from the application.
        # *   **CoCreateApp**: creates the application.
        # *   **CoDeleteApp**: deletes the application.
        # *   **CoDeploy**: deploys the application.
        # *   **CoRestartApplication**: restarts the application.
        # *   **CoRollback**: rolls back the application.
        # *   **CoScaleIn**: scales in the application.
        # *   **CoScaleOut**: scales out the application.
        # *   **CoStart**: starts the application.
        # *   **CoStop**: stops the application.
        # *   **CoRescaleApplicationVertically**: modifies the instance specifications.
        # *   **CoDeployHistroy**: rolls back the application to a historical version.
        # *   **CoBindNas**: associates a NAS file system with the application.
        # *   **CoUnbindNas**: disassociates the NAS file system from the application.
        # *   **CoBatchStartApplication**: starts multiple applications concurrently.
        # *   **CoBatchStopApplication**: stops multiple applications concurrently.
        # *   **CoRestartInstances**: restarts the instances.
        # *   **CoDeleteInstances**: deletes the instances.
        # *   **CoScaleInAppWithInstances**: reduces the number of the specified application instances.
        self.create_user_id = create_user_id
        # The change type, which corresponds to the **CoTypeCode** parameter.
        self.description = description
        # The time when the change order was created.
        self.finish_time = finish_time
        # The description about the application.
        self.group_id = group_id
        # The number of release batches.
        self.source = source
        # The time when the change order was completed.
        self.status = status
        # The source of the change order.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.batch_count is not None:
            result['BatchCount'] = self.batch_count
        if self.batch_type is not None:
            result['BatchType'] = self.batch_type
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.co_type is not None:
            result['CoType'] = self.co_type
        if self.co_type_code is not None:
            result['CoTypeCode'] = self.co_type_code
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user_id is not None:
            result['CreateUserId'] = self.create_user_id
        if self.description is not None:
            result['Description'] = self.description
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.source is not None:
            result['Source'] = self.source
        if self.status is not None:
            result['Status'] = self.status
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BatchCount') is not None:
            self.batch_count = m.get('BatchCount')
        if m.get('BatchType') is not None:
            self.batch_type = m.get('BatchType')
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('CoType') is not None:
            self.co_type = m.get('CoType')
        if m.get('CoTypeCode') is not None:
            self.co_type_code = m.get('CoTypeCode')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUserId') is not None:
            self.create_user_id = m.get('CreateUserId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListChangeOrdersResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_list: List[ListChangeOrdersResponseBodyDataChangeOrderList] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # The change orders.
        self.change_order_list = change_order_list
        # The total number of change orders.
        self.current_page = current_page
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.page_size = page_size
        # The list of change orders.
        self.total_size = total_size

    def validate(self):
        if self.change_order_list:
            for k in self.change_order_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ChangeOrderList'] = []
        if self.change_order_list is not None:
            for k in self.change_order_list:
                result['ChangeOrderList'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.change_order_list = []
        if m.get('ChangeOrderList') is not None:
            for k in m.get('ChangeOrderList'):
                temp_model = ListChangeOrdersResponseBodyDataChangeOrderList()
                self.change_order_list.append(temp_model.from_map(k))
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListChangeOrdersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListChangeOrdersResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # Indicates whether the list of change orders was obtained. Valid values:
        # 
        # *   **true**: indicates that the list was obtained.
        # *   **false**: indicates that the list could not be obtained.
        self.code = code
        # The information about change orders.
        self.data = data
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.error_code = error_code
        # The ID of the trace. It is used to query the details of a request.
        self.message = message
        # The returned message.
        self.request_id = request_id
        self.success = success
        # The information about change orders.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListChangeOrdersResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListChangeOrdersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListChangeOrdersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListChangeOrdersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListConsumedServicesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class ListConsumedServicesResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group_2ip: str = None,
        groups: List[str] = None,
        ips: List[str] = None,
        name: str = None,
        type: str = None,
        version: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # This parameter is reserved.
        self.group_2ip = group_2ip
        # The service groups that corresponds to the consumed services.
        self.groups = groups
        # The addresses where the services can be subscribed to.
        self.ips = ips
        # The name of the published service.
        self.name = name
        # The type of the published service.
        self.type = type
        # The version of the published service.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.group_2ip is not None:
            result['Group2Ip'] = self.group_2ip
        if self.groups is not None:
            result['Groups'] = self.groups
        if self.ips is not None:
            result['Ips'] = self.ips
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Group2Ip') is not None:
            self.group_2ip = m.get('Group2Ip')
        if m.get('Groups') is not None:
            self.groups = m.get('Groups')
        if m.get('Ips') is not None:
            self.ips = m.get('Ips')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListConsumedServicesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListConsumedServicesResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The details of the microservices.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the list of microservices was queried. Valid values:
        # 
        # *   **true**: The list was queried.
        # *   **false**: The list failed to be queried.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListConsumedServicesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListConsumedServicesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListConsumedServicesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListConsumedServicesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListGreyTagRouteRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # 7171a6ca-d1cd-4928-8642-7d5cfe69\\*\\*\\*\\*\
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class ListGreyTagRouteResponseBodyDataResultAlbRulesItems(TeaModel):
    def __init__(
        self,
        cond: str = None,
        expr: str = None,
        index: int = None,
        name: str = None,
        operator: str = None,
        type: str = None,
        value: str = None,
    ):
        self.cond = cond
        self.expr = expr
        self.index = index
        self.name = name
        self.operator = operator
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cond is not None:
            result['cond'] = self.cond
        if self.expr is not None:
            result['expr'] = self.expr
        if self.index is not None:
            result['index'] = self.index
        if self.name is not None:
            result['name'] = self.name
        if self.operator is not None:
            result['operator'] = self.operator
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cond') is not None:
            self.cond = m.get('cond')
        if m.get('expr') is not None:
            self.expr = m.get('expr')
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListGreyTagRouteResponseBodyDataResultAlbRules(TeaModel):
    def __init__(
        self,
        condition: str = None,
        ingress_id: str = None,
        items: List[ListGreyTagRouteResponseBodyDataResultAlbRulesItems] = None,
        service_name: str = None,
    ):
        self.condition = condition
        self.ingress_id = ingress_id
        self.items = items
        self.service_name = service_name

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['condition'] = self.condition
        if self.ingress_id is not None:
            result['ingressId'] = self.ingress_id
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.service_name is not None:
            result['serviceName'] = self.service_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        if m.get('ingressId') is not None:
            self.ingress_id = m.get('ingressId')
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = ListGreyTagRouteResponseBodyDataResultAlbRulesItems()
                self.items.append(temp_model.from_map(k))
        if m.get('serviceName') is not None:
            self.service_name = m.get('serviceName')
        return self


class ListGreyTagRouteResponseBodyDataResultDubboRulesItems(TeaModel):
    def __init__(
        self,
        cond: str = None,
        expr: str = None,
        index: int = None,
        name: str = None,
        operator: str = None,
        type: str = None,
        value: str = None,
    ):
        # The comparison operator. Valid values: **>**, **<**, **>=**, **<=**, **==**, and **! =**.
        self.cond = cond
        # The expression that is used to obtain the value of the parameter. The syntax of the expression must follow the standard of the SpEL. Valid values:
        # 
        # - **Empty**: obtains the value of the parameter.
        # - **.name**: obtains the name property of the parameter. This expression works the same way as args0.getName().
        # - **.isEnabled()**: obtains the enabled property of the parameter. This expression works the same way as args0.isEnabled().
        # - **[0]**: indicates that the value of the parameter is an array and obtains the first value of the array. This expression works the same way as args0[0]. This expression does not start with a period (.).
        # - **.get(0)**: indicates that the value of the parameter is a list and obtains the first value of the list. This expression works the same way as args0.get(0).
        # - **.get("key")**: indicates that the value of the parameter is a map and obtains the value of the key in the map. This expression works the same way as args0.get("key").  >  For more information about the expressions that are used to obtain parameter values, see  [Spring Expression Language (SpEL)](https://docs.spring.io/spring-integration/docs/current/reference/html/spel.html).
        self.expr = expr
        # The index of the parameter. The value 0 indicates the first parameter.
        self.index = index
        # This parameter is not returned for Dubbo services.
        self.name = name
        # The operator. Valid values:
        # 
        # - **rawvalue**: direct comparison.
        # - **list**: whitelist.
        # - **mod**: mods 100.
        # - **deterministic_proportional_steaming_division**: percentage.
        self.operator = operator
        # This parameter is not returned for Dubbo services.
        self.type = type
        # The value of the parameter. This value is compared with the value that is obtained based on the **expr** and **index** parameters.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cond is not None:
            result['cond'] = self.cond
        if self.expr is not None:
            result['expr'] = self.expr
        if self.index is not None:
            result['index'] = self.index
        if self.name is not None:
            result['name'] = self.name
        if self.operator is not None:
            result['operator'] = self.operator
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cond') is not None:
            self.cond = m.get('cond')
        if m.get('expr') is not None:
            self.expr = m.get('expr')
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListGreyTagRouteResponseBodyDataResultDubboRules(TeaModel):
    def __init__(
        self,
        condition: str = None,
        group: str = None,
        items: List[ListGreyTagRouteResponseBodyDataResultDubboRulesItems] = None,
        method_name: str = None,
        service_name: str = None,
        version: str = None,
    ):
        # The relationship between the conditions in the canary release rule. Valid values:
        # 
        # - **AND**: The conditions are in the logical AND relation. All conditions must be met at the same time.
        # - **OR**: The conditions are in the logical OR relation. At least one of the conditions must be met.
        self.condition = condition
        # The group of the Dubbo service that corresponds to the canary release rule.
        self.group = group
        # The conditions.
        self.items = items
        # The method name of the Dubbo service.
        self.method_name = method_name
        # The name of the Dubbo service.
        self.service_name = service_name
        # The version of the Dubbo service.
        self.version = version

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['condition'] = self.condition
        if self.group is not None:
            result['group'] = self.group
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.method_name is not None:
            result['methodName'] = self.method_name
        if self.service_name is not None:
            result['serviceName'] = self.service_name
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        if m.get('group') is not None:
            self.group = m.get('group')
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = ListGreyTagRouteResponseBodyDataResultDubboRulesItems()
                self.items.append(temp_model.from_map(k))
        if m.get('methodName') is not None:
            self.method_name = m.get('methodName')
        if m.get('serviceName') is not None:
            self.service_name = m.get('serviceName')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class ListGreyTagRouteResponseBodyDataResultScRulesItems(TeaModel):
    def __init__(
        self,
        cond: str = None,
        expr: str = None,
        index: int = None,
        name: str = None,
        operator: str = None,
        type: str = None,
        value: str = None,
    ):
        # The comparison operator. Valid values: **>**, **<**, **>=**, **<=**, **==**, and **! =**.
        self.cond = cond
        # This parameter is not returned for Spring Cloud applications.
        self.expr = expr
        # This parameter is not returned for Spring Cloud applications.
        self.index = index
        # The name of the parameter.
        self.name = name
        # The operator. Valid values:
        # 
        # *   **rawvalue**: direct comparison.
        # *   **list**: whitelist.
        # *   **mod**: mods 100.
        # *   **deterministic_proportional_steaming_division**: percentage.
        self.operator = operator
        # The type of the comparison. Valid values:
        # 
        # *   **param**: parameter
        # *   **cookie**: cookie
        # *   **header**: header
        self.type = type
        # The value of the parameter. This value is compared with the value that is obtained based on the **type** and **name** parameters.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cond is not None:
            result['cond'] = self.cond
        if self.expr is not None:
            result['expr'] = self.expr
        if self.index is not None:
            result['index'] = self.index
        if self.name is not None:
            result['name'] = self.name
        if self.operator is not None:
            result['operator'] = self.operator
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cond') is not None:
            self.cond = m.get('cond')
        if m.get('expr') is not None:
            self.expr = m.get('expr')
        if m.get('index') is not None:
            self.index = m.get('index')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListGreyTagRouteResponseBodyDataResultScRules(TeaModel):
    def __init__(
        self,
        condition: str = None,
        items: List[ListGreyTagRouteResponseBodyDataResultScRulesItems] = None,
        path: str = None,
    ):
        # The relationship between the conditions in the canary release rule. Valid values:
        # 
        # *   **AND**: The conditions are in the logical AND relation. All conditions must be met at the same time.
        # *   **OR**: The conditions are in the logical OR relation. At least one of the conditions must be met.
        self.condition = condition
        # The conditions.
        self.items = items
        # The path of the canary release rule of the Spring Cloud application.
        self.path = path

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['condition'] = self.condition
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.path is not None:
            result['path'] = self.path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = ListGreyTagRouteResponseBodyDataResultScRulesItems()
                self.items.append(temp_model.from_map(k))
        if m.get('path') is not None:
            self.path = m.get('path')
        return self


class ListGreyTagRouteResponseBodyDataResult(TeaModel):
    def __init__(
        self,
        alb_rules: List[ListGreyTagRouteResponseBodyDataResultAlbRules] = None,
        create_time: int = None,
        description: str = None,
        dubbo_rules: List[ListGreyTagRouteResponseBodyDataResultDubboRules] = None,
        grey_tag_route_id: int = None,
        name: str = None,
        sc_rules: List[ListGreyTagRouteResponseBodyDataResultScRules] = None,
        update_time: int = None,
    ):
        self.alb_rules = alb_rules
        # The timestamp when the canary release rule was created. Unit: milliseconds.
        self.create_time = create_time
        # The description of the canary release rule.
        self.description = description
        # The canary release rule of the Dubbo service.
        self.dubbo_rules = dubbo_rules
        # The ID of the canary release rule.
        self.grey_tag_route_id = grey_tag_route_id
        # The name of the canary release rule.
        self.name = name
        # The canary release rule of the Spring Cloud application.
        self.sc_rules = sc_rules
        # The timestamp when the canary release rule was updated. Unit: milliseconds.
        self.update_time = update_time

    def validate(self):
        if self.alb_rules:
            for k in self.alb_rules:
                if k:
                    k.validate()
        if self.dubbo_rules:
            for k in self.dubbo_rules:
                if k:
                    k.validate()
        if self.sc_rules:
            for k in self.sc_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlbRules'] = []
        if self.alb_rules is not None:
            for k in self.alb_rules:
                result['AlbRules'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        result['DubboRules'] = []
        if self.dubbo_rules is not None:
            for k in self.dubbo_rules:
                result['DubboRules'].append(k.to_map() if k else None)
        if self.grey_tag_route_id is not None:
            result['GreyTagRouteId'] = self.grey_tag_route_id
        if self.name is not None:
            result['Name'] = self.name
        result['ScRules'] = []
        if self.sc_rules is not None:
            for k in self.sc_rules:
                result['ScRules'].append(k.to_map() if k else None)
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alb_rules = []
        if m.get('AlbRules') is not None:
            for k in m.get('AlbRules'):
                temp_model = ListGreyTagRouteResponseBodyDataResultAlbRules()
                self.alb_rules.append(temp_model.from_map(k))
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.dubbo_rules = []
        if m.get('DubboRules') is not None:
            for k in m.get('DubboRules'):
                temp_model = ListGreyTagRouteResponseBodyDataResultDubboRules()
                self.dubbo_rules.append(temp_model.from_map(k))
        if m.get('GreyTagRouteId') is not None:
            self.grey_tag_route_id = m.get('GreyTagRouteId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.sc_rules = []
        if m.get('ScRules') is not None:
            for k in m.get('ScRules'):
                temp_model = ListGreyTagRouteResponseBodyDataResultScRules()
                self.sc_rules.append(temp_model.from_map(k))
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class ListGreyTagRouteResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        result: List[ListGreyTagRouteResponseBodyDataResult] = None,
        total_size: int = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned on each page. Valid value: **1**.
        self.page_size = page_size
        # The returned result.
        self.result = result
        # The total number of canary release rules. Valid value: **1**.
        self.total_size = total_size

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Result'] = []
        if self.result is not None:
            for k in self.result:
                result['Result'].append(k.to_map() if k else None)
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.result = []
        if m.get('Result') is not None:
            for k in m.get('Result'):
                temp_model = ListGreyTagRouteResponseBodyDataResult()
                self.result.append(temp_model.from_map(k))
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListGreyTagRouteResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListGreyTagRouteResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # - **2xx**: The call was successful.
        # - **3xx**: The call was redirected.
        # - **4xx**: The call failed.
        # - **5xx**: A server error occurred.
        self.code = code
        # The information about the canary release rule.
        self.data = data
        # The returned error code. Valid values:
        # 
        # - If the call is successful, the **ErrorCode** parameter is not returned.
        # - If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned information. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the information of the change order was queried. Valid values:
        # 
        # - **true**: The information was queried.
        # - **false**: The information failed to be queried.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListGreyTagRouteResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListGreyTagRouteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListGreyTagRouteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListGreyTagRouteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIngressesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        current_page: int = None,
        namespace_id: str = None,
        page_size: int = None,
    ):
        # The ID of an application.
        self.app_id = app_id
        self.current_page = current_page
        # The ID of a namespace.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListIngressesResponseBodyDataIngressListCorsConfig(TeaModel):
    def __init__(
        self,
        allow_credentials: str = None,
        allow_headers: str = None,
        allow_methods: str = None,
        allow_origin: str = None,
        enable: str = None,
        expose_headers: str = None,
        max_age: str = None,
    ):
        self.allow_credentials = allow_credentials
        self.allow_headers = allow_headers
        self.allow_methods = allow_methods
        self.allow_origin = allow_origin
        self.enable = enable
        self.expose_headers = expose_headers
        self.max_age = max_age

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_credentials is not None:
            result['AllowCredentials'] = self.allow_credentials
        if self.allow_headers is not None:
            result['AllowHeaders'] = self.allow_headers
        if self.allow_methods is not None:
            result['AllowMethods'] = self.allow_methods
        if self.allow_origin is not None:
            result['AllowOrigin'] = self.allow_origin
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.expose_headers is not None:
            result['ExposeHeaders'] = self.expose_headers
        if self.max_age is not None:
            result['MaxAge'] = self.max_age
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllowCredentials') is not None:
            self.allow_credentials = m.get('AllowCredentials')
        if m.get('AllowHeaders') is not None:
            self.allow_headers = m.get('AllowHeaders')
        if m.get('AllowMethods') is not None:
            self.allow_methods = m.get('AllowMethods')
        if m.get('AllowOrigin') is not None:
            self.allow_origin = m.get('AllowOrigin')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('ExposeHeaders') is not None:
            self.expose_headers = m.get('ExposeHeaders')
        if m.get('MaxAge') is not None:
            self.max_age = m.get('MaxAge')
        return self


class ListIngressesResponseBodyDataIngressListDefaultRule(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        backend_protocol: str = None,
        container_port: int = None,
    ):
        self.app_id = app_id
        self.app_name = app_name
        self.backend_protocol = backend_protocol
        self.container_port = container_port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.backend_protocol is not None:
            result['BackendProtocol'] = self.backend_protocol
        if self.container_port is not None:
            result['ContainerPort'] = self.container_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BackendProtocol') is not None:
            self.backend_protocol = m.get('BackendProtocol')
        if m.get('ContainerPort') is not None:
            self.container_port = m.get('ContainerPort')
        return self


class ListIngressesResponseBodyDataIngressListRulesRuleActions(TeaModel):
    def __init__(
        self,
        action_config: str = None,
        action_type: str = None,
    ):
        self.action_config = action_config
        self.action_type = action_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_config is not None:
            result['ActionConfig'] = self.action_config
        if self.action_type is not None:
            result['ActionType'] = self.action_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionConfig') is not None:
            self.action_config = m.get('ActionConfig')
        if m.get('ActionType') is not None:
            self.action_type = m.get('ActionType')
        return self


class ListIngressesResponseBodyDataIngressListRules(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        backend_protocol: str = None,
        container_port: int = None,
        domain: str = None,
        path: str = None,
        rewrite_path: str = None,
        rule_actions: List[ListIngressesResponseBodyDataIngressListRulesRuleActions] = None,
    ):
        self.app_id = app_id
        self.app_name = app_name
        self.backend_protocol = backend_protocol
        self.container_port = container_port
        self.domain = domain
        self.path = path
        self.rewrite_path = rewrite_path
        self.rule_actions = rule_actions

    def validate(self):
        if self.rule_actions:
            for k in self.rule_actions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.backend_protocol is not None:
            result['BackendProtocol'] = self.backend_protocol
        if self.container_port is not None:
            result['ContainerPort'] = self.container_port
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.path is not None:
            result['Path'] = self.path
        if self.rewrite_path is not None:
            result['RewritePath'] = self.rewrite_path
        result['RuleActions'] = []
        if self.rule_actions is not None:
            for k in self.rule_actions:
                result['RuleActions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BackendProtocol') is not None:
            self.backend_protocol = m.get('BackendProtocol')
        if m.get('ContainerPort') is not None:
            self.container_port = m.get('ContainerPort')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('RewritePath') is not None:
            self.rewrite_path = m.get('RewritePath')
        self.rule_actions = []
        if m.get('RuleActions') is not None:
            for k in m.get('RuleActions'):
                temp_model = ListIngressesResponseBodyDataIngressListRulesRuleActions()
                self.rule_actions.append(temp_model.from_map(k))
        return self


class ListIngressesResponseBodyDataIngressList(TeaModel):
    def __init__(
        self,
        cert_id: str = None,
        cert_ids: str = None,
        cors_config: ListIngressesResponseBodyDataIngressListCorsConfig = None,
        create_time: int = None,
        default_rule: ListIngressesResponseBodyDataIngressListDefaultRule = None,
        description: str = None,
        id: int = None,
        idle_timeout: int = None,
        listener_port: str = None,
        listener_protocol: str = None,
        load_balance_type: str = None,
        mse_gateway_id: str = None,
        mse_gateway_port: str = None,
        mse_gateway_protocol: str = None,
        name: str = None,
        namespace_id: str = None,
        request_timeout: int = None,
        rules: List[ListIngressesResponseBodyDataIngressListRules] = None,
        slb_id: str = None,
        slb_type: str = None,
    ):
        # The ID of the certificate that is associated with a Classic Load Balancer (**CLB**) instance.
        self.cert_id = cert_id
        # The ID of the certificate that is associated with an Application Load Balancer **ALB** instance.
        self.cert_ids = cert_ids
        self.cors_config = cors_config
        self.create_time = create_time
        self.default_rule = default_rule
        # The name of a routing rule.
        self.description = description
        # The ID of a routing rule.
        self.id = id
        self.idle_timeout = idle_timeout
        # The listener ports for an SLB instance.
        self.listener_port = listener_port
        # The protocol that is supported by SLB to forward requests. Valid values:
        # 
        # *   **HTTP**: HTTP is suitable for applications that need to identify the transmitted data.
        # *   **HTTPS**: HTTPS is suitable for applications that require encrypted data transmission.
        # 
        # This parameter is optional in the **CreateIngress** and **UpadateIngress** operations. If you do not configure this parameter when you call the CreateIngress or UpdateIngress operation to create or update a gateway routing rule, this parameter is not returned for the corresponding response.
        self.listener_protocol = listener_protocol
        # The type of SLB instances. Valid values:
        # 
        # *   **clb**: Classic Load Balancer (formerly known as SLB).
        # *   **alb**: Application Load Balancer.
        self.load_balance_type = load_balance_type
        # The ID of an MSE cloud-native gateway.
        self.mse_gateway_id = mse_gateway_id
        # The port of a service.
        self.mse_gateway_port = mse_gateway_port
        # The protocol that is supported by an MSE cloud-native gateway to forward requests. Valid values:
        # 
        # *   **HTTP**: HTTP is suitable for applications that need to identify transmitted data.
        # *   **HTTPS**: HTTPS is suitable for applications that require encrypted data transmission.
        self.mse_gateway_protocol = mse_gateway_protocol
        # The name of a routing rule.
        self.name = name
        # The ID of a namespace.
        self.namespace_id = namespace_id
        self.request_timeout = request_timeout
        self.rules = rules
        # The ID of a Server Load Balancer (SLB) instance.
        self.slb_id = slb_id
        # The type of SLB instances. Valid values:
        # 
        # *   **internet**: an Internet-facing SLB instance
        # *   **intranet**: an Intranet-facing SLB instance
        self.slb_type = slb_type

    def validate(self):
        if self.cors_config:
            self.cors_config.validate()
        if self.default_rule:
            self.default_rule.validate()
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_id is not None:
            result['CertId'] = self.cert_id
        if self.cert_ids is not None:
            result['CertIds'] = self.cert_ids
        if self.cors_config is not None:
            result['CorsConfig'] = self.cors_config.to_map()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.default_rule is not None:
            result['DefaultRule'] = self.default_rule.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.idle_timeout is not None:
            result['IdleTimeout'] = self.idle_timeout
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.listener_protocol is not None:
            result['ListenerProtocol'] = self.listener_protocol
        if self.load_balance_type is not None:
            result['LoadBalanceType'] = self.load_balance_type
        if self.mse_gateway_id is not None:
            result['MseGatewayId'] = self.mse_gateway_id
        if self.mse_gateway_port is not None:
            result['MseGatewayPort'] = self.mse_gateway_port
        if self.mse_gateway_protocol is not None:
            result['MseGatewayProtocol'] = self.mse_gateway_protocol
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.request_timeout is not None:
            result['RequestTimeout'] = self.request_timeout
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        if self.slb_id is not None:
            result['SlbId'] = self.slb_id
        if self.slb_type is not None:
            result['SlbType'] = self.slb_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertId') is not None:
            self.cert_id = m.get('CertId')
        if m.get('CertIds') is not None:
            self.cert_ids = m.get('CertIds')
        if m.get('CorsConfig') is not None:
            temp_model = ListIngressesResponseBodyDataIngressListCorsConfig()
            self.cors_config = temp_model.from_map(m['CorsConfig'])
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DefaultRule') is not None:
            temp_model = ListIngressesResponseBodyDataIngressListDefaultRule()
            self.default_rule = temp_model.from_map(m['DefaultRule'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IdleTimeout') is not None:
            self.idle_timeout = m.get('IdleTimeout')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('ListenerProtocol') is not None:
            self.listener_protocol = m.get('ListenerProtocol')
        if m.get('LoadBalanceType') is not None:
            self.load_balance_type = m.get('LoadBalanceType')
        if m.get('MseGatewayId') is not None:
            self.mse_gateway_id = m.get('MseGatewayId')
        if m.get('MseGatewayPort') is not None:
            self.mse_gateway_port = m.get('MseGatewayPort')
        if m.get('MseGatewayProtocol') is not None:
            self.mse_gateway_protocol = m.get('MseGatewayProtocol')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('RequestTimeout') is not None:
            self.request_timeout = m.get('RequestTimeout')
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = ListIngressesResponseBodyDataIngressListRules()
                self.rules.append(temp_model.from_map(k))
        if m.get('SlbId') is not None:
            self.slb_id = m.get('SlbId')
        if m.get('SlbType') is not None:
            self.slb_type = m.get('SlbType')
        return self


class ListIngressesResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        ingress_list: List[ListIngressesResponseBodyDataIngressList] = None,
        page_size: int = None,
        total_size: int = None,
    ):
        self.current_page = current_page
        # The list of routing rules.
        self.ingress_list = ingress_list
        self.page_size = page_size
        self.total_size = total_size

    def validate(self):
        if self.ingress_list:
            for k in self.ingress_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['IngressList'] = []
        if self.ingress_list is not None:
            for k in self.ingress_list:
                result['IngressList'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.ingress_list = []
        if m.get('IngressList') is not None:
            for k in m.get('IngressList'):
                temp_model = ListIngressesResponseBodyDataIngressList()
                self.ingress_list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListIngressesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListIngressesResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The request was successful.
        # *   **3xx**: The request was redirected.
        # *   **4xx**: The request failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The result returned.
        self.data = data
        # The error code returned if the request failed. Valid values:
        # 
        # *   **ErrorCode** is not returned if a request is successful.
        # *   **ErrorCode** is returned if a request failed. For more information, see **Error codes**.
        self.error_code = error_code
        # The message returned. Valid values:
        # 
        # *   **success** is returned when a request is successful.
        # *   An error code is returned when a request failed.
        self.message = message
        # The ID of a request.
        self.request_id = request_id
        # Indicates whether the list of Ingresses was obtained. Valid values:
        # 
        # *   **true**: The list were obtained.
        # *   **false**: The list failed to be queried.
        self.success = success
        # The ID of a trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListIngressesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListIngressesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIngressesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIngressesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListJobsRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        current_page: int = None,
        field_type: str = None,
        field_value: str = None,
        namespace_id: str = None,
        order_by: str = None,
        page_size: int = None,
        reverse: bool = None,
        tags: str = None,
        workload: str = None,
    ):
        # The name of the job template.
        self.app_name = app_name
        # The number of the page to return. The parameter value is a positive integer that is greater than or equal to 1.
        self.current_page = current_page
        # The dimension by which applications are filtered. Valid values:
        # 
        # *   **appName**: Applications are filtered by job template name.
        # *   **appIds**: Applications are filtered by job template ID.
        self.field_type = field_type
        # Enter the name and ID of the job template.
        self.field_value = field_value
        # The namespace ID.
        self.namespace_id = namespace_id
        # Specifies how applications are sorted. Valid values:
        # 
        # *   **running**: The applications are sorted based on the number of running instances.
        # *   **instances**: The applications are sorted based on the number of destination instances.
        self.order_by = order_by
        # The number of entries to return on each page. Valid value: 0 to 200.
        self.page_size = page_size
        # Specifies whether to sort the field names that are passed by **OrderBy** in ascending order. Valid values:
        # 
        # *   **true**: in ascending order
        # *   **false**: in descending order
        self.reverse = reverse
        # The tags that are displayed in a JSON string. Valid values:
        # 
        # *   **key**: the tag key
        # *   **value**: the tag value
        self.tags = tags
        # Set the value to `job`.
        self.workload = workload

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.field_type is not None:
            result['FieldType'] = self.field_type
        if self.field_value is not None:
            result['FieldValue'] = self.field_value
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.reverse is not None:
            result['Reverse'] = self.reverse
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.workload is not None:
            result['Workload'] = self.workload
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('FieldType') is not None:
            self.field_type = m.get('FieldType')
        if m.get('FieldValue') is not None:
            self.field_value = m.get('FieldValue')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Reverse') is not None:
            self.reverse = m.get('Reverse')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Workload') is not None:
            self.workload = m.get('Workload')
        return self


class ListJobsResponseBodyDataApplicationsTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListJobsResponseBodyDataApplications(TeaModel):
    def __init__(
        self,
        active: int = None,
        app_description: str = None,
        app_id: str = None,
        app_name: str = None,
        completion_time: int = None,
        cpu: int = None,
        failed: int = None,
        image_url: str = None,
        last_changeorder_state: str = None,
        last_job_state: str = None,
        last_start_time: int = None,
        mem: int = None,
        message: str = None,
        namespace_id: str = None,
        region_id: str = None,
        succeeded: int = None,
        suspend: bool = None,
        tags: List[ListJobsResponseBodyDataApplicationsTags] = None,
        trigger_config: str = None,
    ):
        # The number of running instances.
        self.active = active
        # The description of the job template.
        self.app_description = app_description
        # The ID of the job template.
        self.app_id = app_id
        # The name of the job template.
        self.app_name = app_name
        # The time when the job was last completed.
        self.completion_time = completion_time
        # The CPU specifications that are required for each instance. Unit: millicores. This parameter cannot be set to 0. Valid values:
        # 
        # *   **500**\
        # *   **1000**\
        # *   **2000**\
        # *   **4000**\
        # *   **8000**\
        # *   **16000**\
        # *   **32000**\
        self.cpu = cpu
        # The number of instances that failed to run.
        self.failed = failed
        self.image_url = image_url
        # Indicates whether the latest change order was executed. Valid values:
        # 
        # *   **0**: The latest change order failed to be executed.
        # *   **1**: The latest change order was executed.
        self.last_changeorder_state = last_changeorder_state
        # The status of the latest job. Valid values:
        # 
        # *   **0**: The job is not executed.
        # *   **1**: The job was executed.
        # *   **2**: The job failed to be executed.
        # *   **3**: The job is being executed.
        self.last_job_state = last_job_state
        # The time when the job was last started.
        self.last_start_time = last_start_time
        # The size of memory that is required by each instance. Unit: MB. This parameter cannot be set to 0. The values of this parameter correspond to the values of the Cpu parameter:
        # 
        # *   This parameter is set to **1024** if the Cpu parameter is set to 500 or 1000.
        # *   This parameter is set to **2048** if the Cpu parameter is set to 500, 1000, or 2000.
        # *   This parameter is set to **4096** if the Cpu parameter is set to 1000, 2000, or 4000.
        # *   This parameter is set to **8192** if the Cpu parameter is set to 2000, 4000, or 8000.
        # *   This parameter is set to **12288** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **16384** if the Cpu parameter is set to 4000, 8000, or 16000.
        # *   This parameter is set to **24576** if the Cpu parameter is set to 12000.
        # *   This parameter is set to **32768** if the Cpu parameter is set to 16000.
        # *   This parameter is set to **65536** if the Cpu parameter is set to 8000, 16000, or 32000.
        # *   This parameter is set to **131072** if the Cpu parameter is set to 32000.
        self.mem = mem
        # The returned message.
        self.message = message
        # The ID of the namespace.
        self.namespace_id = namespace_id
        # The region ID.
        self.region_id = region_id
        # The number of instances that were successfully run.
        self.succeeded = succeeded
        # Indicates whether the job template is suspended.
        self.suspend = suspend
        # The tags of the job template.
        self.tags = tags
        self.trigger_config = trigger_config

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active is not None:
            result['Active'] = self.active
        if self.app_description is not None:
            result['AppDescription'] = self.app_description
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.completion_time is not None:
            result['CompletionTime'] = self.completion_time
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.failed is not None:
            result['Failed'] = self.failed
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.last_changeorder_state is not None:
            result['LastChangeorderState'] = self.last_changeorder_state
        if self.last_job_state is not None:
            result['LastJobState'] = self.last_job_state
        if self.last_start_time is not None:
            result['LastStartTime'] = self.last_start_time
        if self.mem is not None:
            result['Mem'] = self.mem
        if self.message is not None:
            result['Message'] = self.message
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.succeeded is not None:
            result['Succeeded'] = self.succeeded
        if self.suspend is not None:
            result['Suspend'] = self.suspend
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.trigger_config is not None:
            result['TriggerConfig'] = self.trigger_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Active') is not None:
            self.active = m.get('Active')
        if m.get('AppDescription') is not None:
            self.app_description = m.get('AppDescription')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('CompletionTime') is not None:
            self.completion_time = m.get('CompletionTime')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('Failed') is not None:
            self.failed = m.get('Failed')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('LastChangeorderState') is not None:
            self.last_changeorder_state = m.get('LastChangeorderState')
        if m.get('LastJobState') is not None:
            self.last_job_state = m.get('LastJobState')
        if m.get('LastStartTime') is not None:
            self.last_start_time = m.get('LastStartTime')
        if m.get('Mem') is not None:
            self.mem = m.get('Mem')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Succeeded') is not None:
            self.succeeded = m.get('Succeeded')
        if m.get('Suspend') is not None:
            self.suspend = m.get('Suspend')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListJobsResponseBodyDataApplicationsTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TriggerConfig') is not None:
            self.trigger_config = m.get('TriggerConfig')
        return self


class ListJobsResponseBodyData(TeaModel):
    def __init__(
        self,
        applications: List[ListJobsResponseBodyDataApplications] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # The job templates.
        self.applications = applications
        # The page number of the returned page.
        self.current_page = current_page
        # The number of entries returned on each page.
        self.page_size = page_size
        # The total number of job templates.
        self.total_size = total_size

    def validate(self):
        if self.applications:
            for k in self.applications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Applications'] = []
        if self.applications is not None:
            for k in self.applications:
                result['Applications'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.applications = []
        if m.get('Applications') is not None:
            for k in m.get('Applications'):
                temp_model = ListJobsResponseBodyDataApplications()
                self.applications.append(temp_model.from_map(k))
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListJobsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        current_page: int = None,
        data: ListJobsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total_size: int = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The page number of the returned page.
        self.current_page = current_page
        # The job templates.
        self.data = data
        # The error code returned. Take note of the following rules:
        # 
        # *   If the call is successful, **ErrorCode** is not returned.
        # *   If the call fails, **ErrorCode** is returned. For more information, see the "**Error codes**" section in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The number of entries returned on each page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # Indicates whether the applications were obtained. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The total number of job templates.
        self.total_size = total_size

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Data') is not None:
            temp_model = ListJobsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLogConfigsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        current_page: int = None,
        page_size: int = None,
    ):
        # 10
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the request.
        # 
        # This parameter is required.
        self.current_page = current_page
        # 1
        # 
        # This parameter is required.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListLogConfigsResponseBodyDataLogConfigs(TeaModel):
    def __init__(
        self,
        config_name: str = None,
        create_time: str = None,
        log_dir: str = None,
        log_type: str = None,
        region_id: str = None,
        sls_log_store: str = None,
        sls_project: str = None,
        store_type: str = None,
    ):
        # The path of logs.
        self.config_name = config_name
        # The storage type of logs.
        self.create_time = create_time
        # The path of the log file (log source).
        self.log_dir = log_dir
        # The ID of the region.
        self.log_type = log_type
        # The number of the returned page.
        self.region_id = region_id
        # The time when the configuration was created.
        self.sls_log_store = sls_log_store
        # The type of the log. Set this value to **file_log**.
        self.sls_project = sls_project
        # The ID of the Log Service project.
        self.store_type = store_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_name is not None:
            result['ConfigName'] = self.config_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.log_dir is not None:
            result['LogDir'] = self.log_dir
        if self.log_type is not None:
            result['LogType'] = self.log_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.sls_log_store is not None:
            result['SlsLogStore'] = self.sls_log_store
        if self.sls_project is not None:
            result['SlsProject'] = self.sls_project
        if self.store_type is not None:
            result['StoreType'] = self.store_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigName') is not None:
            self.config_name = m.get('ConfigName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LogDir') is not None:
            self.log_dir = m.get('LogDir')
        if m.get('LogType') is not None:
            self.log_type = m.get('LogType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SlsLogStore') is not None:
            self.sls_log_store = m.get('SlsLogStore')
        if m.get('SlsProject') is not None:
            self.sls_project = m.get('SlsProject')
        if m.get('StoreType') is not None:
            self.store_type = m.get('StoreType')
        return self


class ListLogConfigsResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        log_configs: List[ListLogConfigsResponseBodyDataLogConfigs] = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # The total number of returned entries.
        self.current_page = current_page
        # The details of the logging configuration.
        self.log_configs = log_configs
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.page_size = page_size
        # The number of entries returned on each page.
        self.total_size = total_size

    def validate(self):
        if self.log_configs:
            for k in self.log_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['LogConfigs'] = []
        if self.log_configs is not None:
            for k in self.log_configs:
                result['LogConfigs'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.log_configs = []
        if m.get('LogConfigs') is not None:
            for k in m.get('LogConfigs'):
                temp_model = ListLogConfigsResponseBodyDataLogConfigs()
                self.log_configs.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListLogConfigsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListLogConfigsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # Indicates whether the logging configurations of an application were obtained. Valid values:
        # 
        # *   **true**: indicates that the configurations were obtained.
        # *   **false**: indicates that the configurations could not be obtained.
        self.code = code
        # The logging configurations.
        self.data = data
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.error_code = error_code
        # The ID of the trace. It can be used to query the details of a request.
        self.message = message
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.request_id = request_id
        self.success = success
        # The logging configurations.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListLogConfigsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListLogConfigsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLogConfigsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLogConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListNamespaceChangeOrdersRequest(TeaModel):
    def __init__(
        self,
        co_status: str = None,
        co_type: str = None,
        current_page: int = None,
        key: str = None,
        namespace_id: str = None,
        page_size: int = None,
    ):
        # 2
        self.co_status = co_status
        # CoBatchStartApplication
        self.co_type = co_type
        # 1
        self.current_page = current_page
        # test
        self.key = key
        # cn-shanghai:test
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # 20
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.co_status is not None:
            result['CoStatus'] = self.co_status
        if self.co_type is not None:
            result['CoType'] = self.co_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.key is not None:
            result['Key'] = self.key
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CoStatus') is not None:
            self.co_status = m.get('CoStatus')
        if m.get('CoType') is not None:
            self.co_type = m.get('CoType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListNamespaceChangeOrdersResponseBodyDataChangeOrderList(TeaModel):
    def __init__(
        self,
        batch_count: int = None,
        batch_type: str = None,
        change_order_id: str = None,
        co_type: str = None,
        co_type_code: str = None,
        create_time: str = None,
        create_user_id: str = None,
        description: str = None,
        finish_time: str = None,
        group_id: str = None,
        namespace_id: str = None,
        pipelines: str = None,
        source: str = None,
        status: int = None,
        user_id: str = None,
    ):
        # The number of release batches.
        self.batch_count = batch_count
        # The mode in which the release batches are determined. Valid values:
        # 
        # *   **auto**: SAE automatically determines the release batches.
        # *   **manual**: You must manually determine the release batches.
        self.batch_type = batch_type
        # The ID of the change order.
        self.change_order_id = change_order_id
        # The type of the change order, which corresponds the **CoTypeCode** parameter.
        self.co_type = co_type
        # The code of the change order type. Valid values:
        # 
        # *   **CoBatchStartApplication**: starts multiple applications concurrently.
        # *   **CoBatchStopApplication**: stops multiple applications concurrently.
        self.co_type_code = co_type_code
        # The time when the change order was created.
        self.create_time = create_time
        # The ID of the user who created the change order.
        self.create_user_id = create_user_id
        # The description of the change order.
        self.description = description
        # The time when the change order was completed.
        self.finish_time = finish_time
        # The ID of the group.
        self.group_id = group_id
        # The ID of the namespace.
        self.namespace_id = namespace_id
        # The information about release batches.
        self.pipelines = pipelines
        # The source of the change order.
        self.source = source
        # The status of the change order. Valid values:
        # 
        # *   **0**: The change order is being prepared.
        # *   **1**: The change order is being executed.
        # *   **2**: The change order was executed.
        # *   **3**: The change order could not be executed.
        # *   **6**: The change order was terminated.
        # *   **10**: The change order could not be executed due to a system exception.
        self.status = status
        # The ID of the user.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_count is not None:
            result['BatchCount'] = self.batch_count
        if self.batch_type is not None:
            result['BatchType'] = self.batch_type
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.co_type is not None:
            result['CoType'] = self.co_type
        if self.co_type_code is not None:
            result['CoTypeCode'] = self.co_type_code
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user_id is not None:
            result['CreateUserId'] = self.create_user_id
        if self.description is not None:
            result['Description'] = self.description
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.pipelines is not None:
            result['Pipelines'] = self.pipelines
        if self.source is not None:
            result['Source'] = self.source
        if self.status is not None:
            result['Status'] = self.status
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BatchCount') is not None:
            self.batch_count = m.get('BatchCount')
        if m.get('BatchType') is not None:
            self.batch_type = m.get('BatchType')
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('CoType') is not None:
            self.co_type = m.get('CoType')
        if m.get('CoTypeCode') is not None:
            self.co_type_code = m.get('CoTypeCode')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUserId') is not None:
            self.create_user_id = m.get('CreateUserId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('Pipelines') is not None:
            self.pipelines = m.get('Pipelines')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListNamespaceChangeOrdersResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_list: List[ListNamespaceChangeOrdersResponseBodyDataChangeOrderList] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # The list of change orders.
        self.change_order_list = change_order_list
        # The number of the returned page.
        self.current_page = current_page
        # The number of entries returned on each page.
        self.page_size = page_size
        # The total number of change orders.
        self.total_size = total_size

    def validate(self):
        if self.change_order_list:
            for k in self.change_order_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ChangeOrderList'] = []
        if self.change_order_list is not None:
            for k in self.change_order_list:
                result['ChangeOrderList'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.change_order_list = []
        if m.get('ChangeOrderList') is not None:
            for k in m.get('ChangeOrderList'):
                temp_model = ListNamespaceChangeOrdersResponseBodyDataChangeOrderList()
                self.change_order_list.append(temp_model.from_map(k))
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListNamespaceChangeOrdersResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListNamespaceChangeOrdersResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the list of change orders was obtained. Valid values:
        # 
        # *   **true**: indicates that the list was obtained.
        # *   **false**: indicates that the list could not be obtained.
        self.success = success
        # The ID of the trace. It is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListNamespaceChangeOrdersResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListNamespaceChangeOrdersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListNamespaceChangeOrdersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListNamespaceChangeOrdersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListNamespacedConfigMapsRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
    ):
        # cn-hangzhou
        # 
        # This parameter is required.
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class ListNamespacedConfigMapsResponseBodyDataConfigMapsRelateApps(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        return self


class ListNamespacedConfigMapsResponseBodyDataConfigMaps(TeaModel):
    def __init__(
        self,
        config_map_id: int = None,
        create_time: int = None,
        data: Dict[str, Any] = None,
        description: str = None,
        name: str = None,
        namespace_id: str = None,
        relate_apps: List[ListNamespacedConfigMapsResponseBodyDataConfigMapsRelateApps] = None,
        update_time: int = None,
    ):
        # The ID of the ConfigMap instance.
        self.config_map_id = config_map_id
        # The time when the instance was created.
        self.create_time = create_time
        # The data of ConfigMap key-value pairs. Format:
        # 
        # {"k1":"v1", "k2":"v2"}
        # 
        # k specifies a key and v specifies a value. For more information, see [Manage and use configurations](https://help.aliyun.com/document_detail/171326.html).
        self.data = data
        # The description of the instance.
        self.description = description
        # The name of the ConfigMap instance.
        self.name = name
        # The ID of the namespace.
        self.namespace_id = namespace_id
        # The application that is associated with the instance.
        self.relate_apps = relate_apps
        # The time when the instance was last modified.
        self.update_time = update_time

    def validate(self):
        if self.relate_apps:
            for k in self.relate_apps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.data is not None:
            result['Data'] = self.data
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        result['RelateApps'] = []
        if self.relate_apps is not None:
            for k in self.relate_apps:
                result['RelateApps'].append(k.to_map() if k else None)
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        self.relate_apps = []
        if m.get('RelateApps') is not None:
            for k in m.get('RelateApps'):
                temp_model = ListNamespacedConfigMapsResponseBodyDataConfigMapsRelateApps()
                self.relate_apps.append(temp_model.from_map(k))
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class ListNamespacedConfigMapsResponseBodyData(TeaModel):
    def __init__(
        self,
        config_maps: List[ListNamespacedConfigMapsResponseBodyDataConfigMaps] = None,
    ):
        # The ConfigMap instances.
        self.config_maps = config_maps

    def validate(self):
        if self.config_maps:
            for k in self.config_maps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConfigMaps'] = []
        if self.config_maps is not None:
            for k in self.config_maps:
                result['ConfigMaps'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.config_maps = []
        if m.get('ConfigMaps') is not None:
            for k in m.get('ConfigMaps'):
                temp_model = ListNamespacedConfigMapsResponseBodyDataConfigMaps()
                self.config_maps.append(temp_model.from_map(k))
        return self


class ListNamespacedConfigMapsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListNamespacedConfigMapsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the call was successful.
        # *   **3xx**: indicates that the call was redirected.
        # *   **4xx**: indicates that the call failed.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The returned result.
        self.data = data
        # The returned error code. Valid values:
        # 
        # - If the call is successful, the **ErrorCode** parameter is not returned.
        # - If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The returned information. Valid values:
        # 
        # *   If the call is successful, **success** is returned.
        # *   If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the ConfigMap instances were obtained. Valid values:
        # 
        # *   **true**: The instances were obtained.
        # *   **false**: The instances failed to be obtained.
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListNamespacedConfigMapsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListNamespacedConfigMapsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListNamespacedConfigMapsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListNamespacedConfigMapsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPublishedServicesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class ListPublishedServicesResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group_2ip: str = None,
        groups: List[str] = None,
        ips: List[str] = None,
        name: str = None,
        type: str = None,
        version: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The reserved parameter. This parameter does not take effect.
        self.group_2ip = group_2ip
        # The service group that corresponds to the consumed service.
        self.groups = groups
        # The addresses where services can be subscribed to.
        self.ips = ips
        # The name of the published service.
        self.name = name
        # The type of the published service.
        self.type = type
        # The version of the published services.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.group_2ip is not None:
            result['Group2Ip'] = self.group_2ip
        if self.groups is not None:
            result['Groups'] = self.groups
        if self.ips is not None:
            result['Ips'] = self.ips
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Group2Ip') is not None:
            self.group_2ip = m.get('Group2Ip')
        if m.get('Groups') is not None:
            self.groups = m.get('Groups')
        if m.get('Ips') is not None:
            self.ips = m.get('Ips')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListPublishedServicesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListPublishedServicesResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The details of the microservices.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the list of microservices was queried. Valid values:
        # 
        # *   **true**: The list was queried.
        # *   **false**: The list failed to be queried.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListPublishedServicesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListPublishedServicesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPublishedServicesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPublishedServicesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSecretsRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
    ):
        # The ID of the namespace in which the Secrets reside. By default, the namespace ID is the same as the region ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class ListSecretsResponseBodyDataSecretsRelateApps(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
    ):
        # The application ID.
        self.app_id = app_id
        # The application name.
        self.app_name = app_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        return self


class ListSecretsResponseBodyDataSecrets(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        namespace_id: str = None,
        relate_apps: List[ListSecretsResponseBodyDataSecretsRelateApps] = None,
        secret_id: int = None,
        secret_name: str = None,
        secret_type: str = None,
        update_time: int = None,
    ):
        # The time when the Secret was created.
        self.create_time = create_time
        # The namespace ID.
        self.namespace_id = namespace_id
        # The associated applications.
        self.relate_apps = relate_apps
        # The Secret ID.
        self.secret_id = secret_id
        # The Secret name.
        self.secret_name = secret_name
        # The Secret type.
        # 
        # Set the value to **kubernetes.io/dockerconfigjson**. The value indicates the secret for the username and password of the image repository and is used for authentication when images are pulled during application deployment.
        self.secret_type = secret_type
        # The time when the Secret was updated.
        self.update_time = update_time

    def validate(self):
        if self.relate_apps:
            for k in self.relate_apps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        result['RelateApps'] = []
        if self.relate_apps is not None:
            for k in self.relate_apps:
                result['RelateApps'].append(k.to_map() if k else None)
        if self.secret_id is not None:
            result['SecretId'] = self.secret_id
        if self.secret_name is not None:
            result['SecretName'] = self.secret_name
        if self.secret_type is not None:
            result['SecretType'] = self.secret_type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        self.relate_apps = []
        if m.get('RelateApps') is not None:
            for k in m.get('RelateApps'):
                temp_model = ListSecretsResponseBodyDataSecretsRelateApps()
                self.relate_apps.append(temp_model.from_map(k))
        if m.get('SecretId') is not None:
            self.secret_id = m.get('SecretId')
        if m.get('SecretName') is not None:
            self.secret_name = m.get('SecretName')
        if m.get('SecretType') is not None:
            self.secret_type = m.get('SecretType')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class ListSecretsResponseBodyData(TeaModel):
    def __init__(
        self,
        secrets: List[ListSecretsResponseBodyDataSecrets] = None,
    ):
        # The Secrets.
        self.secrets = secrets

    def validate(self):
        if self.secrets:
            for k in self.secrets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Secrets'] = []
        if self.secrets is not None:
            for k in self.secrets:
                result['Secrets'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.secrets = []
        if m.get('Secrets') is not None:
            for k in m.get('Secrets'):
                temp_model = ListSecretsResponseBodyDataSecrets()
                self.secrets.append(temp_model.from_map(k))
        return self


class ListSecretsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListSecretsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The data returned.
        self.data = data
        # The error code returned. Take note of the following rules:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section in this topic.
        self.error_code = error_code
        # The returned message. Take note of the following rules:
        # 
        # *   If the call is successful, **success** is returned.
        # *   If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the call is successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListSecretsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListSecretsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSecretsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSecretsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSwimmingLaneGatewayRoutesRequest(TeaModel):
    def __init__(
        self,
        gateway_unique_id: str = None,
        namespace_id: str = None,
    ):
        self.gateway_unique_id = gateway_unique_id
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gateway_unique_id is not None:
            result['GatewayUniqueId'] = self.gateway_unique_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GatewayUniqueId') is not None:
            self.gateway_unique_id = m.get('GatewayUniqueId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class ListSwimmingLaneGatewayRoutesResponseBodyDataRoutePredicatePathPredicate(TeaModel):
    def __init__(
        self,
        path: str = None,
        type: str = None,
    ):
        self.path = path
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.path is not None:
            result['Path'] = self.path
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListSwimmingLaneGatewayRoutesResponseBodyDataRoutePredicate(TeaModel):
    def __init__(
        self,
        path_predicate: ListSwimmingLaneGatewayRoutesResponseBodyDataRoutePredicatePathPredicate = None,
    ):
        self.path_predicate = path_predicate

    def validate(self):
        if self.path_predicate:
            self.path_predicate.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.path_predicate is not None:
            result['PathPredicate'] = self.path_predicate.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PathPredicate') is not None:
            temp_model = ListSwimmingLaneGatewayRoutesResponseBodyDataRoutePredicatePathPredicate()
            self.path_predicate = temp_model.from_map(m['PathPredicate'])
        return self


class ListSwimmingLaneGatewayRoutesResponseBodyData(TeaModel):
    def __init__(
        self,
        route_id: int = None,
        route_name: str = None,
        route_predicate: ListSwimmingLaneGatewayRoutesResponseBodyDataRoutePredicate = None,
    ):
        self.route_id = route_id
        self.route_name = route_name
        self.route_predicate = route_predicate

    def validate(self):
        if self.route_predicate:
            self.route_predicate.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.route_id is not None:
            result['RouteId'] = self.route_id
        if self.route_name is not None:
            result['RouteName'] = self.route_name
        if self.route_predicate is not None:
            result['RoutePredicate'] = self.route_predicate.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RouteId') is not None:
            self.route_id = m.get('RouteId')
        if m.get('RouteName') is not None:
            self.route_name = m.get('RouteName')
        if m.get('RoutePredicate') is not None:
            temp_model = ListSwimmingLaneGatewayRoutesResponseBodyDataRoutePredicate()
            self.route_predicate = temp_model.from_map(m['RoutePredicate'])
        return self


class ListSwimmingLaneGatewayRoutesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListSwimmingLaneGatewayRoutesResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListSwimmingLaneGatewayRoutesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListSwimmingLaneGatewayRoutesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSwimmingLaneGatewayRoutesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSwimmingLaneGatewayRoutesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSwimmingLaneGroupTagsRequest(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        namespace_id: str = None,
    ):
        self.group_id = group_id
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class ListSwimmingLaneGroupTagsResponseBodyData(TeaModel):
    def __init__(
        self,
        metadata: str = None,
        tag: str = None,
    ):
        self.metadata = metadata
        self.tag = tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metadata is not None:
            result['Metadata'] = self.metadata
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metadata') is not None:
            self.metadata = m.get('Metadata')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class ListSwimmingLaneGroupTagsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListSwimmingLaneGroupTagsResponseBodyData] = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListSwimmingLaneGroupTagsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListSwimmingLaneGroupTagsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSwimmingLaneGroupTagsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSwimmingLaneGroupTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTagResourcesRequest(TeaModel):
    def __init__(
        self,
        next_token: str = None,
        region_id: str = None,
        resource_ids: str = None,
        resource_type: str = None,
        tags: str = None,
    ):
        # A maximum of 50 entries can be returned for a query. If a query generates more than 50 entries, the NextToken parameter is returned with the first 50 entries. You can use the NextToken parameter value to retrieve the subsequent entries that are not returned in the current query result.
        self.next_token = next_token
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The resource ID. Separate multiple resource IDs with comma (,). This parameter is required if you do not specify the **Tags** parameter.
        self.resource_ids = resource_ids
        # The type of the resource. Set the value to `application`.
        # 
        # This parameter is required.
        self.resource_type = resource_type
        # The tag in the format of a key-value pair. This parameter is required if you do not specify the **ResourceIds** parameter. The following parameters are involved:
        # 
        # *   **key**: the tag key. It cannot exceed 128 characters in length.
        # *   **value**: the tag value. It cannot exceed 128 characters in length.
        # 
        # Tag keys and tag values are case-sensitive. If you specify multiple tags, the system adds all the tags to the specified resources. Each tag key on a resource can have only one tag value. If you create a tag that has the same key as an existing tag, the value of the existing tag is overwritten.
        # 
        # Tag keys and tag values cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.
        self.tags = tags

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_ids is not None:
            result['ResourceIds'] = self.resource_ids
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceIds') is not None:
            self.resource_ids = m.get('ResourceIds')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class ListTagResourcesResponseBodyDataTagResources(TeaModel):
    def __init__(
        self,
        resource_id: str = None,
        resource_type: str = None,
        tag_key: str = None,
        tag_value: str = None,
    ):
        # The ID of the application.
        self.resource_id = resource_id
        # The type of the resource. Valid value: `application`.
        self.resource_type = resource_type
        # The key of the tag.
        self.tag_key = tag_key
        # The value of the tag.
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class ListTagResourcesResponseBodyData(TeaModel):
    def __init__(
        self,
        next_token: str = None,
        tag_resources: List[ListTagResourcesResponseBodyDataTagResources] = None,
    ):
        # A maximum of 50 entries can be returned for a query. If a query generates more than 50 entries, the NextToken parameter is returned with the first 50 entries. You can use the NextToken parameter value to retrieve the subsequent entries that are not returned in the current query result.
        self.next_token = next_token
        # The mapping relationships between applications and tags.
        self.tag_resources = tag_resources

    def validate(self):
        if self.tag_resources:
            for k in self.tag_resources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        result['TagResources'] = []
        if self.tag_resources is not None:
            for k in self.tag_resources:
                result['TagResources'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        self.tag_resources = []
        if m.get('TagResources') is not None:
            for k in m.get('TagResources'):
                temp_model = ListTagResourcesResponseBodyDataTagResources()
                self.tag_resources.append(temp_model.from_map(k))
        return self


class ListTagResourcesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListTagResourcesResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the mapping relationships between applications and tags were queried. Valid values:
        # 
        # *   **true**: The mapping relationships were queried.
        # *   **false**: The mapping relationships failed to be queried.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListTagResourcesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListTagResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTagResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWebApplicationInstancesRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        instance_ids: List[str] = None,
        limit: str = None,
        namespace_id: str = None,
        start_time: int = None,
        statuses: List[str] = None,
        version_ids: List[str] = None,
    ):
        # The time when the operation ended.
        self.end_time = end_time
        # The instance ID.
        self.instance_ids = instance_ids
        # The number of application instances returned.
        self.limit = limit
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # The time when the task was created.
        self.start_time = start_time
        # The status of the application instance.
        self.statuses = statuses
        # The ID of the application version.
        self.version_ids = version_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.statuses is not None:
            result['Statuses'] = self.statuses
        if self.version_ids is not None:
            result['VersionIds'] = self.version_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Statuses') is not None:
            self.statuses = m.get('Statuses')
        if m.get('VersionIds') is not None:
            self.version_ids = m.get('VersionIds')
        return self


class ListWebApplicationInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        instance_ids_shrink: str = None,
        limit: str = None,
        namespace_id: str = None,
        start_time: int = None,
        statuses_shrink: str = None,
        version_ids_shrink: str = None,
    ):
        # The time when the operation ended.
        self.end_time = end_time
        # The instance ID.
        self.instance_ids_shrink = instance_ids_shrink
        # The number of application instances returned.
        self.limit = limit
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # The time when the task was created.
        self.start_time = start_time
        # The status of the application instance.
        self.statuses_shrink = statuses_shrink
        # The ID of the application version.
        self.version_ids_shrink = version_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_ids_shrink is not None:
            result['InstanceIds'] = self.instance_ids_shrink
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.statuses_shrink is not None:
            result['Statuses'] = self.statuses_shrink
        if self.version_ids_shrink is not None:
            result['VersionIds'] = self.version_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceIds') is not None:
            self.instance_ids_shrink = m.get('InstanceIds')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Statuses') is not None:
            self.statuses_shrink = m.get('Statuses')
        if m.get('VersionIds') is not None:
            self.version_ids_shrink = m.get('VersionIds')
        return self


class ListWebApplicationInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWebApplicationInstancesBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWebApplicationInstancesBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWebApplicationRevisionsRequest(TeaModel):
    def __init__(
        self,
        limit: int = None,
        namespace_id: str = None,
        next_token: str = None,
    ):
        # The number of applications returned.
        self.limit = limit
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # The pagination token.
        self.next_token = next_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        return self


class ListWebApplicationRevisionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWebApplicationRevisionsBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWebApplicationRevisionsBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWebApplicationsRequest(TeaModel):
    def __init__(
        self,
        limit: int = None,
        namespace_id: str = None,
        next_token: str = None,
        prefix: str = None,
    ):
        # The number of applications returned.
        self.limit = limit
        # The namespace ID.
        self.namespace_id = namespace_id
        # The pagination token.
        self.next_token = next_token
        # The prefix of the application name.
        self.prefix = prefix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.prefix is not None:
            result['Prefix'] = self.prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Prefix') is not None:
            self.prefix = m.get('Prefix')
        return self


class ListWebApplicationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWebApplicationsBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWebApplicationsBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWebCustomDomainsRequest(TeaModel):
    def __init__(
        self,
        application_id: str = None,
        limit: int = None,
        namespace_id: str = None,
        next_token: str = None,
        prefix: str = None,
    ):
        # The application ID.
        self.application_id = application_id
        # The number of custom domain names returned.
        self.limit = limit
        # The namespace ID.
        self.namespace_id = namespace_id
        # The pagination token.
        self.next_token = next_token
        # The prefix of the custom domain name that you want to query.
        self.prefix = prefix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_id is not None:
            result['ApplicationId'] = self.application_id
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.prefix is not None:
            result['Prefix'] = self.prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationId') is not None:
            self.application_id = m.get('ApplicationId')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Prefix') is not None:
            self.prefix = m.get('Prefix')
        return self


class ListWebCustomDomainsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWebCustomDomainBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWebCustomDomainBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OpenSaeServiceResponseBody(TeaModel):
    def __init__(
        self,
        order_id: str = None,
        request_id: str = None,
    ):
        # PushEvent
        self.order_id = order_id
        # enableWAF
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OpenSaeServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OpenSaeServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OpenSaeServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PublishWebApplicationRevisionRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
        body: PublishWebApplicationRevisionInput = None,
    ):
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # The configurations of the version.
        # 
        # This parameter is required.
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('body') is not None:
            temp_model = PublishWebApplicationRevisionInput()
            self.body = temp_model.from_map(m['body'])
        return self


class PublishWebApplicationRevisionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WebApplicationRevisionBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WebApplicationRevisionBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryResourceStaticsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # 7171a6ca-d1cd-4928-8642-7d5cfe69\\*\\*\\*\\*\
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class QueryResourceStaticsResponseBodyDataRealTimeRes(TeaModel):
    def __init__(
        self,
        cpu: float = None,
        ephemeral_storage: float = None,
        memory: float = None,
    ):
        # The CPU usage. Unit: core per minute.
        self.cpu = cpu
        # The storage size of the temporary storage space. Unit: GiB.
        self.ephemeral_storage = ephemeral_storage
        # The memory usage. Unit: GiB per minute.
        self.memory = memory

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.ephemeral_storage is not None:
            result['EphemeralStorage'] = self.ephemeral_storage
        if self.memory is not None:
            result['Memory'] = self.memory
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('EphemeralStorage') is not None:
            self.ephemeral_storage = m.get('EphemeralStorage')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        return self


class QueryResourceStaticsResponseBodyDataSummary(TeaModel):
    def __init__(
        self,
        active_cpu: float = None,
        cpu: float = None,
        cu: float = None,
        ephemeral_storage: float = None,
        gpu_a10: float = None,
        gpu_ppu_810e: float = None,
        idle_cpu: float = None,
        memory: float = None,
    ):
        # The usage of active vCPU. Unit: Core*min.
        self.active_cpu = active_cpu
        # The CPU usage. Unit: core per minute.
        self.cpu = cpu
        # The CU usage.
        self.cu = cu
        # The storage size of the temporary storage space. Unit: GiB.
        self.ephemeral_storage = ephemeral_storage
        self.gpu_a10 = gpu_a10
        self.gpu_ppu_810e = gpu_ppu_810e
        # The usage of idle CPU. Unit: Core*min.
        self.idle_cpu = idle_cpu
        # The memory usage. Unit: GiB per minute.
        self.memory = memory

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_cpu is not None:
            result['ActiveCpu'] = self.active_cpu
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.ephemeral_storage is not None:
            result['EphemeralStorage'] = self.ephemeral_storage
        if self.gpu_a10 is not None:
            result['GpuA10'] = self.gpu_a10
        if self.gpu_ppu_810e is not None:
            result['GpuPpu810e'] = self.gpu_ppu_810e
        if self.idle_cpu is not None:
            result['IdleCpu'] = self.idle_cpu
        if self.memory is not None:
            result['Memory'] = self.memory
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActiveCpu') is not None:
            self.active_cpu = m.get('ActiveCpu')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('EphemeralStorage') is not None:
            self.ephemeral_storage = m.get('EphemeralStorage')
        if m.get('GpuA10') is not None:
            self.gpu_a10 = m.get('GpuA10')
        if m.get('GpuPpu810e') is not None:
            self.gpu_ppu_810e = m.get('GpuPpu810e')
        if m.get('IdleCpu') is not None:
            self.idle_cpu = m.get('IdleCpu')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        return self


class QueryResourceStaticsResponseBodyData(TeaModel):
    def __init__(
        self,
        real_time_res: QueryResourceStaticsResponseBodyDataRealTimeRes = None,
        summary: QueryResourceStaticsResponseBodyDataSummary = None,
    ):
        # The real-time resource usage.
        self.real_time_res = real_time_res
        # The resource usage of the current month.
        self.summary = summary

    def validate(self):
        if self.real_time_res:
            self.real_time_res.validate()
        if self.summary:
            self.summary.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.real_time_res is not None:
            result['RealTimeRes'] = self.real_time_res.to_map()
        if self.summary is not None:
            result['Summary'] = self.summary.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RealTimeRes') is not None:
            temp_model = QueryResourceStaticsResponseBodyDataRealTimeRes()
            self.real_time_res = temp_model.from_map(m['RealTimeRes'])
        if m.get('Summary') is not None:
            temp_model = QueryResourceStaticsResponseBodyDataSummary()
            self.summary = temp_model.from_map(m['Summary'])
        return self


class QueryResourceStaticsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryResourceStaticsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.code = code
        # The resource usage.
        self.data = data
        # The error code. 
        # 
        # - The **ErrorCode** parameter is not returned when the request succeeds.
        # - The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the resource usage of an application was obtained. Valid values:
        # 
        # *   **true**: indicates that the resource usage was obtained.
        # *   **false**: indicates that the resource usage could not be obtained.
        self.success = success
        # The ID of the trace. It can be used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryResourceStaticsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class QueryResourceStaticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryResourceStaticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryResourceStaticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReduceApplicationCapacityByInstanceIdsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        instance_ids: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the instance. Separate multiple instances with commas (,).
        # 
        # This parameter is required.
        self.instance_ids = instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        return self


class ReduceApplicationCapacityByInstanceIdsResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change process.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class ReduceApplicationCapacityByInstanceIdsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ReduceApplicationCapacityByInstanceIdsResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code.
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The information about the change process.
        self.data = data
        # The error code returned if the request failed. Take note of the following rules:
        # 
        # *   The **ErrorCode** parameter is not returned if the request succeeds.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The additional information that is returned. Take note of the following rules:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the information of the change order was queried. Take note of the following rules:
        # 
        # *   **true**: The information was queried.
        # *   **false**: The image failed to be found.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ReduceApplicationCapacityByInstanceIdsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ReduceApplicationCapacityByInstanceIdsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReduceApplicationCapacityByInstanceIdsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReduceApplicationCapacityByInstanceIdsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RescaleApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        auto_enable_application_scaling_rule: bool = None,
        min_ready_instance_ratio: int = None,
        min_ready_instances: int = None,
        replicas: int = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # Specifies whether to automatically enable an auto scaling policy for the application. Take note of the following rules:
        # 
        # *   **true**: turns on Logon-free Sharing
        # *   **false**: turns off Logon-free Sharing
        self.auto_enable_application_scaling_rule = auto_enable_application_scaling_rule
        # The percentage of the minimum number of available instances. Take note of the following rules:
        # 
        # *   If you set the value to **-1**, the minimum number of available instances is not determined based on this parameter. Default value: -1.
        # *   If you set the value to a number **from 0 to 100**, the minimum number of available instances is calculated by using the following formula: Current number of instances × (Value of MinReadyInstanceRatio × 100%). The value is the nearest integer rounded up from the calculated result. For example, if the percentage is set to **50**% and five instances are available, the minimum number of available instances is 3.
        # 
        # > When **MinReadyInstance** and **MinReadyInstanceRatio** are specified and **MinReadyInstanceRatio** is set to a number from 0 to 100, the value of MinReadyInstanceRatio** takes precedence.**** For example, if **MinReadyInstances** is set to **5, and **MinReadyInstanceRatio** is set to **50**, the minimum number of available instances is set to the nearest integer rounded up from the calculated result of the following formula: Current number of instances × **50%**.
        self.min_ready_instance_ratio = min_ready_instance_ratio
        # The minimum number of available instances. Special values:
        # 
        # *   If you set the value to **0**, business interruptions occur when the application is updated.
        # *   If you set the value to \\*\\*-1\\*\\*, the minimum number of available instances is automatically set to a system-recommended value. The value is the nearest integer to which the calculated result of the following formula is rounded up: Current number of instances × 25%. For example, if five instances are available, the minimum number of available instances is calculated by using the following formula: 5 × 25% = 1.25. In this case, the minimum number of available instances is 2.
        # 
        # > Make sure that at least one instance is available during application deployment and rollback to prevent business interruptions.
        self.min_ready_instances = min_ready_instances
        # The expected number of instances.
        # 
        # This parameter is required.
        self.replicas = replicas

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.auto_enable_application_scaling_rule is not None:
            result['AutoEnableApplicationScalingRule'] = self.auto_enable_application_scaling_rule
        if self.min_ready_instance_ratio is not None:
            result['MinReadyInstanceRatio'] = self.min_ready_instance_ratio
        if self.min_ready_instances is not None:
            result['MinReadyInstances'] = self.min_ready_instances
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AutoEnableApplicationScalingRule') is not None:
            self.auto_enable_application_scaling_rule = m.get('AutoEnableApplicationScalingRule')
        if m.get('MinReadyInstanceRatio') is not None:
            self.min_ready_instance_ratio = m.get('MinReadyInstanceRatio')
        if m.get('MinReadyInstances') is not None:
            self.min_ready_instances = m.get('MinReadyInstances')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        return self


class RescaleApplicationResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class RescaleApplicationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: RescaleApplicationResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. Take note of the following rules:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The response.
        self.data = data
        # The error code returned if the request failed. Take note of the following rules:
        # 
        # *   The **ErrorCode** parameter is not returned if the request succeeds.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The message returned for the operation.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the application is successfully scaled. Take note of the following rules:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = RescaleApplicationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RescaleApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RescaleApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RescaleApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RescaleApplicationVerticallyRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        cpu: str = None,
        disk_size: str = None,
        memory: str = None,
        auto_enable_application_scaling_rule: bool = None,
        min_ready_instance_ratio: int = None,
        min_ready_instances: int = None,
    ):
        # The app ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # Target CPU specification. Unit: millicore.
        # 
        # This parameter is required.
        self.cpu = cpu
        # The disk size. Unit: GB.
        self.disk_size = disk_size
        # Target memory specification. Unit: MB.
        # 
        # This parameter is required.
        self.memory = memory
        # Enable application scale rules automatically.
        self.auto_enable_application_scaling_rule = auto_enable_application_scaling_rule
        # The ratio of minimum ready instances.
        self.min_ready_instance_ratio = min_ready_instance_ratio
        # Minimum ready instances.
        self.min_ready_instances = min_ready_instances

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.disk_size is not None:
            result['DiskSize'] = self.disk_size
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.auto_enable_application_scaling_rule is not None:
            result['autoEnableApplicationScalingRule'] = self.auto_enable_application_scaling_rule
        if self.min_ready_instance_ratio is not None:
            result['minReadyInstanceRatio'] = self.min_ready_instance_ratio
        if self.min_ready_instances is not None:
            result['minReadyInstances'] = self.min_ready_instances
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('DiskSize') is not None:
            self.disk_size = m.get('DiskSize')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('autoEnableApplicationScalingRule') is not None:
            self.auto_enable_application_scaling_rule = m.get('autoEnableApplicationScalingRule')
        if m.get('minReadyInstanceRatio') is not None:
            self.min_ready_instance_ratio = m.get('minReadyInstanceRatio')
        if m.get('minReadyInstances') is not None:
            self.min_ready_instances = m.get('minReadyInstances')
        return self


class RescaleApplicationVerticallyResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ticked ID of updates.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class RescaleApplicationVerticallyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: RescaleApplicationVerticallyResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The request was successful.
        # *   **3xx**: The request was redirected.
        # *   **4xx**: The request failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # Data returned.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # Messages returned for additional information.
        self.message = message
        # Request ID.
        self.request_id = request_id
        # Indicates whether the update of instance specifications was successful. Valid values:
        # 
        # *   **true**: Updated.
        # *   **false**: Failed to update.
        self.success = success
        # Trace ID for request information.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = RescaleApplicationVerticallyResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RescaleApplicationVerticallyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RescaleApplicationVerticallyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RescaleApplicationVerticallyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RestartApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        auto_enable_application_scaling_rule: bool = None,
        min_ready_instance_ratio: int = None,
        min_ready_instances: int = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # Specifies whether to automatically enable an auto scaling policy for the application. Valid values:
        # 
        # *   **true**: enabled.
        # *   **false**: disabled
        self.auto_enable_application_scaling_rule = auto_enable_application_scaling_rule
        # The percentage of the minimum number of available instances. Take note of the following rules:
        # 
        # *   If you set the value to **-1**, the minimum number of available instances is not determined based on this parameter. Default value: -1.
        # *   If you set the value to a number **from 0 to 100**, the minimum number of available instances is calculated by using the following formula: Current number of instances × (Value of MinReadyInstanceRatio × 100%). The value is the nearest integer rounded up from the calculated result. For example, if the percentage is set to **50**% and five instances are available, the minimum number of available instances is 3.
        # 
        # > When **MinReadyInstance** and **MinReadyInstanceRatio** are specified and **MinReadyInstanceRatio** is set to a number from 0 to 100, the value of \\*\\*MinReadyInstanceRatio** takes precedence.**** For example, if **MinReadyInstances** is set to **5\\*\\*, and **MinReadyInstanceRatio** is set to **50**, the minimum number of available instances is set to the nearest integer rounded up from the calculated result of the following formula: Current number of instances × **50%**.
        self.min_ready_instance_ratio = min_ready_instance_ratio
        # The minimum number of available instances. Special values:
        # 
        # *   If you set the value to **0**, business interruptions occur when the application is updated.
        # *   If you set the value to \\*\\*-1\\*\\*, the minimum number of available instances is automatically set to a system-recommended value. The value is the nearest integer to which the calculated result of the following formula is rounded up: Current number of instances × 25%. For example, if five instances are available, the minimum number of available instances is calculated by using the following formula: 5 × 25% = 1.25. In this case, the minimum number of available instances is 2.
        # 
        # > Make sure that at least one instance is available during application deployment and rollback to prevent business interruptions.
        self.min_ready_instances = min_ready_instances

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.auto_enable_application_scaling_rule is not None:
            result['AutoEnableApplicationScalingRule'] = self.auto_enable_application_scaling_rule
        if self.min_ready_instance_ratio is not None:
            result['MinReadyInstanceRatio'] = self.min_ready_instance_ratio
        if self.min_ready_instances is not None:
            result['MinReadyInstances'] = self.min_ready_instances
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AutoEnableApplicationScalingRule') is not None:
            self.auto_enable_application_scaling_rule = m.get('AutoEnableApplicationScalingRule')
        if m.get('MinReadyInstanceRatio') is not None:
            self.min_ready_instance_ratio = m.get('MinReadyInstanceRatio')
        if m.get('MinReadyInstances') is not None:
            self.min_ready_instances = m.get('MinReadyInstances')
        return self


class RestartApplicationResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change process.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class RestartApplicationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: RestartApplicationResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Take note of the following rules:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The response.
        self.data = data
        # The error code returned if the request failed. Take note of the following rules:
        # 
        # *   The **ErrorCode** parameter is not returned if the request succeeds.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The additional information that is returned. Take note of the following rules:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the instance is successfully restarted. Take note of the following rules:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = RestartApplicationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RestartApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RestartApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RestartApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RestartInstancesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        instance_ids: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the instance to be restarted. Separate multiple instance IDs with commas (,).
        # 
        # This parameter is required.
        self.instance_ids = instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        return self


class RestartInstancesResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class RestartInstancesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: RestartInstancesResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Take note of the following rules:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The details of the application.
        self.data = data
        # The error code returned if the request failed. Take note of the following rules:
        # 
        # *   The **ErrorCode** parameter is not returned if the request succeeds.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The additional information that is returned. Take note of the following rules:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Specifies whether the instances are successfully restarted. Take note of the following rules:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = RestartInstancesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RestartInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RestartInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RestartInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RollbackApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        auto_enable_application_scaling_rule: str = None,
        batch_wait_time: int = None,
        min_ready_instance_ratio: int = None,
        min_ready_instances: int = None,
        update_strategy: str = None,
        version_id: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # Specifies whether to automatically enable an auto scaling policy for the application. Take note of the following rules:
        # 
        # *   **true**: turns on Logon-free Sharing
        # *   **false**: turns off Logon-free Sharing
        self.auto_enable_application_scaling_rule = auto_enable_application_scaling_rule
        # The wait time between batches. Unit: seconds.
        self.batch_wait_time = batch_wait_time
        # The percentage of the minimum number of available instances. Take note of the following rules:
        # 
        # *   If you set the value to **-1**, the minimum number of available instances is not determined based on this parameter. Default value: -1.
        # *   If you set the value to a number **from 0 to 100**, the minimum number of available instances is calculated by using the following formula: Current number of instances × (Value of MinReadyInstanceRatio × 100%). The value is the nearest integer rounded up from the calculated result. For example, if the percentage is set to **50**% and five instances are available, the minimum number of available instances is 3.
        # 
        # > When both **MinReadyInstance** and **MinReadyInstanceRatio** are specified and **MinReadyInstanceRatio** is set to a number from 0 to 100, the value of **MinReadyInstanceRatio** takes precedence.** For example, if **MinReadyInstances** is set to **5, and **MinReadyInstanceRatio** is set to **50**, the minimum number of available instances is set to the nearest integer rounded up from the calculated result of the following formula: Current number of instances × **50%**.
        self.min_ready_instance_ratio = min_ready_instance_ratio
        # The minimum number of available instances. Take note of the following rules:
        # 
        # *   If you set the value to **0**, business interruptions occur when the application is updated.
        # *   If you set the value to \\*\\*-1\\*\\*, the minimum number of available instances is automatically set to a system-recommended value. The value is the nearest integer to which the calculated result of the following formula is rounded up: Current number of instances × 25%. For example, if five instances are available, the minimum number of available instances is calculated by using the following formula: 5 × 25% = 1.25. In this case, the minimum number of available instances is 2.
        # 
        # > Make sure that at least one instance is available during application deployment and rollback to prevent business interruptions.
        self.min_ready_instances = min_ready_instances
        # The deployment policy. If the minimum number of available instances is 1, the value of the **UpdateStrategy** parameter is an empty string (""). If the minimum number of available instances is larger than 1, specify this parameter based on your requirements. Examples:
        # 
        # *   Perform canary release for one instance and release the remaining instances in two batches automatically with a one-minute interval between the deployment of each instance:
        # 
        #     `{"type":"GrayBatchUpdate","batchUpdate":{"batch":2,"releaseType":"auto","batchWaitTime":1},"grayUpdate":{"gray":1}}`
        # 
        # *   Perform canary release for one instance and release the remaining instances in two batches manually:
        # 
        #     `{"type":"GrayBatchUpdate","batchUpdate":{"batch":2,"releaseType":"manual"},"grayUpdate":{"gray":1}}`
        # 
        # *   Release the instances in two batches automatically with no interval between the deployment of each instance:
        # 
        #     `{"type":"BatchUpdate","batchUpdate":{"batch":2,"releaseType":"auto","batchWaitTime":0}}`
        # 
        # The following table describes the parameters that are used in the preceding statements.
        # 
        # *   **type**: the type of the release policy. Valid values: **GrayBatchUpdate** and **BatchUpdate**.
        # 
        # *   **batchUpdate**: the phased release policy.
        # 
        #     *   **batch**: the number of release batches.
        #     *   **releaseType**: the processing method for the batches. Valid values: **auto** and **manual**.
        #     *   **batchWaitTime**: the interval between release batches. Unit: seconds.
        # 
        # *   **grayUpdate**: the number of release batches in the phased release after a canary release. This parameter is returned only if the **type** parameter is set to **GrayBatchUpdate**.
        self.update_strategy = update_strategy
        # The ID of the application version. Call the [ListAppVersions](https://help.aliyun.com/document_detail/162054.html) operation to obtain the version ID.
        # 
        # This parameter is required.
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.auto_enable_application_scaling_rule is not None:
            result['AutoEnableApplicationScalingRule'] = self.auto_enable_application_scaling_rule
        if self.batch_wait_time is not None:
            result['BatchWaitTime'] = self.batch_wait_time
        if self.min_ready_instance_ratio is not None:
            result['MinReadyInstanceRatio'] = self.min_ready_instance_ratio
        if self.min_ready_instances is not None:
            result['MinReadyInstances'] = self.min_ready_instances
        if self.update_strategy is not None:
            result['UpdateStrategy'] = self.update_strategy
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AutoEnableApplicationScalingRule') is not None:
            self.auto_enable_application_scaling_rule = m.get('AutoEnableApplicationScalingRule')
        if m.get('BatchWaitTime') is not None:
            self.batch_wait_time = m.get('BatchWaitTime')
        if m.get('MinReadyInstanceRatio') is not None:
            self.min_ready_instance_ratio = m.get('MinReadyInstanceRatio')
        if m.get('MinReadyInstances') is not None:
            self.min_ready_instances = m.get('MinReadyInstances')
        if m.get('UpdateStrategy') is not None:
            self.update_strategy = m.get('UpdateStrategy')
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class RollbackApplicationResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        is_need_approval: bool = None,
    ):
        # The ID of the change process.
        self.change_order_id = change_order_id
        # Specifies whether approval is required when a RAM user performs release. Take note of the following rules:
        # 
        # *   **true**\
        # *   **false**\
        self.is_need_approval = is_need_approval

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.is_need_approval is not None:
            result['IsNeedApproval'] = self.is_need_approval
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('IsNeedApproval') is not None:
            self.is_need_approval = m.get('IsNeedApproval')
        return self


class RollbackApplicationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: RollbackApplicationResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Take note of the following rules:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The response.
        self.data = data
        # The error code returned if the request failed. Take note of the following rules:
        # 
        # *   The **ErrorCode** parameter is not returned if the request succeeds.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The message returned for the operation.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the application is successfully rolled back. Take note of the following rules:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = RollbackApplicationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RollbackApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RollbackApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RollbackApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class StartApplicationResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class StartApplicationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: StartApplicationResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The returned result.
        self.data = data
        # The error code returned. Take note of the following rules:
        # 
        # *   If the call is successful, **ErrorCode** is not returned.
        # *   If the call fails, **ErrorCode** is returned. For more information, see the "**Error codes**" section in this topic.
        self.error_code = error_code
        # The returned message. Take note of the following rules:
        # 
        # *   If the call is successful, **success** is returned.
        # *   If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the application is started. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = StartApplicationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class StartApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartWebApplicationRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
    ):
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class StartWebApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WebApplicationBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WebApplicationBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopApplicationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class StopApplicationResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class StopApplicationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: StopApplicationResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        # The error code.
        # 
        # *   If the request is successful, this parameter is not returned.****\
        # *   This parameter is returned only if the request failed.**** For more information, see **Error codes** in this topic.
        self.data = data
        # Indicates whether the specified application is stopped. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.error_code = error_code
        # The returned data.
        self.message = message
        # The ID of the trace. It can be used to query the details of a request.
        self.request_id = request_id
        self.success = success
        # The ID of the change order.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = StopApplicationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class StopApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopWebApplicationRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
    ):
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class StopWebApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WebApplicationBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WebApplicationBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SuspendJobRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        suspend: bool = None,
    ):
        # The ID of the job template.
        # 
        # This parameter is required.
        self.app_id = app_id
        # Start or suspend a job template.
        # 
        # *   true: Start a job template.
        # *   false: Suspend a job template.
        # 
        # This parameter is required.
        self.suspend = suspend

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.suspend is not None:
            result['Suspend'] = self.suspend
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Suspend') is not None:
            self.suspend = m.get('Suspend')
        return self


class SuspendJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # Whether the execution is successful.
        self.data = data
        # The error code returned. Valid values:
        # 
        # *   The **ErrorCode** parameter is not returned if the request succeeds.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see **Error codes** in this topic.
        self.error_code = error_code
        # The additional information that is returned. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the job was executed. Valid values:
        # 
        # *   **true**: The job was executed.
        # *   **false**: The job failed to be executed.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class SuspendJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SuspendJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SuspendJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TagResourcesRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        resource_ids: str = None,
        resource_type: str = None,
        tags: str = None,
    ):
        # The region ID.
        self.region_id = region_id
        # The IDs of resources. Separate multiple resource IDs with comma (,). This parameter is required if you do not specify the **Tags** parameter.
        # 
        # This parameter is required.
        self.resource_ids = resource_ids
        # The type of the resource. Set the value to `application`.
        # 
        # This parameter is required.
        self.resource_type = resource_type
        # The tag in the format of a key-value pair. This parameter is required if you do not specify the **ResourceIds** parameter. The following parameters are involved:
        # 
        # *   **key**: the tag key. It cannot exceed 128 characters in length.
        # *   **value**: the tag value. It cannot exceed 128 characters in length.
        # 
        # Tag keys and tag values are case-sensitive. If you specify multiple tags, the system adds all the tags to the specified resources. Each tag key on a resource can have only one tag value. If you create a tag that has the same key as an existing tag, the value of the existing tag is overwritten.
        # 
        # Tag keys and tag values cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.
        self.tags = tags

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_ids is not None:
            result['ResourceIds'] = self.resource_ids
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceIds') is not None:
            self.resource_ids = m.get('ResourceIds')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class TagResourcesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # Indicates that the operation was successful.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether tags were added to the specified resources. Valid values:
        # 
        # *   **true**: The tags were added.
        # *   **false**: The tags failed to be added.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class TagResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TagResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnbindNlbRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        nlb_id: str = None,
        port: int = None,
        protocol: str = None,
    ):
        # A short description of struct
        self.app_id = app_id
        # The ID of NLB instance.
        self.nlb_id = nlb_id
        # The listener port of the instance. Valid values: 0 to 65535.
        self.port = port
        # The type of the protocol. Valid values:
        # 
        # *   **TCP**.
        # *   **UDP**.
        # *   **TCPSSL**.
        self.protocol = protocol

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.nlb_id is not None:
            result['NlbId'] = self.nlb_id
        if self.port is not None:
            result['Port'] = self.port
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('NlbId') is not None:
            self.nlb_id = m.get('NlbId')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        return self


class UnbindNlbResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order. The ID can be used to query the status of the change task.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class UnbindNlbResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UnbindNlbResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The request was successful.
        # *   **3xx**: The request was redirected.
        # *   **4xx**: The request failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The returned data.
        self.data = data
        # The status code. Valid values:
        # 
        # *   If the request was successful, **ErrorCode** is not returned.
        # *   If the request failed, **ErrorCode** is returned. For more information, see **Error codes** section of this topic.
        self.error_code = error_code
        # The message returned. Valid values:
        # 
        # *   If the request was successful, **success** is returned.
        # *   If the request failed, an error code is returned.
        self.message = message
        # Id of the request
        self.request_id = request_id
        # Indicates whether the internal-facing or Internet-facing NLB instance was disassociated. Valid values:
        # 
        # *   **true**: The NLB instance was disassociated.
        # *   **false**: The NLB instance failed to be disassociated.
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UnbindNlbResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UnbindNlbResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnbindNlbResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnbindNlbResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnbindSlbRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        internet: bool = None,
        intranet: bool = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # Specifies whether to disassociate the Internet-facing SLB instance. Valid values:
        # 
        # *   **true**: dissociates the Internet-facing SLB instance.
        # *   **false**: does not dissociate the Internet-facing SLB instance.
        self.internet = internet
        # Specifies whether to disassociate the internal-facing SLB instance. Valid values:
        # 
        # *   **true**: dissociates the internal-facing SLB instance.
        # *   **false**: does not dissociate the internal-facing SLB instance.
        self.intranet = intranet

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.internet is not None:
            result['Internet'] = self.internet
        if self.intranet is not None:
            result['Intranet'] = self.intranet
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Internet') is not None:
            self.internet = m.get('Internet')
        if m.get('Intranet') is not None:
            self.intranet = m.get('Intranet')
        return self


class UnbindSlbResponseBodyData(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
    ):
        # The ID of the change order. The ID can be used to query the status of the change task.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class UnbindSlbResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UnbindSlbResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The returned result.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the internal-facing or Internet-facing SLB instance was disassociated. Valid values:
        # 
        # *   **true**: The SLB instance was disassociated.
        # *   **false**: The SLB instance failed to be disassociated.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UnbindSlbResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UnbindSlbResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnbindSlbResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnbindSlbResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UntagResourcesRequest(TeaModel):
    def __init__(
        self,
        delete_all: bool = None,
        region_id: str = None,
        resource_ids: str = None,
        resource_type: str = None,
        tag_keys: str = None,
    ):
        # Specifies whether to remove all the specified tags. This parameter takes effect only if the TagKeys parameter is specified. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.delete_all = delete_all
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The IDs of resources. Separate multiple resource IDs with comma (,).
        # 
        # This parameter is required.
        self.resource_ids = resource_ids
        # The type of the resource. Set the value to `application`.
        # 
        # This parameter is required.
        self.resource_type = resource_type
        # The tag keys. Separate multiple tag keys with commas (,).
        self.tag_keys = tag_keys

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delete_all is not None:
            result['DeleteAll'] = self.delete_all
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_ids is not None:
            result['ResourceIds'] = self.resource_ids
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag_keys is not None:
            result['TagKeys'] = self.tag_keys
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeleteAll') is not None:
            self.delete_all = m.get('DeleteAll')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceIds') is not None:
            self.resource_ids = m.get('ResourceIds')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TagKeys') is not None:
            self.tag_keys = m.get('TagKeys')
        return self


class UntagResourcesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The returned result.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the tags were removed. Valid values:
        # 
        # *   **true**: The tags were removed.
        # *   **false**: The tags failed to be removed.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UntagResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UntagResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UntagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAppModeRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_ids: str = None,
        enable_idle: bool = None,
        namespace_id: str = None,
    ):
        self.app_id = app_id
        self.app_ids = app_ids
        self.enable_idle = enable_idle
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_ids is not None:
            result['AppIds'] = self.app_ids
        if self.enable_idle is not None:
            result['EnableIdle'] = self.enable_idle
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppIds') is not None:
            self.app_ids = m.get('AppIds')
        if m.get('EnableIdle') is not None:
            self.enable_idle = m.get('EnableIdle')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class UpdateAppModeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: str = None,
        trace_id: str = None,
    ):
        self.code = code
        self.error_code = error_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateAppModeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAppModeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAppModeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAppSecurityGroupRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        security_group_id: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the security group.
        # 
        # This parameter is required.
        self.security_group_id = security_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class UpdateAppSecurityGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the security group of the application was updated. Valid values:
        # 
        # *   **true**: The security group was updated.
        # *   **false**: The security group failed to be updated.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateAppSecurityGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAppSecurityGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAppSecurityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateApplicationDescriptionRequest(TeaModel):
    def __init__(
        self,
        app_description: str = None,
        app_id: str = None,
    ):
        # This parameter is required.
        self.app_description = app_description
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_description is not None:
            result['AppDescription'] = self.app_description
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppDescription') is not None:
            self.app_description = m.get('AppDescription')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class UpdateApplicationDescriptionResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateApplicationDescriptionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateApplicationDescriptionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateApplicationDescriptionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateApplicationScalingRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        enable_idle: bool = None,
        min_ready_instance_ratio: int = None,
        min_ready_instances: int = None,
        scaling_rule_metric: str = None,
        scaling_rule_name: str = None,
        scaling_rule_timer: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        self.enable_idle = enable_idle
        # The percentage of the minimum number of available instances. Take note of the following rules:
        # 
        # *   If you set the value to **-1**, the minimum number of available instances is not determined based on this parameter. This is the default value.
        # *   If you set the value to a number **from 0 to 100**, the minimum number of available instances is calculated by using the following formula: Current number of instances × (Value of MinReadyInstanceRatio × 100%). The value is the nearest integer rounded up from the calculated result. For example, if you set this parameter to **50**, and five instances are available, the minimum number of available instances is 3.
        # 
        # > When **MinReadyInstance** and **MinReadyInstanceRatio** are specified and **MinReadyInstanceRatio** is set to a number from 0 to 100, the value of \\*\\*MinReadyInstanceRatio** takes precedence.**** For example, if **MinReadyInstances** is set to **5\\*\\*, and **MinReadyInstanceRatio** is set to **50**, the minimum number of available instances is set to the nearest integer rounded up from the calculated result of the following formula: Current number of instances × **50%**.
        self.min_ready_instance_ratio = min_ready_instance_ratio
        # The minimum number of available instances. Take note of the following rules:
        # 
        # *   If you set the value to **0**, business interruptions occur when the auto-scaling policy is updated.
        # *   If you set the value to \\*\\*-1\\*\\*, the minimum number of available instances is automatically set to a system-recommended value. The value is the nearest integer to which the calculated result of the following formula is rounded up: Current number of instances × 25%. For example, if five instances are available, the minimum number of available instances is calculated by using the following formula: 5 × 25% = 1.25. In this case, the minimum number of available instances is 2.
        # 
        # > Make sure that at least one instance is available during application deployment and rollback to prevent business interruptions.
        self.min_ready_instances = min_ready_instances
        # The configurations of the metric-based auto scaling policy. This parameter is required if you set the ScalingRuleType parameter to metric.
        # 
        # Parameter description:
        # 
        # *   **maxReplicas**: the maximum number of instances in the application.
        # 
        # *   **minReplicas**: the minimum number of instances in the application.
        # 
        # *   **metricType**: the metric that is used to trigger the auto scaling policy.
        # 
        #     *   **CPU**: the CPU utilization.
        #     *   **MEMORY**: the memory usage.
        #     *   **tcpActiveConn**: the average number of active TCP connections in an application instance within 30 seconds.
        #     *   **SLB_QPS**: the average queries per second (QPS) of the Internet-facing Server Load Balancer (SLB) instance associated with an application instance within 15 seconds.
        #     *   **SLB_RT**: the average response time of the Internet-facing SLB instance within 15 seconds.
        # 
        # *   **metricTargetAverageUtilization**: the limit on the metric specified by the **metricType** parameter.
        # 
        #     *   The limit on the CPU utilization. Unit: percentage.
        #     *   The limit on the memory usage. Unit: percentage.
        #     *   The limit on the average number of active TCP connections per second.
        #     *   The limit on the QPS of the Internet-facing SLB instance.
        #     *   The limit on the response time of the Internet-facing SLB instance. Unit: milliseconds.
        # 
        # *   **SlbProject**: the Log Service project.
        # 
        # *   **SlbLogstore**: the Log Service Logstore.
        # 
        # *   **Vport**: the listener port for the SLB instance. HTTP and HTTPS are supported.
        # 
        # *   **scaleUpRules**: the scale-out rule.
        # 
        # *   **scaleDownRules**: the scale-in rule.
        # 
        # *   **step**: the scale-out or scale-in step size. The maximum number of instances that can be added or removed per unit time.
        # 
        # *   **disabled**: specifies whether to disable the application scale-in. If you set this parameter to true, the application instances are never scaled in. This prevents business risks during peak hours.
        # 
        #     *   **true**: disables the application scale-in.
        #     *   **false**: enables the application scale-in. Default value: false.
        # 
        # *   **stabilizationWindowSeconds**: the cooldown period during which the system is stable and does not perform scale-out or scale-in operations. Valid values: 0 to 3600. Unit: seconds. Default value: 0.
        # 
        # > You can specify one or more metrics as the trigger conditions of the auto scaling policy. If you specify multiple metrics, the application is scaled out when the value of a metric is greater than or equal to the limit. The number of application instances after the scale-out cannot exceed the configured maximum number of application instances. If the values of all the metrics are less than the limits, the application is scaled in. The number of instances after the scale-in cannot be less than the configured minimum number of application instances.
        self.scaling_rule_metric = scaling_rule_metric
        # The name of the auto scaling policy. The name must start with a lowercase letter and can contain only lowercase letters, digits, and hyphens (-). The name cannot exceed 32 characters in length.
        # 
        # > You cannot change the names of created policies.
        # 
        # This parameter is required.
        self.scaling_rule_name = scaling_rule_name
        # The configurations of the scheduled auto scaling policy. This parameter is required when you set the ScalingRuleType parameter to timing or when you want to create a scheduled auto scaling policy by using an SDK.
        # 
        # Parameter description:
        # 
        # *   **beginDate** and **endDate**: specify the validity period of the scheduled auto scaling policy. **beginDate** specifies the start date and **endDate** specifies the end date. Take note of the following rules:
        # 
        #     *   If you set the two parameters to **null**, the scheduled auto scaling policy is a long-term policy. Default values of the beginDate and endDate parameters: null.
        #     *   If you set the two parameters to specific dates, the scheduled auto scaling policy can be triggered during the period between the two dates. For example, if you set **beginDate** to **2021-03-25** and **endDate** to **2021-04-25**, the auto scaling policy is valid for one month.
        # 
        # *   **period**: specifies the frequency at which the scheduled auto scaling policy is executed. Valid values:
        # 
        #     *   **\\* \\* \\***: The scheduled auto scaling policy is executed at a specified point in time every day.
        # 
        #     *   **\\* \\* Fri,Mon**: The scheduled auto scaling policy is executed at a specified point in time on one or more specified days of each week. GMT+8 is used. Valid values:
        # 
        #         *   **Sun**\
        #         *   **Mon**\
        #         *   **Tue**\
        #         *   **Wed**\
        #         *   **Thu**\
        #         *   **Fri**\
        #         *   **Sat**\
        # 
        #     *   **1,2,3,28,31 \\* \\***: The scheduled auto scaling policy is executed at a specified point in time on one or more days of each month. Valid values: 1 to 31. If the month does not have a 31st day, the auto scaling policy is executed on the specified days other than the 31st day.
        # 
        # *   **schedules**: specifies the points in time at which the auto scaling policy is triggered and the number of application instances that are retained during the corresponding period of time. You can specify up to 20 points in time. Parameter description:
        # 
        #     *   **atTime**: the point in time at which the policy is triggered. Format: **Hour:Minute**. Example: **08:00**.
        # 
        #     *   **targetReplicas**: specifies the number of application instances that you want to maintain by using this policy. You can also set the value to the minimum number of available instances required for each application release. Valid values: 1 to 50.
        # 
        #         **\
        # 
        #         **Note**Make sure that at least **one** instance is available during the application deployment and rollback to prevent your business from being interrupted. If you set the value to **0**, business interruptions occur when the application is updated.
        self.scaling_rule_timer = scaling_rule_timer

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.enable_idle is not None:
            result['EnableIdle'] = self.enable_idle
        if self.min_ready_instance_ratio is not None:
            result['MinReadyInstanceRatio'] = self.min_ready_instance_ratio
        if self.min_ready_instances is not None:
            result['MinReadyInstances'] = self.min_ready_instances
        if self.scaling_rule_metric is not None:
            result['ScalingRuleMetric'] = self.scaling_rule_metric
        if self.scaling_rule_name is not None:
            result['ScalingRuleName'] = self.scaling_rule_name
        if self.scaling_rule_timer is not None:
            result['ScalingRuleTimer'] = self.scaling_rule_timer
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EnableIdle') is not None:
            self.enable_idle = m.get('EnableIdle')
        if m.get('MinReadyInstanceRatio') is not None:
            self.min_ready_instance_ratio = m.get('MinReadyInstanceRatio')
        if m.get('MinReadyInstances') is not None:
            self.min_ready_instances = m.get('MinReadyInstances')
        if m.get('ScalingRuleMetric') is not None:
            self.scaling_rule_metric = m.get('ScalingRuleMetric')
        if m.get('ScalingRuleName') is not None:
            self.scaling_rule_name = m.get('ScalingRuleName')
        if m.get('ScalingRuleTimer') is not None:
            self.scaling_rule_timer = m.get('ScalingRuleTimer')
        return self


class UpdateApplicationScalingRuleResponseBodyDataMetricMetrics(TeaModel):
    def __init__(
        self,
        metric_target_average_utilization: int = None,
        metric_type: str = None,
        slb_id: str = None,
        slb_logstore: str = None,
        slb_project: str = None,
        vport: str = None,
    ):
        # The limit on the metric.
        # 
        # *   The limit on the CPU utilization. Unit: percentage.
        # *   The limit on the memory usage. Unit: percentage.
        # *   The limit on the average number of active TCP connections per second.
        # *   The limit on the QPS of the Internet-facing SLB instance.
        # *   The limit on the response time of the Internet-facing SLB instance. Unit: milliseconds.
        self.metric_target_average_utilization = metric_target_average_utilization
        # The metric that is used to trigger the auto scaling policy. Valid values:
        # 
        # *   **CPU**: the CPU utilization.
        # *   **MEMORY**: the memory usage.
        # *   **tcpActiveConn**: the average number of active TCP connections of an application instance within 30 seconds.
        # *   **SLB_QPS**: the average QPS of the Internet-facing SLB instance associated with an application instance within 15 seconds.
        # *   **SLB_RT**: the average response time of the Internet-facing SLB instance within 15 seconds.
        self.metric_type = metric_type
        self.slb_id = slb_id
        self.slb_logstore = slb_logstore
        self.slb_project = slb_project
        self.vport = vport

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_target_average_utilization is not None:
            result['MetricTargetAverageUtilization'] = self.metric_target_average_utilization
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.slb_id is not None:
            result['SlbId'] = self.slb_id
        if self.slb_logstore is not None:
            result['SlbLogstore'] = self.slb_logstore
        if self.slb_project is not None:
            result['SlbProject'] = self.slb_project
        if self.vport is not None:
            result['Vport'] = self.vport
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetricTargetAverageUtilization') is not None:
            self.metric_target_average_utilization = m.get('MetricTargetAverageUtilization')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('SlbId') is not None:
            self.slb_id = m.get('SlbId')
        if m.get('SlbLogstore') is not None:
            self.slb_logstore = m.get('SlbLogstore')
        if m.get('SlbProject') is not None:
            self.slb_project = m.get('SlbProject')
        if m.get('Vport') is not None:
            self.vport = m.get('Vport')
        return self


class UpdateApplicationScalingRuleResponseBodyDataMetric(TeaModel):
    def __init__(
        self,
        max_replicas: int = None,
        metrics: List[UpdateApplicationScalingRuleResponseBodyDataMetricMetrics] = None,
        min_replicas: int = None,
    ):
        # The maximum number of instances.
        self.max_replicas = max_replicas
        # The metrics that are used to trigger the auto scaling policy.
        self.metrics = metrics
        # The minimum number of instances.
        self.min_replicas = min_replicas

    def validate(self):
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        result['Metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['Metrics'].append(k.to_map() if k else None)
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        self.metrics = []
        if m.get('Metrics') is not None:
            for k in m.get('Metrics'):
                temp_model = UpdateApplicationScalingRuleResponseBodyDataMetricMetrics()
                self.metrics.append(temp_model.from_map(k))
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        return self


class UpdateApplicationScalingRuleResponseBodyDataTimerSchedules(TeaModel):
    def __init__(
        self,
        at_time: str = None,
        max_replicas: int = None,
        min_replicas: int = None,
        target_replicas: int = None,
    ):
        # The point in time. Format: **Hour:Minute**.
        self.at_time = at_time
        self.max_replicas = max_replicas
        self.min_replicas = min_replicas
        # The expected number of instances.
        self.target_replicas = target_replicas

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.at_time is not None:
            result['AtTime'] = self.at_time
        if self.max_replicas is not None:
            result['MaxReplicas'] = self.max_replicas
        if self.min_replicas is not None:
            result['MinReplicas'] = self.min_replicas
        if self.target_replicas is not None:
            result['TargetReplicas'] = self.target_replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AtTime') is not None:
            self.at_time = m.get('AtTime')
        if m.get('MaxReplicas') is not None:
            self.max_replicas = m.get('MaxReplicas')
        if m.get('MinReplicas') is not None:
            self.min_replicas = m.get('MinReplicas')
        if m.get('TargetReplicas') is not None:
            self.target_replicas = m.get('TargetReplicas')
        return self


class UpdateApplicationScalingRuleResponseBodyDataTimer(TeaModel):
    def __init__(
        self,
        begin_date: str = None,
        end_date: str = None,
        period: str = None,
        schedules: List[UpdateApplicationScalingRuleResponseBodyDataTimerSchedules] = None,
    ):
        # The start date of the validity period of the scheduled auto scaling policy. Parameter description:
        # 
        # *   If **BeginDate** and **EndDate** are set to **null**, the auto scaling policy is a long-term policy. Default values of the beginDate and endDate parameters: null.
        # *   If the two parameters are set to specific dates, the scheduled auto scaling policy can be triggered during the period between the two dates. For example, if **BeginDate** is set to 2021-03-25 and **EndDate** is set to 2021-04-25, the auto scaling policy is valid for one month.
        self.begin_date = begin_date
        # The end date of the validity period of the scheduled auto scaling policy. Take note of the following rules:
        # 
        # *   If **BeginDate** and **EndDate** are set to **null**, the auto scaling policy is a long-term policy. Default values of the beginDate and endDate parameters: null.
        # *   If the two parameters are set to specific dates, the scheduled auto scaling policy can be triggered during the period between the two dates. For example, if **BeginDate** is set to 2021-03-25 and **EndDate** is set to 2021-04-25, the auto scaling policy is valid for one month.
        self.end_date = end_date
        # The frequency at which the scheduled auto scaling policy is executed. Valid values:
        # 
        # *   **\\* \\* \\***: The scheduled auto scaling policy is executed at a specified point in time every day.
        # 
        # *   **\\* \\* Fri,Mon**: The scheduled auto scaling policy is executed at a specified point in time on one or more days of each week. GMT+8 is used. Valid values:
        # 
        #     *   **Sun**\
        #     *   **Mon**\
        #     *   **Tue**\
        #     *   **Wed**\
        #     *   **Thu**\
        #     *   **Fri**\
        #     *   **Sat**\
        # 
        # *   **1,2,3,28,31 \\* \\***: The scheduled auto scaling policy is executed at a specified point in time on one or more days of each month. Valid values: 1 to 31. If the month does not have a 31st day, the auto scaling policy is executed on the specified days other than the 31st day.
        self.period = period
        # The points in time at which the auto scaling policy is triggered within one day.
        self.schedules = schedules

    def validate(self):
        if self.schedules:
            for k in self.schedules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_date is not None:
            result['BeginDate'] = self.begin_date
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.period is not None:
            result['Period'] = self.period
        result['Schedules'] = []
        if self.schedules is not None:
            for k in self.schedules:
                result['Schedules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BeginDate') is not None:
            self.begin_date = m.get('BeginDate')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        self.schedules = []
        if m.get('Schedules') is not None:
            for k in m.get('Schedules'):
                temp_model = UpdateApplicationScalingRuleResponseBodyDataTimerSchedules()
                self.schedules.append(temp_model.from_map(k))
        return self


class UpdateApplicationScalingRuleResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        create_time: int = None,
        enable_idle: bool = None,
        last_disable_time: int = None,
        metric: UpdateApplicationScalingRuleResponseBodyDataMetric = None,
        scale_rule_enabled: bool = None,
        scale_rule_name: str = None,
        scale_rule_type: str = None,
        timer: UpdateApplicationScalingRuleResponseBodyDataTimer = None,
        update_time: int = None,
    ):
        # The application ID.
        self.app_id = app_id
        # The time when the auto scaling policy was created. Unit: milliseconds.
        self.create_time = create_time
        self.enable_idle = enable_idle
        # The time when the auto scaling policy was last disabled.
        self.last_disable_time = last_disable_time
        # The details of the metric-based auto scaling policy.
        self.metric = metric
        # Specifies whether to enable the auto scaling policy. Valid values:
        # 
        # *   **true**: The auto scaling policy is enabled.
        # *   **false**: The auto scaling policy is disabled.
        self.scale_rule_enabled = scale_rule_enabled
        # The name of the auto scaling policy.
        self.scale_rule_name = scale_rule_name
        # The type of the auto scaling policy. Valid values:
        # 
        # *   **timing**: a scheduled auto scaling policy
        # *   **metric**: a metric-based auto scaling policy
        # *   **mix**: a hybrid auto scaling policy
        self.scale_rule_type = scale_rule_type
        # The details of the scheduled auto scaling policy.
        self.timer = timer
        # The time when the auto scaling policy was updated. Unit: milliseconds.
        self.update_time = update_time

    def validate(self):
        if self.metric:
            self.metric.validate()
        if self.timer:
            self.timer.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.enable_idle is not None:
            result['EnableIdle'] = self.enable_idle
        if self.last_disable_time is not None:
            result['LastDisableTime'] = self.last_disable_time
        if self.metric is not None:
            result['Metric'] = self.metric.to_map()
        if self.scale_rule_enabled is not None:
            result['ScaleRuleEnabled'] = self.scale_rule_enabled
        if self.scale_rule_name is not None:
            result['ScaleRuleName'] = self.scale_rule_name
        if self.scale_rule_type is not None:
            result['ScaleRuleType'] = self.scale_rule_type
        if self.timer is not None:
            result['Timer'] = self.timer.to_map()
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('EnableIdle') is not None:
            self.enable_idle = m.get('EnableIdle')
        if m.get('LastDisableTime') is not None:
            self.last_disable_time = m.get('LastDisableTime')
        if m.get('Metric') is not None:
            temp_model = UpdateApplicationScalingRuleResponseBodyDataMetric()
            self.metric = temp_model.from_map(m['Metric'])
        if m.get('ScaleRuleEnabled') is not None:
            self.scale_rule_enabled = m.get('ScaleRuleEnabled')
        if m.get('ScaleRuleName') is not None:
            self.scale_rule_name = m.get('ScaleRuleName')
        if m.get('ScaleRuleType') is not None:
            self.scale_rule_type = m.get('ScaleRuleType')
        if m.get('Timer') is not None:
            temp_model = UpdateApplicationScalingRuleResponseBodyDataTimer()
            self.timer = temp_model.from_map(m['Timer'])
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class UpdateApplicationScalingRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UpdateApplicationScalingRuleResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The returned result.
        self.data = data
        # The error code returned. Take note of the following rules:
        # 
        # *   If the call is successful, **ErrorCode** is not returned.
        # *   If the call fails, **ErrorCode** is returned. For more information, see the "**Error codes**" section in this topic.
        self.error_code = error_code
        # The returned message. Take note of the following rules:
        # 
        # *   If the call is successful, **success** is returned.
        # *   If the call fails, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Specifies whether the instances are successfully restarted. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateApplicationScalingRuleResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateApplicationScalingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateApplicationScalingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateApplicationScalingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateApplicationVswitchesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        v_switch_id: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the vSwitch.
        # 
        # This parameter is required.
        self.v_switch_id = v_switch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class UpdateApplicationVswitchesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The request was successful.
        # *   **3xx**: The request was redirected.
        # *   **4xx**: The request failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The error code. Valid values:
        # 
        # *   If the request was successful, this parameter is not returned.****\
        # *   If the request failed, **ErrorCode** is returned. For more information, see **Error code** section of this topic.
        self.error_code = error_code
        # The message returned. Valid values:
        # 
        # *   If the request was successful, **success** is returned.
        # *   If the request failed, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the list of applications was obtained. Valid values:
        # 
        # *   **true**: The applications were obtained.
        # *   **false**: The applications failed to be queried.
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateApplicationVswitchesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateApplicationVswitchesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateApplicationVswitchesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateConfigMapRequest(TeaModel):
    def __init__(
        self,
        config_map_id: int = None,
        data: str = None,
        description: str = None,
    ):
        # The ID of the request.
        # 
        # This parameter is required.
        self.config_map_id = config_map_id
        # This parameter is required.
        self.data = data
        self.description = description

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        if self.data is not None:
            result['Data'] = self.data
        if self.description is not None:
            result['Description'] = self.description
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        return self


class UpdateConfigMapResponseBodyData(TeaModel):
    def __init__(
        self,
        config_map_id: str = None,
    ):
        # The returned error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.config_map_id = config_map_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_map_id is not None:
            result['ConfigMapId'] = self.config_map_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigMapId') is not None:
            self.config_map_id = m.get('ConfigMapId')
        return self


class UpdateConfigMapResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UpdateConfigMapResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # Indicates whether the ConfigMap instance was updated. Valid values:
        # 
        # *   **true**: The instance was updated.
        # *   **false**: The instance failed to be updated.
        self.code = code
        # The ID of the ConfigMap instance.
        self.data = data
        # The HTTP status code. Valid values:
        # 
        # *   **2xx:**: indicates that the call was successful.
        # *   **3xx**: indicates that the call was redirected.
        # *   **4xx**: indicates that the call failed.
        # *   **5xx**: indicates that a server error occurred.
        self.error_code = error_code
        # The ID of the trace. The ID is used to query the details of a request.
        self.message = message
        # The returned information.
        self.request_id = request_id
        self.success = success
        # The returned result.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateConfigMapResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateConfigMapResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateConfigMapResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateConfigMapResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateGreyTagRouteRequest(TeaModel):
    def __init__(
        self,
        alb_rules: str = None,
        description: str = None,
        dubbo_rules: str = None,
        grey_tag_route_id: int = None,
        sc_rules: str = None,
    ):
        # The canary release rule of the application for which ALB gateway routing is configured.
        self.alb_rules = alb_rules
        # The description of the canary release rule.
        self.description = description
        # The canary release rule of the Dubbo application.
        self.dubbo_rules = dubbo_rules
        # The ID of the canary release rule.
        # 
        # This parameter is required.
        self.grey_tag_route_id = grey_tag_route_id
        # The canary release rule of the Spring Cloud application.
        self.sc_rules = sc_rules

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alb_rules is not None:
            result['AlbRules'] = self.alb_rules
        if self.description is not None:
            result['Description'] = self.description
        if self.dubbo_rules is not None:
            result['DubboRules'] = self.dubbo_rules
        if self.grey_tag_route_id is not None:
            result['GreyTagRouteId'] = self.grey_tag_route_id
        if self.sc_rules is not None:
            result['ScRules'] = self.sc_rules
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlbRules') is not None:
            self.alb_rules = m.get('AlbRules')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DubboRules') is not None:
            self.dubbo_rules = m.get('DubboRules')
        if m.get('GreyTagRouteId') is not None:
            self.grey_tag_route_id = m.get('GreyTagRouteId')
        if m.get('ScRules') is not None:
            self.sc_rules = m.get('ScRules')
        return self


class UpdateGreyTagRouteResponseBodyData(TeaModel):
    def __init__(
        self,
        grey_tag_route_id: int = None,
    ):
        # The ID of the canary release rule. The ID is globally unique.
        self.grey_tag_route_id = grey_tag_route_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grey_tag_route_id is not None:
            result['GreyTagRouteId'] = self.grey_tag_route_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GreyTagRouteId') is not None:
            self.grey_tag_route_id = m.get('GreyTagRouteId')
        return self


class UpdateGreyTagRouteResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UpdateGreyTagRouteResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The information about the canary release rule.
        self.data = data
        # The error code. Valid values:
        # 
        # *   If the call is successful, the **ErrorCode** parameter is not returned.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the **Error codes** section in this topic.
        self.error_code = error_code
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the information of the change order was queried. Valid values:
        # 
        # *   **true**: The information was queried.
        # *   **false**: The information failed to be queried.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateGreyTagRouteResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateGreyTagRouteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateGreyTagRouteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateGreyTagRouteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateIngressRequest(TeaModel):
    def __init__(
        self,
        cert_id: str = None,
        cert_ids: str = None,
        cors_config: str = None,
        default_rule: str = None,
        description: str = None,
        enable_xforwarded_for: bool = None,
        enable_xforwarded_for_client_src_port: bool = None,
        enable_xforwarded_for_proto: bool = None,
        enable_xforwarded_for_slb_id: bool = None,
        enable_xforwarded_for_slb_port: bool = None,
        idle_timeout: int = None,
        ingress_id: int = None,
        listener_port: str = None,
        listener_protocol: str = None,
        load_balance_type: str = None,
        request_timeout: int = None,
        rules: str = None,
        security_policy_id: str = None,
    ):
        # The ID of the certificate that is associated with the Classic Load Balancer (**CLB**) instance.
        # 
        # *   If you set **LoadBalanceType** to **clb**, you can use CertId to configure a certificate for the HTTPS listener.
        # 
        # For more information about how to manage the SSL certificate IDs that are used by CLB instances, see [Overview](https://help.aliyun.com/document_detail/90792.html).
        self.cert_id = cert_id
        # The IDs of the certificates that are associated with the Application Load Balancer (**ALB**) instance.
        # 
        # *   If you set **LoadBalanceType** to **alb**, you can use CertIds to configure multiple certificates for the HTTPS listener. Separate multiple certificate IDs with commas (,).
        # *   The ID of the SSL certificate that is used by an ALB instance can be obtained from Certificate Management Service. For example, if you specify `756***-cn-hangzhou`, `756***` is the certificate ID that is obtained from the service page, and `-cn-hangzhou` is the fixed suffix. For more information, see [Manage certificates](https://help.aliyun.com/document_detail/209076.html).
        self.cert_ids = cert_ids
        self.cors_config = cors_config
        # The default forwarding rule. You can specify a port and an application in the default forwarding rule to forward traffic based on the IP address. The following list describes the involved parameters:
        # 
        # *   **appId**: the ID of the application.
        # *   **containerPort**: the container port of the application.
        # 
        # >  All requests that do not match the forwarding rules specified for Rules are forwarded over the port to the application.
        self.default_rule = default_rule
        # The name of the routing rule.
        self.description = description
        self.enable_xforwarded_for = enable_xforwarded_for
        self.enable_xforwarded_for_client_src_port = enable_xforwarded_for_client_src_port
        self.enable_xforwarded_for_proto = enable_xforwarded_for_proto
        self.enable_xforwarded_for_slb_id = enable_xforwarded_for_slb_id
        self.enable_xforwarded_for_slb_port = enable_xforwarded_for_slb_port
        # The timeout period of idle connections. Unit: seconds.
        # 
        # >  A value of 0 indicates that the default value is used.
        self.idle_timeout = idle_timeout
        # The ID of the routing rule.
        # 
        # This parameter is required.
        self.ingress_id = ingress_id
        # The port specified for the Server Load Balancer (SLB) listener. You must specify a vacant port.
        self.listener_port = listener_port
        # The protocol that is used to forward requests. Valid values:
        # 
        # *   **HTTP**: HTTP is suitable for applications that need to identify the transmitted data.
        # *   **HTTPS**: HTTPS is suitable for applications that require encrypted data transmission.
        self.listener_protocol = listener_protocol
        # This parameter is discontinued.
        self.load_balance_type = load_balance_type
        # The request timed out. Unit: seconds.
        self.request_timeout = request_timeout
        # The forwarding rules. You can specify a port and an application in a forwarding rule to forward traffic based on the specified domain name and request path. The following list describes the involved parameters:
        # 
        # *   **appId**: the ID of the application.
        # *   **containerPort**: the container port of the application.
        # *   **domain**: the domain name.
        # *   **path**: the request path.
        self.rules = rules
        # The ID of a security policy.
        self.security_policy_id = security_policy_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_id is not None:
            result['CertId'] = self.cert_id
        if self.cert_ids is not None:
            result['CertIds'] = self.cert_ids
        if self.cors_config is not None:
            result['CorsConfig'] = self.cors_config
        if self.default_rule is not None:
            result['DefaultRule'] = self.default_rule
        if self.description is not None:
            result['Description'] = self.description
        if self.enable_xforwarded_for is not None:
            result['EnableXForwardedFor'] = self.enable_xforwarded_for
        if self.enable_xforwarded_for_client_src_port is not None:
            result['EnableXForwardedForClientSrcPort'] = self.enable_xforwarded_for_client_src_port
        if self.enable_xforwarded_for_proto is not None:
            result['EnableXForwardedForProto'] = self.enable_xforwarded_for_proto
        if self.enable_xforwarded_for_slb_id is not None:
            result['EnableXForwardedForSlbId'] = self.enable_xforwarded_for_slb_id
        if self.enable_xforwarded_for_slb_port is not None:
            result['EnableXForwardedForSlbPort'] = self.enable_xforwarded_for_slb_port
        if self.idle_timeout is not None:
            result['IdleTimeout'] = self.idle_timeout
        if self.ingress_id is not None:
            result['IngressId'] = self.ingress_id
        if self.listener_port is not None:
            result['ListenerPort'] = self.listener_port
        if self.listener_protocol is not None:
            result['ListenerProtocol'] = self.listener_protocol
        if self.load_balance_type is not None:
            result['LoadBalanceType'] = self.load_balance_type
        if self.request_timeout is not None:
            result['RequestTimeout'] = self.request_timeout
        if self.rules is not None:
            result['Rules'] = self.rules
        if self.security_policy_id is not None:
            result['SecurityPolicyId'] = self.security_policy_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertId') is not None:
            self.cert_id = m.get('CertId')
        if m.get('CertIds') is not None:
            self.cert_ids = m.get('CertIds')
        if m.get('CorsConfig') is not None:
            self.cors_config = m.get('CorsConfig')
        if m.get('DefaultRule') is not None:
            self.default_rule = m.get('DefaultRule')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnableXForwardedFor') is not None:
            self.enable_xforwarded_for = m.get('EnableXForwardedFor')
        if m.get('EnableXForwardedForClientSrcPort') is not None:
            self.enable_xforwarded_for_client_src_port = m.get('EnableXForwardedForClientSrcPort')
        if m.get('EnableXForwardedForProto') is not None:
            self.enable_xforwarded_for_proto = m.get('EnableXForwardedForProto')
        if m.get('EnableXForwardedForSlbId') is not None:
            self.enable_xforwarded_for_slb_id = m.get('EnableXForwardedForSlbId')
        if m.get('EnableXForwardedForSlbPort') is not None:
            self.enable_xforwarded_for_slb_port = m.get('EnableXForwardedForSlbPort')
        if m.get('IdleTimeout') is not None:
            self.idle_timeout = m.get('IdleTimeout')
        if m.get('IngressId') is not None:
            self.ingress_id = m.get('IngressId')
        if m.get('ListenerPort') is not None:
            self.listener_port = m.get('ListenerPort')
        if m.get('ListenerProtocol') is not None:
            self.listener_protocol = m.get('ListenerProtocol')
        if m.get('LoadBalanceType') is not None:
            self.load_balance_type = m.get('LoadBalanceType')
        if m.get('RequestTimeout') is not None:
            self.request_timeout = m.get('RequestTimeout')
        if m.get('Rules') is not None:
            self.rules = m.get('Rules')
        if m.get('SecurityPolicyId') is not None:
            self.security_policy_id = m.get('SecurityPolicyId')
        return self


class UpdateIngressResponseBodyData(TeaModel):
    def __init__(
        self,
        ingress_id: int = None,
    ):
        # The ID of the routing rule.
        self.ingress_id = ingress_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ingress_id is not None:
            result['IngressId'] = self.ingress_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IngressId') is not None:
            self.ingress_id = m.get('IngressId')
        return self


class UpdateIngressResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UpdateIngressResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The request was successful.
        # *   **3xx**: The request was redirected.
        # *   **4xx**: The request failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The returned result.
        self.data = data
        # The error code.
        # 
        # *   If the request was successful, **ErrorCode** is not returned.
        # *   If the request failed, **ErrorCode** is returned. For more information, see the **Error codes** section of this topic.
        self.error_code = error_code
        # The returned information.
        # 
        # *   If the request was successful, **success** is returned.
        # *   If the request failed, an error code is returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the configurations of the routing rule were updated. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The trace ID.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateIngressResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateIngressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateIngressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateIngressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateJobRequest(TeaModel):
    def __init__(
        self,
        acr_assume_role_arn: str = None,
        acr_instance_id: str = None,
        app_id: str = None,
        backoff_limit: int = None,
        command: str = None,
        command_args: str = None,
        concurrency_policy: str = None,
        config_map_mount_desc: str = None,
        custom_host_alias: str = None,
        edas_container_version: str = None,
        enable_image_accl: bool = None,
        envs: str = None,
        image_pull_secrets: str = None,
        image_url: str = None,
        jar_start_args: str = None,
        jar_start_options: str = None,
        jdk: str = None,
        mount_desc: str = None,
        mount_host: str = None,
        nas_id: str = None,
        oss_ak_id: str = None,
        oss_ak_secret: str = None,
        oss_mount_descs: str = None,
        package_url: str = None,
        package_version: str = None,
        php: str = None,
        php_config: str = None,
        php_config_location: str = None,
        post_start: str = None,
        pre_stop: str = None,
        programming_language: str = None,
        python: str = None,
        python_modules: str = None,
        ref_app_id: str = None,
        replicas: str = None,
        slice: bool = None,
        slice_envs: str = None,
        sls_configs: str = None,
        termination_grace_period_seconds: int = None,
        timeout: int = None,
        timezone: str = None,
        tomcat_config: str = None,
        trigger_config: str = None,
        war_start_options: str = None,
        web_container: str = None,
    ):
        # The Alibaba Cloud Resource Name (ARN) of the RAM role that is used to pull images across accounts. For more information, see [Grant permissions across Alibaba Cloud accounts by using a RAM role](https://help.aliyun.com/document_detail/223585.html).
        self.acr_assume_role_arn = acr_assume_role_arn
        # The ID of Container Registry Enterprise Edition instance N. This parameter is required when the **ImageUrl** parameter is set to the URL of an image in an ACR Enterprise Edition instance.
        self.acr_instance_id = acr_instance_id
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The number of times the job is retried.
        self.backoff_limit = backoff_limit
        # The command that is used to start the image. The command must be an existing executable object in the container. Example:
        # 
        #     command:
        #           - echo
        #           - abc
        #           - >
        #           - file0
        # 
        # In this example, the Command parameter is set to `Command="echo", CommandArgs=["abc", ">", "file0"]`.
        self.command = command
        # The parameters of the image startup command. The CommandArgs parameter specifies the parameters that are required for the **Command** parameter. The name must meet the following format requirements:
        # 
        # `["a","b"]`
        # 
        # In the preceding example, the CommandArgs parameter is set to `CommandArgs=["abc", ">", "file0"]`. The data type of `["abc", ">", "file0"]` must be an array of strings in the JSON format. This parameter is optional.
        self.command_args = command_args
        # The concurrency policy of the job. Valid values:
        # 
        # *   **Forbid**: Prohibits concurrent running. If the previous job is not completed, no new job is created.
        # *   **Allow**: Allows concurrent running.
        # *   **Replace**: If the previous job is not completed when the time to create a new job is reached, the new job replaces the previous job.
        self.concurrency_policy = concurrency_policy
        # The description of the **ConfigMap** instance mounted to the application. Use configurations created on the Configuration Items page to configure containers. The following parameters are involved:
        # 
        # *   **congfigMapId**: the ID of the ConfigMap instance. You can call the [ListNamespacedConfigMaps](https://help.aliyun.com/document_detail/176917.html) operation to obtain the ID.
        # *   **key**: the key.
        # 
        # > You can use the `sae-sys-configmap-all` key to mount all keys.
        # 
        # *   **mountPath**: the mount path.
        self.config_map_mount_desc = config_map_mount_desc
        # The custom mappings between hostnames and IP addresses in the container. Valid values:
        # 
        # *   **hostName**: the domain name or hostname.
        # *   **ip**: the IP address.
        self.custom_host_alias = custom_host_alias
        # The version of the container, such as Ali-Tomcat, in which an application developed based on High-speed Service Framework (HSF) is deployed.
        self.edas_container_version = edas_container_version
        self.enable_image_accl = enable_image_accl
        # The environment variables. You can configure custom environment variables or reference a ConfigMap. If you want to reference a ConfigMap, you must first create a ConfigMap. For more information, see [CreateConfigMap](https://help.aliyun.com/document_detail/176914.html). Valid values:
        # 
        # *   Configure custom environment variables
        # 
        #     *   **name**: the name of the environment variable.
        #     *   **value**: the value of the environment variable.
        # 
        # *   Reference ConfigMap
        # 
        #     *   **name**: the name of the environment variable. You can reference one or all keys. If you want to reference all keys, specify `sae-sys-configmap-all-<ConfigMap name>`. Example: `sae-sys-configmap-all-test1`.
        #     *   **valueFrom**: the reference of the environment variable. Set the value to `configMapRef`.
        #     *   **configMapId**: the ConfigMap ID.
        #     *   **key**: the key. If you want to reference all keys, do not configure this parameter.
        self.envs = envs
        # The ID of the corresponding Secret.
        self.image_pull_secrets = image_pull_secrets
        # The URL of the image. This parameter is returned only if the **PackageType** parameter is set to **Image**.
        self.image_url = image_url
        # The arguments in the JAR package. The arguments are used to start the application container. The default startup command is `$JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs`.
        self.jar_start_args = jar_start_args
        # The option settings in the JAR package. The settings are used to start the application container. The default startup command for application deployment is `$JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs`.
        self.jar_start_options = jar_start_options
        # The version of the Java development kit (JDK) on which the deployment package of the application depends. The following versions are supported:
        # 
        # *   **Open JDK 8**\
        # *   **Open JDK 7**\
        # *   **Dragonwell 11**\
        # *   **Dragonwell 8**\
        # *   **openjdk-8u191-jdk-alpine3.9**\
        # *   **openjdk-7u201-jdk-alpine3.9**\
        # 
        # This parameter is not returned if the **PackageType** parameter is set to **Image**.
        self.jdk = jdk
        # The configurations for mounting the NAS file system. If you do not need to modify the NAS configurations when you deploy the application, configure **MountDesc** only in the first request. If you no longer need to use NAS, leave **MountDesc** empty in the request.
        self.mount_desc = mount_desc
        # The mount target of the NAS file system in the VPC where the application is deployed. If you do not need to modify this configuration during the deployment, configure the **MountHost** parameter only in the first request. You do not need to include this parameter in subsequent requests. If you need to remove this configuration, leave the **MountHost** parameter empty in the request.
        self.mount_host = mount_host
        # The ID of the Apsara File Storage NAS file system. If you do not need to modify the NAS configurations when you deploy the application, configure **NasId** only in the first request. If you no longer need to use NAS, leave **NasId** empty in the request.
        self.nas_id = nas_id
        # The AccessKey ID that is used to read data from and write data to OSS.
        self.oss_ak_id = oss_ak_id
        # The AccessKey secret that is used to read data from and write data to OSS.
        self.oss_ak_secret = oss_ak_secret
        # The information about the mounted Object Storage Service (OSS) bucket. The following parameters are involved:
        # 
        # *   **bucketName**: the name of the OSS bucket.
        # 
        # *   **bucketPath**: the directory or object in OSS. If the specified directory or object does not exist, an error is returned.
        # 
        # *   **mountPath**: the directory of the container in SAE. If the path already exists, the newly specified path overwrites the previous one. If the path does not exist, it is created.
        # 
        # *   **readOnly**: specifies whether to only allow the container path to read data from the OSS directory. Valid values:
        # 
        #     *   **true**: The container path only has read permission on the OSS directory.
        #     *   **false**: The application has read and write permissions.
        self.oss_mount_descs = oss_mount_descs
        # The address of the deployment package. This parameter is required if you set **PackageType** to **FatJar**, **War**, or **PythonZip**.
        self.package_url = package_url
        # The version of the deployment package. This parameter is required if you set **PackageType** to **FatJar**, **War**, or **PythonZip**.
        self.package_version = package_version
        # The ID of Container Registry Enterprise Edition instance N.
        self.php = php
        # The details of the PHP configuration file.
        self.php_config = php_config
        # The path on which the PHP configuration file for application startup is mounted. Make sure that the PHP server uses this configuration file during the startup.
        self.php_config_location = php_config_location
        # The script to be run after the container is started. Example: `{"exec":{"command":["sh","-c","echo hello"\\]}}`
        self.post_start = post_start
        # The script that is run before the container is stopped. Example: `{"exec":{"command":["sh","-c","echo hello"\\]}}`
        self.pre_stop = pre_stop
        # The programming language. Valid values: **java**, **php**, **python**, and **shell**.
        self.programming_language = programming_language
        # The Python environment. Set the value to **PYTHON 3.9.15**.
        self.python = python
        # The configurations for installing custom module dependencies. By default, the dependencies defined by the requirements.txt file in the root directory are installed. If the package does not contain this file and you do not configure custom dependencies in the package, specify the dependencies that you want to install in the text box.
        self.python_modules = python_modules
        # The ID of the job that you reference.
        self.ref_app_id = ref_app_id
        # The number of concurrent instances.
        self.replicas = replicas
        # Specifies whether to enable job sharding.
        self.slice = slice
        # The parameters of job sharding.
        self.slice_envs = slice_envs
        # The configurations of Log Service.
        # 
        # *   To use Log Service resources that are automatically created by SAE, set this parameter to `[{"logDir":"","logType":"stdout"},{"logDir":"/tmp/a.log"}]`.
        # *   To use custom Log Service resources, set this parameter to `[{"projectName":"test-sls","logType":"stdout","logDir":"","logstoreName":"sae","logtailName":""},{"projectName":"test","logDir":"/tmp/a.log","logstoreName":"sae","logtailName":""}]`.
        # 
        # The following parameters are involved:
        # 
        # *   **projectName**: the name of the Log Service project.
        # *   **logDir**: the path in which logs are stored.
        # *   **logType**: the log type. **stdout**: the standard output log of the container. You can specify only one stdout value for this parameter. If you leave this parameter empty, file logs are collected.
        # *   **logstoreName**: the name of the Logstore in Log Service.
        # *   **logtailName**: the name of the Logtail configuration in Log Service. If you do not configure this parameter, a new Logtail configuration is created.
        # 
        # If you do not need to modify the logging configurations when you deploy the application, configure the **SlsConfigs** parameter only in the first request. You do not need to include this parameter in subsequent requests. If you no longer need to use Log Service, leave the **SlsConfigs** parameter empty in the request.
        # 
        # > A Log Service project that is automatically created by SAE when you create an application is deleted when the application is deleted. Therefore, when you create an application, you cannot select a Log Service project that is automatically created by SAE for log collection.
        self.sls_configs = sls_configs
        # The timeout period for a graceful shutdown. Default value: 30. Unit: seconds. Valid values: 1 to 300.
        self.termination_grace_period_seconds = termination_grace_period_seconds
        # The timeout period. Unit: seconds.
        self.timeout = timeout
        # The time zone. Default value: **Asia/Shanghai**.
        self.timezone = timezone
        # The Tomcat configuration. If you want to delete the configuration, set this parameter to {} or leave this parameter empty. Valid values:
        # 
        # *   **port**: the port number. The port number ranges from 1024 to 65535. Though the admin permissions are configured for the container, the root permissions are required to perform operations on ports whose number is smaller than 1024. Enter a value that ranges from 1025 to 65535 because the container has only the admin permissions. If you do not specify this parameter, the default port number 8080 is used.
        # *   **contextPath**: the path. Default value: /. This value indicates the root directory.
        # *   **maxThreads**: the maximum number of connections in the connection pool. Default value: 400.
        # *   **uriEncoding**: the URI encoding scheme in the Tomcat container. Valid values: **UTF-8**, **ISO-8859-1**, **GBK**, and GB2312. If you do not specify this parameter, the default value **ISO-8859-1** is used.
        # *   **useBodyEncoding**: specifies whether to use the encoding scheme that is specified by **BodyEncoding for URL**. Default value: **true**.
        self.tomcat_config = tomcat_config
        self.trigger_config = trigger_config
        # The startup command of the WAR package. For information about how to configure the startup command, see [Configure startup commands](https://help.aliyun.com/document_detail/96677.html).
        self.war_start_options = war_start_options
        # The version of the Tomcat container on which the deployment package depends. The following versions are supported:
        # 
        # *   **apache-tomcat-7.0.91**\
        # *   **apache-tomcat-8.5.42**\
        # 
        # This parameter is not returned if the **PackageType** parameter is set to **Image**.
        self.web_container = web_container

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acr_assume_role_arn is not None:
            result['AcrAssumeRoleArn'] = self.acr_assume_role_arn
        if self.acr_instance_id is not None:
            result['AcrInstanceId'] = self.acr_instance_id
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.backoff_limit is not None:
            result['BackoffLimit'] = self.backoff_limit
        if self.command is not None:
            result['Command'] = self.command
        if self.command_args is not None:
            result['CommandArgs'] = self.command_args
        if self.concurrency_policy is not None:
            result['ConcurrencyPolicy'] = self.concurrency_policy
        if self.config_map_mount_desc is not None:
            result['ConfigMapMountDesc'] = self.config_map_mount_desc
        if self.custom_host_alias is not None:
            result['CustomHostAlias'] = self.custom_host_alias
        if self.edas_container_version is not None:
            result['EdasContainerVersion'] = self.edas_container_version
        if self.enable_image_accl is not None:
            result['EnableImageAccl'] = self.enable_image_accl
        if self.envs is not None:
            result['Envs'] = self.envs
        if self.image_pull_secrets is not None:
            result['ImagePullSecrets'] = self.image_pull_secrets
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.jar_start_args is not None:
            result['JarStartArgs'] = self.jar_start_args
        if self.jar_start_options is not None:
            result['JarStartOptions'] = self.jar_start_options
        if self.jdk is not None:
            result['Jdk'] = self.jdk
        if self.mount_desc is not None:
            result['MountDesc'] = self.mount_desc
        if self.mount_host is not None:
            result['MountHost'] = self.mount_host
        if self.nas_id is not None:
            result['NasId'] = self.nas_id
        if self.oss_ak_id is not None:
            result['OssAkId'] = self.oss_ak_id
        if self.oss_ak_secret is not None:
            result['OssAkSecret'] = self.oss_ak_secret
        if self.oss_mount_descs is not None:
            result['OssMountDescs'] = self.oss_mount_descs
        if self.package_url is not None:
            result['PackageUrl'] = self.package_url
        if self.package_version is not None:
            result['PackageVersion'] = self.package_version
        if self.php is not None:
            result['Php'] = self.php
        if self.php_config is not None:
            result['PhpConfig'] = self.php_config
        if self.php_config_location is not None:
            result['PhpConfigLocation'] = self.php_config_location
        if self.post_start is not None:
            result['PostStart'] = self.post_start
        if self.pre_stop is not None:
            result['PreStop'] = self.pre_stop
        if self.programming_language is not None:
            result['ProgrammingLanguage'] = self.programming_language
        if self.python is not None:
            result['Python'] = self.python
        if self.python_modules is not None:
            result['PythonModules'] = self.python_modules
        if self.ref_app_id is not None:
            result['RefAppId'] = self.ref_app_id
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.slice is not None:
            result['Slice'] = self.slice
        if self.slice_envs is not None:
            result['SliceEnvs'] = self.slice_envs
        if self.sls_configs is not None:
            result['SlsConfigs'] = self.sls_configs
        if self.termination_grace_period_seconds is not None:
            result['TerminationGracePeriodSeconds'] = self.termination_grace_period_seconds
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.tomcat_config is not None:
            result['TomcatConfig'] = self.tomcat_config
        if self.trigger_config is not None:
            result['TriggerConfig'] = self.trigger_config
        if self.war_start_options is not None:
            result['WarStartOptions'] = self.war_start_options
        if self.web_container is not None:
            result['WebContainer'] = self.web_container
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcrAssumeRoleArn') is not None:
            self.acr_assume_role_arn = m.get('AcrAssumeRoleArn')
        if m.get('AcrInstanceId') is not None:
            self.acr_instance_id = m.get('AcrInstanceId')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BackoffLimit') is not None:
            self.backoff_limit = m.get('BackoffLimit')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('CommandArgs') is not None:
            self.command_args = m.get('CommandArgs')
        if m.get('ConcurrencyPolicy') is not None:
            self.concurrency_policy = m.get('ConcurrencyPolicy')
        if m.get('ConfigMapMountDesc') is not None:
            self.config_map_mount_desc = m.get('ConfigMapMountDesc')
        if m.get('CustomHostAlias') is not None:
            self.custom_host_alias = m.get('CustomHostAlias')
        if m.get('EdasContainerVersion') is not None:
            self.edas_container_version = m.get('EdasContainerVersion')
        if m.get('EnableImageAccl') is not None:
            self.enable_image_accl = m.get('EnableImageAccl')
        if m.get('Envs') is not None:
            self.envs = m.get('Envs')
        if m.get('ImagePullSecrets') is not None:
            self.image_pull_secrets = m.get('ImagePullSecrets')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('JarStartArgs') is not None:
            self.jar_start_args = m.get('JarStartArgs')
        if m.get('JarStartOptions') is not None:
            self.jar_start_options = m.get('JarStartOptions')
        if m.get('Jdk') is not None:
            self.jdk = m.get('Jdk')
        if m.get('MountDesc') is not None:
            self.mount_desc = m.get('MountDesc')
        if m.get('MountHost') is not None:
            self.mount_host = m.get('MountHost')
        if m.get('NasId') is not None:
            self.nas_id = m.get('NasId')
        if m.get('OssAkId') is not None:
            self.oss_ak_id = m.get('OssAkId')
        if m.get('OssAkSecret') is not None:
            self.oss_ak_secret = m.get('OssAkSecret')
        if m.get('OssMountDescs') is not None:
            self.oss_mount_descs = m.get('OssMountDescs')
        if m.get('PackageUrl') is not None:
            self.package_url = m.get('PackageUrl')
        if m.get('PackageVersion') is not None:
            self.package_version = m.get('PackageVersion')
        if m.get('Php') is not None:
            self.php = m.get('Php')
        if m.get('PhpConfig') is not None:
            self.php_config = m.get('PhpConfig')
        if m.get('PhpConfigLocation') is not None:
            self.php_config_location = m.get('PhpConfigLocation')
        if m.get('PostStart') is not None:
            self.post_start = m.get('PostStart')
        if m.get('PreStop') is not None:
            self.pre_stop = m.get('PreStop')
        if m.get('ProgrammingLanguage') is not None:
            self.programming_language = m.get('ProgrammingLanguage')
        if m.get('Python') is not None:
            self.python = m.get('Python')
        if m.get('PythonModules') is not None:
            self.python_modules = m.get('PythonModules')
        if m.get('RefAppId') is not None:
            self.ref_app_id = m.get('RefAppId')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('Slice') is not None:
            self.slice = m.get('Slice')
        if m.get('SliceEnvs') is not None:
            self.slice_envs = m.get('SliceEnvs')
        if m.get('SlsConfigs') is not None:
            self.sls_configs = m.get('SlsConfigs')
        if m.get('TerminationGracePeriodSeconds') is not None:
            self.termination_grace_period_seconds = m.get('TerminationGracePeriodSeconds')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('TomcatConfig') is not None:
            self.tomcat_config = m.get('TomcatConfig')
        if m.get('TriggerConfig') is not None:
            self.trigger_config = m.get('TriggerConfig')
        if m.get('WarStartOptions') is not None:
            self.war_start_options = m.get('WarStartOptions')
        if m.get('WebContainer') is not None:
            self.web_container = m.get('WebContainer')
        return self


class UpdateJobResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        change_order_id: str = None,
    ):
        # The application ID.
        self.app_id = app_id
        # The ID of the change order. It can be used to query the task status.
        self.change_order_id = change_order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        return self


class UpdateJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UpdateJobResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The response.
        self.data = data
        # The error code returned. Valid values:
        # 
        # *   The **ErrorCode** parameter is not returned if the request succeeds.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The additional information that is returned. Valid values:
        # 
        # *   success: If the call is successful, **success** is returned.
        # *   An error code: If the call fails, an error code is returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the application deployment is successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateNamespaceRequest(TeaModel):
    def __init__(
        self,
        enable_micro_registration: bool = None,
        name_space_short_id: str = None,
        namespace_description: str = None,
        namespace_id: str = None,
        namespace_name: str = None,
    ):
        # Indicates whether to enable SAE built-in registry:
        # 
        # *   **true**\
        # *   **false**\
        # 
        # If you set this parameter to true, a shared registry is created for the namespace. The registry cannot be disabled after it is created.
        self.enable_micro_registration = enable_micro_registration
        # The short ID of the namespace. You do not need to specify a region ID. We recommend that you configure this parameter. The value of this parameter can be up to 20 characters in length and can contain only lowercase letters and digits.
        self.name_space_short_id = name_space_short_id
        # The description of the namespace. The description cannot exceed 100 characters in length.
        self.namespace_description = namespace_description
        # The long ID of the namespace. If you configure this parameter, the long ID take effects and the value of the NameSpaceShortId parameter is ignored. To ensure compatibility, we recommend that you specify a short namespace ID. A long namespace ID follows the `<RegionId>:<NamespaceId>` format. The `NamespaceId` variable can contain only lowercase letters and digits. Example: `cn-beijing:test`. The value of the Namespaceid variable cannot exceed 32 characters in length. For more information about **RegionId**, you can call the [DescribeRegions](https://help.aliyun.com/document_detail/2834842.html) operation to obtain the IDs of regions supported by SAE.
        self.namespace_id = namespace_id
        # The name of the namespace. The name cannot exceed 64 characters in length.
        # 
        # This parameter is required.
        self.namespace_name = namespace_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_micro_registration is not None:
            result['EnableMicroRegistration'] = self.enable_micro_registration
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_description is not None:
            result['NamespaceDescription'] = self.namespace_description
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.namespace_name is not None:
            result['NamespaceName'] = self.namespace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableMicroRegistration') is not None:
            self.enable_micro_registration = m.get('EnableMicroRegistration')
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceDescription') is not None:
            self.namespace_description = m.get('NamespaceDescription')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NamespaceName') is not None:
            self.namespace_name = m.get('NamespaceName')
        return self


class UpdateNamespaceResponseBodyData(TeaModel):
    def __init__(
        self,
        enable_micro_registration: bool = None,
        name_space_short_id: str = None,
        namespace_description: str = None,
        namespace_id: str = None,
        namespace_name: str = None,
        region_id: str = None,
    ):
        # Indicates whether to enable SAE built-in registry:
        # 
        # *   **true**\
        # *   **false**\
        self.enable_micro_registration = enable_micro_registration
        # The short ID of the namespace.
        self.name_space_short_id = name_space_short_id
        # The description of the namespace.
        self.namespace_description = namespace_description
        # The ID of the namespace.
        self.namespace_id = namespace_id
        # The name of the namespace.
        self.namespace_name = namespace_name
        # The region where the namespace resides.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_micro_registration is not None:
            result['EnableMicroRegistration'] = self.enable_micro_registration
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_description is not None:
            result['NamespaceDescription'] = self.namespace_description
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.namespace_name is not None:
            result['NamespaceName'] = self.namespace_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableMicroRegistration') is not None:
            self.enable_micro_registration = m.get('EnableMicroRegistration')
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceDescription') is not None:
            self.namespace_description = m.get('NamespaceDescription')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('NamespaceName') is not None:
            self.namespace_name = m.get('NamespaceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class UpdateNamespaceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UpdateNamespaceResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: The call was successful.
        # *   **3xx**: The call was redirected.
        # *   **4xx**: The call failed.
        # *   **5xx**: A server error occurred.
        self.code = code
        # The information about a namespace.
        self.data = data
        # The error code returned. Take note of the following rules:
        # 
        # *   The **ErrorCode** parameter is not returned if the request succeeds.
        # *   If the call fails, the **ErrorCode** parameter is returned. For more information, see the "**Error codes**" section of this topic.
        self.error_code = error_code
        # The message returned for the operation.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the information about the namespace was updated. Valid values:
        # 
        # *   **true**: The instance was updated.
        # *   **false**: The instance failed to be updated.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateNamespaceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateNamespaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateNamespaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateNamespaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateNamespaceVpcRequest(TeaModel):
    def __init__(
        self,
        name_space_short_id: str = None,
        namespace_id: str = None,
        vpc_id: str = None,
    ):
        self.name_space_short_id = name_space_short_id
        # vpc-2ze0i263cnn311nvj\\*\\*\\*\\*\
        self.namespace_id = namespace_id
        # The ID of the request.
        # 
        # This parameter is required.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_space_short_id is not None:
            result['NameSpaceShortId'] = self.name_space_short_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NameSpaceShortId') is not None:
            self.name_space_short_id = m.get('NameSpaceShortId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class UpdateNamespaceVpcResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # Indicates whether the VPC information was updated. Valid values:
        # 
        # *   **true**: indicates that the information was updated.
        # *   **false**: indicates that the information could not be updated.
        self.code = code
        # The HTTP status code. Valid values:
        # 
        # *   **2xx**: indicates that the request was successful.
        # *   **3xx**: indicates that the request was redirected.
        # *   **4xx**: indicates that the request was invalid.
        # *   **5xx**: indicates that a server error occurred.
        self.error_code = error_code
        # The ID of the trace. It can be used to query the details of a request.
        self.message = message
        # The returned message.
        # 
        # *   **success** is returned when the request succeeds.
        # *   An error code is returned when the request fails.
        self.request_id = request_id
        self.success = success
        # The error code.
        # 
        # *   The **ErrorCode** parameter is not returned when the request succeeds.
        # *   The **ErrorCode** parameter is returned when the request fails. For more information, see **Error codes** in this topic.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateNamespaceVpcResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateNamespaceVpcResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateNamespaceVpcResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSecretRequestSecretData(TeaModel):
    def __init__(
        self,
        secret_data: str = None,
    ):
        # The information about the key-value pairs of the Secret. This parameter is required. The following formats are supported:
        # 
        # {"Data":"{"k1":"v1", "k2":"v2"}"}
        # 
        # k specifies a key and v specifies a value. For more information, see [Manage a Kubernetes Secret](https://help.aliyun.com/document_detail/463383.html).
        # 
        # This parameter is required.
        self.secret_data = secret_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.secret_data is not None:
            result['SecretData'] = self.secret_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SecretData') is not None:
            self.secret_data = m.get('SecretData')
        return self


class UpdateSecretRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
        secret_data: UpdateSecretRequestSecretData = None,
        secret_id: int = None,
    ):
        # The ID of the namespace where the Secret resides. If the namespace is the default namespace, you need to only enter the region ID, such as `cn-beijing`.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # The Secret data.
        # 
        # This parameter is required.
        self.secret_data = secret_data
        # This parameter is required.
        self.secret_id = secret_id

    def validate(self):
        if self.secret_data:
            self.secret_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.secret_data is not None:
            result['SecretData'] = self.secret_data.to_map()
        if self.secret_id is not None:
            result['SecretId'] = self.secret_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('SecretData') is not None:
            temp_model = UpdateSecretRequestSecretData()
            self.secret_data = temp_model.from_map(m['SecretData'])
        if m.get('SecretId') is not None:
            self.secret_id = m.get('SecretId')
        return self


class UpdateSecretShrinkRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
        secret_data_shrink: str = None,
        secret_id: int = None,
    ):
        # The ID of the namespace where the Secret resides. If the namespace is the default namespace, you need to only enter the region ID, such as `cn-beijing`.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # The Secret data.
        # 
        # This parameter is required.
        self.secret_data_shrink = secret_data_shrink
        # This parameter is required.
        self.secret_id = secret_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.secret_data_shrink is not None:
            result['SecretData'] = self.secret_data_shrink
        if self.secret_id is not None:
            result['SecretId'] = self.secret_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('SecretData') is not None:
            self.secret_data_shrink = m.get('SecretData')
        if m.get('SecretId') is not None:
            self.secret_id = m.get('SecretId')
        return self


class UpdateSecretResponseBodyData(TeaModel):
    def __init__(
        self,
        secret_id: int = None,
    ):
        self.secret_id = secret_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.secret_id is not None:
            result['SecretId'] = self.secret_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SecretId') is not None:
            self.secret_id = m.get('SecretId')
        return self


class UpdateSecretResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UpdateSecretResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateSecretResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateSecretResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSecretResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSecretResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSwimmingLaneEnableAttributeRequest(TeaModel):
    def __init__(
        self,
        enable: bool = None,
        group_id: int = None,
        lane_id: int = None,
        namespace_id: str = None,
    ):
        self.enable = enable
        self.group_id = group_id
        self.lane_id = lane_id
        self.namespace_id = namespace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lane_id is not None:
            result['LaneId'] = self.lane_id
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('LaneId') is not None:
            self.lane_id = m.get('LaneId')
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        return self


class UpdateSwimmingLaneEnableAttributeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateSwimmingLaneEnableAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSwimmingLaneEnableAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSwimmingLaneEnableAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateWebApplicationRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
        body: UpdateWebApplicationInput = None,
    ):
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # Updates the information about a web application.
        # 
        # This parameter is required.
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('body') is not None:
            temp_model = UpdateWebApplicationInput()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateWebApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WebApplicationBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WebApplicationBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateWebApplicationScalingConfigRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
        body: UpdateWebApplicationScalingConfigInput = None,
    ):
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # The information about scaling configurations.
        # 
        # This parameter is required.
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('body') is not None:
            temp_model = UpdateWebApplicationScalingConfigInput()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateWebApplicationScalingConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WebApplicationScalingConfigBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WebApplicationScalingConfigBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateWebApplicationTrafficConfigRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
        body: UpdateWebApplicationTrafficConfigInput = None,
    ):
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # The traffic configurations.
        # 
        # This parameter is required.
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('body') is not None:
            temp_model = UpdateWebApplicationTrafficConfigInput()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateWebApplicationTrafficConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WebApplicationTrafficConfigBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WebApplicationTrafficConfigBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateWebCustomDomainRequest(TeaModel):
    def __init__(
        self,
        namespace_id: str = None,
        body: UpdateWebCustomDomainInput = None,
    ):
        # The namespace ID.
        # 
        # This parameter is required.
        self.namespace_id = namespace_id
        # The information about the custom domain name.
        # 
        # This parameter is required.
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace_id is not None:
            result['NamespaceId'] = self.namespace_id
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NamespaceId') is not None:
            self.namespace_id = m.get('NamespaceId')
        if m.get('body') is not None:
            temp_model = UpdateWebCustomDomainInput()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateWebCustomDomainResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WebCustomDomainBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WebCustomDomainBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpgradeApplicationApmServiceRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class UpgradeApplicationApmServiceResponseBodyData(TeaModel):
    def __init__(
        self,
        status: bool = None,
    ):
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class UpgradeApplicationApmServiceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UpgradeApplicationApmServiceResponseBodyData = None,
        error_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpgradeApplicationApmServiceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpgradeApplicationApmServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpgradeApplicationApmServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpgradeApplicationApmServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


